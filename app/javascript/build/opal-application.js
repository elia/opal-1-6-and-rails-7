(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (global_object.console == null) {
    global_object.console = {};
  }

  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal.Opal class (helpers etc.)
  var _Opal;

  // The Kernel module
  var Kernel;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    experimental_features_severity: 'warning',// warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $has_own   = Object.hasOwnProperty;
  var $bind      = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice     = Array.prototype.slice;
  var $splice    = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  function $uid() {
    unique_id += 2;
    return unique_id;
  };
  Opal.uid = $uid;

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id == null) {
      $prop(obj, '$$id', $uid());
    }
    return obj.$$id;
  };

  // Globals table
  var $gvars = Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if ($gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    var exception = Opal.exceptions.pop();
    if (exception) {
      $gvars["!"] = exception;
      $gvars["@"] = exception.$backtrace();
    }
    else {
      $gvars["!"] = $gvars["@"] = nil;
    }
  };

  function $prop(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.prop = $prop;

  // @deprecated
  Opal.defineProperty = Opal.prop;

  Opal.slice = $slice;


  // Helpers
  // -----

  var $truthy = Opal.truthy = function(val) {
    return false !== val && nil !== val && undefined !== val && null !== val && (!(val instanceof Boolean) || true === val.valueOf());
  };

  Opal.falsy = function(val) {
    return !$truthy(val);
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    var body;

    if (method === 'to_int' && type === Opal.Integer && object.$$is_number)
      return object < 0 ? Math.ceil(object) : Math.floor(object);

    if (method === 'to_str' && type === Opal.String && object.$$is_string)
      return object;

    if (Opal.is_a(object, type)) return object;

    // Fast path for the most common situation
    if (object['$respond_to?'].$$pristine && object.$method_missing.$$pristine) {
      body = object['$' + method];
      if (body == null || body.$$stub) throw Opal.type_error(object, type);
      return body.apply(object, args);
    }

    if (!object['$respond_to?'](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
      if (!obj['$respond_to_missing?'].$$pristine) {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for(i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  function handle_autoload(cref, name) {
    if (!cref.$$autoload[name].loaded) {
      cref.$$autoload[name].loaded = true;
      try {
        Opal.Kernel.$require(cref.$$autoload[name].path);
      } catch (e) {
        cref.$$autoload[name].exception = e;
        throw e;
      }
      cref.$$autoload[name].required = true;
      if (cref.$$const[name] != null) {
        cref.$$autoload[name].success = true;
        return cref.$$const[name];
      }
    } else if (cref.$$autoload[name].loaded && !cref.$$autoload[name].required) {
      if (cref.$$autoload[name].exception) { throw cref.$$autoload[name].exception; }
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) {
      if (cref.$$const[name] != null) { return cref.$$const[name]; }
      if (cref.$$autoload && cref.$$autoload[name]) {
        return handle_autoload(cref, name);
      }
    }
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) {
        return constant;
      } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
        return handle_autoload(nesting[i], name);
      }
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = $ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
        return handle_autoload(ancestors[i], name);
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name) {
    return (cref || _Object).$const_missing(name);
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);
    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (name == null) {
      // A shortpath for calls like ::String => $$$("String")
      result = const_get_name(_Object, cref);

      if (result != null) return result;
      return Opal.const_get_qualified(_Object, cref, skip_missing);
    }

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $prop(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $prop(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  function $const_set(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $prop(cref, name, value);

    return value;
  };

  Opal.const_set = $const_set;

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat($ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat($ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
      if (module.$$autoload) {
        for (constant in module.$$autoload) {
          constants[constant] = true;
        }
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload && cref.$$autoload[name]) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Generates a function that is a curried const_get_relative.
  Opal.const_get_relative_factory = function(nesting) {
    return function(name, skip_missing) {
      return Opal.$$(nesting, name, skip_missing);
    }
  }

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;
  Opal.$r = Opal.const_get_relative_factory;

  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass   [Class,null] superclass of the new class (may be null)
  // @param singleton    [Boolean,null] a true value denotes we want to allocate
  //                                    a singleton
  //
  // @return new [Class]  or existing ruby class
  //
  function $allocate_class(name, superclass, singleton) {
    var klass;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      klass = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      klass = function(){};
    }

    if (name && name !== nil) {
      $prop(klass, 'displayName', '::'+name);
    }

    $prop(klass, '$$name', name);
    $prop(klass, '$$constructor', klass);
    $prop(klass, '$$prototype', klass.prototype);
    $prop(klass, '$$const', {});
    $prop(klass, '$$is_class', true);
    $prop(klass, '$$is_a_module', true);
    $prop(klass, '$$super', superclass);
    $prop(klass, '$$cvars', {});
    $prop(klass, '$$own_included_modules', []);
    $prop(klass, '$$own_prepended_modules', []);
    $prop(klass, '$$ancestors', []);
    $prop(klass, '$$ancestors_cache_version', null);
    $prop(klass, '$$subclasses', []);

    $prop(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (singleton !== true) {
        // Let's not forbid GC from cleaning up our
        // subclasses.
        if (typeof WeakRef !== 'undefined') {
          // First, let's clean up our array from empty objects.
          var i, subclass, rebuilt_subclasses = [];
          for (i = 0; i < superclass.$$subclasses.length; i++) {
            subclass = superclass.$$subclasses[i];
            if (subclass.deref() !== undefined) {
              rebuilt_subclasses.push(subclass);
            }
          }
          // Now, let's add our class.
          rebuilt_subclasses.push(new WeakRef(klass));
          superclass.$$subclasses = rebuilt_subclasses;
        }
        else {
          superclass.$$subclasses.push(klass);
        }
      }

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };
  Opal.allocate_class = $allocate_class;


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        throw Opal.TypeError.$new("superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass != null) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
    }
    else {
      // Class doesn't exist, create a new one with given superclass...

      // Not specifying a superclass means we can assume it to be Object
      if (superclass == null) {
        superclass = _Object;
      }

      // Create the class object (instance of Class)
      klass = $allocate_class(name, superclass);
      $const_set(scope, name, klass);

      // Call .inherited() hook with new class on the superclass
      if (superclass.$inherited) {
        superclass.$inherited(klass);
      }

      if (bridged) {
        Opal.bridge(bridged, klass);
      }
    }

    if (Opal.trace_class) { invoke_tracers_for_class(klass); }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  function $allocate_module(name) {
    var constructor = function(){};
    var module = constructor;

    if (name)
      $prop(constructor, 'displayName', name+'.constructor');

    $prop(module, '$$name', name);
    $prop(module, '$$prototype', constructor.prototype);
    $prop(module, '$$const', {});
    $prop(module, '$$is_module', true);
    $prop(module, '$$is_a_module', true);
    $prop(module, '$$cvars', {});
    $prop(module, '$$iclasses', []);
    $prop(module, '$$own_included_modules', []);
    $prop(module, '$$own_prepended_modules', []);
    $prop(module, '$$ancestors', [module]);
    $prop(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };
  Opal.allocate_module = $allocate_module;

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module == null) {
      // Module doesnt exist, create a new one...
      module = $allocate_module(name);
      $const_set(scope, name, module);
    }

    if (Opal.trace_class) { invoke_tracers_for_class(module); }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // helper to set $$meta on klass, module or instance
  function set_meta(obj, meta) {
    if (obj.hasOwnProperty('$$meta')) {
      obj.$$meta = meta;
    } else {
      $prop(obj, '$$meta', meta);
    }
    if (obj.$$frozen) {
      // If a object is frozen (sealed), freeze $$meta too.
      // No need to inject $$meta.$$prototype in the prototype chain,
      // as $$meta cannot be modified anyway.
      obj.$$meta.$freeze();
    } else {
      $set_proto(obj, meta.$$prototype);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    var superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    var meta = $allocate_class(null, superclass, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', klass);
    set_meta(klass, meta);
    // Restoring ClassName.class
    $prop(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = $allocate_class(null, Opal.Module, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', mod);
    set_meta(mod, meta);
    // Restoring ModuleName.class
    $prop(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = $allocate_class(nil, superclass, true);

    $prop(klass, '$$is_singleton', true);
    $prop(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    set_meta(object, klass);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = $ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(obj.$$meta || obj.$$class);
  };

  Opal.own_methods = function(obj) {
    return obj.$$meta ? Opal.own_instance_methods(obj.$$meta) : [];
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own.call(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = $ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      throw Opal.NameError.$new('uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = $ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $prop(dummy_prepender, '$$dummy', true);
      $prop(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = $ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $prop(iclass, prop, proto[prop]);
    }

    $prop(iclass, '$$iclass', true);
    $prop(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $prop(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $prop(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $prop(klass, '$$prototype', native_klass.prototype);

    $prop(klass.$$prototype, '$$class', klass);
    $prop(klass, '$$constructor', native_klass);
    $prop(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  function $ancestors(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = $ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };
  Opal.ancestors = $ancestors;

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs("foo,bar,baz=");
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;
    var stub, existing_method;
    stubs = stubs.split(',');

    for (var i = 0, length = stubs.length; i < length; i++) {
      stub = '$'+stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    // Opal.stub_for(stub) is the method_missing_stub
    $prop(prototype, stub, Opal.stub_for(stub));
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  function get_ancestors(obj) {
    if (obj.hasOwnProperty('$$meta') && obj.$$meta !== null) {
      return $ancestors(obj.$$meta);
    } else {
      return $ancestors(obj.$$class);
    }
  };

  // Super dispatcher
  Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = '$' + mid, ancestors, super_method;

    ancestors = get_ancestors(obj);

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new(
        "implicit argument passing of super from method defined by define_method() is not supported. " +
        "Specify all arguments explicitly"
      );
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super(obj, call_jsid, current_func, defcheck);
  };

  // @deprecated
  Opal.find_super_dispatcher = Opal.find_super;

  // @deprecated
  Opal.find_iter_super_dispatcher = Opal.find_block_super;

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error || candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var ancestors = $ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    return ancestors.indexOf(klass) !== -1;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice.call(parameters, parameters.length - 1);
      return kwargs;
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  function apply_blockopts(block, blockopts) {
    if (typeof(blockopts) === 'number') {
      block.$$arity = blockopts;
    }
    else if (typeof(blockopts) === 'object') {
      Object.assign(block, blockopts);
    }
  }

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @param blockopts [Object, Number] optional properties to set on the block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block, blockopts) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv['$'+method];
    } else {
      throw Opal.NameError.$new("Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block, blockopts);
  };

  Opal.send2 = function(recv, body, method, args, block, blockopts) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    apply_blockopts(block, blockopts);

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function(refinement_groups, recv, method, args, block, blockopts) {
    var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;

    ancestors = get_ancestors(recv);

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);

      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];

        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === 'undefined') continue;

          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;

          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] === 'undefined') continue;
          refine_module = refine_modules[ancestor];

          // Does this module define a method we want to call?
          if (typeof refine_module.$$prototype['$'+method] !== 'undefined') {
            body = refine_module.$$prototype['$'+method];
            return Opal.send2(recv, body, method, args, block, blockopts);
          }
        }
      }
    }

    return Opal.send(recv, method, args, block, blockopts);
  };

  Opal.lambda = function(block, blockopts) {
    block.$$is_lambda = true;

    apply_blockopts(block, blockopts);

    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @param blockopts [Object, Number] optional properties to set on the body
  // @return [null]
  //
  Opal.def = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      return Opal.defn(Opal.Object, jsid, body);
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      return Opal.defn(obj, jsid, body);
    }
    else {
      return Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    $deny_frozen_access(module);

    body.displayName = jsid;
    body.$$owner = module;

    var name = jsid.substr(1);

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $prop(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $prop(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(name);
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(name);
    }

    return name;
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    return Opal.defn(Opal.get_singleton_class(obj), jsid, body);
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body,
        alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === 'undefined') {
      obj = Opal.Object;
    }

    body = obj.$$prototype['$' + old];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      alias.$$p = null;

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_gvar = function(new_name, old_name) {
    Object.defineProperty($gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function() {
        return $gvars[old_name];
      },
      set: function(new_value) {
        $gvars[old_name] = new_value;
      }
    });
    return nil;
  }

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value, key_tmp;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        key_tmp = keys[i];

        if (key_tmp.$$is_string && typeof key_tmp !== "string") {
          key_tmp = key_tmp.valueOf();
        }

        if (key_tmp === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1) {
      args = arguments[0];

      if (arguments[0].$$is_array) {
        length = args.length;

        for (i = 0; i < length; i++) {
          if (args[i].length !== 2) {
            throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
          }

          key = args[i][0];
          value = args[i][1];

          Opal.hash_put(hash, key, value);
        }

        return hash;
      }
      else {
        args = arguments[0];
        for (key in args) {
          if ($has_own.call(args, key)) {
            value = args[key];

            Opal.hash_put(hash, key, value);
          }
        }

        return hash;
      }
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  var reserved_ivar_names = [
    // properties
    "constructor", "displayName", "__count__", "__noSuchMethod__",
    "__parent__", "__proto__",
    // methods
    "hasOwnProperty", "valueOf"
  ];

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (reserved_ivar_names.indexOf(name) !== -1) {
      name += "$";
    }

    return name;
  };

  // Support for #freeze
  // -------------------

  // helper that can be used from methods
  function $deny_frozen_access(obj) {
    if (obj.$$frozen) {
      throw Opal.FrozenError.$new("can't modify frozen " + (obj.$class()) + ": " + (obj), Opal.hash2(["receiver"], {"receiver": obj}));
    }
  };
  Opal.deny_frozen_access = $deny_frozen_access;

  // common #freeze runtime support
  Opal.freeze = function(obj) {
    $prop(obj, "$$frozen", true);

    // set $$id
    if (!obj.hasOwnProperty('$$id')) { $prop(obj, '$$id', $uid()); }

    if (obj.hasOwnProperty('$$meta')) {
      // freeze $$meta if it has already been set
      obj.$$meta.$freeze();
    } else {
      // ensure $$meta can be set lazily, $$meta is frozen when set in runtime.js
      $prop(obj, '$$meta', null);
    }

    // $$comparable is used internally and set multiple times
    // defining it before sealing ensures it can be modified later on
    if (!obj.hasOwnProperty('$$comparable')) { $prop(obj, '$$comparable', null); }

    // seal the Object
    Object.seal(obj);

    return obj;
  };

  // freze props, make setters of instance variables throw FrozenError
  Opal.freeze_props = function(obj) {
    var prop, prop_type, desc;

    for(prop in obj) {
      prop_type = typeof(prop);

      // prop_type "object" here is a String(), skip $ props
      if ((prop_type === "string" || prop_type === "object") && prop[0] === '$') {
        continue;
      }

      desc = Object.getOwnPropertyDescriptor(obj, prop);
      if (desc && desc.enumerable && desc.writable) {
        // create closure to retain current value as cv
        // for Opal 2.0 let for cv should do the trick, instead of a function
        (function() {
          // set v to undefined, as if the property is not set
          var cv = obj[prop];
          Object.defineProperty(obj, prop, {
            get: function() { return cv; },
            set: function(_val) { $deny_frozen_access(obj); },
            enumerable: true
          });
        })();
      }
    }
  };

  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result, flags;

    // RegExp already has the global and multiline flag
    if (pattern.global && pattern.multiline) return pattern;

    flags = 'gm' + (pattern.ignoreCase ? 'i' : '');
    if (pattern.multiline) {
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g == null) {
        pattern.$$g = new RegExp(pattern.source, flags);
      }
      result = pattern.$$g;
    } else {
      if (pattern.$$gm == null) {
        pattern.$$gm = new RegExp(pattern.source, flags);
      }
      result = pattern.$$gm;
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load_normalized = function(path) {
    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      var retval = module(Opal);
      if (typeof Promise !== 'undefined' && retval instanceof Promise) {
        // A special case of require having an async top:
        // We will need to await it.
        return retval.then($return_val(true));
      }
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    return Opal.load_normalized(path);
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load_normalized(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) throw Opal.ArgumentError.$new("unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }

  Opal.last_promise = null;
  Opal.promise_unhandled_exception = false;

  // Run a block of code, but if it returns a Promise, don't run the next
  // one, but queue it.
  Opal.queue = function(proc) {
    if (Opal.last_promise) {
      // The async path is taken only if anything before returned a
      // Promise(V2).
      Opal.last_promise = Opal.last_promise.then(function() {
        if (!Opal.promise_unhandled_exception) return proc(Opal);
      })['catch'](function(error) {
        if (Opal.respond_to(error, '$full_message')) {
          error = error.$full_message();
        }
        console.error(error);
        // Abort further execution
        Opal.promise_unhandled_exception = true;
        Opal.exit(1);
      });
      return Opal.last_promise;
    }
    else {
      var ret = proc(Opal);
      if (typeof Promise === 'function' && typeof ret === 'object' && ret instanceof Promise) {
        Opal.last_promise = ret;
      }
      return ret;
    }
  }

  // Operator helpers
  // ----------------

  function are_both_numbers(l,r) { return typeof(l) === 'number' && typeof(r) === 'number' }

  Opal.rb_plus   = function(l,r) { return are_both_numbers(l,r) ? l + r : l['$+'](r); }
  Opal.rb_minus  = function(l,r) { return are_both_numbers(l,r) ? l - r : l['$-'](r); }
  Opal.rb_times  = function(l,r) { return are_both_numbers(l,r) ? l * r : l['$*'](r); }
  Opal.rb_divide = function(l,r) { return are_both_numbers(l,r) ? l / r : l['$/'](r); }
  Opal.rb_lt     = function(l,r) { return are_both_numbers(l,r) ? l < r : l['$<'](r); }
  Opal.rb_gt     = function(l,r) { return are_both_numbers(l,r) ? l > r : l['$>'](r); }
  Opal.rb_le     = function(l,r) { return are_both_numbers(l,r) ? l <= r : l['$<='](r); }
  Opal.rb_ge     = function(l,r) { return are_both_numbers(l,r) ? l >= r : l['$>='](r); }

  // Optimized helpers for calls like $truthy((a)['$==='](b)) -> $eqeqeq(a, b)
  function are_both_numbers_or_strings(lhs, rhs) {
    return (typeof lhs === 'number' && typeof rhs === 'number') ||
           (typeof lhs === 'string' && typeof rhs === 'string');
  }

  function $eqeq(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$=='](rhs));
  };
  Opal.eqeq = $eqeq;
  Opal.eqeqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$==='](rhs));
  };
  Opal.neqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs !== rhs : $truthy((lhs)['$!='](rhs));
  };
  Opal.not = function(arg) {
    if (undefined === arg || null === arg || false === arg || nil === arg) return true;
    if (true === arg || arg['$!'].$$pristine) return false;
    return $truthy(arg['$!']());
  }

  // Shortcuts - optimized function generators for simple kinds of functions
  function $return_val(arg) {
    return function() {
      return arg;
    }
  }
  Opal.return_val = $return_val;

  Opal.return_self = function() {
    return this;
  }
  Opal.return_ivar = function(ivar) {
    return function() {
      if (this[ivar] == null) { return nil; }
      return this[ivar];
    }
  }
  Opal.assign_ivar = function(ivar) {
    return function(val) {
      $deny_frozen_access(this);
      return this[ivar] = val;
    }
  }
  Opal.assign_ivar_val = function(ivar, static_val) {
    return function() {
      $deny_frozen_access(this);
      return this[ivar] = static_val;
    }
  }

  // Primitives for handling parameters
  Opal.ensure_kwargs = function(kwargs) {
    if (kwargs == null) {
      return Opal.hash2([], {});
    } else if (kwargs.$$is_hash) {
      return kwargs;
    } else {
      throw Opal.ArgumentError.$new('expected kwargs');
    }
  }

  Opal.get_kwarg = function(kwargs, key) {
    if (!$has_own.call(kwargs.$$smap, key)) {
      throw Opal.ArgumentError.$new('missing keyword: '+key);
    }
    return kwargs.$$smap[key];
  }

  // Initialization
  // --------------
  Opal.BasicObject = BasicObject = $allocate_class('BasicObject', null);
  Opal.Object      = _Object     = $allocate_class('Object', Opal.BasicObject);
  Opal.Module      = Module      = $allocate_class('Module', Opal.Object);
  Opal.Class       = Class       = $allocate_class('Class', Opal.Module);
  Opal.Opal        = _Opal       = $allocate_module('Opal');
  Opal.Kernel      = Kernel      = $allocate_module('Kernel');

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const.BasicObject = BasicObject;

  // Assign basic constants
  $const_set(_Object, "BasicObject",  BasicObject);
  $const_set(_Object, "Object",       _Object);
  $const_set(_Object, "Module",       Module);
  $const_set(_Object, "Class",        Class);
  $const_set(_Object, "Opal",         _Opal);
  $const_set(_Object, "Kernel",       Kernel);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;
  _Opal.$$class       = Module;
  Kernel.$$class      = Module;

  // Forward .toString() to #to_s
  $prop(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $prop(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = $return_val('main');
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments);
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', args, block)
  };

  // Nil
  Opal.NilClass = $allocate_class('NilClass', Opal.Object);
  $const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };
  nil.$$frozen = true;
  nil.$$comparable = false;
  Object.seal(nil);

  Opal.thrower = function(type) {
    var thrower = new Error('unexpected '+type);
    thrower.$thrower_type = type;
    thrower.$throw = function(value) {
      if (value == null) value = nil;
      thrower.$v = value;
      throw thrower;
    };
    return thrower;
  };

  Opal.t_eval_return = Opal.thrower("return");

  TypeError.$$super = Error;

  // If enable-file-source-embed compiler option is enabled, each module loaded will add its
  // sources to this object
  Opal.file_sources = {};
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
Opal.modules["corelib/irb"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $hash = Opal.hash, $gvars = Opal.gvars, $lambda = Opal.lambda, $send = Opal.send, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $range = Opal.range, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include?,raise,attr_accessor,singleton_class,output=,browser?,each,dup,write_proc=,proc,+,output,join,last,split,end_with?,call,write_proc,tty=,read_proc,read_proc=,freeze,new,string,ensure_loaded,prepare_console,loop,print,gets,puts,start_with?,[],==,silence,message,empty?,warnings,warn,full_message,eval_and_print,irb');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'IRB');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$ensure_loaded', function $$ensure_loaded(library) {
        var version = nil, url = nil;

        
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        };
        version = ($truthy($$('RUBY_ENGINE_VERSION')['$include?']("dev")) ? ("master") : ($$('RUBY_ENGINE_VERSION')));
        url = "https://cdn.opalrb.com/opal/" + (version) + "/" + (library) + ".js";
        
        var libcode;

        if (typeof XMLHttpRequest !== 'undefined') { // Browser
          var r = new XMLHttpRequest();
          r.open("GET", url, false);
          r.send('');
          libcode = r.responseText;
        }
        else {
          $Kernel.$raise("You need to provision " + (library) + " yourself in this environment")
        }

        (new Function('Opal', libcode))(Opal);

        Opal.require(library);
      ;
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        } else {
          return $Kernel.$raise("Could not load " + (library) + " for some reason")
        };
      }, 1);
      self.$singleton_class().$attr_accessor("output");
      $defs(self, '$prepare_console', function $$prepare_console() {
        var block = $$prepare_console.$$p || nil, $a, self = this, original = nil, original_read_proc = nil;
        if ($gvars.stdout == null) $gvars.stdout = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;
        if ($gvars.stdin == null) $gvars.stdin = nil;

        $$prepare_console.$$p = null;
        
        ;
        return (function() { try {
        
        self['$output=']("");
        original = $hash($gvars.stdout, $lambda(function $$1(i){
          
          if (i == null) i = nil;
          return ($gvars.stdout = i);}, 1), $gvars.stderr, $lambda(function $$2(i){
          
          if (i == null) i = nil;
          return ($gvars.stderr = i);}, 1));
        if ($truthy(self['$browser?']())) {
          
          $send(original, 'each', [], function $$3(pipe, pipe_setter){var self = $$3.$$s == null ? this : $$3.$$s, new_pipe = nil;

            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            new_pipe = pipe.$dup();
            new_pipe['$write_proc=']($send(self, 'proc', [], function $$4(str){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (str == null) str = nil;
              self['$output=']($rb_plus(self.$output(), str));
              self['$output='](self.$output().$split("\n").$last(30).$join("\n"));
              if ($truthy(str['$end_with?']("\n"))) {
                self['$output=']($rb_plus(self.$output(), "\n"))
              };
              return pipe.$write_proc().$call(str);}, {$$arity: 1, $$s: self}));
            new_pipe['$tty='](false);
            return pipe_setter.$call(new_pipe);}, {$$arity: 2, $$s: self});
          original_read_proc = $gvars.stdin.$read_proc();
          $gvars.stdin['$read_proc='](function(s) { var p = prompt(self.$output()); if (p !== null) return p + "\n"; return nil; });
        };
        return Opal.yieldX(block, []);;
        } finally {
          ($send(original, 'each', [], function $$5(pipe, pipe_setter){
            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            return pipe_setter.$call(pipe);}, 2), ($a = [original_read_proc], $send($gvars.stdin, 'read_proc=', $a), $a[$a.length - 1]), ($a = [""], $send(self, 'output=', $a), $a[$a.length - 1]))
        }; })();
      }, 0);
      $defs(self, '$browser?', function $IRB_browser$ques$6() {
        
        return typeof(document) !== 'undefined' && typeof(prompt) !== 'undefined';
      }, 0);
      $const_set($nesting[0], 'LINEBREAKS', ["unexpected token $end", "unterminated string meets end of file"].$freeze());
      return (function($base, $super) {
        var self = $klass($base, $super, 'Silencer');

        var $proto = self.$$prototype;

        $proto.collector = $proto.stderr = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          return (self.stderr = $gvars.stderr)
        }, 0);
        
        $def(self, '$silence', function $$silence() {
          var $yield = $$silence.$$p || nil, self = this;

          $$silence.$$p = null;
          return (function() { try {
          
          self.collector = $$$('StringIO').$new();
          $gvars.stderr = self.collector;
          return Opal.yieldX($yield, []);;
          } finally {
            ($gvars.stderr = self.stderr)
          }; })()
        }, 0);
        return $def(self, '$warnings', function $$warnings() {
          var self = this;

          return self.collector.$string()
        }, 0);
      })($nesting[0], null);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Binding');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$irb', function $$irb() {try { var $t_return = $thrower('return'); 
      var self = this, silencer = nil;

      
      $$$($Opal, 'IRB').$ensure_loaded("opal-replutils");
      silencer = $$$($$$($Opal, 'IRB'), 'Silencer').$new();
      return $send($$$($Opal, 'IRB'), 'prepare_console', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        return (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s, line = nil, code = nil, mode = nil, js_code = nil, e = nil;

          
          self.$print(">> ");
          line = self.$gets();
          if (!$truthy(line)) {
            $t_break.$throw()
          };
          code = "";
          if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
            self.$puts(line)
          };
          if ($truthy(line['$start_with?']("ls "))) {
            
            code = line['$[]']($range(3, -1, false));
            mode = "ls";
          } else if ($eqeq(line, "ls\n")) {
            
            code = "self";
            mode = "ls";
          } else if ($truthy(line['$start_with?']("show "))) {
            
            code = line['$[]']($range(5, -1, false));
            mode = "show";
          } else {
            
            code = line;
            mode = "inspect";
          };
          js_code = nil;
          
          do { try {
            $send(silencer, 'silence', [], function $$9(){
              return (js_code = Opal.compile(code, {irb: true}))}, 0)
          } catch ($err) {
            if (Opal.rescue($err, [$$('SyntaxError')])) {(e = $err)
              try {
                if ($truthy($$$($$$($Opal, 'IRB'), 'LINEBREAKS')['$include?'](e.$message()))) {
                  
                  self.$print(".. ");
                  line = self.$gets();
                  if (!$truthy(line)) {
                    $t_return.$throw()
                  };
                  if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
                    self.$puts(line)
                  };
                  code = $rb_plus(code, line);
                  continue;
                } else if ($truthy(silencer.$warnings()['$empty?']())) {
                  self.$warn(e.$full_message())
                } else {
                  self.$warn(silencer.$warnings())
                }
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          } break; } while(1);;
          if ($eqeq(mode, "show")) {
            
            self.$puts(js_code);
            $t_return.$throw();
          };
          return self.$puts($$$('REPLUtils').$eval_and_print(js_code, mode, false, self));}, {$$arity: 0, $$s: self, $$ret: $t_return})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})()}, {$$arity: 0, $$s: self});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, 0)
  })('::', null, $nesting);
  
  // Run in WebTools console with: Opal.irb(c => eval(c))
  Opal.irb = function(fun) {
    $$$('Binding').$new(fun).$irb()
  }

  Opal.load_parser = function() {
    Opal.Opal.IRB.$ensure_loaded('opal-parser');
  }

  if (typeof Opal.eval === 'undefined') {
    Opal.eval = function(str) {
      Opal.load_parser();
      return Opal.eval(str);
    }
  }

  if (typeof Opal.compile === 'undefined') {
    Opal.compile = function(str, options) {
      Opal.load_parser();
      return Opal.compile(str, options);
    }
  }
;
};

Opal.modules["corelib/unsupported"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $Kernel = Opal.Kernel, $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $module = Opal.module, $def = Opal.def, $return_val = Opal.return_val, $alias = Opal.alias, $defs = Opal.defs, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,warn,each,define_method,%,public,private_method_defined?,private_class_method,instance_method,instance_methods,method_defined?,private_methods');
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $Kernel.$raise($$$('NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    return $send(["<<", "capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], 'each', [], function $String$1(method_name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      if (method_name == null) method_name = nil;
      return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, $rest_arg;

        
        $post_args = $slice.call(arguments);
        $rest_arg = $post_args;
        return $Kernel.$raise($$$('NotImplementedError'), (ERROR)['$%'](method_name));}, -1);}, {$$arity: 1, $$s: self});
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object tainting is not supported by Opal";
    
    $def(self, '$taint', function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    
    $def(self, '$untaint', function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, 0);
    return $def(self, '$tainted?', function $Kernel_tainted$ques$3() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    }, 0);
  })('::');
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    
    
    $def(self, '$public', function $Module_public$4($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice.call(arguments);
      methods = $post_args;
      
      if (methods.length === 0) {
        self.$$module_function = false;
        return nil;
      }
      return (methods.length === 1) ? methods[0] : methods;
    ;
    }, -1);
    
    $def(self, '$private_class_method', function $$private_class_method($a) {
      var $post_args, methods;

      
      $post_args = $slice.call(arguments);
      methods = $post_args;
      return (methods.length === 1) ? methods[0] : methods;;
    }, -1);
    
    $def(self, '$private_method_defined?', $return_val(false), 0);
    
    $def(self, '$private_constant', function $$private_constant($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    $alias(self, "nesting", "public");
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_class_method", "private_class_method");
    $alias(self, "public_instance_method", "instance_method");
    $alias(self, "public_instance_methods", "instance_methods");
    return $alias(self, "public_method_defined?", "method_defined?");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$private_methods', function $$private_methods($a) {
      var $post_args, methods;

      
      $post_args = $slice.call(arguments);
      methods = $post_args;
      return [];
    }, -1);
    $alias(self, "protected_methods", "private_methods");
    $alias(self, "private_instance_methods", "private_methods");
    return $alias(self, "protected_instance_methods", "private_methods");
  })('::');
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$eval', function $Kernel_eval$5($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'), "To use Kernel#eval, you must first require 'opal-parser'. " + ("See https://github.com/opal/opal/blob/" + ($$('RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, -1)
  })('::', $nesting);
  $defs(self, '$public', function $public$6($a) {
    var $post_args, methods;

    
    $post_args = $slice.call(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
  return $defs(self, '$private', function $private$7($a) {
    var $post_args, methods;

    
    $post_args = $slice.call(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
};

Opal.modules["corelib/binding"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $Kernel = Opal.Kernel, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $module = Opal.module, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('js_eval,call,raise,inspect,include?,==,receiver,eval,attr_reader,new');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Binding');

    var $proto = self.$$prototype;

    $proto.jseval = $proto.scope_variables = nil;
    
    
    $def(self, '$initialize', function $$initialize(jseval, scope_variables, receiver, source_location) {
      var $a, self = this;

      
      if (scope_variables == null) scope_variables = [];
      ;
      if (source_location == null) source_location = nil;
      $a = [jseval, scope_variables, receiver, source_location], (self.jseval = $a[0]), (self.scope_variables = $a[1]), (self.receiver = $a[2]), (self.source_location = $a[3]), $a;
      if ($truthy(typeof receiver !== undefined)) {
        return nil
      } else {
        return (receiver = self.$js_eval("self"))
      };
    }, -2);
    
    $def(self, '$js_eval', function $$js_eval($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(self.jseval)) {
        return $send(self.jseval, 'call', $to_a(args))
      } else {
        return $Kernel.$raise("Evaluation on a Proc#binding is not supported")
      };
    }, -1);
    
    $def(self, '$local_variable_get', function $$local_variable_get(symbol) {
      var self = this;

      try {
        return self.$js_eval(symbol)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {
          try {
            return $Kernel.$raise($$$('NameError'), "local variable `" + (symbol) + "' is not defined for " + (self.$inspect()))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$local_variable_set', function $$local_variable_set(symbol, value) {
      var self = this;

      
      Opal.Binding.tmp_value = value;
      self.$js_eval("" + (symbol) + " = Opal.Binding.tmp_value");
      delete Opal.Binding.tmp_value;
      return value;
    }, 2);
    
    $def(self, '$local_variables', $return_ivar("scope_variables"), 0);
    
    $def(self, '$local_variable_defined?', function $Binding_local_variable_defined$ques$1(value) {
      var self = this;

      return self.scope_variables['$include?'](value)
    }, 1);
    
    $def(self, '$eval', function $Binding_eval$2(str, file, line) {try { var $t_eval_return = $thrower('eval_return'); 
      var self = this;

      
      if (file == null) file = nil;
      if (line == null) line = nil;
      if ($eqeq(str, "self")) {
        return self.$receiver()
      };
      return $Kernel.$eval(str, self, file, line);} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    }, -2);
    return self.$attr_reader("receiver", "source_location");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$binding', function $$binding() {
      
      return $Kernel.$raise("Opal doesn't support dynamic calls to binding")
    }, 0)
  })('::');
  return $const_set($nesting[0], 'TOPLEVEL_BINDING', $$$('Binding').$new(
    function(js) {
      return (new Function("self", "return " + js))(self);
    }
  , [], self, ["<main>", 0]));
};

Opal.modules["corelib/process"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $return_val = Opal.return_val, $Kernel = Opal.Kernel, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('const_set,size,<<,__register_clock__,to_f,now,new,[],raise');
  return (function($base) {
    var self = $module($base, 'Process');

    var monotonic = nil;

    
    self.__clocks__ = [];
    $defs(self, '$__register_clock__', function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)
    };
    $defs(self, '$pid', $return_val(0), 0);
    $defs(self, '$times', function $$times() {
      var t = nil;

      
      t = $$$('Time').$now().$to_f();
      return $$$($$$('Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, 0);
    return $defs(self, '$clock_gettime', function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      if (unit == null) unit = "float_second";
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        $Kernel.$raise($$$($$$('Errno'), 'EINVAL'), "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: $Kernel.$raise($$$('ArgumentError'), "unexpected unit: " + (unit))
      }
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/string/encoding"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $send = Opal.send, $defs = Opal.defs, $eqeq = Opal.eqeq, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $a, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,+,[],clone,initialize,new,instance_eval,to_proc,each,const_set,tr,==,default_external,attr_accessor,singleton_class,attr_reader,raise,register,length,bytes,force_encoding,dup,bytesize,enum_for,each_byte,to_a,each_char,each_codepoint,coerce_to!,find,<,default_external=');
  
  self.$require("corelib/string");
  (function($base, $super) {
    var self = $klass($base, $super, 'Encoding');

    var $proto = self.$$prototype;

    $proto.name = $proto.dummy = nil;
    
    $defs(self, '$register', function $$register(name, options) {
      var block = $$register.$$p || nil, self = this, names = nil, $ret_or_1 = nil, ascii = nil, dummy = nil, encoding = nil, register = nil;

      $$register.$$p = null;
      
      ;
      if (options == null) options = $hash2([], {});
      names = $rb_plus([name], ($truthy(($ret_or_1 = options['$[]']("aliases"))) ? ($ret_or_1) : ([])));
      ascii = ($truthy(($ret_or_1 = options['$[]']("ascii"))) && ($ret_or_1));
      dummy = ($truthy(($ret_or_1 = options['$[]']("dummy"))) && ($ret_or_1));
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())
      };
      register = Opal.encodings;
      return $send(names, 'each', [], function $$1(encoding_name){var self = $$1.$$s == null ? this : $$1.$$s;

        
        if (encoding_name == null) encoding_name = nil;
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, {$$arity: 1, $$s: self});
    }, -2);
    $defs(self, '$find', function $$find(name) {
      var self = this;

      
      if ($eqeq(name, "default_external")) {
        return self.$default_external()
      };
      return Opal.find_encoding(name);;
    }, 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    $def(self, '$initialize', function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, 4);
    
    $def(self, '$ascii_compatible?', $return_ivar("ascii"), 0);
    
    $def(self, '$dummy?', $return_ivar("dummy"), 0);
    
    $def(self, '$binary?', $return_val(false), 0);
    
    $def(self, '$to_s', $return_ivar("name"), 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Encoding:" + (self.name) + (($truthy(self.dummy) ? (" (dummy)") : nil)) + ">"
    }, 0);
    
    $def(self, '$charsize', function $$charsize(string) {
      
      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    }, 1);
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      $$each_char.$$p = null;
      
      ;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    }, 1);
    
    $def(self, '$each_byte', function $$each_byte($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    
    $def(self, '$bytesize', function $$bytesize($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    $klass('::', $$$('StandardError'), 'EncodingError');
    return ($klass('::', $$$('EncodingError'), 'CompatibilityError'), nil);
  })('::', null);
  $send($$$('Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            }

            // valid lead
            leadSurrogate = codePoint;

            continue;
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint;
            continue;
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.$bytes().$length()
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16LE"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 2;
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_16LE')})], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1)}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32LE"], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    }, 1);
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 4;
    }, 1);}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32BE", $hash2(["inherits"], {"inherits": $$$($$$('Encoding'), 'UTF_32LE')})], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1)}, {$$arity: 0, $$s: self});
  $send($$$('Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii"], {"aliases": ["BINARY"], "ascii": true})], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

    
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      $$each_char.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    }, 1);
    
    $def(self, '$charsize', function $$charsize(string) {
      
      return string.length;
    }, 1);
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, 1);
    
    $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length;
    }, 1);
    return $def(self, '$binary?', $return_val(true), 0);}, {$$arity: 0, $$s: self});
  $$$('Encoding').$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  $$$('Encoding').$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ASCII"], "ascii": true, "inherits": $$$($$$('Encoding'), 'ASCII_8BIT')}));
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    var $proto = self.$$prototype;

    $proto.internal_encoding = $proto.bytes = $proto.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.prop(String.prototype, 'bytes', nil);
    Opal.prop(String.prototype, 'encoding', $$$($$$('Encoding'), 'UTF_8'));
    Opal.prop(String.prototype, 'internal_encoding', $$$($$$('Encoding'), 'UTF_8'));
    
    $def(self, '$b', function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    }, 0);
    
    $def(self, '$bytesize', function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, 0);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_byte"], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

          return self.$bytesize()}, {$$arity: 0, $$s: self})
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$bytes', function $$bytes() {
      var self = this, $ret_or_1 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = ($truthy(($ret_or_1 = self.bytes)) ? ($ret_or_1) : (self.$each_byte().$to_a()));
      return self.bytes.$dup();
    }, 0);
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_char"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$length()}, {$$arity: 0, $$s: self})
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$chars', function $$chars() {
      var block = $$chars.$$p || nil, self = this;

      $$chars.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, 0);
    
    $def(self, '$each_codepoint', function $$each_codepoint() {
      var block = $$each_codepoint.$$p || nil, self = this;

      $$each_codepoint.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$codepoints', function $$codepoints() {
      var block = $$codepoints.$$p || nil, self = this;

      $$codepoints.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())
      };
      return self.$each_codepoint().$to_a();
    }, 0);
    
    $def(self, '$encode', function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, 1);
    
    $def(self, '$force_encoding', function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $Opal['$coerce_to!'](encoding, $$$('String'), "to_s");
      encoding = $$$('Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    }, 1);
    
    $def(self, '$getbyte', function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $Opal['$coerce_to!'](idx, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil
      };
      return string_bytes['$[]'](idx);
    }, 1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      
      return "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    }, 1);
    return $def(self, '$valid_encoding?', $return_val(true), 0);
  })('::', null);
  return ($a = [$$$($$('Encoding'), 'UTF_8')], $send($$$('Encoding'), 'default_external=', $a), $a[$a.length - 1]);
};

Opal.modules["opal/mini"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("opal/base");
  $Object.$require("corelib/nil");
  $Object.$require("corelib/boolean");
  $Object.$require("corelib/string");
  $Object.$require("corelib/comparable");
  $Object.$require("corelib/enumerable");
  $Object.$require("corelib/enumerator");
  $Object.$require("corelib/array");
  $Object.$require("corelib/hash");
  $Object.$require("corelib/number");
  $Object.$require("corelib/range");
  $Object.$require("corelib/proc");
  $Object.$require("corelib/method");
  $Object.$require("corelib/regexp");
  $Object.$require("corelib/variables");
  $Object.$require("corelib/io");
  return $Object.$require("opal/regexp_anchors");
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $const_set = Opal.const_set, $Opal = Opal.Opal, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $def = Opal.def, $Kernel = Opal.Kernel, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_minus = Opal.rb_minus, $range = Opal.range, $send = Opal.send, $slice = Opal.slice, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?,expand_path,exist?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    $const_set($nesting[0], 'Separator', $const_set($nesting[0], 'SEPARATOR', "/"));
    $const_set($nesting[0], 'ALT_SEPARATOR', nil);
    $const_set($nesting[0], 'PATH_SEPARATOR', ":");
    $const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$absolute_path', function $$absolute_path(path, basedir) {
        var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");
        basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$$('Dir').$pwd()));
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split($regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)
        };
        return new_path;
      }, -2);
      
      $def(self, '$expand_path', function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$('Dir').$home();
          if (!$truthy(home)) {
            $Kernel.$raise($$$('ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if (!$truthy(home['$start_with?'](leading_sep))) {
            $Kernel.$raise($$$('ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)
          };
        };
        return self.$absolute_path(path, basedir);
      }, -2);
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$('ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$('SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$('SEPARATOR'), $$('ALT_SEPARATOR')));
        }
      }
    ;
      
      $def(self, '$dirname', function $$dirname(path, level) {
        var self = this, sep_chars = nil;

        
        if (level == null) level = 1;
        if ($eqeq(level, 0)) {
          return path
        };
        if ($truthy($rb_lt(level, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "level can't be negative")
        };
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("^[" + (sep_chars) + "]")), out;

        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          out = absolute ? '/' : '.';
        }
        else {
          out = path;
        }

        if (level == 1) {
          return out;
        }
        else {
          return self.$dirname(out, $rb_minus(level, 1))
        }
      ;
      }, -2);
      
      $def(self, '$basename', function $$basename(name, suffix) {
        var sep_chars = nil;

        
        if (suffix == null) suffix = nil;
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $Opal['$coerce_to!'](suffix, $$$('String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, -2);
      
      $def(self, '$extname', function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""
        };
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if (($truthy(last_dot_idx['$nil?']()) || ($eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, 1);
      
      $def(self, '$exist?', function $exist$ques$1(path) {
        
        return Opal.modules[path] != null
      }, 1);
      
      $def(self, '$directory?', function $directory$ques$2(path) {
        var files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub($regexp(["(^.", $$('SEPARATOR'), "+|", $$('SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], function $$3(f){
          
          if (f == null) f = nil;
          return f['$=~']($regexp(["^", path]));}, 1);
        return file;
      }, 1);
      
      $def(self, '$join', function $$join($a) {
        var $post_args, paths, result = nil;

        
        $post_args = $slice.call(arguments);
        paths = $post_args;
        if ($truthy(paths['$empty?']())) {
          return ""
        };
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], function $$4(item, index){
          
          if (item == null) item = nil;
          if (index == null) index = nil;
          if (($eqeq(index, 0) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else if (($eqeq(paths.$length(), $rb_plus(index, 1)) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else {
            return item
          };}, 2);
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], function $$5(item, index){var next_item = nil;

          
          if (item == null) item = nil;
          if (index == null) index = nil;
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if (($truthy(item['$end_with?']($$('SEPARATOR'))) && ($truthy(next_item['$start_with?']($$('SEPARATOR')))))) {
              item = item.$sub($regexp([$$('SEPARATOR'), "+$"]), "")
            };
            return (result = (($truthy(item['$end_with?']($$('SEPARATOR'))) || ($truthy(next_item['$start_with?']($$('SEPARATOR'))))) ? ("" + (result) + (item)) : ("" + (result) + (item) + ($$('SEPARATOR')))));
          };}, 2);
        return result;
      }, -1);
      
      $def(self, '$split', function $$split(path) {
        
        return path.$split($$('SEPARATOR'))
      }, 1);
      $alias(self, "realpath", "expand_path");
      return $alias(self, "exists?", "exist?");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('IO'), $nesting)
};

Opal.modules["corelib/time"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $slice = Opal.slice, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_divide = Opal.rb_divide, $rb_minus = Opal.rb_minus, $range = Opal.range, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $eqeq = Opal.eqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,===,raise,coerce_to!,respond_to?,to_str,to_i,_parse_offset,new,<=>,to_f,nil?,>,<,strftime,each,define_method,year,month,day,+,round,/,-,copy_instance_variables,initialize_dup,is_a?,zero?,wday,utc?,mon,yday,hour,min,sec,rjust,ljust,zone,to_s,[],cweek_cyear,jd,to_date,format,isdst,!=,<=,==,ceil,local,gm,asctime,getgm,gmt_offset,inspect,usec,gmtime,gmt?');
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    $defs(self, '$at', function $$at(seconds, frac) {
      
      
      ;
      
      var result;

      if ($$$('Time')['$==='](seconds)) {
        if (frac !== undefined) {
          $Kernel.$raise($$$('TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.timezone = seconds.timezone;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $Opal['$coerce_to!'](seconds, $$$('Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $Opal['$coerce_to!'](frac, $$$('Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $Opal['$coerce_to!'](year, $$$('Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $Opal['$coerce_to!'](month, $$$('Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        $Kernel.$raise($$$('ArgumentError'), "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $Opal['$coerce_to!'](day, $$$('Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        $Kernel.$raise($$$('ArgumentError'), "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $Opal['$coerce_to!'](hour, $$$('Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        $Kernel.$raise($$$('ArgumentError'), "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $Opal['$coerce_to!'](min, $$$('Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        $Kernel.$raise($$$('ArgumentError'), "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $Opal['$coerce_to!'](sec, $$$('Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        $Kernel.$raise($$$('ArgumentError'), "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    $defs(self, '$new', function $Time_new$1(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (utc_offset == null) utc_offset = nil;
      
      var args, result, timezone, utc_date;

      if (year === undefined) {
        return new Date();
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      if (utc_offset === nil) {
        result = new Date(year, month, day, hour, min, 0, sec * 1000);
        if (year < 100) {
          result.setFullYear(year);
        }
        return result;
      }

      timezone = self.$_parse_offset(utc_offset);
      utc_date = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        utc_date.setUTCFullYear(year);
      }

      result = new Date(utc_date.getTime() - timezone * 3600000);
      result.timezone = timezone;

      return result;
    ;
    }, -1);
    $defs(self, '$_parse_offset', function $$_parse_offset(utc_offset) {
      
      
      var timezone;
      if (utc_offset.$$is_string) {
        if (utc_offset == 'UTC') {
          timezone = 0;
        }
        else if(/^[+-]\d\d:[0-5]\d$/.test(utc_offset)) {
          var sign, hours, minutes;
          sign = utc_offset[0];
          hours = +(utc_offset[1] + utc_offset[2]);
          minutes = +(utc_offset[4] + utc_offset[5]);

          timezone = (sign == '-' ? -1 : 1) * (hours + minutes / 60);
        }
        else {
          // Unsupported: "A".."I","K".."Z"
          $Kernel.$raise($$$('ArgumentError'), "\"+HH:MM\", \"-HH:MM\", \"UTC\" expected for utc_offset: " + (utc_offset))
        }
      }
      else if (utc_offset.$$is_number) {
        timezone = utc_offset / 3600;
      }
      else {
        $Kernel.$raise($$$('ArgumentError'), "Opal doesn't support other types for a timezone argument than Integer and String")
      }
      return timezone;
    
    }, 1);
    $defs(self, '$local', function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, -2);
    $defs(self, '$gm', function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.timezone = 0;
      return result;
    ;
    }, -2);
    $defs(self, '$now', function $$now() {
      var self = this;

      return self.$new()
    }, 0);
    
    $def(self, '$+', function $Time_$plus$2(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        $Kernel.$raise($$$('TypeError'), "time + time?")
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    }, 1);
    
    $def(self, '$-', function $Time_$minus$3(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        return (self.getTime() - other.getTime()) / 1000
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    }, 1);
    
    $def(self, '$<=>', function $Time_$lt_eq_gt$4(other) {
      var self = this, r = nil;

      if ($eqeqeq($$$('Time'), other)) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, 1);
    
    $def(self, '$==', function $Time_$eq_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$$('Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$asctime', function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, 0);
    $send([["year", "getFullYear", "getUTCFullYear"], ["mon", "getMonth", "getUTCMonth", 1], ["wday", "getDay", "getUTCDay"], ["day", "getDate", "getUTCDate"], ["hour", "getHours", "getUTCHours"], ["min", "getMinutes", "getUTCMinutes"], ["sec", "getSeconds", "getUTCSeconds"]], 'each', [], function $Time$6(method, getter, utcgetter, difference){var self = $Time$6.$$s == null ? this : $Time$6.$$s;

      
      if (method == null) method = nil;
      if (getter == null) getter = nil;
      if (utcgetter == null) utcgetter = nil;
      if (difference == null) difference = 0;
      return $send(self, 'define_method', [method], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        
        return difference + ((self.timezone != null) ?
          (new Date(self.getTime() + self.timezone * 3600000))[utcgetter]() :
          self[getter]())
      }, {$$arity: 0, $$s: self});}, {$$arity: -4, $$s: self});
    
    $def(self, '$yday', function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$('Time').$new(self.$year()).$to_i();
      start_of_day = $$('Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, 0);
    
    $def(self, '$isdst', function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$eql?', function $Time_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = other['$is_a?']($$$('Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_1
      }
    }, 1);
    $send([["sunday?", 0], ["monday?", 1], ["tuesday?", 2], ["wednesday?", 3], ["thursday?", 4], ["friday?", 5], ["saturday?", 6]], 'each', [], function $Time$9(method, weekday){var self = $Time$9.$$s == null ? this : $Time$9.$$s;

      
      if (method == null) method = nil;
      if (weekday == null) weekday = nil;
      return $send(self, 'define_method', [method], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$wday() === weekday}, {$$arity: 0, $$s: self});}, {$$arity: 2, $$s: self});
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, 0);
    
    $def(self, '$succ', function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.timezone = self.timezone;
      return result;
    
    }, 0);
    
    $def(self, '$usec', function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, 0);
    
    $def(self, '$zone', function $$zone() {
      var self = this;

      
      if (self.timezone === 0) return "UTC";
      else if (self.timezone != null) return nil;

      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, 0);
    
    $def(self, '$getgm', function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.timezone = 0;
      return result;
    
    }, 0);
    
    $def(self, '$gmtime', function $$gmtime() {
      var self = this;

      
      if (self.timezone !== 0) {
        $deny_frozen_access(self);
        self.timezone = 0;
      }
      return self;
    
    }, 0);
    
    $def(self, '$gmt?', function $Time_gmt$ques$11() {
      var self = this;

      return self.timezone === 0;
    }, 0);
    
    $def(self, '$gmt_offset', function $$gmt_offset() {
      var self = this;

      return (self.timezone != null) ? self.timezone * 60 : -self.getTimezoneOffset() * 60;
    }, 0);
    
    $def(self, '$strftime', function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "", jd, c, s,
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = (self.timezone == null) ? self.getTimezoneOffset() : (-self.timezone * 60),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          // Non-standard: JIS X 0301 date format
          case 'J':
            jd = self.$to_date().$jd();
            if (jd < 2405160) {
              result += self.$strftime("%Y-%m-%d");
              break;
            }
            else if (jd < 2419614)
              c = 'M', s = 1867;
            else if (jd < 2424875)
              c = 'T', s = 1911;
            else if (jd < 2447535)
              c = 'S', s = 1925;
            else if (jd < 2458605)
              c = 'H', s = 1988;
            else
              c = 'R', s = 2018;

            result += self.$format("%c%02d", c, $rb_minus(self.$year(), s));
            result += self.$strftime("-%m-%d");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, 1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, 0);
    
    $def(self, '$cweek_cyear', function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$$('Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if (($truthy($rb_le(jan01_wday, 4)) && ($neqeq(jan01_wday, 0)))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if ($eqeq(offset, -8)) {
          offset = -1
        };
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$$('Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if ($eqeq(week, 53)) {
        
        dec31 = $$$('Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if (($truthy($rb_le(dec31_wday, 3)) && ($neqeq(dec31_wday, 0)))) {
          
          week = 1;
          year = $rb_plus(year, 1);
        };
      };
      return [week, year];
    }, 0);
    (function(self, $parent_nesting) {
      
      
      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "ctime", "asctime");
    $alias(self, "dst?", "isdst");
    $alias(self, "getutc", "getgm");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "mday", "day");
    $alias(self, "month", "mon");
    $alias(self, "to_s", "inspect");
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc", "gmtime");
    $alias(self, "utc?", "gmt?");
    return $alias(self, "utc_offset", "gmt_offset");
  })('::', Date, $nesting);
};

Opal.modules["corelib/random"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $Kernel = Opal.Kernel, $defs = Opal.defs, $Opal = Opal.Opal, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,attr_reader,to_int,raise,new_seed,coerce_to!,reseed,rand,seed,bytes,===,==,state,_verify_count,encode,join,new,chr,random_number,random_float,const_defined?,const_set');
  
  self.$require("corelib/random/formatter");
  (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    
    
    self.$attr_reader("seed", "state");
    $defs(self, '$_verify_count', function $$_verify_count(count) {
      
      
      if (!$truthy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) $Kernel.$raise($$$('ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    }, 1);
    
    $def(self, '$initialize', function $$initialize(seed) {
      var self = this;

      
      if (seed == null) seed = $$$('Random').$new_seed();
      seed = $Opal['$coerce_to!'](seed, $$$('Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, -1);
    
    $def(self, '$reseed', function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, 1);
    $defs(self, '$new_seed', function $$new_seed() {
      
      return Opal.$$rand.new_seed();
    }, 0);
    $defs(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return $$$(self, 'DEFAULT').$rand(limit);
    }, -1);
    $defs(self, '$srand', function $$srand(n) {
      var self = this, previous_seed = nil;

      
      if (n == null) n = $$$('Random').$new_seed();
      n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      previous_seed = $$$(self, 'DEFAULT').$seed();
      $$$(self, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, -1);
    $defs(self, '$urandom', function $$urandom(size) {
      
      return $$$('SecureRandom').$bytes(size)
    }, 1);
    
    $def(self, '$==', function $Random_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      
      if (!$eqeqeq($$$('Random'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$bytes', function $$bytes(length) {
      var self = this;

      
      length = $$$('Random').$_verify_count(length);
      return $send($$$('Array'), 'new', [length], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return self.$rand(255).$chr()}, {$$arity: 0, $$s: self}).$join().$encode("ASCII-8BIT");
    }, 1);
    $defs(self, '$bytes', function $$bytes(length) {
      var self = this;

      return $$$(self, 'DEFAULT').$bytes(length)
    }, 1);
    
    $def(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, -1);
    
    $def(self, '$random_float', function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    }, 0);
    $defs(self, '$random_float', function $$random_float() {
      var self = this;

      return $$$(self, 'DEFAULT').$random_float()
    }, 0);
    return $defs(self, '$generator=', function $Random_generator$eq$3(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$$(self, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, 1);
  })('::', null);
  return self.$require("corelib/random/mersenne_twister");
};

Opal.modules["corelib/dir"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('[],pwd');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      
      
      
      $def(self, '$chdir', function $$chdir(dir) {
        var $yield = $$chdir.$$p || nil, prev_cwd = nil;

        $$chdir.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, 1);
      
      $def(self, '$pwd', function $$pwd() {
        
        return Opal.current_dir || '.';
      }, 0);
      
      $def(self, '$home', function $$home() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$('ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      }, 0);
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/process/base"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $return_val = Opal.return_val, nil = Opal.nil;

  
  (function($base, $super) {
    var self = $klass($base, $super, 'Signal');

    
    return $defs(self, '$trap', function $$trap($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1)
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'GC');

    
    return $defs(self, '$start', $return_val(nil), 0)
  })('::', null);
};

Opal.modules["corelib/rational/base"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $def = Opal.def, $klass = Opal.klass, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('convert,from_string');
  
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$Rational', function $$Rational(numerator, denominator) {
      
      
      if (denominator == null) denominator = 1;
      return $$$('Rational').$convert(numerator, denominator);
    }, -2)
  })('::');
  return (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_r', function $$to_r() {
      var self = this;

      return $$$('Rational').$from_string(self)
    }, 0)
  })('::', null);
};

Opal.modules["corelib/regexp"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $coerce_to = Opal.coerce_to, $prop = Opal.prop, $freeze = Opal.freeze, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $alias = Opal.alias, $send = Opal.send, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $ensure_kwargs = Opal.ensure_kwargs, $rb_ge = Opal.rb_ge, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('nil?,[],raise,escape,options,to_str,new,join,coerce_to!,!,match,coerce_to?,begin,frozen?,uniq,map,scan,source,to_proc,transform_values,group_by,each_with_index,+,last,=~,==,attr_reader,>=,length,is_a?,include?,names,regexp,named_captures,===,captures,-,inspect,empty?,each,to_a');
  
  $klass('::', $$$('StandardError'), 'RegexpError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'IGNORECASE', 1);
    $const_set(self, 'EXTENDED', 2);
    $const_set(self, 'MULTILINE', 4);
    Opal.prop(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var $yield = $$allocate.$$p || nil, self = this, allocated = nil;

        $$allocate.$$p = null;
        
        allocated = $send2(self, $find_super(self, 'allocate', $$allocate, false, true), 'allocate', [], $yield);
        allocated.uninitialized = true;
        return allocated;
      }, 0);
      
      $def(self, '$escape', function $$escape(string) {
        
        return Opal.escape_regexp(string);
      }, 1);
      
      $def(self, '$last_match', function $$last_match(n) {
                if ($gvars["~"] == null) $gvars["~"] = nil;

        
        if (n == null) n = nil;
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else if ($truthy($gvars["~"])) {
          return $gvars["~"]['$[]'](n)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$union', function $$union($a) {
        var $post_args, parts, self = this;

        
        $post_args = $slice.call(arguments);
        parts = $post_args;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              $Kernel.$raise($$$('TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, -1);
      
      $def(self, '$new', function $new$1(regexp, options) {
        
        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $Opal['$coerce_to!'](regexp, $$$('String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          $Kernel.$raise($$$('RegexpError'), "too short escape sequence: /" + (regexp) + "/")
        }

        regexp = regexp.replace('\\A', '^').replace('\\z', '$')

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$('IGNORECASE') & options) { temp += 'i'; }
          if ($$('MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, -2);
      $alias(self, "compile", "new");
      return $alias(self, "quote", "escape");
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$==', function $Regexp_$eq_eq$2(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, 1);
    
    $def(self, '$===', function $Regexp_$eq_eq_eq$3(string) {
      var self = this;

      return self.$match($Opal['$coerce_to?'](string, $$$('String'), "to_str")) !== nil
    }, 1);
    
    $def(self, '$=~', function $Regexp_$eq_tilde$4(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$g')) { $prop(self, '$$g', null); }
      if (!self.hasOwnProperty('$$gm')) { $prop(self, '$$gm', null); }

      return $freeze(self);
    ;
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, 0);
    
    $def(self, '$match', function $$match(string, pos) {
      var block = $$match.$$p || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      $$match.$$p = null;
      
      ;
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$$('String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$$('MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$$('MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, -2);
    
    $def(self, '$match?', function $Regexp_match$ques$5(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$$('String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, -2);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return $send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$uniq()
    }, 0);
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this;

      return $send($send($send(self.$source().$scan(/\(?<(\w+)>/, $hash2(["no_matchdata"], {"no_matchdata": true})), 'map', [], "first".$to_proc()).$each_with_index(), 'group_by', [], "first".$to_proc()), 'transform_values', [], function $$6(i){
        
        if (i == null) i = nil;
        return $send(i, 'map', [], function $$7(j){
          
          if (j == null) j = nil;
          return $rb_plus(j.$last(), 1);}, 1);}, 1)
    }, 0);
    
    $def(self, '$~', function $Regexp_$$8() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, 0);
    
    $def(self, '$source', function $$source() {
      var self = this;

      return self.source;
    }, 0);
    
    $def(self, '$options', function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$('MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$('IGNORECASE');
      }
      return result;
    
    }, 0);
    
    $def(self, '$casefold?', function $Regexp_casefold$ques$9() {
      var self = this;

      return self.ignoreCase;
    }, 0);
    $alias(self, "eql?", "==");
    return $alias(self, "to_s", "source");
  })('::', RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    $def(self, '$initialize', function $$initialize(regexp, match_groups, $kwargs) {
      var no_matchdata, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];if (no_matchdata == null) no_matchdata = false;
      if (!$truthy(no_matchdata)) {
        $gvars["~"] = self
      };
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, -3);
    
    $def(self, '$match', function $$match(idx) {
      var self = this, match = nil;

      if ($truthy((match = self['$[]'](idx)))) {
        return match
      } else if (($truthy(idx['$is_a?']($$('Integer'))) && ($truthy($rb_ge(idx, self.$length()))))) {
        return $Kernel.$raise($$$('IndexError'), "index " + (idx) + " out of matches")
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$match_length', function $$match_length(idx) {
      var $a, self = this;

      return ($a = self.$match(idx), ($a === nil || $a == null) ? nil : $a.$length())
    }, 1);
    
    $def(self, '$[]', function $MatchData_$$$10($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      if (args[0].$$is_string) {
        if (self.$regexp().$names()['$include?'](args['$[]'](0))['$!']()) {
          $Kernel.$raise($$$('IndexError'), "undefined group name reference: " + (args['$[]'](0)))
        }
        return self.$named_captures()['$[]'](args['$[]'](0))
      }
      else {
        return $send(self.matches, '[]', $to_a(args))
      }
    ;
    }, -1);
    
    $def(self, '$offset', function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, 1);
    
    $def(self, '$==', function $MatchData_$eq_eq$11(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

      
      if (!$eqeqeq($$$('MatchData'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.string == other.string)) ? (self.regexp.toString() == other.regexp.toString()) : ($ret_or_4)))) ? (self.pre_match == other.pre_match) : ($ret_or_3)))) ? (self.post_match == other.post_match) : ($ret_or_2))))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$begin', function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, 1);
    
    $def(self, '$end', function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, 1);
    
    $def(self, '$captures', function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, 0);
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this, matches = nil;

      
      matches = self.$captures();
      return $send(self.$regexp().$named_captures(), 'transform_values', [], function $$12(i){
        
        if (i == null) i = nil;
        return matches['$[]']($rb_minus(i.$last(), 1));}, 1);
    }, 0);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return self.$regexp().$names()
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      if (self.$regexp().$names()['$empty?']()) {
        for (var i = 1, length = self.matches.length; i < length; i++) {
          str += " " + i + ":" + (self.matches[i]).$inspect();
        }
      }
      else {
        $send(self.$named_captures(), 'each', [], function $$13(k, v){
        
        if (k == null) k = nil;
        if (v == null) v = nil;
        return                str += " " + k + ":" + v.$inspect();}, 2)
      }

      return str + ">";
    
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.matches.length
    }, 0);
    
    $def(self, '$to_a', $return_ivar("matches"), 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.matches[0]
    }, 0);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $Opal['$coerce_to!'](args[i], $$$('Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, -1);
    $alias(self, "eql?", "==");
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/struct"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $send = Opal.send, $Class = Opal.Class, $to_a = Opal.to_a, $def = Opal.def, $defs = Opal.defs, $Kernel = Opal.Kernel, $hash2 = Opal.hash2, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,!=,upcase,[],==,class,unshift,const_name!,map,coerce_to!,new,each,define_struct_attribute,allocate,initialize,alias_method,module_eval,to_proc,const_set,raise,<<,members,define_method,instance_eval,last,>,length,-,keys,any?,join,[]=,each_with_index,hash,===,<,-@,size,>=,include?,to_sym,instance_of?,__id__,eql?,enum_for,+,name,each_pair,inspect,to_h,args,each_with_object,flatten,to_a,respond_to?,dig');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    $defs(self, '$new', function $Struct_new$1(const_name, $a, $b) {
      var block = $Struct_new$1.$$p || nil, $post_args, $kwargs, args, keyword_init, self = this, klass = nil;

      $Struct_new$1.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      args = $post_args;
      
      keyword_init = $kwargs.$$smap["keyword_init"];if (keyword_init == null) keyword_init = false;
      if ($truthy(const_name)) {
        if (($eqeq(const_name.$class(), $$$('String')) && ($neqeq(const_name['$[]'](0).$upcase(), const_name['$[]'](0))))) {
          
          args.$unshift(const_name);
          const_name = nil;
        } else {
          
          try {
            const_name = $Opal['$const_name!'](const_name)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('TypeError'), $$$('NameError')])) {
              try {
                
                args.$unshift(const_name);
                const_name = nil;
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };
        }
      };
      $send(args, 'map', [], function $$2(arg){
        
        if (arg == null) arg = nil;
        return $Opal['$coerce_to!'](arg, $$$('String'), "to_str");}, 1);
      klass = $send($Class, 'new', [self], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        
        $send(args, 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;

          
          if (arg == null) arg = nil;
          return self.$define_struct_attribute(arg);}, {$$arity: 1, $$s: self});
        return (function(self, $parent_nesting) {
          
          
          
          $def(self, '$new', function $new$5($a) {
            var $post_args, args, self = this, instance = nil;

            
            $post_args = $slice.call(arguments);
            args = $post_args;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', $to_a(args));
            return instance;
          }, -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, {$$arity: 0, $$s: self});
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())
      };
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$$('Struct').$const_set(const_name, klass)
      };
      return klass;
    }, -2);
    $defs(self, '$define_struct_attribute', function $$define_struct_attribute(name) {
      var self = this;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "you cannot define attributes to the Struct class")
      };
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$$data[name];}, {$$arity: 0, $$s: self});
      return $send(self, 'define_method', ["" + (name) + "="], function $$7(value){var self = $$7.$$s == null ? this : $$7.$$s;

        
        if (value == null) value = nil;
        return self.$$data[name] = value;;}, {$$arity: 1, $$s: self});
    }, 1);
    $defs(self, '$members', function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "the Struct class has no members")
      };
      return (self.members = ($truthy(($ret_or_1 = self.members)) ? ($ret_or_1) : ([])));
    }, 0);
    $defs(self, '$inherited', function $$inherited(klass) {
      var self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

        return (self.members = members)}, {$$arity: 0, $$s: self});
    }, 1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this, kwargs = nil, $ret_or_1 = nil, extra = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy(($ret_or_1 = args.$last())) ? ($ret_or_1) : ($hash2([], {})));
        if (($truthy($rb_gt(args.$length(), 1)) || ($truthy((args.length === 1 && !kwargs.$$is_hash))))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given " + (args.$length()) + ", expected 0)")
        };
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          $Kernel.$raise($$$('ArgumentError'), "unknown keywords: " + (extra.$join(", ")))
        };
        return $send(self.$class().$members(), 'each', [], function $$9(name){var $b, self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return ($b = [name, kwargs['$[]'](name)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$arity: 1, $$s: self});
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          $Kernel.$raise($$$('ArgumentError'), "struct size differs")
        };
        return $send(self.$class().$members(), 'each_with_index', [], function $$10(name, index){var $b, self = $$10.$$s == null ? this : $$10.$$s;

          
          if (name == null) name = nil;
          if (index == null) index = nil;
          return ($b = [name, args['$[]'](index)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$arity: 2, $$s: self});
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    }, 1);
    $defs(self, '$keyword_init?', function $Struct_keyword_init$ques$11() {
      var self = this;

      return self.$$keyword_init;
    }, 0);
    
    $def(self, '$members', function $$members() {
      var self = this;

      return self.$class().$members()
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return $$('Hash').$new(self.$$data).$hash()
    }, 0);
    
    $def(self, '$[]', function $Struct_$$$12(name) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name];;
    }, 1);
    
    $def(self, '$[]=', function $Struct_$$$eq$13(name, value) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        if (!$truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name] = value;;
    }, 2);
    
    $def(self, '$==', function $Struct_$eq_eq$14(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, 1);
    
    $def(self, '$eql?', function $Struct_eql$ques$15(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, 1);
    
    $def(self, '$each', function $$each() {
      var $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$17(name){var self = $$17.$$s == null ? this : $$17.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, self['$[]'](name));;}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      $$each_pair.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each_pair"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$19(name){var self = $$19.$$s == null ? this : $$19.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, {$$arity: 1, $$s: self});
      return self;
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return $send(self.$class().$members(), 'map', [], function $$20(name){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (name == null) name = nil;
        return self['$[]'](name);}, {$$arity: 1, $$s: self})
    }, 0);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, pushed = nil;

      return (function() { try {
      
      result = "#<struct ";
      if ($truthy((inspect_stack)['$include?'](self.$__id__()))) {
        return $rb_plus(result, ":...>")
      } else {
        
        (inspect_stack)['$<<'](self.$__id__());
        pushed = true;
        if (($eqeqeq($$$('Struct'), self) && ($truthy(self.$class().$name())))) {
          result = $rb_plus(result, "" + (self.$class()) + " ")
        };
        result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$21(name, value){
          
          if (name == null) name = nil;
          if (value == null) value = nil;
          return "" + (name) + "=" + ($$('Opal').$inspect(value));}, 2).$join(", "));
        result = $rb_plus(result, ">");
        return result;
      };
      } finally {
        ($truthy(pushed) ? (inspect_stack.pop()) : nil)
      }; })()
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(self.$args()))
      };
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], function $$22(name, h){var $a, self = $$22.$$s == null ? this : $$22.$$s;

        
        if (name == null) name = nil;
        if (h == null) h = nil;
        return ($a = [name, self['$[]'](name)], $send(h, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
    }, 0);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      args = $send(args, 'map', [], function $$23(arg){
        
        if (arg == null) arg = nil;
        return arg.$$is_range ? arg.$to_a() : arg;}, 1).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, -1);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice.call(arguments, 1);
      keys = $post_args;
      item = ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key)) ? (self.$$data[key] || nil) : nil);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    $alias(self, "size", "length");
    $alias(self, "to_s", "inspect");
    return $alias(self, "values", "to_a");
  })('::', null, $nesting);
};

Opal.modules["corelib/rational"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_divide = Opal.rb_divide, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $Opal = Opal.Opal, $def = Opal.def, $return_ivar = Opal.return_ivar, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $return_self = Opal.return_self, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,to_i,==,raise,<,-@,new,gcd,/,nil?,===,reduce,to_r,!,equal?,coerce_to!,freeze,to_f,numerator,denominator,<=>,-,*,__coerced__,+,Rational,>,**,abs,ceil,with_precision,floor,<=,truncate,send');
  
  self.$require("corelib/numeric");
  self.$require("corelib/rational/base");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Rational');

    var $proto = self.$$prototype;

    $proto.num = $proto.den = nil;
    
    $defs(self, '$reduce', function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if ($eqeq(den, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if ($eqeq(den, 1)) {
        return self.$new(num, den)
      };
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, 2);
    $defs(self, '$convert', function $$convert(num, den) {
      var self = this;

      
      if (($truthy(num['$nil?']()) || ($truthy(den['$nil?']())))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert nil into Rational")
      };
      if (($eqeqeq($$$('Integer'), num) && ($eqeqeq($$$('Integer'), den)))) {
        return self.$reduce(num, den)
      };
      if ((($eqeqeq($$$('Float'), num) || ($eqeqeq($$$('String'), num))) || ($eqeqeq($$$('Complex'), num)))) {
        num = num.$to_r()
      };
      if ((($eqeqeq($$$('Float'), den) || ($eqeqeq($$$('String'), den))) || ($eqeqeq($$$('Complex'), den)))) {
        den = den.$to_r()
      };
      if (($truthy(den['$equal?'](1)) && ($not($$$('Integer')['$==='](num))))) {
        return $Opal['$coerce_to!'](num, $$$('Rational'), "to_r")
      } else if (($eqeqeq($$$('Numeric'), num) && ($eqeqeq($$$('Numeric'), den)))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, 2);
    
    $def(self, '$initialize', function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      self.den = den;
      return self.$freeze();
    }, 2);
    
    $def(self, '$numerator', $return_ivar("num"), 0);
    
    $def(self, '$denominator', $return_ivar("den"), 0);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return [other, self]
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return [other.$to_r(), self]
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return [other, self.$to_f()]
      } else {
        return nil
      }
    }, 1);
    
    $def(self, '$==', function $Rational_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        if ($truthy(($ret_or_2 = self.num['$=='](other.$numerator())))) {
          return self.den['$=='](other.$denominator())
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($truthy(($ret_or_2 = self.num['$=='](other)))) {
          return self.den['$=='](1)
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$=='](other)
      } else {
        return other['$=='](self)
      }
    }, 1);
    
    $def(self, '$<=>', function $Rational_$lt_eq_gt$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$<=>'](other)
      } else {
        return self.$__coerced__("<=>", other)
      }
    }, 1);
    
    $def(self, '$+', function $Rational_$plus$3(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_plus(self.$to_f(), other)
      } else {
        return self.$__coerced__("+", other)
      }
    }, 1);
    
    $def(self, '$-', function $Rational_$minus$4(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_minus(self.$to_f(), other)
      } else {
        return self.$__coerced__("-", other)
      }
    }, 1);
    
    $def(self, '$*', function $Rational_$$5(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$numerator());
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_times(self.num, other), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_times(self.$to_f(), other)
      } else {
        return self.$__coerced__("*", other)
      }
    }, 1);
    
    $def(self, '$/', function $Rational_$slash$6(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$denominator());
        den = $rb_times(self.den, other.$numerator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $rb_divide(self.$to_f(), 0.0)
        } else {
          return $Kernel.$Rational(self.num, $rb_times(self.den, other))
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_divide(self.$to_f(), other)
      } else {
        return self.$__coerced__("/", other)
      }
    }, 1);
    
    $def(self, '$**', function $Rational_$$$7(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Integer'), ($ret_or_1 = other))) {
        if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $$$($$$('Float'), 'INFINITY')
        } else if ($truthy($rb_gt(other, 0))) {
          return $Kernel.$Rational(self.num['$**'](other), self.den['$**'](other))
        } else if ($truthy($rb_lt(other, 0))) {
          return $Kernel.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
        } else {
          return $Kernel.$Rational(1, 1)
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$**'](other)
      } else if ($eqeqeq($$$('Rational'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $Kernel.$Rational(1, 1)
        } else if ($eqeq(other.$denominator(), 1)) {
          if ($truthy($rb_lt(other, 0))) {
            return $Kernel.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
          } else {
            return $Kernel.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
          }
        } else if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        } else {
          return self.$to_f()['$**'](other)
        }
      } else {
        return self.$__coerced__("**", other)
      }
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $Kernel.$Rational(self.num.$abs(), self.den.$abs())
    }, 0);
    
    $def(self, '$ceil', function $$ceil(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, -1);
    
    $def(self, '$floor', function $$floor(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Rational:" + (self.num) + ":" + (self.den)
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return $Kernel.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, -1);
    
    $def(self, '$round', function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      if (precision == null) precision = 0;
      if (!$eqeq(precision, 0)) {
        return self.$with_precision("round", precision)
      };
      if ($eqeq(self.num, 0)) {
        return 0
      };
      if ($eqeq(self.den, 1)) {
        return self.num
      };
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, -1);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self.$truncate()
    }, 0);
    
    $def(self, '$to_r', $return_self, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, 0);
    
    $def(self, '$truncate', function $$truncate(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, -1);
    
    $def(self, '$with_precision', function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if (!$eqeqeq($$$('Integer'), precision)) {
        $Kernel.$raise($$$('TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return $Kernel.$Rational(s.$send(method), p)
      };
    }, 2);
    $defs(self, '$from_string', function $$from_string(string) {
      
      
      var str = string.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return $Kernel.$Rational(numerator, denominator);
          } else {
            return $Kernel.$Rational(numerator, 1);
          }
        } else {
          return $Kernel.$Rational(numerator, 1);
        }
      } else {
        return $Kernel.$Rational(0, 1);
      }
    
    }, 1);
    $alias(self, "divide", "/");
    return $alias(self, "quo", "/");
  })('::', $$$('Numeric'));
};

Opal.modules["corelib/math"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $type_error = Opal.type_error, $module = Opal.module, $const_set = Opal.const_set, $Class = Opal.Class, $slice = Opal.slice, $Kernel = Opal.Kernel, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_divide = Opal.rb_divide, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,raise,Float,Integer,module_function,each,define_method,checked,float!,===,gamma,-,integer!,/,infinite?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'E', Math.E);
    $const_set(self, 'PI', Math.PI);
    $const_set(self, 'DomainError', $Class.$new($$$('StandardError')));
    $defs(self, '$checked', function $$checked(method, $a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, -2);
    $defs(self, '$float!', function $Math_float$excl$1(value) {
      
      try {
        return $Kernel.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Float')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    $defs(self, '$integer!', function $Math_integer$excl$2(value) {
      
      try {
        return $Kernel.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Integer')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    self.$module_function();
    if (!$truthy((typeof(Math.erf) !== "undefined"))) {
      
      Opal.prop(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    if (!$truthy((typeof(Math.erfc) !== "undefined"))) {
      
      Opal.prop(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    $send(["acos", "acosh", "asin", "asinh", "atan", "atanh", "cbrt", "cos", "cosh", "erf", "erfc", "exp", "sin", "sinh", "sqrt", "tanh"], 'each', [], function $Math$3(method){var self = $Math$3.$$s == null ? this : $Math$3.$$s;

      
      if (method == null) method = nil;
      return $send(self, 'define_method', [method], function $$4(x){
        
        if (x == null) x = nil;
        return $$$('Math').$checked(method, $$$('Math')['$float!'](x));}, 1);}, {$$arity: 1, $$s: self});
    
    $def(self, '$atan2', function $$atan2(y, x) {
      
      return $$$('Math').$checked("atan2", $$$('Math')['$float!'](y), $$$('Math')['$float!'](x))
    }, 2);
    
    $def(self, '$hypot', function $$hypot(x, y) {
      
      return $$$('Math').$checked("hypot", $$$('Math')['$float!'](x), $$$('Math')['$float!'](y))
    }, 2);
    
    $def(self, '$frexp', function $$frexp(x) {
      
      
      x = $$('Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, 1);
    
    $def(self, '$gamma', function $$gamma(n) {
      
      
      n = $$('Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$('Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$$('Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, 1);
    
    $def(self, '$ldexp', function $$ldexp(mantissa, exponent) {
      
      
      mantissa = $$('Math')['$float!'](mantissa);
      exponent = $$('Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        $Kernel.$raise($$$('RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, 2);
    
    $def(self, '$lgamma', function $$lgamma(n) {
      
      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$$('Math').$gamma(n))), $$$('Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, 1);
    
    $def(self, '$log', function $$log(x, base) {
      
      
      ;
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      if ($truthy(base == null)) {
        return $$$('Math').$checked("log", $$$('Math')['$float!'](x))
      } else {
        
        if ($eqeqeq($$$('String'), base)) {
          $Kernel.$raise($type_error(base, $$$('Float')))
        };
        return $rb_divide($$$('Math').$checked("log", $$$('Math')['$float!'](x)), $$$('Math').$checked("log", $$$('Math')['$float!'](base)));
      };
    }, -2);
    
    $def(self, '$log10', function $$log10(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log10", $$$('Math')['$float!'](x));
    }, 1);
    
    $def(self, '$log2', function $$log2(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log2", $$$('Math')['$float!'](x));
    }, 1);
    return $def(self, '$tan', function $$tan(x) {
      
      
      x = $$$('Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      return $$$('Math').$checked("tan", $$$('Math')['$float!'](x));
    }, 1);
  })('::', $nesting)
};

Opal.modules["corelib/string"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $global_multiline_regexp = Opal.global_multiline_regexp, $prop = Opal.prop, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $gvars = Opal.gvars, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $alias = Opal.alias, $const_set = Opal.const_set, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,initialize,===,format,raise,respond_to?,to_s,to_str,<=>,==,=~,new,force_encoding,casecmp,empty?,ljust,ceil,/,+,rjust,floor,coerce_to!,nil?,class,copy_singleton_methods,initialize_clone,initialize_dup,enum_for,chomp,[],to_i,length,each_line,to_proc,to_a,match,match?,captures,proc,succ,escape,include?,upcase,unicode_normalize,dup,__id__,next,intern,pristine');
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    Opal.prop(self.$$prototype, '$$is_string', true);
  ;
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.toString();
    }, 0);
    $defs(self, '$try_convert', function $$try_convert(what) {
      
      return $Opal['$coerce_to?'](what, $$$('String'), "to_str")
    }, 1);
    $defs(self, '$new', function $String_new$1($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$$('String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', $to_a(args));
      return str;
    ;
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity;

      
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) str = $post_args.shift();;
      
      encoding = $kwargs.$$smap["encoding"];if (encoding == null) encoding = nil;
      
      capacity = $kwargs.$$smap["capacity"];if (capacity == null) capacity = nil;
      return nil;
    }, -1);
    
    $def(self, '$%', function $String_$percent$2(data) {
      var self = this;

      if ($eqeqeq($$$('Array'), data)) {
        return $send(self, 'format', [self].concat($to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, 1);
    
    $def(self, '$*', function $String_$$3(count) {
      var self = this;

      
      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return '';
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        $Kernel.$raise($$$('RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return result;
    
    }, 1);
    
    $def(self, '$+', function $String_$plus$4(other) {
      var self = this;

      
      other = $coerce_to(other, $$$('String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    }, 1);
    
    $def(self, '$<=>', function $String_$lt_eq_gt$5(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, 1);
    
    $def(self, '$==', function $String_$eq_eq$6(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    }, 1);
    
    $def(self, '$=~', function $String_$eq_tilde$7(other) {
      var self = this;

      
      if (other.$$is_string) {
        $Kernel.$raise($$$('TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, 1);
    
    $def(self, '$[]', function $String_$$$8(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude, range;

      if (index.$$is_range) {
        exclude = index.excl;
        range   = index;
        length  = index.end === nil ? -1 : $coerce_to(index.end, $$$('Integer'), 'to_int');
        index   = index.begin === nil ? 0 : $coerce_to(index.begin, $$$('Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude || range.end === nil) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.substr(index, length);
      }


      if (index.$$is_string) {
        if (length != null) {
          $Kernel.$raise($$$('TypeError'))
        }
        return self.indexOf(index) !== -1 ? index : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$$('MatchData').$new(index, match))

        if (length == null) {
          return match[0];
        }

        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return match[length += match.length];
        }

        if (length >= 0 && length < match.length) {
          return match[length];
        }

        return nil;
      }


      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.substr(index, 1);
      }

      length = $coerce_to(length, $$$('Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.substr(index, length);
    ;
    }, -2);
    
    $def(self, '$b', function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    }, 0);
    
    $def(self, '$capitalize', function $$capitalize() {
      var self = this;

      return self.charAt(0).toUpperCase() + self.substr(1).toLowerCase();
    }, 0);
    
    $def(self, '$casecmp', function $$casecmp(other) {
      var self = this;

      
      if (!$truthy(other['$respond_to?']("to_str"))) {
        return nil
      };
      other = ($coerce_to(other, $$$('String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, 1);
    
    $def(self, '$casecmp?', function $String_casecmp$ques$9(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, 1);
    
    $def(self, '$center', function $$center(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return rjustified + ljustified.slice(self.length);
    ;
    }, -2);
    
    $def(self, '$chomp', function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      if ($truthy(separator === nil || self.length === 0)) {
        return self
      };
      separator = $Opal['$coerce_to!'](separator, $$$('String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return result;
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$chop', function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return result;
    
    }, 0);
    
    $def(self, '$chr', function $$chr() {
      var self = this;

      return self.charAt(0);
    }, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash2(["freeze"], {"freeze": freeze}));
      if ($eqeq(freeze, true)) {
        if (!copy.$$frozen) { copy.$$frozen = true; }
      } else if ($truthy(freeze['$nil?']())) {
        if (self.$$frozen) { copy.$$frozen = true; }
      };
      return copy;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$count', function $$count($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice.call(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, -1);
    
    $def(self, '$delete', function $String_delete$10($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice.call(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp(char_class, 'g'), '');
    ;
    }, -1);
    
    $def(self, '$delete_prefix', function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$$('String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.slice(prefix.length);
      } else {
        return self;
      }
    
    }, 1);
    
    $def(self, '$delete_suffix', function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$$('String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.slice(0, self.length - suffix.length);
      } else {
        return self;
      }
    
    }, 1);
    
    $def(self, '$downcase', function $$downcase() {
      var self = this;

      return self.toLowerCase();
    }, 0);
    
    $def(self, '$each_line', function $$each_line($a, $b) {
      var block = $$each_line.$$p || nil, $post_args, $kwargs, separator, chomp, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each_line.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $kwargs.$$smap["chomp"];if (chomp == null) chomp = false;
      if (!(block !== nil)) {
        return self.$enum_for("each_line", separator, $hash2(["chomp"], {"chomp": chomp}))
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$$('String'), 'to_str');

      var a, i, n, length, chomped, trailing, splitted, value;

      if (separator.length === 0) {
        for (a = self.split(/((?:\r?\n){2})(?:(?:\r?\n)*)/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            value = (a[i] || "") + (a[i + 1] || "");
            if (chomp) {
              value = (value).$chomp("\n");
            }
            Opal.yield1(block, value);
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        value = splitted[i];
        if (i < length - 1 || trailing) {
          value += separator;
        }
        if (chomp) {
          value = (value).$chomp(separator);
        }
        Opal.yield1(block, value);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$empty?', function $String_empty$ques$11() {
      var self = this;

      return self.length === 0;
    }, 0);
    
    $def(self, '$end_with?', function $String_end_with$ques$12($a) {
      var $post_args, suffixes, self = this;

      
      $post_args = $slice.call(arguments);
      suffixes = $post_args;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$$('String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, -1);
    
    $def(self, '$gsub', function $$gsub(pattern, replacement) {
      var block = $$gsub.$$p || nil, self = this;

      $$gsub.$$p = null;
      
      ;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$$('MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$$('String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return result;
    ;
    }, -2);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$hex', function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, 0);
    
    $def(self, '$include?', function $String_include$ques$13(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$$('String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    }, 1);
    
    $def(self, '$index', function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = $global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$$('MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, -2);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
      /* eslint-enable no-misleading-character-class */
    
    }, 0);
    
    $def(self, '$intern', function $$intern() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    }, 0);
    $alias(self, "size", "length");
    
    $def(self, '$lines', function $$lines($a, $b) {
      var block = $$lines.$$p || nil, $post_args, $kwargs, separator, chomp, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$lines.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $kwargs.$$smap["chomp"];if (chomp == null) chomp = false;
      e = $send(self, 'each_line', [separator, $hash2(["chomp"], {"chomp": chomp})], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, -1);
    
    $def(self, '$ljust', function $$ljust(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self + result.slice(0, width);
    ;
    }, -2);
    
    $def(self, '$lstrip', function $$lstrip() {
      var self = this;

      return self.replace(/^[\u0000\s]*/, '');
    }, 0);
    
    $def(self, '$ascii_only?', function $String_ascii_only$ques$14() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    }, 0);
    
    $def(self, '$match', function $$match(pattern, pos) {
      var block = $$match.$$p || nil, self = this;

      $$match.$$p = null;
      
      ;
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, -2);
    
    $def(self, '$match?', function $String_match$ques$15(pattern, pos) {
      var self = this;

      
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, -2);
    
    $def(self, '$next', function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return '';
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return result;
    
    }, 0);
    
    $def(self, '$oct', function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, 0);
    
    $def(self, '$ord', function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    }, 0);
    
    $def(self, '$partition', function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, 1);
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, 0);
    
    $def(self, '$rindex', function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, -2);
    
    $def(self, '$rjust', function $$rjust(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return result + padstr.slice(0, remaining) + self;
    ;
    }, -2);
    
    $def(self, '$rpartition', function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, 1);
    
    $def(self, '$rstrip', function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, 0);
    
    $def(self, '$scan', function $$scan(pattern, $kwargs) {
      var block = $$scan.$$p || nil, no_matchdata, self = this;

      $$scan.$$p = null;
      
      ;
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $kwargs.$$smap["no_matchdata"];if (no_matchdata == null) no_matchdata = false;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$$('MatchData').$new(pattern, match, $hash2(["no_matchdata"], {"no_matchdata": no_matchdata}));
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? Opal.yield1(block, match[0]) : Opal.yield1(block, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      if (!no_matchdata) ($gvars["~"] = match_data);

      return (block !== nil ? self : result);
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, 0);
    
    $def(self, '$split', function $$split(pattern, limit) {
      var self = this, $ret_or_1 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy(($ret_or_1 = $gvars[";"])) ? ($ret_or_1) : (" "));
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [result[0]];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        return result;
      }

      if (limit >= result.length) {
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      return result;
    ;
    }, -1);
    
    $def(self, '$squeeze', function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice.call(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        return self.replace(/(.)\1+/g, '$1');
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1');
    ;
    }, -1);
    
    $def(self, '$start_with?', function $String_start_with$ques$16($a) {
      var $post_args, prefixes, self = this;

      
      $post_args = $slice.call(arguments);
      prefixes = $post_args;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$$('MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$$('String'), 'to_str').$to_s();

          if (self.indexOf(prefix) === 0) {
            return true;
          }
        }
      }

      return false;
    ;
    }, -1);
    
    $def(self, '$strip', function $$strip() {
      var self = this;

      return self.replace(/^[\s\u0000]*|[\s\u0000]*$/g, '');
    }, 0);
    
    $def(self, '$sub', function $$sub(pattern, replacement) {
      var block = $$sub.$$p || nil, self = this;

      $$sub.$$p = null;
      
      ;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$$('MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$$('String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$sum', function $$sum(n) {
      var self = this;

      
      if (n == null) n = 16;
      
      n = $coerce_to(n, $$$('Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, -1);
    
    $def(self, '$swapcase', function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      return str;
    
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, 0);
    
    $def(self, '$to_i', function $$to_i(base) {
      var self = this;

      
      if (base == null) base = 10;
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$$('Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, -1);
    
    $def(self, '$to_proc', function $$to_proc() {
      var $yield = $$to_proc.$$p || nil, self = this, method_name = nil, proc = nil;

      $$to_proc.$$p = null;
      
      method_name = self.valueOf();
      proc = $send($Kernel, 'proc', [], function $$17($a){var block = $$17.$$p || nil, $post_args, args;

        $$17.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        
        if (args.length === 0) {
          $Kernel.$raise($$$('ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv['$' + method_name];

        if (!body) {
          body = recv.$method_missing;
          args[0] = method_name;
        } else {
          args = args.slice(1);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 0) {
          return body.call(recv);
        } else {
          return body.apply(recv, args);
        }
      ;}, -1);
      proc.$$source_location = nil;
      return proc;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.toString();
    }, 0);
    
    $def(self, '$tr', function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return new_str;
    
    }, 2);
    
    $def(self, '$tr_s', function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return new_str;
    
    }, 2);
    
    $def(self, '$upcase', function $$upcase() {
      var self = this;

      return self.toUpperCase();
    }, 0);
    
    $def(self, '$upto', function $$upto(stop, excl) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (excl == null) excl = false;
      if (!(block !== nil)) {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$$('String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$$('String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$$('Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$$('Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    }, 0);
    $defs(self, '$_load', function $$_load($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$unicode_normalize', function $$unicode_normalize(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      if (!$truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
        $Kernel.$raise($$$('ArgumentError'), "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, -1);
    
    $def(self, '$unicode_normalized?', function $String_unicode_normalized$ques$18(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      return self.$unicode_normalize(form)['$=='](self);
    }, -1);
    
    $def(self, '$unpack', function $$unpack(format) {
      
      return $Kernel.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, 1);
    
    $def(self, '$unpack1', function $$unpack1(format) {
      
      return $Kernel.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, 1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') { return self; }
      $prop(self, "$$frozen", true);
      return self;
    
    }, 0);
    
    $def(self, '$-@', function $String_$minus$$19() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    }, 0);
    
    $def(self, '$frozen?', function $String_frozen$ques$20() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    }, 0);
    $alias(self, "+@", "dup");
    $alias(self, "===", "==");
    $alias(self, "byteslice", "[]");
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "===");
    $alias(self, "object_id", "__id__");
    $alias(self, "slice", "[]");
    $alias(self, "succ", "next");
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");
    return $Opal.$pristine(self, "initialize");
  })('::', String, $nesting);
  return $const_set($nesting[0], 'Symbol', $$('String'));
};

Opal.modules["corelib/kernel/format"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $coerce_to = Opal.coerce_to, $module = Opal.module, $slice = Opal.slice, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $def = Opal.def, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,[],==,length,coerce_to?,nil?,to_a,raise,to_int,fetch,Integer,Float,to_ary,to_str,inspect,to_s,format');
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$format', function $$format(format_string, $a) {
      var $post_args, args, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      if (($eqeq(args.$length(), 1) && ($truthy(args['$[]'](0)['$respond_to?']("to_ary"))))) {
        
        ary = $Opal['$coerce_to?'](args['$[]'](0), $$$('Array'), "to_ary");
        if (!$truthy(ary['$nil?']())) {
          args = ary.$to_a()
        };
      };
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "flag after width") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "width given twice") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { $Kernel.$raise($$$('ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with numbered") // raise
        case -2: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with named") // raise
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          $Kernel.$raise($$$('ArgumentError'), "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              $Kernel.$raise($$$('ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
          // no-break
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                $Kernel.$raise($$$('ArgumentError'), "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                $Kernel.$raise($$$('ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  $Kernel.$raise($$$('ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }
            // raise

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              $Kernel.$raise($$$('ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = $Kernel.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            $Kernel.$raise($$$('NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")
            // raise

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$$('Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              $Kernel.$raise($$$('ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        $Kernel.$raise($$$('ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, -2);
    return $alias(self, "sprintf", "format");
  })('::')
};

Opal.modules["corelib/complex"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $defs = Opal.defs, $rb_times = Opal.rb_times, $def = Opal.def, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $return_val = Opal.return_val, $const_set = Opal.const_set, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,real?,===,raise,new,*,cos,sin,attr_reader,freeze,class,==,real,imag,Complex,-@,+,__coerced__,-,nan?,/,conj,abs2,quo,polar,exp,log,>,!=,divmod,**,hypot,atan2,lcm,denominator,finite?,infinite?,numerator,abs,arg,rationalize,to_f,to_i,to_r,inspect,zero?,positive?,Rational,rect,angle');
  
  self.$require("corelib/numeric");
  self.$require("corelib/complex/base");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.real = $proto.imag = nil;
    
    $defs(self, '$rect', function $$rect(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      if (!((($eqeqeq($$$('Numeric'), real) && ($truthy(real['$real?']()))) && ($eqeqeq($$$('Numeric'), imag))) && ($truthy(imag['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, -2);
    $defs(self, '$polar', function $$polar(r, theta) {
      var self = this;

      
      if (theta == null) theta = 0;
      if (!((($eqeqeq($$$('Numeric'), r) && ($truthy(r['$real?']()))) && ($eqeqeq($$$('Numeric'), theta))) && ($truthy(theta['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$$('Math').$cos(theta)), $rb_times(r, $$$('Math').$sin(theta)));
    }, -2);
    self.$attr_reader("real", "imag");
    
    $def(self, '$initialize', function $$initialize(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      self.real = real;
      self.imag = imag;
      return self.$freeze();
    }, -2);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return [other, self]
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return [$$$('Complex').$new(other, 0), self]
      } else {
        return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, 1);
    
    $def(self, '$==', function $Complex_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Complex'), other)) {
        if ($truthy(($ret_or_1 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_1
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        if ($truthy(($ret_or_1 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_1
        }
      } else {
        return other['$=='](self)
      }
    }, 1);
    
    $def(self, '$-@', function $Complex_$minus$$2() {
      var self = this;

      return $Kernel.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, 0);
    
    $def(self, '$+', function $Complex_$plus$3(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, 1);
    
    $def(self, '$-', function $Complex_$minus$4(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, 1);
    
    $def(self, '$*', function $Complex_$$5(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, 1);
    
    $def(self, '$/', function $Complex_$slash$6(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        if ((((($eqeqeq($$$('Number'), self.real) && ($truthy(self.real['$nan?']()))) || (($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$real()) && ($truthy(other.$real()['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$imag()) && ($truthy(other.$imag()['$nan?']())))))) {
          return $$$('Complex').$new($$$($$$('Float'), 'NAN'), $$$($$$('Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, 1);
    
    $def(self, '$**', function $Complex_$$$7(other) {
      var $a, $b, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if ($eqeq(other, 0)) {
        return $$$('Complex').$new(1, 0)
      };
      if ($eqeqeq($$$('Complex'), other)) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$$('Math').$exp($rb_minus($rb_times(ore, $$$('Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$$('Math').$log(r)));
        return $$$('Complex').$polar(nr, ntheta);
      } else if ($eqeqeq($$$('Integer'), other)) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($neqeq(n, 0)) {
          
            $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            while ($eqeq(mod, 0)) {
            
              x = $Kernel.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$$('Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$$('Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $$$('Math').$hypot(self.real, self.imag)
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, 0);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      return $$$('Math').$atan2(self.imag, self.real)
    }, 0);
    
    $def(self, '$conj', function $$conj() {
      var self = this;

      return $Kernel.$Complex(self.real, self.imag['$-@']())
    }, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, 0);
    
    $def(self, '$eql?', function $Complex_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('Complex')['$==='](other))) ? (self.real.$class()['$=='](self.imag.$class())) : ($ret_or_2))))) {
        return self['$=='](other)
      } else {
        return $ret_or_1
      }
    }, 1);
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Numeric'), other)) {
        $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, 1);
    
    $def(self, '$finite?', function $Complex_finite$ques$9() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_1
      }
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return "Complex:" + (self.real) + ":" + (self.imag)
    }, 0);
    
    $def(self, '$infinite?', function $Complex_infinite$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$infinite?']()))) {
        return $ret_or_1
      } else {
        return self.imag['$infinite?']()
      }
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return $Kernel.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, 0);
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($neqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.$real().$rationalize(eps);
    }, -1);
    
    $def(self, '$real?', $return_val(false), 0);
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, 0);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (((($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))) || ($truthy(self.imag['$positive?']()))) || ($truthy(self.imag['$zero?']()))) ? ("+") : ("-")));
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if (($eqeqeq($$$('Number'), self.imag) && (($truthy(self.imag['$nan?']()) || ($truthy(self.imag['$infinite?']())))))) {
        result = $rb_plus(result, "*")
      };
      return $rb_plus(result, "i");
    }, 0);
    $const_set($nesting[0], 'I', self.$new(0, 1));
    $defs(self, '$from_string', function $$from_string(str) {
      
      
      var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return $Kernel.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return $Kernel.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return $Kernel.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return $Kernel.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return $Kernel.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return $Kernel.$Complex(real, imag);
      }
    
    }, 1);
    (function(self, $parent_nesting) {
      
      return $alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "divide", "/");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "phase", "arg");
    $alias(self, "quo", "/");
    $alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.udef(self, '$' + "positive?");;
    
    
    Opal.udef(self, '$' + "step");;
    return nil;;
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/variables"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $gvars = Opal.gvars, $const_set = Opal.const_set, $Object = Opal.Object, $hash2 = Opal.hash2, nil = Opal.nil;

  Opal.add_stubs('new');
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  $const_set('::', 'ARGV', []);
  $const_set('::', 'ARGF', $Object.$new());
  $const_set('::', 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

Opal.modules["corelib/number"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $not = Opal.not, $rb_lt = Opal.rb_lt, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq, $return_self = Opal.return_self, $rb_divide = Opal.rb_divide, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $return_val = Opal.return_val, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,bridge,raise,name,class,Float,respond_to?,coerce_to!,__coerced__,===,>,!,**,new,<,to_f,==,nan?,infinite?,enum_for,+,-,gcd,lcm,%,/,frexp,to_i,ldexp,rationalize,*,<<,to_r,truncate,-@,size,<=,>=,inspect,angle,to_s,is_a?,abs,__id__,next,coerce_to?');
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting);

    
    $Opal.$bridge(Number, self);
    Opal.prop(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [$Kernel.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$Opal['$coerce_to!'](other, $$$('Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
    
    }, 1);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, 0);
    
    $def(self, '$+', function $Number_$plus$1(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, 1);
    
    $def(self, '$-', function $Number_$minus$2(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, 1);
    
    $def(self, '$*', function $Number_$$3(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, 1);
    
    $def(self, '$/', function $Number_$slash$4(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, 1);
    
    $def(self, '$%', function $Number_$percent$5(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, 1);
    
    $def(self, '$&', function $Number_$$6(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, 1);
    
    $def(self, '$|', function $Number_$$7(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, 1);
    
    $def(self, '$^', function $Number_$$8(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, 1);
    
    $def(self, '$<', function $Number_$lt$9(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, 1);
    
    $def(self, '$<=', function $Number_$lt_eq$10(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, 1);
    
    $def(self, '$>', function $Number_$gt$11(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, 1);
    
    $def(self, '$>=', function $Number_$gt_eq$12(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    $def(self, '$<=>', function $Number_$lt_eq_gt$13(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$<<', function $Number_$lt$lt$14(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, 1);
    
    $def(self, '$>>', function $Number_$gt$gt$15(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, 1);
    
    $def(self, '$[]', function $Number_$$$16(bit) {
      var self = this;

      
      bit = $Opal['$coerce_to!'](bit, $$$('Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, 1);
    
    $def(self, '$+@', function $Number_$plus$$17() {
      var self = this;

      return +self;
    }, 0);
    
    $def(self, '$-@', function $Number_$minus$$18() {
      var self = this;

      return -self;
    }, 0);
    
    $def(self, '$~', function $Number_$$19() {
      var self = this;

      return ~self;
    }, 0);
    
    $def(self, '$**', function $Number_$$$20(other) {
      var self = this;

      if ($eqeqeq($$$('Integer'), other)) {
        if (($not($$$('Integer')['$==='](self)) || ($truthy($rb_gt(other, 0))))) {
          return Math.pow(self, other);
        } else {
          return $$$('Rational').$new(self, 1)['$**'](other)
        }
      } else if (($rb_lt(self, 0) && (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))))) {
        return $$$('Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, 1);
    
    $def(self, '$==', function $Number_$eq_eq$21(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, 1);
    $alias(self, "===", "==");
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return Math.abs(self);
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, 0);
    
    $def(self, '$allbits?', function $Number_allbits$ques$22(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == mask;;
    }, 1);
    
    $def(self, '$anybits?', function $Number_anybits$ques$23(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) !== 0;;
    }, 1);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self
      };
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, 0);
    
    $def(self, '$bit_length', function $$bit_length() {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), self)) {
        $Kernel.$raise($$$('NoMethodError').$new("undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$chr', function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, -1);
    
    $def(self, '$denominator', function $$denominator() {
      var $yield = $$denominator.$$p || nil, self = this;

      $$denominator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return 1
      } else {
        return $send2(self, $find_super(self, 'denominator', $$denominator, false, true), 'denominator', [], $yield)
      }
    }, 0);
    
    $def(self, '$downto', function $$downto(stop) {
      var block = $$downto.$$p || nil, self = this;

      $$downto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["downto", stop], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$equal?', function $Number_equal$ques$25(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$=='](other)))) {
        return $ret_or_1
      } else {
        return isNaN(self) && isNaN(other);
      }
    }, 1);
    
    $def(self, '$even?', function $Number_even$ques$26() {
      var self = this;

      return self % 2 === 0;
    }, 0);
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$gcd', function $$gcd(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, 1);
    
    $def(self, '$gcdlcm', function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    }, 1);
    
    $def(self, '$integer?', function $Number_integer$ques$27() {
      var self = this;

      return self % 1 === 0;
    }, 0);
    
    $def(self, '$is_a?', function $Number_is_a$ques$28(klass) {
      var $yield = $Number_is_a$ques$28.$$p || nil, self = this;

      $Number_is_a$ques$28.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'is_a?', $Number_is_a$ques$28, false, true), 'is_a?', [klass], $yield);
    }, 1);
    
    $def(self, '$instance_of?', function $Number_instance_of$ques$29(klass) {
      var $yield = $Number_instance_of$ques$29.$$p || nil, self = this;

      $Number_instance_of$ques$29.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'instance_of?', $Number_instance_of$ques$29, false, true), 'instance_of?', [klass], $yield);
    }, 1);
    
    $def(self, '$lcm', function $$lcm(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, 1);
    
    $def(self, '$next', function $$next() {
      var self = this;

      return self + 1;
    }, 0);
    
    $def(self, '$nobits?', function $Number_nobits$ques$30(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == 0;;
    }, 1);
    
    $def(self, '$nonzero?', function $Number_nonzero$ques$31() {
      var self = this;

      return self == 0 ? nil : self;
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var $yield = $$numerator.$$p || nil, self = this;

      $$numerator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return self
      } else {
        return $send2(self, $find_super(self, 'numerator', $$numerator, false, true), 'numerator', [], $yield)
      }
    }, 0);
    
    $def(self, '$odd?', function $Number_odd$ques$32() {
      var self = this;

      return self % 2 !== 0;
    }, 0);
    
    $def(self, '$ord', $return_self, 0);
    
    $def(self, '$pow', function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$$('Integer')['$==='](b))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$$('Integer')['$==='](m))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, -2);
    
    $def(self, '$pred', function $$pred() {
      var self = this;

      return self - 1;
    }, 0);
    
    $def(self, '$quo', function $$quo(other) {
      var $yield = $$quo.$$p || nil, self = this;

      $$quo.$$p = null;
      if ($eqeqeq($$$('Integer'), self)) {
        return $send2(self, $find_super(self, 'quo', $$quo, false, true), 'quo', [other], $yield)
      } else {
        return $rb_divide(self, other)
      }
    }, 1);
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$$('Float'), 'MANT_DIG'));
        return $$$('Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$$('Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, -1);
    
    $def(self, '$remainder', function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, 1);
    
    $def(self, '$round', function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($eqeqeq($$$('Integer'), self)) {
        
        if ($truthy(ndigits == null)) {
          return self
        };
        if (($eqeqeq($$$('Float'), ndigits) && ($truthy(ndigits['$infinite?']())))) {
          $Kernel.$raise($$$('RangeError'), "Infinity")
        };
        ndigits = $Opal['$coerce_to!'](ndigits, $$$('Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$$('Integer'), 'MIN')))) {
          $Kernel.$raise($$$('RangeError'), "out of bounds")
        };
        if ($truthy(ndigits >= 0)) {
          return self
        };
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if (($truthy(self['$nan?']()) && ($truthy(ndigits == null)))) {
          $Kernel.$raise($$$('FloatDomainError'), "NaN")
        };
        ndigits = $Opal['$coerce_to!'](ndigits || 0, $$$('Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            $Kernel.$raise($$$('RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            $Kernel.$raise($$$('FloatDomainError'), "Infinity")
          }
        } else if ($eqeq(ndigits, 0)) {
          return Math.round(self)
        } else if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
          return self
        };
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$$('Float'), 'DIG'), 2), ($truthy($rb_gt(exp, 0)) ? ($rb_divide(exp, 4)) : ($rb_minus($rb_divide(exp, 3), 1))))))) {
          return self
        };
        if ($truthy($rb_lt(ndigits, ($truthy($rb_gt(exp, 0)) ? ($rb_plus($rb_divide(exp, 3), 1)) : ($rb_divide(exp, 4)))['$-@']()))) {
          return 0
        };
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, -1);
    
    $def(self, '$times', function $$times() {
      var block = $$times.$$p || nil, self = this;

      $$times.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["times"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$to_f', $return_self, 0);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    }, 0);
    
    $def(self, '$to_r', function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$$('Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$$('Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, 0);
    
    $def(self, '$to_s', function $$to_s(base) {
      var self = this;

      
      if (base == null) base = 10;
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if (($truthy($rb_lt(base, 2)) || ($truthy($rb_gt(base, 36))))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      if (($eqeq(self, 0) && ($truthy(1/self === -Infinity)))) {
        return "-0.0"
      };
      return self.toString(base);;
    }, -1);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$digits', function $$digits(base) {
      var self = this;

      
      if (base == null) base = 10;
      if ($rb_lt(self, 0)) {
        $Kernel.$raise($$$($$$('Math'), 'DomainError'), "out of domain")
      };
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      
      if (self != parseInt(self)) $Kernel.$raise($$$('NoMethodError'), "undefined method `digits' for " + (self.$inspect()))

      var value = self, result = [];

      if (self == 0) {
        return [0];
      }

      while (value != 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var $yield = $$divmod.$$p || nil, self = this;

      $$divmod.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(other['$nan?']())))) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else {
        return $send2(self, $find_super(self, 'divmod', $$divmod, false, true), 'divmod', [other], $yield)
      }
    }, 1);
    
    $def(self, '$upto', function $$upto(stop) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["upto", stop], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$zero?', function $Number_zero$ques$35() {
      var self = this;

      return self == 0;
    }, 0);
    
    $def(self, '$size', $return_val(4), 0);
    
    $def(self, '$nan?', function $Number_nan$ques$36() {
      var self = this;

      return isNaN(self);
    }, 0);
    
    $def(self, '$finite?', function $Number_finite$ques$37() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, 0);
    
    $def(self, '$infinite?', function $Number_infinite$ques$38() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, 0);
    
    $def(self, '$positive?', function $Number_positive$ques$39() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, 0);
    
    $def(self, '$negative?', function $Number_negative$ques$40() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, 0);
    
    function numberToUint8Array(num) {
      var uint8array = new Uint8Array(8);
      new DataView(uint8array.buffer).setFloat64(0, num, true);
      return uint8array;
    }

    function uint8ArrayToNumber(arr) {
      return new DataView(arr.buffer).getFloat64(0, true);
    }

    function incrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0xff) {
          arr[i] = 0;
        } else {
          arr[i]++;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }

    function decrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0) {
          arr[i] = 0xff;
        } else {
          arr[i]--;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }
  ;
    
    $def(self, '$next_float', function $$next_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY'))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($rb_ge(self, 0)) {
        return incrementNumberBit(Math.abs(self));
      } else {
        return decrementNumberBit(self);
      };
    }, 0);
    
    $def(self, '$prev_float', function $$prev_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY')['$-@']())) {
        return $$$($$$('Float'), 'INFINITY')['$-@']()
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($rb_gt(self, 0)) {
        return decrementNumberBit(self);
      } else {
        return -incrementNumberBit(Math.abs(self));
      };
    }, 0);
    $alias(self, "arg", "angle");
    $alias(self, "eql?", "==");
    $alias(self, "fdiv", "/");
    $alias(self, "inspect", "to_s");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "object_id", "__id__");
    $alias(self, "phase", "angle");
    $alias(self, "succ", "next");
    return $alias(self, "to_int", "to_i");
  })('::', $$$('Numeric'), $nesting);
  $const_set('::', 'Fixnum', $$$('Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      Opal.udef(self, '$' + "new");;
      
      $def(self, '$sqrt', function $$sqrt(n) {
        
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        
        if (n < 0) {
          $Kernel.$raise($$$($$$('Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, 1);
      return $def(self, '$try_convert', function $$try_convert(object) {
        var self = this;

        return $$('Opal')['$coerce_to?'](object, self, "to_int")
      }, 1);
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'MAX', Math.pow(2, 30) - 1);
    return $const_set(self, 'MIN', -Math.pow(2, 30));
  })('::', $$$('Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      Opal.udef(self, '$' + "new");;
      return $def(self, '$===', function $eq_eq_eq$41(other) {
        
        return !!other.$$is_number;
      }, 1);
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'INFINITY', Infinity);
    $const_set(self, 'MAX', Number.MAX_VALUE);
    $const_set(self, 'MIN', Number.MIN_VALUE);
    $const_set(self, 'NAN', NaN);
    $const_set(self, 'DIG', 15);
    $const_set(self, 'MANT_DIG', 53);
    $const_set(self, 'RADIX', 2);
    return $const_set(self, 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/complex/base"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,from_string');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Complex', function $$Complex(real, imag) {
      
      
      if (imag == null) imag = nil;
      if ($truthy(imag)) {
        return $$('Complex').$new(real, imag)
      } else {
        return $$('Complex').$new(real, 0)
      };
    }, -2)
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $$('Complex').$from_string(self)
    }, 0)
  })('::', null, $nesting);
};

Opal.modules["opal/regexp_anchors"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'REGEXP_START', "^");
    $const_set(self, 'REGEXP_END', "$");
    $const_set(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'INLINE_IDENTIFIER_REGEXP', $$('Regexp').$new("[^" + ($$$(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$$(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    $const_set(self, 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return $const_set(self, 'CONST_NAME_REGEXP', $$('Regexp').$new("" + ($$$(self, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$$(self, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$$(self, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

Opal.modules["corelib/numeric"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $to_ary = Opal.to_ary, $return_self = Opal.return_self, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $return_val = Opal.return_val, $Opal = Opal.Opal, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $not = Opal.not, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,instance_of?,class,Float,respond_to?,coerce,__send__,raise,equal?,-,*,div,<,-@,ceil,to_f,denominator,to_r,==,floor,/,%,Complex,zero?,numerator,abs,arg,coerce_to!,round,<=>,compare,is_a?,!,new,enum_for,to_proc,negative?,>=,<=,+,to_i,truncate,>,angle,conj,imag,rect');
  
  self.$require("corelib/comparable");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    
    self.$include($$$('Comparable'));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]
      };
      return [$Kernel.$Float(other), $Kernel.$Float(self)];
    }, 1);
    
    $def(self, '$__coerced__', function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = $to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else 
      switch (method) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "&":
        case "|":
        case "^":
        case "**":
          return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")
        case ">":
        case ">=":
        case "<":
        case "<=":
        case "<=>":
          return $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
        default:
          return nil
      }
    }, 2);
    
    $def(self, '$<=>', function $Numeric_$lt_eq_gt$1(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0
      };
      return nil;
    }, 1);
    
    $def(self, '$+@', $return_self, 0);
    
    $def(self, '$-@', function $Numeric_$minus$$2() {
      var self = this;

      return $rb_minus(0, self)
    }, 0);
    
    $def(self, '$%', function $Numeric_$percent$3(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, 1);
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, 0);
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, 0);
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$$('Math'), 'PI')
      } else {
        return 0
      }
    }, 0);
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$ceil(ndigits);
    }, -1);
    
    $def(self, '$conj', $return_self, 0);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, 0);
    
    $def(self, '$div', function $$div(other) {
      var self = this;

      
      if ($eqeq(other, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by o")
      };
      return $rb_divide(self, other).$floor();
    }, 1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, 1);
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, 1);
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$floor(ndigits);
    }, -1);
    
    $def(self, '$i', function $$i() {
      var self = this;

      return $Kernel.$Complex(0, self)
    }, 0);
    
    $def(self, '$imag', $return_val(0), 0);
    
    $def(self, '$integer?', $return_val(false), 0);
    
    $def(self, '$nonzero?', function $Numeric_nonzero$ques$4() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, 0);
    
    $def(self, '$numerator', function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, 0);
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, 0);
    
    $def(self, '$quo', function $$quo(other) {
      var self = this;

      return $rb_divide($Opal['$coerce_to!'](self, $$$('Rational'), "to_r"), other)
    }, 1);
    
    $def(self, '$real', $return_self, 0);
    
    $def(self, '$real?', $return_val(true), 0);
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self, 0]
    }, 0);
    
    $def(self, '$round', function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, -1);
    
    $def(self, '$step', function $$step($a, $b, $c) {
      var block = $$step.$$p || nil, $post_args, $kwargs, limit, step, to, by, self = this, counter = nil;

      $$step.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) limit = $post_args.shift();;
      
      if ($post_args.length > 0) step = $post_args.shift();;
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          $Kernel.$raise($$$('TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          $Kernel.$raise($$$('ArgumentError'), "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$$('Float'), 'INFINITY') : $$$($$$('Float'), 'INFINITY')['$-@']();
        }

        $Opal.$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$$('Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if (!(block !== nil)) {
        if ((($not(limit) || ($truthy(limit['$is_a?']($$$('Numeric'))))) && (($not(step) || ($truthy(step['$is_a?']($$$('Numeric')))))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new([limit, step, ($truthy(to) ? ("to: ") : nil), ($truthy(by) ? ("by: ") : nil)], self)
        } else {
          return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
        }
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
      
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, -1);
    
    $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $Kernel.$Complex(self, 0)
    }, 0);
    
    $def(self, '$to_int', function $$to_int() {
      var self = this;

      return self.$to_i()
    }, 0);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$truncate(ndigits);
    }, -1);
    
    $def(self, '$zero?', function $Numeric_zero$ques$5() {
      var self = this;

      return self['$=='](0)
    }, 0);
    
    $def(self, '$positive?', function $Numeric_positive$ques$6() {
      var self = this;

      return $rb_gt(self, 0)
    }, 0);
    
    $def(self, '$negative?', function $Numeric_negative$ques$7() {
      var self = this;

      return $rb_lt(self, 0)
    }, 0);
    
    $def(self, '$dup', $return_self, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$finite?', $return_val(true), 0);
    
    $def(self, '$infinite?', $return_val(nil), 0);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "phase", "arg");
    return $alias(self, "rectangular", "rect");
  })('::', null);
};

Opal.modules["opal/base"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("corelib/runtime");
  $Object.$require("corelib/helpers");
  $Object.$require("corelib/module");
  $Object.$require("corelib/class");
  $Object.$require("corelib/basic_object");
  $Object.$require("corelib/kernel");
  $Object.$require("corelib/main");
  $Object.$require("corelib/error");
  return $Object.$require("corelib/constants");
};

Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, nil = Opal.nil, $$$ = Opal.$$$, mersenne_twister = nil;

  Opal.add_stubs('generator=');
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    var $a;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    $const_set(self, 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    return ($a = [$$$(self, 'MERSENNE_TWISTER_GENERATOR')], $send(self, 'generator=', $a), $a[$a.length - 1]);
  })('::', null);
};

Opal.modules["corelib/io"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $not = Opal.not, $truthy = Opal.truthy, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $range = Opal.range, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $assign_ivar_val = Opal.assign_ivar_val, $alias = Opal.alias, $a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,attr_accessor,!,match?,include?,size,write,String,flatten,puts,sysread_noraise,+,!=,[],ord,getc,readchar,raise,gets,==,to_str,length,split,sub,sysread,>,to_a,each_line,enum_for,getbyte,closed_write?,closed_read?,each,eof,new,write_proc=,read_proc=');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'IO');

    var $proto = self.$$prototype;

    $proto.read_buffer = $proto.closed = nil;
    
    $const_set(self, 'SEEK_SET', 0);
    $const_set(self, 'SEEK_CUR', 1);
    $const_set(self, 'SEEK_END', 2);
    $const_set(self, 'SEEK_DATA', 3);
    $const_set(self, 'SEEK_HOLE', 4);
    $const_set(self, 'READABLE', 1);
    $const_set(self, 'WRITABLE', 4);
    self.$attr_reader("eof");
    self.$attr_accessor("read_proc", "sync", "tty", "write_proc");
    
    $def(self, '$initialize', function $$initialize(fd, flags) {
      var self = this;

      
      if (flags == null) flags = "r";
      self.fd = fd;
      self.flags = flags;
      self.eof = false;
      if (($truthy(flags['$include?']("r")) && ($not(flags['$match?'](/[wa+]/))))) {
        return (self.closed = "write")
      } else if (($truthy(flags['$match?'](/[wa]/)) && ($not(flags['$match?'](/[r+]/))))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$fileno', $return_ivar("fd"), 0);
    
    $def(self, '$tty?', function $IO_tty$ques$1() {
      var self = this;

      return self.tty == true;
    }, 0);
    
    $def(self, '$write', function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, 1);
    
    $def(self, '$flush', $return_val(nil), 0);
    
    $def(self, '$<<', function $IO_$lt$lt$2(string) {
      var self = this;

      
      self.$write(string);
      return self;
    }, 1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, args, self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = $Kernel.$String(args[i])
      }
      self.$write(args.join($gvars[","]));
    ;
      return nil;
    }, -1);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var line
      if (args.length === 0) {
        self.$write("\n");
        return nil;
      } else {
        for (var i = 0, ii = args.length; i < ii; i++) {
          if (args[i].$$is_array){
            var ary = (args[i]).$flatten()
            if (ary.length > 0) $send(self, 'puts', $to_a((ary)))
          } else {
            if (args[i].$$is_string) {
              line = args[i].valueOf();
            } else {
              line = $Kernel.$String(args[i]);
            }
            if (!line.endsWith("\n")) line += "\n"
            self.$write(line)
          }
        }
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$getc', function $$getc() {
      var self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($neqeq(self.read_buffer, "")) {
          
          ret = self.read_buffer['$[]'](0);
          self.read_buffer = self.read_buffer['$[]']($range(1, -1, false));
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(1))));;
      return nil;
    }, 0);
    
    $def(self, '$getbyte', function $$getbyte() {
      var $a, self = this;

      return ($a = self.$getc(), ($a === nil || $a == null) ? nil : $a.$ord())
    }, 0);
    
    $def(self, '$readbyte', function $$readbyte() {
      var self = this;

      return self.$readchar().$ord()
    }, 0);
    
    $def(self, '$readchar', function $$readchar() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$getc()))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      }
    }, 0);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args, self = this, $ret_or_1 = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(($ret_or_1 = $send(self, 'gets', $to_a(args))))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      };
    }, -1);
    
    $def(self, '$gets', function $$gets(sep, limit, opts) {
      var $a, $b, self = this, orig_sep = nil, $ret_or_1 = nil, seplen = nil, data = nil, ret = nil, orig_buffer = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (sep == null) sep = false;
      if (limit == null) limit = nil;
      if (opts == null) opts = $hash2([], {});
      if (($truthy(sep.$$is_number) && ($not(limit)))) {
        $a = [false, sep, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      if ((($truthy(sep.$$is_hash) && ($not(limit))) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [false, nil, sep], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      } else if (($truthy(limit.$$is_hash) && ($eqeq(opts, $hash2([], {}))))) {
        $a = [sep, nil, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      orig_sep = sep;
      if ($eqeq(sep, false)) {
        sep = $gvars["/"]
      };
      if ($eqeq(sep, "")) {
        sep = /\r?\n\r?\n/
      };
      sep = ($truthy(($ret_or_1 = sep)) ? ($ret_or_1) : (""));
      if (!$eqeq(orig_sep, "")) {
        sep = sep.$to_str()
      };
      seplen = ($eqeq(orig_sep, "") ? (2) : (sep.$length()));
      if ($eqeq(sep, " ")) {
        sep = / /
      };
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      data = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, data);
        if (($neqeq(sep, "") && ($truthy(($truthy(sep.$$is_regexp) ? (self.read_buffer['$match?'](sep)) : (self.read_buffer['$include?'](sep))))))) {
          
          orig_buffer = self.read_buffer;
          $b = self.read_buffer.$split(sep, 2), $a = $to_ary($b), (ret = ($a[0] == null ? nil : $a[0])), (self.read_buffer = ($a[1] == null ? nil : $a[1])), $b;
          if ($neqeq(ret, orig_buffer)) {
            ret = $rb_plus(ret, orig_buffer['$[]'](ret.$length(), seplen))
          };
          break;
        };
      } while ($truthy((data = self.$sysread_noraise(($eqeq(sep, "") ? (65536) : (1))))));;
      if (!$truthy(ret)) {
        
        $a = [($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : ("")), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
        if ($eqeq(ret, "")) {
          ret = nil
        };
      };
      if ($truthy(ret)) {
        
        if ($truthy(limit)) {
          
          ret = ret['$[]'](Opal.Range.$new(0,limit, true));
          self.read_buffer = $rb_plus(ret['$[]'](Opal.Range.$new(limit, -1, false)), self.read_buffer);
        };
        if ($truthy(opts['$[]']("chomp"))) {
          ret = ret.$sub(/\r?\n$/, "")
        };
        if ($eqeq(orig_sep, "")) {
          ret = ret.$sub(/^[\r\n]+/, "")
        };
      };
      if ($eqeq(orig_sep, false)) {
        $gvars._ = ret
      };
      return ret;
    }, -1);
    
    $def(self, '$sysread', function $$sysread(integer) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.read_proc(integer)))) {
        return $ret_or_1
      } else {
        
        self.eof = true;
        return $Kernel.$raise($$$('EOFError'), "end of file reached");
      }
    }, 1);
    
    $def(self, '$sysread_noraise', function $$sysread_noraise(integer) {
      var self = this;

      try {
        return self.$sysread(integer)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('EOFError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, 1);
    
    $def(self, '$readpartial', function $$readpartial(integer) {
      var $a, self = this, $ret_or_1 = nil, part = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      part = self.$sysread(integer);
      $a = [$rb_plus(self.read_buffer, ($truthy(($ret_or_1 = part)) ? ($ret_or_1) : (""))), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      if ($eqeq(ret, "")) {
        ret = nil
      };
      return ret;
    }, 1);
    
    $def(self, '$read', function $$read(integer) {
      var $a, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      if (integer == null) integer = nil;
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if (($truthy(integer) && ($truthy($rb_gt(self.read_buffer.$length(), integer))))) {
          
          $a = [self.read_buffer['$[]'](Opal.Range.$new(0,integer, true)), self.read_buffer['$[]'](Opal.Range.$new(integer, -1, false))], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(($truthy(($ret_or_1 = integer)) ? ($ret_or_1) : (65536))))));;
      $a = [self.read_buffer, ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      return ret;
    }, -1);
    
    $def(self, '$readlines', function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      return self.$each_line(separator).$to_a();
    }, -1);
    
    $def(self, '$each', function $$each($a, $b) {
      var block = $$each.$$p || nil, $post_args, sep, args, self = this, s = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      
      if ($post_args.length > 0) sep = $post_args.shift();if (sep == null) sep = $gvars["/"];
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each", sep].concat($to_a(args)))
      };
      while ($truthy((s = $send(self, 'gets', [sep].concat($to_a(args)))))) {
      Opal.yield1(block, s)
      };
      return self;
    }, -1);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this, s = nil;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_byte")
      };
      while ($truthy((s = self.$getbyte()))) {
      Opal.yield1(block, s)
      };
      return self;
    }, 0);
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this, s = nil;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_char")
      };
      while ($truthy((s = self.$getc()))) {
      Opal.yield1(block, s)
      };
      return self;
    }, 0);
    
    $def(self, '$close', $assign_ivar_val("closed", "both"), 0);
    
    $def(self, '$close_read', function $$close_read() {
      var self = this;

      if ($eqeq(self.closed, "write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    }, 0);
    
    $def(self, '$close_write', function $$close_write() {
      var self = this;

      if ($eqeq(self.closed, "read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    }, 0);
    
    $def(self, '$closed?', function $IO_closed$ques$3() {
      var self = this;

      return self.closed['$==']("both")
    }, 0);
    
    $def(self, '$closed_read?', function $IO_closed_read$ques$4() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("read")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    }, 0);
    
    $def(self, '$closed_write?', function $IO_closed_write$ques$5() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("write")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    }, 0);
    
    $def(self, '$check_writable', function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for writing")
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$check_readable', function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for reading")
      } else {
        return nil
      }
    }, 0);
    $alias(self, "each_line", "each");
    return $alias(self, "eof?", "eof");
  })('::', null);
  $const_set('::', 'STDIN', ($gvars.stdin = $$$('IO').$new(0, "r")));
  $const_set('::', 'STDOUT', ($gvars.stdout = $$$('IO').$new(1, "w")));
  $const_set('::', 'STDERR', ($gvars.stderr = $$$('IO').$new(2, "w")));
  var console = Opal.global.console;
  $$$('STDOUT')['$write_proc='](typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)});
  $$$('STDERR')['$write_proc='](typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)});
  return ($a = [function(s) { var p = prompt(); if (p !== null) return p + "\n"; return nil; }], $send($$$('STDIN'), 'read_proc=', $a), $a[$a.length - 1]);
};

Opal.modules["corelib/hash"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $yield1 = Opal.yield1, $hash = Opal.hash, $hash_init = Opal.hash_init, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $hash2 = Opal.hash2, $truthy = Opal.truthy, $to_a = Opal.to_a, $return_self = Opal.return_self, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,[],merge!,allocate,raise,coerce_to!,each,fetch,>=,>,==,compare_by_identity,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,inspect,map,to_proc,flatten,frozen?,eql?,default,default_proc,default_proc=,default=,to_h,proc,clone,select,select!,has_key?,indexes,index,length,[]=,has_value?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_hash = true;
    $defs(self, '$[]', function $Hash_$$$1($a) {
      var $post_args, argv, self = this;

      
      $post_args = $slice.call(arguments);
      argv = $post_args;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Array'), "to_ary");
        if (argv === nil) {
          $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            $Kernel.$raise($$$('ArgumentError'), "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, -1);
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      $hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, 0);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Hash'), "to_hash")
    }, 1);
    
    $def(self, '$initialize', function $$initialize(defaults) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (defaults !== undefined && block !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, -1);
    
    $def(self, '$==', function $Hash_$eq_eq$2(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = $hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, 1);
    
    $def(self, '$>=', function $Hash_$gt_eq$3(other) {
      var self = this, result = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], function $$4(other_key, other_val){var self = $$4.$$s == null ? this : $$4.$$s, val = nil;

        
        if (other_key == null) other_key = nil;
        if (other_val == null) other_val = nil;
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, {$$arity: 2, $$s: self});
      return result;
    }, 1);
    
    $def(self, '$>', function $Hash_$gt$5(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, 1);
    
    $def(self, '$<', function $Hash_$lt$6(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_gt(other, self);
    }, 1);
    
    $def(self, '$<=', function $Hash_$lt_eq$7(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_ge(other, self);
    }, 1);
    
    $def(self, '$[]', function $Hash_$$$8(key) {
      var self = this;

      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, 1);
    
    $def(self, '$[]=', function $Hash_$$$eq$9(key, value) {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_put(self, key, value);
      return value;
    
    }, 2);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_init(self);
      return self;
    
    }, 0);
    
    $def(self, '$clone', function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, 0);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, 0);
    
    $def(self, '$compact!', function $Hash_compact$excl$10() {
      var self = this;

      
      $deny_frozen_access(self);

      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, 0);
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      
      $deny_frozen_access(self);

      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        $hash_put(identity_hash, key, $hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, 0);
    
    $def(self, '$compare_by_identity?', function $Hash_compare_by_identity$ques$11() {
      var self = this;

      return self.$$by_identity === true;
    }, 0);
    
    $def(self, '$default', function $Hash_default$12(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, -1);
    
    $def(self, '$default=', function $Hash_default$eq$13(object) {
      var self = this;

      
      $deny_frozen_access(self);

      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, 1);
    
    $def(self, '$default_proc', function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, 0);
    
    $def(self, '$default_proc=', function $Hash_default_proc$eq$14(default_proc) {
      var self = this;

      
      $deny_frozen_access(self);

      var proc = default_proc;

      if (proc !== nil) {
        proc = $Opal['$coerce_to!'](proc, $$$('Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          $Kernel.$raise($$$('TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, 1);
    
    $def(self, '$delete', function $Hash_delete$15(key) {
      var block = $Hash_delete$15.$$p || nil, self = this;

      $Hash_delete$15.$$p = null;
      
      ;
      
      $deny_frozen_access(self);
      var value = $hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["delete_if"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice.call(arguments, 1);
      keys = $post_args;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $yield1(block, [key, value]);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$each_key', function $$each_key() {
      var block = $$each_key.$$p || nil, self = this;

      $$each_key.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_key"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$each_value', function $$each_value() {
      var block = $$each_value.$$p || nil, self = this;

      $$each_value.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_value"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, keys = self.$$keys.slice(), length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$empty?', function $Hash_empty$ques$20() {
      var self = this;

      return self.$$keys.length === 0;
    }, 0);
    
    $def(self, '$except', function $$except($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice.call(arguments);
      keys = $post_args;
      return $send(self.$dup(), 'except!', $to_a(keys));
    }, -1);
    
    $def(self, '$except!', function $Hash_except$excl$21($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice.call(arguments);
      keys = $post_args;
      $send(keys, 'each', [], function $$22(key){var self = $$22.$$s == null ? this : $$22.$$s;

        
        if (key == null) key = nil;
        return self.$delete(key);}, {$$arity: 1, $$s: self});
      return self;
    }, -1);
    
    $def(self, '$fetch', function $$fetch(key, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return $Kernel.$raise($$$('KeyError').$new("key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, -2);
    
    $def(self, '$fetch_values', function $$fetch_values($a) {
      var block = $$fetch_values.$$p || nil, $post_args, keys, self = this;

      $$fetch_values.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      keys = $post_args;
      return $send(keys, 'map', [], function $$23(key){var self = $$23.$$s == null ? this : $$23.$$s;

        
        if (key == null) key = nil;
        return $send(self, 'fetch', [key], block.$to_proc());}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      if (level == null) level = 1;
      level = $Opal['$coerce_to!'](level, $$$('Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    }, 0);
    
    $def(self, '$has_key?', function $Hash_has_key$ques$24(key) {
      var self = this;

      return $hash_get(self, key) !== undefined;
    }, 1);
    
    $def(self, '$has_value?', function $Hash_has_value$ques$25(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, 0);
    
    $def(self, '$index', function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$indexes', function $$indexes($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = $hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    var inspect_ids;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];
    ;
      
      return (function() { try {
      
      
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          key = $$('Opal').$inspect(key)
          value = $$('Opal').$inspect(value)

          result.push(key + '=>' + value);
        }

        return '{' + result.join(', ') + '}';
      ;
      return nil;
      } finally {
        if (top) inspect_ids = undefined
      }; })();;
    }, 0);
    
    $def(self, '$invert', function $$invert() {
      var self = this;

      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        $hash_put(hash, value, key);
      }

      return hash;
    
    }, 0);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["keep_if"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$$keys.length;
    }, 0);
    
    $def(self, '$merge', function $$merge($a) {
      var block = $$merge.$$p || nil, $post_args, others, self = this;

      $$merge.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      others = $post_args;
      return $send(self.$dup(), 'merge!', $to_a(others), block.$to_proc());
    }, -1);
    
    $def(self, '$merge!', function $Hash_merge$excl$27($a) {
      var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self = this;

      $Hash_merge$excl$27.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      others = $post_args;
      
      $deny_frozen_access(self);
      var i, j, other, other_keys, length, key, value, other_value;
      for (i = 0; i < others.length; ++i) {
        other = $Opal['$coerce_to!'](others[i], $$$('Hash'), "to_hash");
        other_keys = other.$$keys, length = other_keys.length;

        if (block === nil) {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            $hash_put(self, key, other_value);
          }
        } else {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            value = $hash_get(self, key);

            if (value === undefined) {
              $hash_put(self, key, other_value);
              continue;
            }

            $hash_put(self, key, block(key, value, other_value));
          }
        }
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$rehash', function $$rehash() {
      var self = this;

      
      $deny_frozen_access(self);
      Opal.hash_rehash(self);
      return self;
    
    }, 0);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject"], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$reject!', function $Hash_reject$excl$29() {
      var block = $Hash_reject$excl$29.$$p || nil, self = this;

      $Hash_reject$excl$29.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject!"], function $$30(){var self = $$30.$$s == null ? this : $$30.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if ($hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, 0);
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);;
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      $hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        $hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        self['$default_proc='](other.$default_proc())
      } else {
        self['$default='](other.$default())
      };
      return self;
    }, 1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var hash = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$select!', function $Hash_select$excl$32() {
      var block = $Hash_select$excl$32.$$p || nil, self = this;

      $Hash_select$excl$32.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select!"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if ($hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$shift', function $$shift() {
      var self = this;

      
      $deny_frozen_access(self);
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, $hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, 0);
    
    $def(self, '$slice', function $$slice($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice.call(arguments);
      keys = $post_args;
      
      var result = $hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = $hash_get(self, key);

        if (value !== undefined) {
          $hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()
      };
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      $hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    }, 0);
    
    $def(self, '$to_hash', $return_self, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return $send(self, 'proc', [], function $$34(key){var self = $$34.$$s == null ? this : $$34.$$s;

        
        ;
        
        if (key == null) {
          $Kernel.$raise($$$('ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, {$$arity: -1, $$s: self})
    }, 0);
    
    $def(self, '$transform_keys', function $$transform_keys() {
      var block = $$transform_keys.$$p || nil, self = this;

      $$transform_keys.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = $yield1(block, key);

        $hash_put(result, key, value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$transform_keys!', function $Hash_transform_keys$excl$36() {
      var block = $Hash_transform_keys$excl$36.$$p || nil, self = this;

      $Hash_transform_keys$excl$36.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_keys!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = $yield1(block, key);

        $hash_delete(self, key);
        $hash_put(self, new_key, value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$transform_values', function $$transform_values() {
      var block = $$transform_values.$$p || nil, self = this;

      $$transform_values.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = $hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(result, key, value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$transform_values!', function $Hash_transform_values$excl$39() {
      var block = $Hash_transform_values$excl$39.$$p || nil, self = this;

      $Hash_transform_values$excl$39.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values!"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = $yield1(block, value);

        $hash_put(self, key, value);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$values', function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, 0);
    $alias(self, "dup", "clone");
    $alias(self, "each_pair", "each");
    $alias(self, "eql?", "==");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "include?", "has_key?");
    $alias(self, "indices", "indexes");
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    $alias(self, "member?", "has_key?");
    $alias(self, "size", "length");
    $alias(self, "store", "[]=");
    $alias(self, "to_s", "inspect");
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    return $alias(self, "values_at", "indexes");
  })('::', null, $nesting);
};

Opal.modules["corelib/range"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $send = Opal.send, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $return_ivar = Opal.return_ivar, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $Opal = Opal.Opal, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $rb_times = Opal.rb_times, $rb_ge = Opal.rb_ge, $thrower = Opal.thrower, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,attr_reader,raise,nil?,<=>,include?,!,<,<=,enum_for,size,upto,to_proc,respond_to?,class,succ,==,===,exclude_end?,eql?,begin,end,last,to_a,>,-@,-,to_i,coerce_to!,ceil,/,is_a?,new,loop,+,*,>=,each_with_index,%,step,bsearch,inspect,[],hash,cover?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.begin = $proto.end = $proto.excl = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    $def(self, '$initialize', function $$initialize(first, last, exclude) {
      var self = this;

      
      if (exclude == null) exclude = false;
      if ($truthy(self.begin)) {
        $Kernel.$raise($$$('NameError'), "'initialize' called twice")
      };
      if (!(($truthy(first['$<=>'](last)) || ($truthy(first['$nil?']()))) || ($truthy(last['$nil?']())))) {
        $Kernel.$raise($$$('ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, -3);
    
    $def(self, '$===', function $Range_$eq_eq_eq$1(value) {
      var self = this;

      return self['$include?'](value)
    }, 1);
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    $def(self, '$count', function $$count() {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      if (($not((block !== nil)) && ($truthy(is_infinite(self))))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [], block);
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var $yield = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      if ($truthy(is_infinite(self))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert endless range to an array")
      };
      return $send2(self, $find_super(self, 'to_a', $$to_a, false, true), 'to_a', [], $yield);
    }, 0);
    
    $def(self, '$cover?', function $Range_cover$ques$2(value) {
      var self = this, beg_cmp = nil, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, end_cmp = nil;

      
      beg_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.begin['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (self.begin['$<=>'](value))))) && ($ret_or_1));
      end_cmp = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.end['$nil?']())) ? (-1) : ($ret_or_3)))) ? ($ret_or_2) : (value['$<=>'](self.end))))) && ($ret_or_1));
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(self.excl) ? (($truthy(($ret_or_3 = end_cmp)) ? ($rb_lt(end_cmp, 0)) : ($ret_or_3))) : ($truthy(($ret_or_3 = end_cmp)) ? ($rb_le(end_cmp, 0)) : ($ret_or_3))))) ? (beg_cmp) : ($ret_or_2))))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this, current = nil, last = nil, $ret_or_1 = nil;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + ($truthy(self.excl) ? (0) : (1)); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if (!$truthy(current['$respond_to?']("succ"))) {
        $Kernel.$raise($$$('TypeError'), "can't iterate from " + (current.$class()))
      };
      while ($truthy(($truthy(($ret_or_1 = self.end['$nil?']())) ? ($ret_or_1) : ($rb_lt(current['$<=>'](last), 0))))) {
      
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if (($not(self.excl) && ($eqeq(current, last)))) {
        Opal.yield1(block, current)
      };
      return self;
    }, 0);
    
    $def(self, '$eql?', function $Range_eql$ques$4(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      if (!$eqeqeq($$$('Range'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.excl['$==='](other['$exclude_end?']()))) ? (self.begin['$eql?'](other.$begin())) : ($ret_or_2))))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_1
      };
    }, 1);
    
    $def(self, '$exclude_end?', $return_ivar("excl"), 0);
    
    $def(self, '$first', function $$first(n) {
      var $yield = $$first.$$p || nil, self = this;

      $$first.$$p = null;
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      };
      if ($truthy(n == null)) {
        return self.begin
      };
      return $send2(self, $find_super(self, 'first', $$first, false, true), 'first', [n], $yield);
    }, -1);
    
    $def(self, '$last', function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      };
      if ($truthy(n == null)) {
        return self.end
      };
      return self.$to_a().$last(n);
    }, -1);
    
    $def(self, '$max', function $$max() {
      var $yield = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      if ($truthy(self.end['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'max', $$max, false, true), 'max', [], $yield)
      } else if (($not(self.begin['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, 0);
    
    $def(self, '$min', function $$min() {
      var $yield = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      if ($truthy(self.begin['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'min', $$min, false, true), 'min', [], $yield)
      } else if (($not(self.end['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.begin
      }
    }, 0);
    
    $def(self, '$size', function $$size() {
      var self = this, infinity = nil, range_begin = nil, range_end = nil;

      
      infinity = $$$($$$('Float'), 'INFINITY');
      if ((($eqeq(self.begin, infinity) && ($not(self.end['$nil?']()))) || (($eqeq(self.end, infinity['$-@']()) && ($not(self.begin['$nil?']())))))) {
        return 0
      };
      if ($truthy(is_infinite(self))) {
        return infinity
      };
      if (!($eqeqeq($$$('Numeric'), self.begin) && ($eqeqeq($$$('Numeric'), self.end)))) {
        return nil
      };
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0
      };
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, 0);
    
    $def(self, '$step', function $$step(n) {
      var $yield = $$step.$$p || nil, self = this, $ret_or_1 = nil, i = nil;

      $$step.$$p = null;
      
      ;
      
      function coerceStepSize() {
        if (n == null) {
          n = 1;
        }
        else if (!n.$$is_number) {
          n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int")
        }

        if (n < 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$$('Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (!($yield !== nil)) {
        if (((($truthy(self.begin['$is_a?']($$('Numeric'))) || ($truthy(self.begin['$nil?']()))) && (($truthy(self.end['$is_a?']($$('Numeric'))) || ($truthy(self.end['$nil?']()))))) && ($not(($truthy(($ret_or_1 = self.begin['$nil?']())) ? (self.end['$nil?']()) : ($ret_or_1)))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "step")
        } else {
          return $send(self, 'enum_for', ["step", n], function $$5(){
            
            coerceStepSize();
            return enumeratorSize();
          }, 0)
        }
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

          
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              $t_break.$throw()
            }
          } else if ($truthy($rb_gt(current, self.end))) {
            $t_break.$throw()
          };
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, {$$arity: 0, $$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], function $$7(value, idx){
          
          if (value == null) value = nil;
          if (idx == null) idx = nil;
          if ($eqeq(idx['$%'](n), 0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, 2);
      };
      return self;
    }, -1);
    
    $def(self, '$%', function $Range_$percent$8(n) {
      var self = this;

      if (($truthy(self.begin['$is_a?']($$('Numeric'))) && ($truthy(self.end['$is_a?']($$('Numeric')))))) {
        return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "%")
      } else {
        return self.$step(n)
      }
    }, 1);
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        $Kernel.$raise($$$('NotImplementedError'), "Can't #bsearch an infinite range")
      };
      if (!$truthy(self.begin.$$is_number && self.end.$$is_number)) {
        $Kernel.$raise($$$('TypeError'), "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? ($ret_or_1) : (""))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? ($ret_or_1) : ("")))
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? (self.begin.$inspect()) : ($ret_or_1))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? (self.end.$inspect()) : ($ret_or_1)))
    }, 0);
    
    $def(self, '$marshal_load', function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, 1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, 0);
    $alias(self, "==", "eql?");
    $alias(self, "include?", "cover?");
    return $alias(self, "member?", "cover?");
  })('::', null, $nesting);
};

Opal.modules["corelib/error"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $slice = Opal.slice, $gvars = Opal.gvars, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $Kernel = Opal.Kernel, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $Object = Opal.Object, $ensure_kwargs = Opal.ensure_kwargs, $send2 = Opal.send2, $find_super = Opal.find_super, $module = Opal.module, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,map,backtrace,clone,to_s,merge,tty?,[],include?,raise,dup,empty?,!,caller,shift,+,class,join,cause,full_message,==,reverse,split,autoload,attr_reader,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.message = nil;
    
    Opal.prop(self.$$prototype, '$$is_exception', true);
    var stack_trace_limit;
    Error.stackTraceLimit = 100;
    $defs(self, '$new', function $Exception_new$1($a) {
      var $post_args, args, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      error.cause   = $gvars["!"];
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, -1);
    stack_trace_limit = self.$new;
    $defs(self, '$exception', function $$exception($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, -1);
    
    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [], m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        }
        /* Chromium format */
        else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
        else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        }
        /* Node format */
        else if ((m = loc.match(/^  from (.*?)$/))) {
          new_bt.push(m[1]);
        }
        /* Mozilla/Apple format */
        else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          new_bt.push(m[2] + ':in `' + m[1] + "'");
        }
      }

      return new_bt;
    }
  ;
    
    $def(self, '$backtrace', function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) !== 'undefined' && backtrace.$$is_string) {
        return self.backtrace = correct_backtrace(backtrace.split("\n"));
      }
      else if (backtrace) {
        return self.backtrace = correct_backtrace(backtrace);
      }

      return [];
    
    }, 0);
    
    $def(self, '$backtrace_locations', function $$backtrace_locations() {
      var $a, self = this;

      
      if (self.backtrace_locations) return self.backtrace_locations;
      self.backtrace_locations = ($a = self.$backtrace(), ($a === nil || $a == null) ? nil : $send($a, 'map', [], function $$2(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}, 1))
      return self.backtrace_locations;
    
    }, 0);
    
    $def(self, '$cause', function $$cause() {
      var self = this;

      return self.cause || nil;
    }, 0);
    
    $def(self, '$exception', function $$exception(str) {
      var self = this;

      
      if (str == null) str = nil;
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
      cloned.stack = self.stack;
      cloned.cause = self.cause;
      return cloned;
    ;
    }, -1);
    
    $def(self, '$message', function $$message() {
      var self = this;

      return self.$to_s()
    }, 0);
    
    $def(self, '$full_message', function $$full_message(kwargs) {
      var $a, $b, self = this, $ret_or_1 = nil, highlight = nil, order = nil, bold_underline = nil, bold = nil, reset = nil, bt = nil, first = nil, msg = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      if (kwargs == null) kwargs = nil;
      if (!$truthy((($a = $$('Hash', 'skip_raise')) ? 'constant' : nil))) {
        return "" + (self.message) + "\n" + (self.stack)
      };
      kwargs = $hash2(["highlight", "order"], {"highlight": $gvars.stderr['$tty?'](), "order": "top"}).$merge(($truthy(($ret_or_1 = kwargs)) ? ($ret_or_1) : ($hash2([], {}))));
      $b = [kwargs['$[]']("highlight"), kwargs['$[]']("order")], (highlight = $b[0]), (order = $b[1]), $b;
      if (!$truthy([true, false]['$include?'](highlight))) {
        $Kernel.$raise($$$('ArgumentError'), "expected true or false as highlight: " + (highlight))
      };
      if (!$truthy(["top", "bottom"]['$include?'](order))) {
        $Kernel.$raise($$$('ArgumentError'), "expected :top or :bottom as order: " + (order))
      };
      if ($truthy(highlight)) {
        
        bold_underline = "\u001b[1;4m";
        bold = "\u001b[1m";
        reset = "\u001b[m";
      } else {
        bold_underline = (bold = (reset = ""))
      };
      bt = self.$backtrace().$dup();
      if (($not(bt) || ($truthy(bt['$empty?']())))) {
        bt = self.$caller()
      };
      first = bt.$shift();
      msg = "" + (first) + ": ";
      msg = $rb_plus(msg, "" + (bold) + (self.$to_s()) + " (" + (bold_underline) + (self.$class()) + (reset) + (bold) + ")" + (reset) + "\n");
      msg = $rb_plus(msg, $send(bt, 'map', [], function $$3(loc){
        
        if (loc == null) loc = nil;
        return "\tfrom " + (loc) + "\n";}, 1).$join());
      if ($truthy(self.$cause())) {
        msg = $rb_plus(msg, self.$cause().$full_message($hash2(["highlight"], {"highlight": highlight})))
      };
      if ($eqeq(order, "bottom")) {
        
        msg = msg.$split("\n").$reverse().$join("\n");
        msg = $rb_plus("" + (bold) + "Traceback" + (reset) + " (most recent call last):\n", msg);
      };
      return msg;
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, 0);
    
    $def(self, '$set_backtrace', function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = '  from ' + backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          $Kernel.$raise($$$('TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = $send((backtrace), 'map', [], function $$4(i){
        
        if (i == null) i = nil;
        return $rb_plus("  from ", i);}, 1).join("\n");
      }

      return backtrace;
    
    }, 1);
    return $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.message)) ? (self.message.$to_s()) : ($ret_or_2))))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    }, 0);
  })('::', Error, $nesting);
  $klass('::', $$$('Exception'), 'ScriptError');
  $klass('::', $$$('ScriptError'), 'SyntaxError');
  $klass('::', $$$('ScriptError'), 'LoadError');
  $klass('::', $$$('ScriptError'), 'NotImplementedError');
  $klass('::', $$$('Exception'), 'SystemExit');
  $klass('::', $$$('Exception'), 'NoMemoryError');
  $klass('::', $$$('Exception'), 'SignalException');
  $klass('::', $$$('SignalException'), 'Interrupt');
  $klass('::', $$$('Exception'), 'SecurityError');
  $klass('::', $$$('Exception'), 'SystemStackError');
  $klass('::', $$$('Exception'), 'StandardError');
  $klass('::', $$$('StandardError'), 'EncodingError');
  $klass('::', $$$('StandardError'), 'ZeroDivisionError');
  $klass('::', $$$('StandardError'), 'NameError');
  $klass('::', $$$('NameError'), 'NoMethodError');
  $klass('::', $$$('StandardError'), 'RuntimeError');
  $klass('::', $$$('RuntimeError'), 'FrozenError');
  $klass('::', $$$('StandardError'), 'LocalJumpError');
  $klass('::', $$$('StandardError'), 'TypeError');
  $klass('::', $$$('StandardError'), 'ArgumentError');
  $klass('::', $$$('ArgumentError'), 'UncaughtThrowError');
  $klass('::', $$$('StandardError'), 'IndexError');
  $klass('::', $$$('IndexError'), 'StopIteration');
  $klass('::', $$$('StopIteration'), 'ClosedQueueError');
  $klass('::', $$$('IndexError'), 'KeyError');
  $klass('::', $$$('StandardError'), 'RangeError');
  $klass('::', $$$('RangeError'), 'FloatDomainError');
  $klass('::', $$$('StandardError'), 'IOError');
  $klass('::', $$$('IOError'), 'EOFError');
  $klass('::', $$$('StandardError'), 'SystemCallError');
  $klass('::', $$$('StandardError'), 'RegexpError');
  $klass('::', $$$('StandardError'), 'ThreadError');
  $klass('::', $$$('StandardError'), 'FiberError');
  $Object.$autoload("Errno", "corelib/error/errno");
  (function($base, $super) {
    var self = $klass($base, $super, 'FrozenError');

    
    
    self.$attr_reader("receiver");
    return $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $kwargs.$$smap["receiver"];if (receiver == null) receiver = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.receiver = receiver);
    }, -2);
  })('::', $$$('RuntimeError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $proto = self.$$prototype;

    $proto.tag = nil;
    
    self.$attr_reader("tag", "value");
    return $def(self, '$initialize', function $$initialize(tag, value) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (value == null) value = nil;
      self.tag = tag;
      self.value = value;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', ["uncaught throw " + (self.tag.$inspect())], null);
    }, -2);
  })('::', $$$('ArgumentError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'NameError');

    
    
    self.$attr_reader("name");
    return $def(self, '$initialize', function $$initialize(message, name) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NoMethodError');

    
    
    self.$attr_reader("args");
    return $def(self, '$initialize', function $$initialize(message, name, args) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      if (args == null) args = [];
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'StopIteration');

    
    return self.$attr_reader("result")
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'KeyError');

    var $proto = self.$$prototype;

    $proto.receiver = $proto.key = nil;
    
    
    $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, key, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $kwargs.$$smap["receiver"];if (receiver == null) receiver = nil;
      
      key = $kwargs.$$smap["key"];if (key == null) key = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, -2);
    
    $def(self, '$receiver', function $$receiver() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.receiver))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no receiver is available")
      }
    }, 0);
    return $def(self, '$key', function $$key() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.key))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no key is available")
      }
    }, 0);
  })('::', null);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return ($klass($nesting[0], null, 'Error'), nil)
  })('::', $nesting);
};

Opal.modules["corelib/method"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $slice = Opal.slice, $alias = Opal.alias, $Kernel = Opal.Kernel, $send = Opal.send, $to_a = Opal.to_a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,arity,curry,>>,<<,new,class,join,source_location,call,raise,bind,to_proc');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Method');

    var $proto = self.$$prototype;

    $proto.method = $proto.receiver = $proto.owner = $proto.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    $def(self, '$initialize', function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, 4);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, 0);
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    }, 0);
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      return self.method.$curry(arity);
    }, -1);
    
    $def(self, '$>>', function $Method_$gt$gt$1(other) {
      var self = this;

      return self.method['$>>'](other)
    }, 1);
    
    $def(self, '$<<', function $Method_$lt$lt$2(other) {
      var self = this;

      return self.method['$<<'](other)
    }, 1);
    
    $def(self, '$unbind', function $$unbind() {
      var self = this;

      return $$$('UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, 0);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, 0);
    $alias(self, "[]", "call");
    return $alias(self, "===", "call");
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $proto = self.$$prototype;

    $proto.method = $proto.owner = $proto.name = $proto.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    $def(self, '$initialize', function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, 4);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, 0);
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    }, 0);
    
    $def(self, '$bind', function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$$('Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, 1);
    
    $def(self, '$bind_call', function $$bind_call(object, $a) {
      var block = $$bind_call.$$p || nil, $post_args, args, self = this;

      $$bind_call.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      return $send(self.$bind(object), 'call', $to_a(args), block.$to_proc());
    }, -2);
    return $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, 0);
  })('::', null);
};

Opal.modules["corelib/main"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $return_val = Opal.return_val, $def = Opal.def, $Object = Opal.Object, $slice = Opal.slice, $Kernel = Opal.Kernel, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,raise');
  return (function(self, $parent_nesting) {
    
    
    
    $def(self, '$to_s', $return_val("main"), 0);
    
    $def(self, '$include', function $$include(mod) {
      
      return $Object.$include(mod)
    }, 1);
    
    $def(self, '$autoload', function $$autoload($a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return Opal.Object.$autoload.apply(Opal.Object, args);;
    }, -1);
    return $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("main.using is permitted only at toplevel")
    }, 1);
  })(Opal.get_singleton_class(self), $nesting)
};

Opal.modules["corelib/proc"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $return_self = Opal.return_self, $Opal = Opal.Opal, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,proc,call,to_proc,new,source_location,coerce_to!,dup');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    Opal.prop(self.$$prototype, '$$is_proc', true);
    Opal.prop(self.$$prototype, '$$is_lambda', false);
    $defs(self, '$new', function $Proc_new$1() {
      var block = $Proc_new$1.$$p || nil;

      $Proc_new$1.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, 0);
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk, $ret = self.$$ret;

      if ($brk || ($ret && self.$$is_lambda)) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return err.$v;
          }
          else if (self.$$is_lambda && err === $ret) {
            return err.$v;
          }
          else {
            throw err;
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$>>', function $Proc_$gt$gt$2(other) {
      var $yield = $Proc_$gt$gt$2.$$p || nil, self = this;

      $Proc_$gt$gt$2.$$p = null;
      return $send($Kernel, 'proc', [], function $$3($a){var block = $$3.$$p || nil, $post_args, args, self = $$3.$$s == null ? this : $$3.$$s, out = nil;

        $$3.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        out = $send(self, 'call', $to_a(args), block.$to_proc());
        return other.$call(out);}, {$$arity: -1, $$s: self})
    }, 1);
    
    $def(self, '$<<', function $Proc_$lt$lt$4(other) {
      var $yield = $Proc_$lt$lt$4.$$p || nil, self = this;

      $Proc_$lt$lt$4.$$p = null;
      return $send($Kernel, 'proc', [], function $$5($a){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, out = nil;

        $$5.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        out = $send(other, 'call', $to_a(args), block.$to_proc());
        return self.$call(out);}, {$$arity: -1, $$s: self})
    }, 1);
    
    $def(self, '$to_proc', $return_self, 0);
    
    $def(self, '$lambda?', function $Proc_lambda$ques$6() {
      var self = this;

      return !!self.$$is_lambda;
    }, 0);
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, 0);
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      
      if (self.$$is_curried) { return nil; };
      if ($truthy(($ret_or_1 = self.$$source_location))) {
        return $ret_or_1
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$binding', function $$binding() {
      var $a, self = this;

      
      if (self.$$is_curried) { $Kernel.$raise($$$('ArgumentError'), "Can't create Binding") };
      if ($truthy((($a = $$$('::', 'Binding', 'skip_raise')) ? 'constant' : nil))) {
        return $$$('Binding').$new(nil, [], self.$$s, self.$source_location())
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, 0);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $Opal['$coerce_to!'](arity, $$$('Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, 0);
    $alias(self, "===", "call");
    $alias(self, "clone", "dup");
    $alias(self, "yield", "call");
    return $alias(self, "[]", "call");
  })('::', Function)
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        self.$$comparable = false;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    }, 1);
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, 1);
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, 1);
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, 1);
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, 1);
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false
      };
      if ($rb_gt(self, max)) {
        return false
      };
      return true;
    }, 2);
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      if (max == null) max = nil;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/basic_object"] = function(Opal) {/* Generated by Opal 1.6.0 */
  "use strict";
  var $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $alias = Opal.alias, $return_val = Opal.return_val, $Opal = Opal.Opal, $truthy = Opal.truthy, $range = Opal.range, $Kernel = Opal.Kernel, $to_a = Opal.to_a, $hash2 = Opal.hash2, $send = Opal.send, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('==,raise,inspect,pristine,!,nil?,cover?,size,merge,compile,proc,[],first,>=,length,instance_variable_get,any?,new,caller');
  return (function($base, $super) {
    var self = $klass($base, $super, 'BasicObject');

    
    
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$==', function $BasicObject_$eq_eq$1(other) {
      var self = this;

      return self === other;
    }, 1);
    
    $def(self, '$eql?', function $BasicObject_eql$ques$2(other) {
      var self = this;

      return self['$=='](other)
    }, 1);
    $alias(self, "equal?", "==");
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.prop(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, 0);
    
    $def(self, '$__send__', function $$__send__(symbol, $a) {
      var block = $$__send__.$$p || nil, $post_args, args, self = this;

      $$__send__.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      
      if (!symbol.$$is_string) {
        self.$raise($$$('TypeError'), "" + (self.$inspect()) + " is not a symbol nor a string")
      }

      var func = self['$' + symbol];

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, -2);
    
    $def(self, '$!', $return_val(false), 0);
    $Opal.$pristine("!");
    
    $def(self, '$!=', function $BasicObject_$not_eq$3(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, 1);
    
    $def(self, '$instance_eval', function $$instance_eval($a) {
      var block = $$instance_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$instance_eval.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$arity: 0, $$s: self});
      } else if ((($truthy(block['$nil?']()) && ($truthy($rb_ge(args.$length(), 1)))) && ($eqeq(args.$first()['$[]'](0), "@")))) {
        return self.$instance_variable_get(args.$first())
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$size()) + " for 0)")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$instance_exec', function $$instance_exec($a) {
      var block = $$instance_exec.$$p || nil, $post_args, args, self = this;

      $$instance_exec.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$singleton_method_added', function $$singleton_method_added($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_removed', function $$singleton_method_removed($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_undefined', function $$singleton_method_undefined($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(symbol, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this, inspect_result = nil;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      inspect_result = $Opal.$inspect(self);
      return $Kernel.$raise($$$('NoMethodError').$new("undefined method `" + (symbol) + "' for " + (inspect_result), symbol, args), nil, $Kernel.$caller(1));
    }, -2);
    $Opal.$pristine(self, "method_missing");
    return $def(self, '$respond_to_missing?', function $BasicObject_respond_to_missing$ques$5(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
  })('::', null)
};

Opal.modules["corelib/enumerator"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $slice = Opal.slice, $coerce_to = Opal.coerce_to, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $def = Opal.def, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $Opal = Opal.Opal, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_ge = Opal.rb_ge, $Kernel = Opal.Kernel, $rb_le = Opal.rb_le, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,allocate,new,to_proc,!,respond_to?,empty?,nil?,+,class,__send__,call,enum_for,size,destructure,map,>=,length,raise,[],peek_values,<=,next_values,inspect,any?,each_with_object,autoload');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.size = $proto.args = $proto.object = $proto.method = $proto.values = $proto.cursor = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    $defs(self, '$for', function $Enumerator_for$1(object, $a, $b) {
      var block = $Enumerator_for$1.$$p || nil, $post_args, method, args, self = this;

      $Enumerator_for$1.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;
      obj.cursor = 0;

      return obj;
    ;
    }, -2);
    
    $def(self, '$initialize', function $$initialize($a) {
      var block = $$initialize.$$p || nil, $post_args, $rest_arg, self = this;

      $$initialize.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      $deny_frozen_access(self);
      self.cursor = 0;
      if ($truthy(block)) {
        
        self.object = $send($$('Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if (($truthy(self.size) && ($not(self.size['$respond_to?']("call"))))) {
          return (self.size = $coerce_to(self.size, $$$('Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, -1);
    
    $def(self, '$each', function $$each($a) {
      var block = $$each.$$p || nil, $post_args, args, self = this;

      $$each.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(args['$empty?']())))) {
        return self
      };
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat($to_a(args)))
      };
      return $send(self.object, '__send__', [self.method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$size', function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', $to_a(self.args))
      } else {
        return self.size
      }
    }, 0);
    
    $def(self, '$with_index', function $$with_index(offset) {
      var block = $$with_index.$$p || nil, self = this;

      $$with_index.$$p = null;
      
      ;
      if (offset == null) offset = 0;
      offset = ($truthy(offset) ? ($coerce_to(offset, $$$('Integer'), 'to_int')) : (0));
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["with_index", offset], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, -1);
    
    $def(self, '$each_with_index', function $$each_with_index() {
      var block = $$each_with_index.$$p || nil, self = this;

      $$each_with_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send2(self, $find_super(self, 'each_with_index', $$each_with_index, false, true), 'each_with_index', [], block);
      return self.object;
    }, 0);
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      
      self.cursor = 0;
      return self;
    }, 0);
    
    $def(self, '$peek_values', function $$peek_values() {
      var self = this, $ret_or_1 = nil;

      
      self.values = ($truthy(($ret_or_1 = self.values)) ? ($ret_or_1) : ($send(self, 'map', [], function $$4($a){var $post_args, i;

        
        $post_args = $slice.call(arguments);
        i = $post_args;
        return i;}, -1)));
      if ($truthy($rb_ge(self.cursor, self.values.$length()))) {
        $Kernel.$raise($$$('StopIteration'), "iteration reached an end")
      };
      return self.values['$[]'](self.cursor);
    }, 0);
    
    $def(self, '$peek', function $$peek() {
      var self = this, values = nil;

      
      values = self.$peek_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    }, 0);
    
    $def(self, '$next_values', function $$next_values() {
      var self = this, out = nil;

      
      out = self.$peek_values();
      self.cursor = $rb_plus(self.cursor, 1);
      return out;
    }, 0);
    
    $def(self, '$next', function $$next() {
      var self = this, values = nil;

      
      values = self.$next_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    }, 0);
    
    $def(self, '$feed', function $$feed(arg) {
      var self = this;

      return self.$raise($$('NotImplementedError'), "Opal doesn't support Enumerator#feed")
    }, 1);
    
    $def(self, '$+', function $Enumerator_$plus$5(other) {
      var self = this;

      return $$$($$$('Enumerator'), 'Chain').$new(self, other)
    }, 1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      result = "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "(" + (self.args.$inspect()['$[]']($$$('Range').$new(1, -2))) + ")")
      };
      return $rb_plus(result, ">");
    }, 0);
    $alias(self, "with_object", "each_with_object");
    self.$autoload("ArithmeticSequence", "corelib/enumerator/arithmetic_sequence");
    self.$autoload("Chain", "corelib/enumerator/chain");
    self.$autoload("Generator", "corelib/enumerator/generator");
    self.$autoload("Lazy", "corelib/enumerator/lazy");
    return self.$autoload("Yielder", "corelib/enumerator/yielder");
  })('::', null, $nesting);
};

Opal.modules["corelib/boolean"] = function(Opal) {/* Generated by Opal 1.6.0 */
  "use strict";
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_self = Opal.return_self, $ensure_kwargs = Opal.ensure_kwargs, $slice = Opal.slice, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,==,to_s,__id__');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.prop(self.$$prototype, '$$is_boolean', true);
    
    var properties = ['$$class', '$$meta'];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function() {
          return this == true  ? Opal.TrueClass :
                 this == false ? Opal.FalseClass :
                                 Opal.Boolean;
        }
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function() {
        return this == true  ? 2 :
               this == false ? 0 :
                               nil;
      }
    });
  ;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, 0);
    
    $def(self, '$!', function $Boolean_$excl$1() {
      var self = this;

      return self != true;
    }, 0);
    
    $def(self, '$&', function $Boolean_$$2(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, 1);
    
    $def(self, '$|', function $Boolean_$$3(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, 1);
    
    $def(self, '$^', function $Boolean_$$4(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, 1);
    
    $def(self, '$==', function $Boolean_$eq_eq$5(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, 1);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return self.$$meta;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, 0);
    
    $def(self, '$dup', $return_self, 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(method, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      var body = self.$$class.$$prototype['$' + method];
      if (!$truthy(typeof body !== 'undefined' && !body.$$stub)) {
        $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [method].concat($to_a(args)), block)
      };
      return Opal.send(self, body, args, block);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Boolean_respond_to_missing$ques$6(method, _include_all) {
      var self = this;

      
      if (_include_all == null) _include_all = false;
      var body = self.$$class.$$prototype['$' + method];
      return typeof body !== 'undefined' && !body.$$stub;;
    }, -2);
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "==");
    $alias(self, "inspect", "to_s");
    return $alias(self, "object_id", "__id__");
  })('::', Boolean, $nesting);
  $klass('::', $$$('Boolean'), 'TrueClass');
  return ($klass('::', $$$('Boolean'), 'FalseClass'), nil);
};

Opal.modules["corelib/kernel"] = function(Opal) {/* Generated by Opal 1.6.0 */
  "use strict";
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $Opal = Opal.Opal, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $freeze_props = Opal.freeze_props, $module = Opal.module, $return_val = Opal.return_val, $def = Opal.def, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $ensure_kwargs = Opal.ensure_kwargs, $eqeq = Opal.eqeq, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $eqeqeq = Opal.eqeqeq, $return_self = Opal.return_self, $rb_le = Opal.rb_le, $extract_kwargs = Opal.extract_kwargs, $rb_lt = Opal.rb_lt, $Object = Opal.Object, $alias = Opal.alias, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('!,=~,==,object_id,raise,new,class,coerce_to?,<<,map,caller,nil?,allocate,copy_instance_variables,copy_singleton_methods,initialize_clone,frozen?,freeze,initialize_copy,define_method,singleton_class,to_proc,initialize_dup,for,empty?,pop,call,append_features,extend_object,extended,gets,__id__,include?,each,instance_variables,instance_variable_get,inspect,+,to_s,instance_variable_name!,respond_to?,to_int,coerce_to!,Integer,===,enum_for,result,any?,print,format,puts,<=,length,[],readline,<,first,split,to_str,exception,backtrace,rand,respond_to_missing?,pristine,try_convert!,expand_path,join,start_with?,new_seed,srand,tag,value,open,is_a?,__send__,yield_self,include');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$=~', $return_val(false), 0);
    
    $def(self, '$!~', function $Kernel_$excl_tilde$1(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, 1);
    
    $def(self, '$===', function $Kernel_$eq_eq_eq$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    }, 1);
    
    $def(self, '$<=>', function $Kernel_$lt_eq_gt$3(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, 1);
    
    $def(self, '$method', function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$$('Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, 1);
    
    $def(self, '$methods', function $$methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$public_methods', function $$public_methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$Array', function $$Array(object) {
      
      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, 1);
    
    $def(self, '$at_exit', function $$at_exit() {
      var block = $$at_exit.$$p || nil, $ret_or_1 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      $$at_exit.$$p = null;
      
      ;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      $gvars.__at_exit__['$<<'](block);
      return block;
    }, 0);
    
    $def(self, '$caller', function $$caller(start, length) {
      
      
      if (start == null) start = 1;
      if (length == null) length = nil;
      
      var stack, result;

      stack = new Error().$backtrace();
      result = [];

      for (var i = start + 1, ii = stack.length; i < ii; i++) {
        if (!stack[i].match(/runtime\.js/)) {
          result.push(stack[i]);
        }
      }
      if (length != nil) result = result.slice(0, length);
      return result;
    ;
    }, -1);
    
    $def(self, '$caller_locations', function $$caller_locations($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($send(self, 'caller', $to_a(args)), 'map', [], function $$4(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}, 1);
    }, -1);
    
    $def(self, '$class', function $Kernel_class$5() {
      var self = this;

      return self.$$class;
    }, 0);
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, 1);
    
    $def(self, '$copy_singleton_methods', function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta') && other.$$meta !== null) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, 1);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, $hash2(["freeze"], {"freeze": freeze}));
      if (($eqeq(freeze, true) || (($truthy(freeze['$nil?']()) && ($truthy(self['$frozen?']())))))) {
        copy.$freeze()
      };
      return copy;
    }, -1);
    
    $def(self, '$initialize_clone', function $$initialize_clone(other, $kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = nil;
      self.$initialize_copy(other);
      return self;
    }, -2);
    
    $def(self, '$define_singleton_method', function $$define_singleton_method(name, method) {
      var block = $$define_singleton_method.$$p || nil, self = this;

      $$define_singleton_method.$$p = null;
      
      ;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, 0);
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, 1);
    
    $def(self, '$enum_for', function $$enum_for($a, $b) {
      var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

      $$enum_for.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      return $send($$$('Enumerator'), 'for', [self, method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$equal?', function $Kernel_equal$ques$6(other) {
      var self = this;

      return self === other;
    }, 1);
    
    $def(self, '$exit', function $$exit(status) {
      var $ret_or_1 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      if (status == null) status = true;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
      
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$$('Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, -1);
    
    $def(self, '$extend', function $$extend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice.call(arguments);
      mods = $post_args;
      
      if (mods.length == 0) {
        self.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      $deny_frozen_access(self);

      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (typeof(self) === "object") {
        $freeze_props(self);
        return $freeze(self);
      }
      return self;
    ;
    }, 0);
    
    $def(self, '$frozen?', function $Kernel_frozen$ques$7() {
      var self = this;

      
      switch (typeof(self)) {
      case "string":
      case "symbol":
      case "number":
      case "boolean":
        return true;
      case "object":
        return (self.$$frozen || false);
      default:
        return false;
      }
    
    }, 0);
    
    $def(self, '$gets', function $$gets($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'gets', $to_a(args));
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.$__id__()
    }, 0);
    
    $def(self, '$initialize_copy', $return_val(nil), 0);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, ivs = nil, id = nil, pushed = nil, e = nil;

      return (function() { try {
      try {
        
        ivs = "";
        id = self.$__id__();
        if ($truthy((inspect_stack)['$include?'](id))) {
          ivs = " ..."
        } else {
          
          (inspect_stack)['$<<'](id);
          pushed = true;
          $send(self.$instance_variables(), 'each', [], function $$8(i){var self = $$8.$$s == null ? this : $$8.$$s, ivar = nil, inspect = nil;

            
            if (i == null) i = nil;
            ivar = self.$instance_variable_get(i);
            inspect = $$('Opal').$inspect(ivar);
            return (ivs = $rb_plus(ivs, " " + (i) + "=" + (inspect)));}, {$$arity: 1, $$s: self});
        };
        return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + (ivs) + ">";
      } catch ($err) {
        if (Opal.rescue($err, [$$('StandardError')])) {(e = $err)
          try {
            return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        ($truthy(pushed) ? ((inspect_stack).$pop()) : nil)
      }; })()
    }, 0);
    
    $def(self, '$instance_of?', function $Kernel_instance_of$ques$9(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, 1);
    
    $def(self, '$instance_variable_defined?', function $Kernel_instance_variable_defined$ques$10(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, 1);
    
    $def(self, '$instance_variable_get', function $$instance_variable_get(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, 1);
    
    $def(self, '$instance_variable_set', function $$instance_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, 2);
    
    $def(self, '$remove_instance_variable', function $$remove_instance_variable(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return $Kernel.$raise($$$('NameError'), "instance variable " + (name) + " not defined");
    }, 1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$Integer', function $$Integer(value, base) {
      
      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          $Kernel.$raise($$$('ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          $Kernel.$raise($$$('TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            $Kernel.$raise($$$('FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $Opal['$coerce_to!'](value, $$$('Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$$('Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
          // no-break
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
          // no-break
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
          // no-break
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
          // no-break
        }
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, -2);
    
    $def(self, '$Float', function $$Float(value) {
      
      
      var str;

      if (value === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return $Kernel.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $Opal['$coerce_to!'](value, $$$('Float'), "to_f");
    
    }, 1);
    
    $def(self, '$Hash', function $$Hash(arg) {
      
      
      if (($truthy(arg['$nil?']()) || ($eqeq(arg, [])))) {
        return $hash2([], {})
      };
      if ($eqeqeq($$$('Hash'), arg)) {
        return arg
      };
      return $Opal['$coerce_to!'](arg, $$$('Hash'), "to_hash");
    }, 1);
    
    $def(self, '$is_a?', function $Kernel_is_a$ques$11(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, 1);
    
    $def(self, '$itself', $return_self, 0);
    
    $def(self, '$lambda', function $$lambda() {
      var block = $$lambda.$$p || nil;

      $$lambda.$$p = null;
      
      ;
      return Opal.lambda(block);;
    }, 0);
    
    $def(self, '$load', function $$load(file) {
      
      
      file = $Opal['$coerce_to!'](file, $$$('String'), "to_str");
      return Opal.load(file);
    }, 1);
    
    $def(self, '$loop', function $$loop() {
      var $yield = $$loop.$$p || nil, self = this, e = nil;

      $$loop.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["loop"], function $$12(){
          return $$$($$$('Float'), 'INFINITY')}, 0)
      };
      while ($truthy(true)) {
      
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$$('StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      };
      return self;
    }, 0);
    
    $def(self, '$nil?', $return_val(false), 0);
    
    $def(self, '$printf', function $$printf($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', $to_a(args)))
      };
      return nil;
    }, -1);
    
    $def(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, 0);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice.call(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'puts', $to_a(strs));
    }, -1);
    
    $def(self, '$p', function $$p($a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      $send(args, 'each', [], function $$13(obj){        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        if (obj == null) obj = nil;
        return $gvars.stdout.$puts(obj.$inspect());}, 1);
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, -1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice.call(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'print', $to_a(strs));
    }, -1);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'readline', $to_a(args));
    }, -1);
    
    $def(self, '$warn', function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $c, $d, self = this, location = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      $post_args = $slice.call(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      strs = $post_args;
      
      uplevel = $kwargs.$$smap["uplevel"];if (uplevel == null) uplevel = nil;
      if ($truthy(uplevel)) {
        
        uplevel = $Opal['$coerce_to!'](uplevel, $$$('Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "negative level (" + (uplevel) + ")")
        };
        location = ($c = ($d = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($d === nil || $d == null) ? nil : $d.$split(":in `")), ($c === nil || $c == null) ? nil : $c.$first());
        if ($truthy(location)) {
          location = "" + (location) + ": "
        };
        strs = $send(strs, 'map', [], function $$14(s){
          
          if (s == null) s = nil;
          return "" + (location) + "warning: " + (s);}, 1);
      };
      if (($truthy($gvars.VERBOSE['$nil?']()) || ($truthy(strs['$empty?']())))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', $to_a(strs))
      };
    }, -1);
    
    $def(self, '$raise', function $$raise(exception, string, backtrace) {
            if ($gvars["!"] == null) $gvars["!"] = nil;
      if ($gvars["@"] == null) $gvars["@"] = nil;

      
      ;
      if (string == null) string = nil;
      if (backtrace == null) backtrace = nil;
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$$('RuntimeError').$new("");
      }
      else if ($respond_to(exception, '$to_str')) {
        exception = $$$('RuntimeError').$new(exception.$to_str());
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && $respond_to(exception, '$exception')) {
        exception = exception.$exception(string);
      }
      else if (exception.$$is_exception) {
        // exception is fine
      }
      else {
        exception = $$$('TypeError').$new("exception class/object expected");
      }

      if (backtrace !== nil) {
        exception.$set_backtrace(backtrace);
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;
      $gvars["@"] = (exception).$backtrace();

      throw exception;
    ;
    }, -1);
    
    $def(self, '$rand', function $$rand(max) {
      
      
      ;
      
      if (max === undefined) {
        return $$$($$$('Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$$('Random'), 'DEFAULT').$rand(max);
    }, -1);
    
    $def(self, '$respond_to?', function $Kernel_respond_to$ques$15(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Kernel_respond_to_missing$ques$16(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
    $Opal.$pristine(self, "respond_to?", "respond_to_missing?");
    
    $def(self, '$require', function $$require(file) {
      
      
      // As Object.require refers to Kernel.require once Kernel has been loaded the String
      // class may not be available yet, the coercion requires both  String and Array to be loaded.
      if (typeof file !== 'string' && Opal.String && Opal.Array) {
        (file = $Opal['$coerce_to!'](file, $$$('String'), "to_str"))
      }
      return Opal.require(file)
    
    }, 1);
    
    $def(self, '$require_relative', function $$require_relative(file) {
      
      
      $Opal['$try_convert!'](file, $$$('String'), "to_str");
      file = $$$('File').$expand_path($$$('File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, 1);
    
    $def(self, '$require_tree', function $$require_tree(path, $kwargs) {
      var autoload;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      autoload = $kwargs.$$smap["autoload"];if (autoload == null) autoload = false;
      
      var result = [];

      path = $$$('File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          if(!autoload) {
            result.push([name, Opal.require(name)]);
          } else {
            result.push([name, true]); // do nothing, delegated to a autoloading
          }
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, 0);
    
    $def(self, '$sleep', function $$sleep(seconds) {
      
      
      if (seconds == null) seconds = nil;
      
      if (seconds === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        $Kernel.$raise($$$('ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, -1);
    
    $def(self, '$srand', function $$srand(seed) {
      
      
      if (seed == null) seed = $$('Random').$new_seed();
      return $$$('Random').$srand(seed);
    }, -1);
    
    $def(self, '$String', function $$String(str) {
      var $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $Opal['$coerce_to?'](str, $$$('String'), "to_str")))) {
        return $ret_or_1
      } else {
        return $Opal['$coerce_to!'](str, $$$('String'), "to_s")
      }
    }, 1);
    
    $def(self, '$tap', function $$tap() {
      var block = $$tap.$$p || nil, self = this;

      $$tap.$$p = null;
      
      ;
      Opal.yield1(block, self);
      return self;
    }, 0);
    
    $def(self, '$to_proc', $return_self, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, 0);
    
    $def(self, '$catch', function $Kernel_catch$17(tag) {
      var $yield = $Kernel_catch$17.$$p || nil, $ret_or_1 = nil, e = nil;

      $Kernel_catch$17.$$p = null;
      
      if (tag == null) tag = nil;
      try {
        
        tag = ($truthy(($ret_or_1 = tag)) ? ($ret_or_1) : ($Object.$new()));
        return Opal.yield1($yield, tag);;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('UncaughtThrowError')])) {(e = $err)
          try {
            
            if ($eqeq(e.$tag(), tag)) {
              return e.$value()
            };
            return $Kernel.$raise();
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };
    }, -1);
    
    $def(self, '$throw', function $Kernel_throw$18(tag, obj) {
      
      
      if (obj == null) obj = nil;
      return $Kernel.$raise($$$('UncaughtThrowError').$new(tag, obj));
    }, -2);
    
    $def(self, '$open', function $$open($a) {
      var block = $$open.$$p || nil, $post_args, args;

      $$open.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($$$('File'), 'open', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$yield_self', function $$yield_self() {
      var $yield = $$yield_self.$$p || nil, self = this;

      $$yield_self.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["yield_self"], $return_val(1), 0)
      };
      return Opal.yield1($yield, self);;
    }, 0);
    $alias(self, "fail", "raise");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "object_id", "__id__");
    $alias(self, "public_send", "__send__");
    $alias(self, "send", "__send__");
    $alias(self, "then", "yield_self");
    return $alias(self, "to_enum", "enum_for");
  })('::', $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    
    delete $Object.$$prototype.$require;
    return self.$include($Kernel);
  })('::', null);
};

Opal.modules["corelib/error/errno"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('+,errno,class,attr_reader');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting), errors = nil, klass = nil;

    
    errors = [["EINVAL", "Invalid argument", 22], ["EEXIST", "File exists", 17], ["EISDIR", "Is a directory", 21], ["EMFILE", "Too many open files", 24], ["ESPIPE", "Illegal seek", 29], ["EACCES", "Permission denied", 13], ["EPERM", "Operation not permitted", 1], ["ENOENT", "No such file or directory", 2], ["ENAMETOOLONG", "File name too long", 36]];
    klass = nil;
    
    var i;
    for (i = 0; i < errors.length; i++) {
      (function() { // Create a closure
        var class_name = errors[i][0];
        var default_message = errors[i][1];
        var errno = errors[i][2];

        klass = Opal.klass(self, Opal.SystemCallError, class_name);
        klass.errno = errno;

        (function(self, $parent_nesting) {
      
      return $def(self, '$new', function $new$1(name) {
        var $yield = $new$1.$$p || nil, self = this, message = nil;

        $new$1.$$p = null;
        
        if (name == null) name = nil;
        message = default_message;
        if ($truthy(name)) {
          message = $rb_plus(message, " - " + (name))
        };
        return $send2(self, $find_super(self, 'new', $new$1, false, true), 'new', [message], null);
      }, -1)
    })(Opal.get_singleton_class(klass), $nesting)
      })();
    }
  ;
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    
    
    $def(self, '$errno', function $$errno() {
      var self = this;

      return self.$class().$errno()
    }, 0);
    return (function(self, $parent_nesting) {
      
      return self.$attr_reader("errno")
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('StandardError'), $nesting);
};

Opal.modules["corelib/class"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $rb_plus = Opal.rb_plus, $return_val = Opal.return_val, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,class_eval,to_proc,+,subclasses,flatten,map,initialize_copy,allocate,name,to_s');
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$new', function $Class_new$1(superclass) {
      var block = $Class_new$1.$$p || nil;

      $Class_new$1.$$p = null;
      
      ;
      if (superclass == null) superclass = $$('Object');
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      ((block !== nil) ? ($send((klass), 'class_eval', [], block.$to_proc())) : nil)
      return klass;
    ;
    }, -1);
    
    $def(self, '$allocate', function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, 0);
    
    $def(self, '$descendants', function $$descendants() {
      var self = this;

      return $rb_plus(self.$subclasses(), $send(self.$subclasses(), 'map', [], "descendants".$to_proc()).$flatten())
    }, 0);
    
    $def(self, '$inherited', $return_val(nil), 0);
    
    $def(self, '$initialize_dup', function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, 1);
    
    $def(self, '$new', function $Class_new$2($a) {
      var block = $Class_new$2.$$p || nil, $post_args, args, self = this;

      $Class_new$2.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, -1);
    
    $def(self, '$subclasses', function $$subclasses() {
      var self = this;

      
      if (typeof WeakRef !== 'undefined') {
        var i, subclass, out = [];
        for (i = 0; i < self.$$subclasses.length; i++) {
          subclass = self.$$subclasses[i].deref();
          if (subclass !== undefined) {
            out.push(subclass);
          }
        }
        return out;
      }
      else {
        return self.$$subclasses;
      }
    
    }, 0);
    
    $def(self, '$superclass', function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, 0);
    
    $def(self, '$to_s', function $$to_s() {
      var $yield = $$to_s.$$p || nil, self = this;

      $$to_s.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], null);
    
    }, 0);
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
};

Opal.modules["corelib/random/formatter"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $module = Opal.module, $def = Opal.def, $range = Opal.range, $send = Opal.send, $rb_divide = Opal.rb_divide, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('_verify_count,bytes,encode,strict_encode64,random_bytes,urlsafe_encode64,split,hex,[]=,[],map,to_proc,join,times,<<,|,ord,/,abs,random_float,raise,coerce_to!,flatten,new,random_number,length,include,extend');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$hex', function $$hex(count) {
        var self = this;

        
        if (count == null) count = nil;
        count = $$$('Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, -1);
      
      $def(self, '$random_bytes', function $$random_bytes(count) {
        var self = this;

        
        if (count == null) count = nil;
        return self.$bytes(count);
      }, -1);
      
      $def(self, '$base64', function $$base64(count) {
        var self = this;

        
        if (count == null) count = nil;
        return $$$('Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$urlsafe_base64', function $$urlsafe_base64(count, padding) {
        var self = this;

        
        if (count == null) count = nil;
        if (padding == null) padding = false;
        return $$$('Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$uuid', function $$uuid() {
        var self = this, str = nil;

        
        str = self.$hex(16).$split("");
        str['$[]='](12, "4");
        str['$[]='](16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16));
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      }, 0);
      
      $def(self, '$random_float', function $$random_float() {
        var self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], function $$1(i){
          
          if (i == null) i = nil;
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));}, 1);
        return $rb_divide(num.$abs(), 2147483647);
      }, 0);
      
      $def(self, '$random_number', function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");

          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, -1);
      return $def(self, '$alphanumeric', function $$alphanumeric(count) {
        var self = this, map = nil;

        
        if (count == null) count = nil;
        count = $$('Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$$('Array'), 'new', [count], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (i == null) i = nil;
          return map['$[]'](self.$random_number(map.$length()));}, {$$arity: 1, $$s: self}).$join();
      }, -1);
    })(self, $nesting);
    self.$include($$$($$$('Random'), 'Formatter'));
    return self.$extend($$$($$$('Random'), 'Formatter'));
  })('::', null, $nesting)
};

Opal.modules["corelib/array"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $Kernel = Opal.Kernel, $def = Opal.def, $Opal = Opal.Opal, $eqeqeq = Opal.eqeqeq, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $gvars = Opal.gvars, $rb_ge = Opal.rb_ge, $assign_ivar = Opal.assign_ivar, $rb_lt = Opal.rb_lt, $return_self = Opal.return_self, $neqeq = Opal.neqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,to_a,warn,raise,replace,respond_to?,to_ary,coerce_to?,===,join,to_str,hash,<=>,==,object_id,inspect,enum_for,class,bsearch_index,to_proc,nil?,coerce_to!,>,*,enumerator_size,empty?,size,map,equal?,dup,each,reduce,-,[],dig,eql?,length,exclude_end?,flatten,frozen?,__id__,&,!,intersection,to_s,new,item,max,min,>=,**,delete_if,reverse,rotate,rand,at,keep_if,shuffle!,<,sort,sort_by,!=,times,[]=,<<,uniq,|,values,is_a?,end,begin,upto,reject,push,select,select!,collect,collect!,unshift,pristine,singleton_class');
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    Opal.prop(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    $defs(self, '$[]', function $Array_$$$1($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice.call(arguments);
      objects = $post_args;
      return toArraySubclass(objects, self);;
    }, -1);
    
    $def(self, '$initialize', function $$initialize(size, obj) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (size == null) size = nil;
      if (obj == null) obj = nil;
      
      $deny_frozen_access(self);

      if (obj !== nil && block !== nil) {
        $Kernel.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$$('Integer'), 'MAX')) {
        $Kernel.$raise($$$('ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$$('Integer'), 'to_int');

      if (size < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, -1);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Array'), "to_ary")
    }, 1);
    
    $def(self, '$&', function $Array_$$2(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$|', function $Array_$$3(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, 1);
    
    $def(self, '$*', function $Array_$$4(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())
      };
      other = $coerce_to(other, $$$('Integer'), 'to_int');
      if ($truthy(other < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      };
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$+', function $Array_$plus$5(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      return self.concat(other);;
    }, 1);
    
    $def(self, '$-', function $Array_$minus$6(other) {
      var self = this;

      
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(other.length === 0)) {
        return self.slice()
      };
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 1);
    
    $def(self, '$<<', function $Array_$lt$lt$7(object) {
      var self = this;

      
      $deny_frozen_access(self);
      self.push(object);
      return self;
    }, 1);
    
    $def(self, '$<=>', function $Array_$lt_eq_gt$8(other) {
      var self = this;

      
      if ($eqeqeq($$$('Array'), other)) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, 1);
    
    $def(self, '$==', function $Array_$eq_eq$9(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (index.excl_rev && index.begin !== nil) {
        from += 1;
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude || index.end === nil) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_arithmetic_seq(self, index) {
      var array, out = [], i = 0, pseudorange;

      if (index.step < 0) {
        pseudorange = {
          begin: index.range.end,
          end: index.range.begin,
          excl: false,
          excl_rev: index.range.excl
        };
        array = $array_slice_range(self, pseudorange).$reverse();
      }
      else {
        array = $array_slice_range(self, index.range);
      }

      while (i < array.length) {
        out.push(array[i]);
        i += Math.abs(index.step);
      }

      return out;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    $def(self, '$[]', function $Array_$$$10(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else if (index.$$is_arithmetic_seq) {
        return $array_slice_arithmetic_seq(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, -2);
    
    $def(self, '$[]=', function $Array_$$$eq$11(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
      $deny_frozen_access(self);
      data = nil;
      
      var i, size = self.length;

      if (index.$$is_range) {
        if (value.$$is_array)
          data = value.$to_a();
        else if (value['$respond_to?']("to_ary"))
          data = value.$to_ary().$to_a();
        else
          data = [value];

        var exclude = index.excl,
            from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int'),
            to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            $Kernel.$raise($$$('RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude || index.end === nil) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      } else {
        if (extra === undefined) {
          (length = 1)
        } else {
          length = value;
          value  = extra;

          if (value.$$is_array)
            data = value.$to_a();
          else if (value['$respond_to?']("to_ary"))
            data = value.$to_ary().$to_a();
          else
            data = [value];
        }

        var old;

        index  = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          $Kernel.$raise($$$('IndexError'), "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      }
    ;
    }, -3);
    
    $def(self, '$any?', function $Array_any$ques$12(pattern) {
      var block = $Array_any$ques$12.$$p || nil, self = this;

      $Array_any$ques$12.$$p = null;
      
      ;
      ;
      if (self.length === 0) return false;
      return $send2(self, $find_super(self, 'any?', $Array_any$ques$12, false, true), 'any?', [pattern], block);
    }, -1);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$at', function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    }, 1);
    
    $def(self, '$bsearch_index', function $$bsearch_index() {
      var block = $$bsearch_index.$$p || nil, self = this;

      $$bsearch_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, 0);
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this, index = nil;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, 0);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          if ($truthy(n['$nil?']())) {
            return $$$($$$('Float'), 'INFINITY')
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$arity: 0, $$s: self})
      };
      if (($truthy(self['$empty?']()) || ($eqeq(n, 0)))) {
        return nil
      };
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);
      self.splice(0, self.length);
      return self;
    }, 0);
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      ;
      if (($truthy(object !== undefined) || ($truthy(block)))) {
        return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [object], block)
      } else {
        return self.$size()
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, 1);
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$collect!', function $Array_collect$excl$15() {
      var block = $Array_collect$excl$15.$$p || nil, self = this;

      $Array_collect$excl$15.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect!"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    $def(self, '$combination', function $$combination(n) {
      var $yield = $$combination.$$p || nil, self = this, num = nil;

      $$combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["combination", num], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return binomial_coefficient(self.length, num)}, {$$arity: 0, $$s: self})
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$repeated_combination', function $$repeated_combination(n) {
      var $yield = $$repeated_combination.$$p || nil, self = this, num = nil;

      $$repeated_combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_combination", num], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return binomial_coefficient(self.length + num - 1, num);}, {$$arity: 0, $$s: self})
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, 0);
    
    $def(self, '$compact!', function $Array_compact$excl$19() {
      var self = this;

      
      $deny_frozen_access(self);

      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, 0);
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, others, self = this;

      
      $post_args = $slice.call(arguments);
      others = $post_args;
      $deny_frozen_access(self);
      others = $send(others, 'map', [], function $$20(other){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (other == null) other = nil;
        other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()
        };
        return other;}, {$$arity: 1, $$s: self});
      $send(others, 'each', [], function $$21(other){var self = $$21.$$s == null ? this : $$21.$$s;

        
        if (other == null) other = nil;
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, {$$arity: 1, $$s: self});
      return self;
    }, -1);
    
    $def(self, '$delete', function $Array_delete$22(object) {
      var $yield = $Array_delete$22.$$p || nil, self = this;

      $Array_delete$22.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          $deny_frozen_access(self);

          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, 1);
    
    $def(self, '$delete_at', function $$delete_at(index) {
      var self = this;

      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, 1);
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["delete_if"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $falsy, block)
    ;
      return self;
    }, 0);
    
    $def(self, '$difference', function $$difference($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice.call(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$24(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return $rb_minus(a, b);}, 2);
    }, -1);
    
    $def(self, '$dig', function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      $post_args = $slice.call(arguments, 1);
      idxs = $post_args;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(idxs));
    }, -2);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');

      if (number < 0) {
        $Kernel.$raise($$$('ArgumentError'))
      }

      return self.slice(number);
    
    }, 1);
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this;

      $$dup.$$p = null;
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
    }, 0);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$each_index', function $$each_index() {
      var block = $$each_index.$$p || nil, self = this;

      $$each_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_index"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$empty?', function $Array_empty$ques$27() {
      var self = this;

      return self.length === 0;
    }, 0);
    
    $def(self, '$eql?', function $Array_eql$ques$28(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, 1);
    
    $def(self, '$fetch', function $$fetch(index, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var original = index;

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, -2);
    
    $def(self, '$fill', function $$fill($a) {
      var block = $$fill.$$p || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      $$fill.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      $deny_frozen_access(self);

      var i, length, value;
    ;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 0..2)")
        };
        $c = args, $b = $to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 1..3)")
        };
        $c = args, $b = $to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($eqeqeq($$$('Range'), one)) {
        
        if ($truthy(two)) {
          $Kernel.$raise($$$('TypeError'), "length invalid with range")
        };
        left = one.begin === nil ? 0 : $coerce_to(one.begin, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          $Kernel.$raise($$$('RangeError'), "" + (one.$inspect()) + " out of range")
        };
        right = one.end === nil ? -1 : $coerce_to(one.end, $$$('Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length
        };
        if (!$truthy(one['$exclude_end?']())) {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self
        };
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          left = 0
        };
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$$('Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self
          };
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      
      };
      if ($truthy(right > this.length)) {
        this.length = right
      };
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, -1);
    
    $def(self, '$first', function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            $Kernel.$raise($$$('TypeError'));
          }

          if (ary === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$$('Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, -1);
    
    $def(self, '$flatten!', function $Array_flatten$excl$29(level) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    }, 0);
    
    $def(self, '$include?', function $Array_include$ques$30(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$index', function $$index(object) {
      var block = $$index.$$p || nil, self = this;

      $$index.$$p = null;
      
      ;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$insert', function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice.call(arguments, 1);
      objects = $post_args;
      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, -2);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var result = [],
      id = self.$__id__(),
      pushed = true;
    ;
      
      return (function() { try {
      
      
        if (inspect_stack.indexOf(id) !== -1) {
          pushed = false;
          return '[...]';
        }
        inspect_stack.push(id)

        for (var i = 0, length = self.length; i < length; i++) {
          var item = self['$[]'](i);

          result.push($$('Opal').$inspect(item));
        }

        return '[' + result.join(', ') + ']';
      ;
      return nil;
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, 0);
    
    $def(self, '$intersection', function $$intersection($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice.call(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$31(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$&'](b);}, 2);
    }, -1);
    
    $def(self, '$intersect?', function $Array_intersect$ques$32(other) {
      var self = this;

      return self.$intersection(other)['$empty?']()['$!']()
    }, 1);
    
    $def(self, '$join', function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      if (sep == null) sep = nil;
      if ($truthy(self.length === 0)) {
        return ""
      };
      if ($truthy(sep === nil)) {
        sep = $gvars[","]
      };
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        $Kernel.$raise($$$('NoMethodError').$new("" + ($$('Opal').$inspect(self.$item())) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($Opal['$coerce_to!'](sep, $$$('String'), "to_str").$to_s());
      }
    ;
    }, -1);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["keep_if"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $truthy, block)
    ;
      return self;
    }, 0);
    
    $def(self, '$last', function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    }, 0);
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, -1);
    
    $def(self, '$min', function $$min() {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    $def(self, '$permutation', function $$permutation(num) {
      var block = $$permutation.$$p || nil, self = this, perm = nil, used = nil;

      $$permutation.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["permutation", num], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          return descending_factorial(self.length, num === undefined ? self.length : num);}, {$$arity: 0, $$s: self})
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$$('Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$('Array').$new(num));
        (used = $$('Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$repeated_permutation', function $$repeated_permutation(n) {
      var $yield = $$repeated_permutation.$$p || nil, self = this, num = nil;

      $$repeated_permutation.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_permutation", num], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, {$$arity: 0, $$s: self})
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, 1);
    
    $def(self, '$pop', function $$pop(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return self.pop();
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, -1);
    
    $def(self, '$product', function $$product($a) {
      var block = $$product.$$p || nil, $post_args, args, self = this;

      $$product.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$$('Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          $Kernel.$raise($$$('RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, -1);
    
    $def(self, '$push', function $$push($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice.call(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, 1);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$36(){var self = $$36.$$s == null ? this : $$36.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, 0);
    
    $def(self, '$reject!', function $Array_reject$excl$37() {
      var block = $Array_reject$excl$37.$$p || nil, self = this, original = nil;

      $Array_reject$excl$37.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject!"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $deny_frozen_access(self);
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$length(), original)) {
        return nil
      } else {
        return self
      };
    }, 0);
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);
      other = ($eqeqeq($$$('Array'), other) ? (other.$to_a()) : (($coerce_to(other, $$$('Array'), 'to_ary')).$to_a()));
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, 1);
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, 0);
    
    $def(self, '$reverse!', function $Array_reverse$excl$39() {
      var self = this;

      
      $deny_frozen_access(self);
      return self.reverse();;
    }, 0);
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, 0);
    
    $def(self, '$rindex', function $$rindex(object) {
      var block = $$rindex.$$p || nil, self = this;

      $$rindex.$$p = null;
      
      ;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$rotate', function $$rotate(n) {
      var self = this;

      
      if (n == null) n = 1;
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$$('Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, -1);
    
    $def(self, '$rotate!', function $Array_rotate$excl$41(cnt) {
      var self = this, ary = nil;

      
      if (cnt == null) cnt = 1;
      
      $deny_frozen_access(self);

      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$$('Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, -1);
    (function($base, $super) {
      var self = $klass($base, $super, 'SampleRandom');

      var $proto = self.$$prototype;

      $proto.rng = nil;
      
      
      $def(self, '$initialize', $assign_ivar("rng"), 0);
      return $def(self, '$rand', function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$$('Integer'), 'to_int');
        if ($truthy(random < 0)) {
          $Kernel.$raise($$$('RangeError'), "random value must be >= 0")
        };
        if (!$truthy(random < size)) {
          $Kernel.$raise($$$('RangeError'), "random value must be less than Array size")
        };
        return random;
      }, 1);
    })(self, null);
    
    $def(self, '$sample', function $$sample(count, options) {
      var self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($Kernel.$rand(self.length))
      };
      if ($truthy(options === undefined)) {
        if ($truthy((o = $Opal['$coerce_to?'](count, $$$('Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$$('Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$$('Integer'), 'to_int');
        options = $coerce_to(options, $$$('Hash'), 'to_hash');
      };
      if (($truthy(count) && ($truthy(count < 0)))) {
        $Kernel.$raise($$$('ArgumentError'), "count must be greater than 0")
      };
      if ($truthy(options)) {
        rng = options['$[]']("random")
      };
      rng = (($truthy(rng) && ($truthy(rng['$respond_to?']("rand")))) ? ($$('SampleRandom').$new(rng)) : ($Kernel));
      if (!$truthy(count)) {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$('Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, -1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select"], function $$42(){var self = $$42.$$s == null ? this : $$42.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$select!', function $Array_select$excl$43() {
      var block = $Array_select$excl$43.$$p || nil, self = this;

      $Array_select$excl$43.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select!"], function $$44(){var self = $$44.$$s == null ? this : $$44.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      
      $deny_frozen_access(self)

      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, 0);
    
    $def(self, '$shift', function $$shift(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return shiftNoArg(self);
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      return self.splice(0, count);;
    }, -1);
    
    $def(self, '$shuffle', function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, -1);
    
    $def(self, '$shuffle!', function $Array_shuffle$excl$45(rng) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $Opal['$coerce_to?'](rng, $$$('Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            $Kernel.$raise($$$('RangeError'), "random number too small " + (j))
          }

          if (j >= i) {
            $Kernel.$raise($$$('RangeError'), "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$slice!', function $Array_slice$excl$46(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      $deny_frozen_access(self);
      result = nil;
      if ($truthy(length === undefined)) {
        if ($eqeqeq($$$('Range'), index)) {
          
          range = index;
          result = self['$[]'](range);
          range_start = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');
          range_end = range.end === nil ? -1 : $coerce_to(range.end, $$$('Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl && range.end !== nil) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, -2);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this;

      $$sort.$$p = null;
      
      ;
      if (!$truthy(self.length > 1)) {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, 0);
    
    $def(self, '$sort!', function $Array_sort$excl$47() {
      var block = $Array_sort$excl$47.$$p || nil, self = this;

      $Array_sort$excl$47.$$p = null;
      
      ;
      
      $deny_frozen_access(self)

      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, 0);
    
    $def(self, '$sort_by!', function $Array_sort_by$excl$48() {
      var block = $Array_sort_by$excl$48.$$p || nil, self = this;

      $Array_sort_by$excl$48.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by!"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$size()}, {$$arity: 0, $$s: self})
      };
      $deny_frozen_access(self);
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, 0);
    
    $def(self, '$take', function $$take(count) {
      var self = this;

      
      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'));
      }

      return self.slice(0, count);
    
    }, 1);
    
    $def(self, '$take_while', function $$take_while() {
      var block = $$take_while.$$p || nil, self = this;

      $$take_while.$$p = null;
      
      ;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    }, 0);
    
    $def(self, '$to_ary', $return_self, 0);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this, array = nil;

      $$to_h.$$p = null;
      
      ;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())
      };
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $Opal['$coerce_to?'](array[i], $$$('Array'), "to_ary");
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    }, 0);
    
    $def(self, '$transpose', function $$transpose() {
      var self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []
      };
      result = [];
      max = nil;
      $send(self, 'each', [], function $$50(row){var $ret_or_1 = nil;

        
        if (row == null) row = nil;
        row = ($eqeqeq($$$('Array'), row) ? (row.$to_a()) : (($coerce_to(row, $$$('Array'), 'to_ary')).$to_a()));
        max = ($truthy(($ret_or_1 = max)) ? ($ret_or_1) : (row.length));
        if ($neqeq(row.length, max)) {
          $Kernel.$raise($$$('IndexError'), "element size differs (" + (row.length) + " should be " + (max) + ")")
        };
        return $send((row.length), 'times', [], function $$51(i){var $a, entry = nil;

          
          if (i == null) i = nil;
          entry = ($truthy(($ret_or_1 = result['$[]'](i))) ? ($ret_or_1) : (($a = [i, []], $send(result, '[]=', $a), $a[$a.length - 1])));
          return entry['$<<'](row.$at(i));}, 1);}, 1);
      return result;
    }, 0);
    
    $def(self, '$union', function $$union($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice.call(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$uniq()], function $$52(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$|'](b);}, 2);
    }, -1);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this;

      $$uniq.$$p = null;
      
      ;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    }, 0);
    
    $def(self, '$uniq!', function $Array_uniq$excl$53() {
      var block = $Array_uniq$excl$53.$$p || nil, self = this;

      $Array_uniq$excl$53.$$p = null;
      
      ;
      
      $deny_frozen_access(self);

      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, 0);
    
    $def(self, '$unshift', function $$unshift($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice.call(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this, out = nil;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      out = [];
      $send(args, 'each', [], function $$54(elem){var self = $$54.$$s == null ? this : $$54.$$s, finish = nil, start = nil, i = nil;

        
        if (elem == null) elem = nil;
        if ($truthy(elem['$is_a?']($$$('Range')))) {
          
          finish = elem.$end() === nil ? -1 : $coerce_to(elem.$end(), $$$('Integer'), 'to_int');
          start = elem.$begin() === nil ? 0 : $coerce_to(elem.$begin(), $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']() && elem.$end() !== nil) {
            finish--;
          }
          if (finish < start) {
            return nil;
          }
        ;
          return $send(start, 'upto', [finish], function $$55(i){var self = $$55.$$s == null ? this : $$55.$$s;

            
            if (i == null) i = nil;
            return out['$<<'](self.$at(i));}, {$$arity: 1, $$s: self});
        } else {
          
          i = $coerce_to(elem, $$$('Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, {$$arity: 1, $$s: self});
      return out;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this, $ret_or_1 = nil;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      others = $post_args;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = ($truthy(($ret_or_1 = $Opal['$coerce_to?'](o, $$$('Array'), "to_ary"))) ? ($ret_or_1) : ($Opal['$coerce_to!'](o, $$$('Enumerator'), "to_enum", "each"))).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          Opal.yield1(block, result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, -1);
    $defs(self, '$inherited', function $$inherited(klass) {
      
      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, 1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var $yield = $$instance_variables.$$p || nil, self = this;

      $$instance_variables.$$p = null;
      return $send($send2(self, $find_super(self, 'instance_variables', $$instance_variables, false, true), 'instance_variables', [], $yield), 'reject', [], function $$56(ivar){var $ret_or_1 = nil;

        
        if (ivar == null) ivar = nil;
        if ($truthy(($ret_or_1 = /^@\d+$/.test(ivar)))) {
          return $ret_or_1
        } else {
          return ivar['$==']("@length")
        };}, 1)
    }, 0);
    
    $def(self, '$pack', function $$pack($a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $Kernel.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, -1);
    $alias(self, "append", "push");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");
    $alias(self, "prepend", "unshift");
    $alias(self, "size", "length");
    $alias(self, "slice", "[]");
    $alias(self, "to_s", "inspect");
    $Opal.$pristine(self.$singleton_class(), "allocate");
    return $Opal.$pristine(self, "copy_instance_variables", "initialize_dup");
  })('::', Array, $nesting);
};

Opal.modules["corelib/enumerator/chain"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Enumerator');

    
    return (function($base, $super) {
      var self = $klass($base, $super, 'Chain');

      var $proto = self.$$prototype;

      $proto.enums = $proto.iterated = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, enums, self = this;

        
        $post_args = $slice.call(arguments);
        enums = $post_args;
        $deny_frozen_access(self);
        self.enums = enums;
        self.iterated = [];
        return (self.object = self);
      }, -1);
      
      $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this;

        $$each.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        if (!(block !== nil)) {
          return $send(self, 'to_enum', ["each"].concat($to_a(args)), function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$size()}, {$$arity: 0, $$s: self})
        };
        $send(self.enums, 'each', [], function $$2(enum$){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.iterated == null) self.iterated = nil;

          
          if (enum$ == null) enum$ = nil;
          self.iterated['$<<'](enum$);
          return $send(enum$, 'each', $to_a(args), block.$to_proc());}, {$$arity: 1, $$s: self});
        return self;
      }, -1);
      
      $def(self, '$size', function $$size($a) {try { var $t_return = $thrower('return'); 
        var $post_args, args, self = this, accum = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        accum = 0;
        $send(self.enums, 'each', [], function $$3(enum$){var size = nil;

          
          if (enum$ == null) enum$ = nil;
          size = $send(enum$, 'size', $to_a(args));
          if ($truthy([nil, $$$($$$('Float'), 'INFINITY')]['$include?'](size))) {
            $t_return.$throw(size)
          };
          return (accum = $rb_plus(accum, size));}, {$$arity: 1, $$ret: $t_return});
        return accum;} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        }
      }, -1);
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        $send(self.iterated, 'reverse_each', [], function $$4(enum$){
          
          if (enum$ == null) enum$ = nil;
          if ($truthy(enum$['$respond_to?']("rewind"))) {
            return enum$.$rewind()
          } else {
            return nil
          };}, 1);
        self.iterated = [];
        return self;
      }, 0);
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Enumerator::Chain: " + (self.enums.$inspect()) + ">"
      }, 0);
    })(self, self)
  })('::', null)
};

Opal.modules["corelib/module"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $const_set = Opal.const_set, $Object = Opal.Object, $return_ivar = Opal.return_ivar, $assign_ivar = Opal.assign_ivar, $ivar = Opal.ivar, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $prop = Opal.prop, $klass = Opal.klass, $defs = Opal.defs, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $Module = Opal.Module, $Kernel = Opal.Kernel, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $slice = Opal.slice, $to_a = Opal.to_a, $hash2 = Opal.hash2, $Opal = Opal.Opal, $eqeq = Opal.eqeq, $return_val = Opal.return_val, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('module_eval,to_proc,===,raise,equal?,<,>,nil?,attr_reader,attr_writer,warn,attr_accessor,const_name?,class_variable_name!,const_name!,=~,new,inject,split,const_get,==,start_with?,!~,bind,call,class,frozen?,name,append_features,included,cover?,size,merge,compile,proc,any?,prepend_features,prepended,to_s,__id__,constants,include?,copy_class_variables,copy_constants,class_exec,module_exec,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, 0);
    
    $def(self, '$initialize', function $$initialize() {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, 0);
    
    $def(self, '$===', function $Module_$eq_eq_eq$1(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false
      };
      return Opal.is_a(object, self);;
    }, 1);
    
    $def(self, '$<', function $Module_$lt$2(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, 1);
    
    $def(self, '$<=', function $Module_$lt_eq$3(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    }, 1);
    
    $def(self, '$>', function $Module_$gt$4(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, 1);
    
    $def(self, '$>=', function $Module_$gt_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_gt(self, other)
      }
    }, 1);
    
    $def(self, '$<=>', function $Module_$lt_eq_gt$6(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if (!$eqeqeq($Module, other)) {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil
      };
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, 1);
    
    $def(self, '$alias_method', function $$alias_method(newname, oldname) {
      var self = this;

      
      $deny_frozen_access(self);
      newname = $coerce_to(newname, $$$('String'), 'to_str');
      oldname = $coerce_to(oldname, $$$('String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    }, 2);
    
    $def(self, '$alias_native', function $$alias_native(mid, jsid) {
      var self = this;

      
      if (jsid == null) jsid = mid;
      $deny_frozen_access(self);
      Opal.alias_native(self, mid, jsid);
      return self;
    }, -2);
    
    $def(self, '$ancestors', function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, 0);
    
    $def(self, '$append_features', function $$append_features(includer) {
      var self = this;

      
      $deny_frozen_access(includer);
      Opal.append_features(self, includer);
      return self;
    }, 1);
    
    $def(self, '$attr_accessor', function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      $send(self, 'attr_reader', $to_a(names));
      return $send(self, 'attr_writer', $to_a(names));
    }, -1);
    
    $def(self, '$attr', function $$attr($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', $to_a(args));
    }, -1);
    
    $def(self, '$attr_reader', function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = $ivar(name);

        var body = $return_ivar(ivar);

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$attr_writer', function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = $ivar(name);

        var body = $assign_ivar(ivar)

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$autoload', function $$autoload(const$, path) {
      var self = this;

      
      $deny_frozen_access(self);

      if (!$$('Opal')['$const_name?'](const$)) {
        $Kernel.$raise($$$('NameError'), "autoload must be constant name: " + (const$))
      }

      if (path == "") {
        $Kernel.$raise($$$('ArgumentError'), "empty file name")
      }

      if (!self.$$const.hasOwnProperty(const$)) {
        if (!self.$$autoload) {
          self.$$autoload = {};
        }
        Opal.const_cache_version++;
        self.$$autoload[const$] = { path: path, loaded: false, required: false, success: false, exception: false };
      }
      return nil;
    
    }, 2);
    
    $def(self, '$autoload?', function $Module_autoload$ques$7(const$) {
      var self = this;

      
      if (self.$$autoload && self.$$autoload[const$] && !self.$$autoload[const$].required && !self.$$autoload[const$].success) {
        return self.$$autoload[const$].path;
      }

      var ancestors = self.$ancestors();

      for (var i = 0, length = ancestors.length; i < length; i++) {
        if (ancestors[i].$$autoload && ancestors[i].$$autoload[const$] && !ancestors[i].$$autoload[const$].required && !ancestors[i].$$autoload[const$].success) {
          return ancestors[i].$$autoload[const$].path;
        }
      }
      return nil;
    
    }, 1);
    
    $def(self, '$class_variables', function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, 0);
    
    $def(self, '$class_variable_get', function $$class_variable_get(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    }, 1);
    
    $def(self, '$class_variable_set', function $$class_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, 2);
    
    $def(self, '$class_variable_defined?', function $Module_class_variable_defined$ques$8(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, 1);
    
    $def(self, '$remove_class_variable', function $$remove_class_variable(name) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        $Kernel.$raise($$$('NameError'), "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, 1);
    
    $def(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      return Opal.constants(self, inherit);;
    }, -1);
    $defs(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat($Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, -1);
    $defs(self, '$nesting', function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, 0);
    
    $def(self, '$const_defined?', function $Module_const_defined$ques$9(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([$Object]).concat(Opal.ancestors($Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) { return true; }
        if (
          module.$$autoload &&
          module.$$autoload[name] &&
          !module.$$autoload[name].required &&
          !module.$$autoload[name].success
        ) {
          return true;
        }
      }

      return false;
    ;
    }, -2);
    
    $def(self, '$const_get', function $$const_get(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], function $$10(o, c){
          
          if (o == null) o = nil;
          if (c == null) c = nil;
          return o.$const_get(c);}, 2)
      };
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return Opal.$$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, -2);
    
    $def(self, '$const_missing', function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      full_const_name = ($eqeq(self, $Object) ? (name) : ("" + (self) + "::" + (name)));
      return $Kernel.$raise($$$('NameError').$new("uninitialized constant " + (full_const_name), name));
    }, 1);
    
    $def(self, '$const_set', function $$const_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$const_name!'](name);
      if (($truthy(name['$!~']($$$($Opal, 'CONST_NAME_REGEXP'))) || ($truthy(name['$start_with?']("::"))))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      $const_set(self, name, value);
      return value;
    }, 2);
    
    $def(self, '$public_constant', $return_val(nil), 0);
    
    $def(self, '$define_method', function $$define_method(name, method) {
      var block = $$define_method.$$p || nil, self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      $$define_method.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (method === undefined && block === nil)
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
    ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($eqeqeq($$$('Proc'), ($ret_or_2 = method)) ? (method) : ($eqeqeq($$$('Method'), $ret_or_2) ? (method.$to_proc().$$unbound) : ($eqeqeq($$$('UnboundMethod'), $ret_or_2) ? ($lambda(function $$11($a){var $post_args, args, self = $$11.$$s == null ? this : $$11.$$s, bound = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        bound = method.$bind(self);
        return $send(bound, 'call', $to_a(args));}, {$$arity: -1, $$s: self})) : ($Kernel.$raise($$$('TypeError'), "wrong argument type " + (block.$class()) + " (expected Proc/Method)"))))));
      
      if (typeof(Proxy) !== 'undefined') {
        var meta = Object.create(null)

        block.$$proxy_target = block
        block = new Proxy(block, {
          apply: function(target, self, args) {
            var old_name = target.$$jsid
            target.$$jsid = name;
            try {
              return target.apply(self, args);
            } catch(e) {
              if (e === target.$$brk || e === target.$$ret) return e.$v;
              throw e;
            } finally {
              target.$$jsid = old_name
            }
          }
        })
      }

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      return Opal.defn(self, '$' + name, block);
    ;
    }, -2);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$base_module')) { $prop(self, '$$base_module', null); }

      return $freeze(self);
    ;
    }, 0);
    
    $def(self, '$remove_method', function $$remove_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        if (!(typeof name === "string" || name.$$is_string)) {
          self.$raise($$$('TypeError'), "" + (self.$name()) + " is not a symbol nor a string")
        }
        $deny_frozen_access(self);

        Opal.rdef(self, "$" + name);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$singleton_class?', function $Module_singleton_class$ques$12() {
      var self = this;

      return !!self.$$is_singleton;
    }, 0);
    
    $def(self, '$include', function $$include($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice.call(arguments);
      mods = $post_args;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$included_modules', function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, 0);
    
    $def(self, '$include?', function $Module_include$ques$13(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, 1);
    
    $def(self, '$instance_method', function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$$('UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, 1);
    
    $def(self, '$instance_methods', function $$instance_methods(include_super) {
      var self = this;

      
      if (include_super == null) include_super = true;
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$included', $return_val(nil), 0);
    
    $def(self, '$extended', $return_val(nil), 0);
    
    $def(self, '$extend_object', function $$extend_object(object) {
      
      
      $deny_frozen_access(object);
      return nil;
    }, 1);
    
    $def(self, '$method_added', function $$method_added($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_removed', function $$method_removed($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_undefined', function $$method_undefined($a) {
      var $post_args, $rest_arg;

      
      $post_args = $slice.call(arguments);
      $rest_arg = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$module_eval', function $$module_eval($a) {
      var block = $$module_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$module_eval.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)")), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$arity: 0, $$s: self});
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "" + ("wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$module_exec', function $$module_exec($a) {
      var block = $$module_exec.$$p || nil, $post_args, args, self = this;

      $$module_exec.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      if (block === nil) {
        $Kernel.$raise($$$('LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$method_defined?', function $Module_method_defined$ques$15(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, 1);
    
    $def(self, '$module_function', function $$module_function($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice.call(arguments);
      methods = $post_args;
      
      $deny_frozen_access(self);

      if (methods.length === 0) {
        self.$$module_function = true;
        return nil;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
        return methods.length === 1 ? methods[0] : methods;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$name', function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === $Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, 0);
    
    $def(self, '$prepend', function $$prepend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice.call(arguments);
      mods = $post_args;
      
      if (mods.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$prepend_features', function $$prepend_features(prepender) {
      var self = this;

      
      
      $deny_frozen_access(prepender);

      if (!self.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, 1);
    
    $def(self, '$prepended', $return_val(nil), 0);
    
    $def(self, '$remove_const', function $$remove_const(name) {
      var self = this;

      
      $deny_frozen_access(self);
      return Opal.const_remove(self, name);;
    }, 1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = Opal.Module.$name.call(self)))) {
        return $ret_or_1
      } else {
        return "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    }, 0);
    
    $def(self, '$undef_method', function $$undef_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice.call(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        if (!(typeof name === "string" || name.$$is_string)) {
          self.$raise($$$('TypeError'), "" + (self.$name()) + " is not a symbol nor a string")
        }
        $deny_frozen_access(self);

        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this, copy = nil;

      $$dup.$$p = null;
      
      copy = $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, 0);
    
    $def(self, '$copy_class_variables', function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, 1);
    
    $def(self, '$copy_constants', function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        $const_set(self, name, other_constants[name]);
      }
    
    }, 1);
    
    $def(self, '$refine', function $$refine(klass) {
      var block = $$refine.$$p || nil, $a, self = this, refinement_module = nil, m = nil, klass_id = nil;

      $$refine.$$p = null;
      
      ;
      $a = [self, nil, nil], (refinement_module = $a[0]), (m = $a[1]), (klass_id = $a[2]), $a;
      
      klass_id = Opal.id(klass);
      if (typeof self.$$refine_modules === "undefined") {
        self.$$refine_modules = {};
      }
      if (typeof self.$$refine_modules[klass_id] === "undefined") {
        m = self.$$refine_modules[klass_id] = $$$('Refinement').$new();
      }
      else {
        m = self.$$refine_modules[klass_id];
      }
      m.refinement_module = refinement_module
      m.refined_class = klass
    ;
      $send(m, 'class_exec', [], block.$to_proc());
      return m;
    }, 1);
    
    $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("Module#using is not permitted in methods")
    }, 1);
    $alias(self, "class_eval", "module_eval");
    $alias(self, "class_exec", "module_exec");
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Refinement');

    var $proto = self.$$prototype;

    $proto.refinement_module = $proto.refined_class = nil;
    return $def(self, '$inspect', function $$inspect() {
      var $yield = $$inspect.$$p || nil, self = this;

      $$inspect.$$p = null;
      if ($truthy(self.refinement_module)) {
        return "#<refinement:" + (self.refined_class.$inspect()) + "@" + (self.refinement_module.$inspect()) + ">"
      } else {
        return $send2(self, $find_super(self, 'inspect', $$inspect, false, true), 'inspect', [], $yield)
      }
    }, 0)
  })('::', $Module);
};

Opal.modules["corelib/enumerator/generator"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,raise,new,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        $deny_frozen_access(self);
        if (!$truthy(block)) {
          $Kernel.$raise($$$('LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, 0);
      return $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this, yielder = nil;

        $$each.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        yielder = $send($$('Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e && e.$thrower_type == "breaker") {
            return e.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/constants"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $const_set = Opal.const_set, nil = Opal.nil, $$$ = Opal.$$$;

  
  $const_set('::', 'RUBY_PLATFORM', "opal");
  $const_set('::', 'RUBY_ENGINE', "opal");
  $const_set('::', 'RUBY_VERSION', "3.1.0");
  $const_set('::', 'RUBY_ENGINE_VERSION', "1.6.0");
  $const_set('::', 'RUBY_RELEASE_DATE', "2022-11-24");
  $const_set('::', 'RUBY_PATCHLEVEL', 0);
  $const_set('::', 'RUBY_REVISION', "0");
  $const_set('::', 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2022 Adam Beynon and the Opal contributors");
  return $const_set('::', 'RUBY_DESCRIPTION', "opal " + ($$$('RUBY_ENGINE_VERSION')) + " (" + ($$$('RUBY_RELEASE_DATE')) + " revision " + ($$$('RUBY_REVISION')) + ")");
};

Opal.modules["corelib/enumerator/lazy"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $defs = Opal.defs, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $return_self = Opal.return_self, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,each,new,enumerator_size,yield,respond_to?,try_convert,<,===,+,for,class,to_proc,destructure,inspect,to_a,find_all,collect_concat,collect,enum_for');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.enumerator = nil;
      
      $klass(self, $$$('Exception'), 'StopLazyError');
      $defs(self, '$for', function $Lazy_for$1(object, $a) {
        var $post_args, $rest_arg, $yield = $Lazy_for$1.$$p || nil, self = this, lazy = nil;

        $Lazy_for$1.$$p = null;
        
        $post_args = $slice.call(arguments, 1);
        $rest_arg = $post_args;
        lazy = $send2(self, $find_super(self, 'for', $Lazy_for$1, false, true), 'for', [object].concat($to_a($rest_arg)), $yield);
        lazy.enumerator = object;
        return lazy;
      }, -2);
      
      $def(self, '$initialize', function $$initialize(object, size) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        if (size == null) size = nil;
        $deny_frozen_access(self);
        if (!(block !== nil)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], function $$2(yielder, $a){var $post_args, each_args;

          
          if (yielder == null) yielder = nil;
          $post_args = $slice.call(arguments, 1);
          each_args = $post_args;
          try {
            return $send(object, 'each', $to_a(each_args), function $$3($b){var $post_args, args;

              
              $post_args = $slice.call(arguments);
              args = $post_args;
              
            args.unshift(yielder);

            $yieldX(block, args);
          ;}, -1)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StopLazyError')])) {
              try {
                return nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };}, -2);
      }, -2);
      
      $def(self, '$lazy', $return_self, 0);
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        $$collect.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, self.$enumerator_size()], function $$4(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          enum$.$yield(value);
        ;}, -2);
      }, 0);
      
      $def(self, '$collect_concat', function $$collect_concat() {
        var block = $$collect_concat.$$p || nil, self = this;

        $$collect_concat.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$5(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], function $$6(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);}, 1)
          }
          else {
            var array = $Opal.$try_convert(value, $$$('Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], function $$7(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);}, 1);
            }
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$drop', function $$drop(n) {
        var self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        dropped = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$8(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      }, 1);
      
      $def(self, '$drop_while', function $$drop_while() {
        var block = $$drop_while.$$p || nil, self = this, succeeding = nil;

        $$drop_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$('Lazy'), 'new', [self, nil], function $$9(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          if ($truthy(succeeding)) {
            
            var value = $yieldX(block, args);

            if (!$truthy(value)) {
              succeeding = false;

              $send(enum$, 'yield', $to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      }, 0);
      
      $def(self, '$enum_for', function $$enum_for($a, $b) {
        var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

        $$enum_for.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        
        if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
        args = $post_args;
        return $send(self.$class(), 'for', [self, method].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$find_all', function $$find_all() {
        var block = $$find_all.$$p || nil, self = this;

        $$find_all.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$10(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$grep', function $$grep(pattern) {
        var block = $$grep.$$p || nil, self = this;

        $$grep.$$p = null;
        
        ;
        if ($truthy(block)) {
          return $send($$('Lazy'), 'new', [self, nil], function $$11(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice.call(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = $yield1(block, param);

              enum$.$yield($yield1(block, param));
            }
          ;}, -2)
        } else {
          return $send($$('Lazy'), 'new', [self, nil], function $$12(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice.call(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, -2)
        };
      }, 1);
      
      $def(self, '$reject', function $$reject() {
        var block = $$reject.$$p || nil, self = this;

        $$reject.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$13(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if (!$truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$take', function $$take(n) {
        var self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        taken = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$14(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', $to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return $Kernel.$raise($$('StopLazyError'))
          };}, -2);
      }, 1);
      
      $def(self, '$take_while', function $$take_while() {
        var block = $$take_while.$$p || nil, self = this;

        $$take_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$15(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
          else {
            $Kernel.$raise($$('StopLazyError'));
          }
        ;}, -2);
      }, 0);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, 0);
      $alias(self, "force", "to_a");
      $alias(self, "filter", "find_all");
      $alias(self, "flat_map", "collect_concat");
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");
      return $alias(self, "to_enum", "enum_for");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/yielder"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('yield,proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Yielder');

      var $proto = self.$$prototype;

      $proto.block = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.block = block;
        return self;
      }, 0);
      
      $def(self, '$yield', function $Yielder_yield$1($a) {
        var $post_args, values, self = this;

        
        $post_args = $slice.call(arguments);
        values = $post_args;
        
        var value = Opal.yieldX(self.block, values);

        if (value && value.$thrower_type == "break") {
          throw value;
        }

        return value;
      ;
      }, -1);
      
      $def(self, '$<<', function $Yielder_$lt$lt$2(value) {
        var self = this;

        
        self.$yield(value);
        return self;
      }, 1);
      return $def(self, '$to_proc', function $$to_proc() {
        var self = this;

        return $send(self, 'proc', [], function $$3($a){var $post_args, values, self = $$3.$$s == null ? this : $$3.$$s;

          
          $post_args = $slice.call(arguments);
          values = $post_args;
          return $send(self, 'yield', $to_a(values));}, {$$arity: -1, $$s: self})
      }, 0);
    })($nesting[0], null)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator/arithmetic_sequence"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $def = Opal.def, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('is_a?,==,raise,respond_to?,class,attr_reader,begin,end,exclude_end?,>,step,<,<=,>=,-@,_lesser_than_end?,<<,+,-,===,%,_greater_than_begin?,reverse,!,include?,*,to_i,abs,/,hash,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.step_arg2 = $proto.receiver_num = $proto.step_arg1 = $proto.step = $proto.range = $proto.topfx = $proto.bypfx = $proto.creation_method = $proto.skipped_arg = nil;
      
      Opal.prop(self.$$prototype, '$$is_arithmetic_seq', true);
      var inf = Infinity;
      
      $def(self, '$initialize', function $$initialize(range, step, creation_method) {
        var $a, self = this, $ret_or_1 = nil;

        
        ;
        if (creation_method == null) creation_method = "step";
        self.creation_method = creation_method;
        if ($truthy(range['$is_a?']($$$('Array')))) {
          
          $a = [].concat($to_a(range)), (self.step_arg1 = ($a[0] == null ? nil : $a[0])), (self.step_arg2 = ($a[1] == null ? nil : $a[1])), (self.topfx = ($a[2] == null ? nil : $a[2])), (self.bypfx = ($a[3] == null ? nil : $a[3])), $a;
          self.receiver_num = step;
          self.step = 1;
          self.range = ($truthy(self.step_arg2) ? (((self.step = self.step_arg2), Opal.Range.$new(self.receiver_num, self.step_arg1, false))) : ($truthy(self.step_arg1) ? (Opal.Range.$new(self.receiver_num, self.step_arg1, false)) : (Opal.Range.$new(self.receiver_num, nil, false))));
        } else {
          
          if (!$truthy(step)) {
            self.skipped_arg = true
          };
          $a = [range, ($truthy(($ret_or_1 = step)) ? ($ret_or_1) : (1))], (self.range = $a[0]), (self.step = $a[1]), $a;
        };
        self.object = self;
        if ($eqeq(self.step, 0)) {
          $Kernel.$raise($$('ArgumentError'), "step can't be 0")
        };
        if ($truthy(self.step['$respond_to?']("to_int"))) {
          return nil
        } else {
          return $Kernel.$raise($$('ArgumentError'), "" + ("no implicit conversion of " + (self.step.$class()) + " ") + "into Integer")
        };
      }, -2);
      self.$attr_reader("step");
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        return self.range.$begin()
      }, 0);
      
      $def(self, '$end', function $$end() {
        var self = this;

        return self.range.$end()
      }, 0);
      
      $def(self, '$exclude_end?', function $ArithmeticSequence_exclude_end$ques$1() {
        var self = this;

        return self.range['$exclude_end?']()
      }, 0);
      
      $def(self, '$_lesser_than_end?', function $ArithmeticSequence__lesser_than_end$ques$2(val) {
        var self = this, end_ = nil, $ret_or_1 = nil;

        
        end_ = ($truthy(($ret_or_1 = self.$end())) ? ($ret_or_1) : (inf));
        if ($truthy($rb_gt(self.$step(), 0))) {
          if ($truthy(self['$exclude_end?']())) {
            return $rb_lt(val, end_)
          } else {
            return $rb_le(val, end_)
          }
        } else if ($truthy(self['$exclude_end?']())) {
          return $rb_gt(val, end_)
        } else {
          return $rb_ge(val, end_)
        };
      }, 1);
      
      $def(self, '$_greater_than_begin?', function $ArithmeticSequence__greater_than_begin$ques$3(val) {
        var self = this, begin_ = nil, $ret_or_1 = nil;

        
        begin_ = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if ($truthy($rb_gt(self.$step(), 0))) {
          return $rb_gt(val, begin_)
        } else {
          return $rb_lt(val, begin_)
        };
      }, 1);
      
      $def(self, '$first', function $$first(count) {
        var self = this, iter = nil, $ret_or_1 = nil, out = nil;

        
        ;
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if (!$truthy(count)) {
          return ($truthy(self['$_lesser_than_end?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_lesser_than_end?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_plus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this, $ret_or_1 = nil, iter = nil;

        $$each.$$p = null;
        
        ;
        if (!(block !== nil)) {
          return self
        };
        if ($eqeqeq(nil, ($ret_or_1 = self.$begin()))) {
          $Kernel.$raise($$('TypeError'), "nil can't be coerced into Integer")
        } else {
          nil
        };
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        while ($truthy(self['$_lesser_than_end?'](iter))) {
        
          Opal.yield1(block, iter);
          iter = $rb_plus(iter, self.$step());
        };
        return self;
      }, 0);
      
      $def(self, '$last', function $$last(count) {
        var self = this, $ret_or_1 = nil, iter = nil, out = nil;

        
        ;
        if (($eqeqeq(inf, ($ret_or_1 = self.$end())) || ($eqeqeq((inf)['$-@'](), $ret_or_1)))) {
          $Kernel.$raise($$$('FloatDomainError'), self.$end())
        } else if ($eqeqeq(nil, $ret_or_1)) {
          $Kernel.$raise($$$('RangeError'), "cannot get the last element of endless arithmetic sequence")
        } else {
          nil
        };
        iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
        if (!$truthy(self['$_lesser_than_end?'](iter))) {
          iter = $rb_minus(iter, self.$step())
        };
        if (!$truthy(count)) {
          return ($truthy(self['$_greater_than_begin?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_greater_than_begin?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_minus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out.$reverse();
      }, -1);
      
      $def(self, '$size', function $$size() {
        var self = this, step_sign = nil, iter = nil;

        
        step_sign = ($truthy($rb_gt(self.$step(), 0)) ? (1) : (-1));
        if ($not(self['$_lesser_than_end?'](self.$begin()))) {
          return 0
        } else if ($truthy([(inf)['$-@'](), inf]['$include?'](self.$step()))) {
          return 1
        } else if (($truthy([$rb_times((inf)['$-@'](), step_sign), nil]['$include?'](self.$begin())) || ($truthy([$rb_times(inf, step_sign), nil]['$include?'](self.$end()))))) {
          return inf;
        } else {
          
          iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
          if (!$truthy(self['$_lesser_than_end?'](iter))) {
            iter = $rb_minus(iter, self.$step())
          };
          return $rb_plus($rb_divide($rb_minus(iter, self.$begin()), self.$step()).$abs().$to_i(), 1);
        };
      }, 0);
      
      $def(self, '$==', function $ArithmeticSequence_$eq_eq$4(other) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$class()['$=='](other.$class()))) ? (self.$begin()['$=='](other.$begin())) : ($ret_or_4)))) ? (self.$end()['$=='](other.$end())) : ($ret_or_3)))) ? (self.$step()['$=='](other.$step())) : ($ret_or_2))))) {
          return self['$exclude_end?']()['$=='](other['$exclude_end?']())
        } else {
          return $ret_or_1
        }
      }, 1);
      
      $def(self, '$hash', function $$hash() {
        var self = this;

        return [self.$begin(), self.$end(), self.$step(), self['$exclude_end?']()].$hash()
      }, 0);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this, args = nil;

        if ($truthy(self.receiver_num)) {
          
          args = ($truthy(self.step_arg2) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ", " + (self.bypfx) + (self.step_arg2.$inspect()) + ")") : ($truthy(self.step_arg1) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ")") : nil));
          return "(" + (self.receiver_num.$inspect()) + "." + (self.creation_method) + (args) + ")";
        } else {
          
          args = ($truthy(self.skipped_arg) ? (nil) : ("(" + (self.step) + ")"));
          return "((" + (self.range.$inspect()) + ")." + (self.creation_method) + (args) + ")";
        }
      }, 0);
      $alias(self, "===", "==");
      return $alias(self, "eql?", "==");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerable"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $module = Opal.module, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $Opal = Opal.Opal, $thrower = Opal.thrower, $def = Opal.def, $Kernel = Opal.Kernel, $return_val = Opal.return_val, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $rb_le = Opal.rb_le, $hash2 = Opal.hash2, $lambda = Opal.lambda, $not = Opal.not, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,public_send,destructure,to_enum,enumerator_size,new,yield,raise,slice_when,!,enum_for,flatten,map,to_proc,compact,to_a,warn,proc,==,nil?,respond_to?,coerce_to!,>,*,try_convert,<,+,-,ceil,/,size,select,__send__,length,<=,[],push,<<,[]=,===,inspect,<=>,first,reverse,sort,take,sort_by,compare,call,dup,sort!,map!,include?,-@,key?,values,transform_values,group_by,fetch,to_h,coerce_to?,class,zip,detect,find_all,collect_concat,collect,inject,entries');
  return (function($base) {
    var self = $module($base, 'Enumerable');

    
    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    $def(self, '$all?', function $Enumerable_all$ques$1(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_all$ques$1.$$p || nil, self = this;

      $Enumerable_all$ques$1.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$2($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$3($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$4($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            return nil
          } else {
            $t_return.$throw(false)
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$any?', function $Enumerable_any$ques$5(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_any$ques$5.$$p || nil, self = this;

      $Enumerable_any$ques$5.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$6($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$7($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$8($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            $t_return.$throw(true)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$chunk', function $$chunk() {
      var block = $$chunk.$$p || nil, self = this;

      $$chunk.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["chunk"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send($$$('Enumerator'), 'new', [], function $$10(yielder){var self = $$10.$$s == null ? this : $$10.$$s;

        
        if (yielder == null) yielder = nil;
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = $yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, {$$arity: 1, $$s: self});
    }, 0);
    
    $def(self, '$chunk_while', function $$chunk_while() {
      var block = $$chunk_while.$$p || nil, self = this;

      $$chunk_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], function $$11(before, after){
        
        if (before == null) before = nil;
        if (after == null) after = nil;
        return Opal.yieldX(block, [before, after])['$!']();}, 2);
    }, 0);
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = $yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$collect_concat', function $$collect_concat() {
      var block = $$collect_concat.$$p || nil, self = this;

      $$collect_concat.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect_concat"], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send(self, 'map', [], block.$to_proc()).$flatten(1);
    }, 0);
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      return self.$to_a().$compact()
    }, 0);
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this, result = nil;

      $$count.$$p = null;
      
      ;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send($Kernel, 'proc', [], function $$14($a){var $post_args, args;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          return $Opal.$destructure(args)['$=='](object);}, -1)
      } else if ($truthy(block['$nil?']())) {
        block = $send($Kernel, 'proc', [], $return_val(true), 0)
      };
      $send(self, 'each', [], function $$15($a){var $post_args, args;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        if ($truthy($yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$$('Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil
        };
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, -1);
    
    $def(self, '$detect', function $$detect(ifnone) {try { var $t_return = $thrower('return'); 
      var block = $$detect.$$p || nil, self = this;

      $$detect.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], function $$17($a){var $post_args, args, value = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          $t_return.$throw(value)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');
      if ($truthy(number < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
      };
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($Opal.$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, 1);
    
    $def(self, '$drop_while', function $$drop_while() {
      var block = $$drop_while.$$p || nil, self = this;

      $$drop_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        if (dropping) {
          var value = $yield1(block, param);

          if (!$truthy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$each_cons', function $$each_cons(n) {
      var block = $$each_cons.$$p || nil, self = this;

      $$each_cons.$$p = null;
      
      ;
      if ($truthy(arguments.length != 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 1)")
      };
      n = $Opal.$try_convert(n, $$$('Integer'), "to_int");
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_cons", n], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s, enum_size = nil;

          
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if (($eqeq(enum_size, 0) || ($truthy($rb_lt(enum_size, n))))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, {$$arity: 0, $$s: self})
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          $yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return self;
    ;
    }, 1);
    
    $def(self, '$each_entry', function $$each_entry($a) {
      var block = $$each_entry.$$p || nil, $post_args, data, self = this;

      $$each_entry.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      data = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["each_entry"].concat($to_a(data)), function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      self.$each.$$p = function() {
        var item = $Opal.$destructure(arguments);

        $yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, -1);
    
    $def(self, '$each_slice', function $$each_slice(n) {
      var block = $$each_slice.$$p || nil, self = this;

      $$each_slice.$$p = null;
      
      ;
      n = $coerce_to(n, $$$('Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid slice size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_slice", n], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s;

          if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, {$$arity: 0, $$s: self})
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          $yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        $yield1(block, slice);
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$each_with_index', function $$each_with_index($a) {
      var block = $$each_with_index.$$p || nil, $post_args, args, self = this;

      $$each_with_index.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"].concat($to_a(args)), function $$21(){var self = $$21.$$s == null ? this : $$21.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, -1);
    
    $def(self, '$each_with_object', function $$each_with_object(object) {
      var block = $$each_with_object.$$p || nil, self = this;

      $$each_with_object.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_object", object], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    }, 1);
    
    $def(self, '$entries', function $$entries($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($Opal.$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, -1);
    
    $def(self, '$filter_map', function $$filter_map() {
      var block = $$filter_map.$$p || nil, self = this;

      $$filter_map.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["filter_map"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    }, 0);
    
    $def(self, '$find_all', function $$find_all() {
      var block = $$find_all.$$p || nil, self = this;

      $$find_all.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["find_all"], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$find_index', function $$find_index(object) {try { var $t_return = $thrower('return'); 
      var block = $$find_index.$$p || nil, self = this, index = nil;

      $$find_index.$$p = null;
      
      ;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")
      };
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], function $$25($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($eqeq($Opal.$destructure(value), object)) {
            $t_return.$throw(index)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$26($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(index)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      };
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$first', function $$first(number) {try { var $t_return = $thrower('return'); 
      var self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], function $$27(value){
          
          if (value == null) value = nil;
          $t_return.$throw(value);}, {$$arity: 1, $$ret: $t_return})
      } else {
        
        result = [];
        number = $coerce_to(number, $$$('Integer'), 'to_int');
        if ($truthy(number < 0)) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        if ($truthy(number == 0)) {
          return []
        };
        current = 0;
        $send(self, 'each', [], function $$28($a){var $post_args, args;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          result.push($Opal.$destructure(args));
          if ($truthy(number <= ++current)) {
            $t_return.$throw(result)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return});
        return result;
      };} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$grep', function $$grep(pattern) {
      var block = $$grep.$$p || nil, self = this, result = nil;

      $$grep.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$29($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice.call(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if (!$truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    }, 1);
    
    $def(self, '$grep_v', function $$grep_v(pattern) {
      var block = $$grep_v.$$p || nil, self = this, result = nil;

      $$grep_v.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$30($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice.call(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    }, 1);
    
    $def(self, '$group_by', function $$group_by() {
      var block = $$group_by.$$p || nil, $a, self = this, hash = nil, $ret_or_1 = nil;

      $$group_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["group_by"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        ($truthy(($ret_or_1 = hash['$[]'](value))) ? ($ret_or_1) : (($a = [value, []], $send(hash, '[]=', $a), $a[$a.length - 1])))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, 0);
    
    $def(self, '$include?', function $Enumerable_include$ques$32(obj) {try { var $t_return = $thrower('return'); 
      var self = this;

      
      $send(self, 'each', [], function $$33($a){var $post_args, args;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        if ($eqeq($Opal.$destructure(args), obj)) {
          $t_return.$throw(true)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, 1);
    
    $def(self, '$inject', function $$inject(object, sym) {
      var block = $$inject.$$p || nil, self = this;

      $$inject.$$p = null;
      
      ;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = $yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$$('Symbol')['$==='](object)) {
            $Kernel.$raise($$$('TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$lazy', function $$lazy() {
      var self = this;

      return $send($$$($$$('Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], function $$34(enum$, $a){var $post_args, args;

        
        if (enum$ == null) enum$ = nil;
        $post_args = $slice.call(arguments, 1);
        args = $post_args;
        return $send(enum$, 'yield', $to_a(args));}, -2)
    }, 0);
    
    $def(self, '$enumerator_size', function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = $yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$$('Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, -1);
    
    $def(self, '$max_by', function $$max_by(n) {
      var block = $$max_by.$$p || nil, self = this;

      $$max_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["max_by", n], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min', function $$min(n) {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(n['$nil?']())) {
        if ((block !== nil)) {
          return $send(self, 'sort', [], function $$36(a, b){
            
            if (a == null) a = nil;
            if (b == null) b = nil;
            return Opal.yieldX(block, [a, b]);;}, 2).$take(n)
        } else {
          return self.$sort().$take(n)
        }
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($Opal.$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min_by', function $$min_by(n) {
      var block = $$min_by.$$p || nil, self = this;

      $$min_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["min_by", n], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$minmax', function $$minmax() {
      var block = $$minmax.$$p || nil, self = this, $ret_or_1 = nil;

      $$minmax.$$p = null;
      
      ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($send($Kernel, 'proc', [], function $$38(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$<=>'](b);}, 2)));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, 0);
    
    $def(self, '$minmax_by', function $$minmax_by() {
      var block = $$minmax_by.$$p || nil, self = this;

      $$minmax_by.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["minmax_by"], function $$39(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    }, 0);
    
    $def(self, '$none?', function $Enumerable_none$ques$40(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_none$ques$40.$$p || nil, self = this;

      $Enumerable_none$ques$40.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$41($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$42($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$43($a){var $post_args, value, item = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          item = $Opal.$destructure(value);
          if ($truthy(item)) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$one?', function $Enumerable_one$ques$44(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_one$ques$44.$$p || nil, self = this, count = nil;

      $Enumerable_one$ques$44.$$p = null;
      
      ;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$45($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              $t_return.$throw(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$46($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if (!$truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$47($a){var $post_args, value;

          
          $post_args = $slice.call(arguments);
          value = $post_args;
          if (!$truthy($Opal.$destructure(value))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return count['$=='](1);} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, -1);
    
    $def(self, '$partition', function $$partition() {
      var block = $$partition.$$p || nil, self = this;

      $$partition.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["partition"], function $$48(){var self = $$48.$$s == null ? this : $$48.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, 0);
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (!$truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, 0);
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$50(){var self = $$50.$$s == null ? this : $$50.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        $yieldX(block, result[i]);
      }

      return result;
    ;
    }, 0);
    
    $def(self, '$slice_before', function $$slice_before(pattern) {
      var block = $$slice_before.$$p || nil, self = this;

      $$slice_before.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$51(e){var self = $$51.$$s == null ? this : $$51.$$s;

        
        if (e == null) e = nil;
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = $yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $Opal.$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$slice_after', function $$slice_after(pattern) {
      var block = $$slice_after.$$p || nil, self = this;

      $$slice_after.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      if ($truthy(pattern !== undefined)) {
        block = $send($Kernel, 'proc', [], function $$52(e){
          
          if (e == null) e = nil;
          return pattern['$==='](e);}, 1)
      };
      return $send($$$('Enumerator'), 'new', [], function $$53(yielder){var self = $$53.$$s == null ? this : $$53.$$s;

        
        if (yielder == null) yielder = nil;
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $Opal.$destructure(arguments),
              end_chunk = $yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, {$$arity: 1, $$s: self});
    }, -1);
    
    $def(self, '$slice_when', function $$slice_when() {
      var block = $$slice_when.$$p || nil, self = this;

      $$slice_when.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$54(yielder){var self = $$54.$$s == null ? this : $$54.$$s;

        
        if (yielder == null) yielder = nil;
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $Opal.$destructure(arguments),
              before = params[0],
              after = params[1],
              match = $yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, {$$arity: 1, $$s: self});
    }, 0);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this, ary = nil;

      $$sort.$$p = null;
      
      ;
      ary = self.$to_a();
      if (!(block !== nil)) {
        block = $lambda(function $$55(a, b){
          
          if (a == null) a = nil;
          if (b == null) b = nil;
          return a['$<=>'](b);}, 2)
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, 0);
    
    $def(self, '$sort_by', function $$sort_by() {
      var block = $$sort_by.$$p || nil, self = this, dup = nil;

      $$sort_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by"], function $$56(){var self = $$56.$$s == null ? this : $$56.$$s;

          return self.$enumerator_size()}, {$$arity: 0, $$s: self})
      };
      dup = $send(self, 'map', [], function $$57(){var arg = nil;

        
        arg = $Opal.$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, 0);
      $send(dup, 'sort!', [], function $$58(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return (a[0])['$<=>'](b[0]);}, 2);
      return $send(dup, 'map!', [], function $$59(i){
        
        if (i == null) i = nil;
        return i[1];;}, 1);
    }, 0);
    
    $def(self, '$sum', function $$sum(initial) {
      var $yield = $$sum.$$p || nil, self = this, result = nil, compensation = nil;

      $$sum.$$p = null;
      
      if (initial == null) initial = 0;
      result = initial;
      compensation = 0;
      $send(self, 'each', [], function $$60($a){var $post_args, args, item = nil, y = nil, t = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        item = (($yield !== nil) ? (Opal.yieldX($yield, $to_a(args))) : ($Opal.$destructure(args)));
        if (($not([$$$($$$('Float'), 'INFINITY'), $$$($$$('Float'), 'INFINITY')['$-@']()]['$include?'](item)) && ($truthy(item['$respond_to?']("-"))))) {
          
          y = $rb_minus(item, compensation);
          t = $rb_plus(result, y);
          compensation = $rb_minus($rb_minus(t, result), y);
          return (result = t);
        } else {
          return (result = $rb_plus(result, item))
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$take', function $$take(num) {
      var self = this;

      return self.$first(num)
    }, 1);
    
    $def(self, '$take_while', function $$take_while() {try { var $t_return = $thrower('return'); 
      var block = $$take_while.$$p || nil, self = this, result = nil;

      $$take_while.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], function $$61($a){var $post_args, args, value = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if (!$truthy(Opal.yield1(block, value))) {
          $t_return.$throw(result)
        };
        return result.push(value);;}, {$$arity: -1, $$ret: $t_return});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      }
    }, 0);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this, hash = nil;

      $$uniq.$$p = null;
      
      ;
      hash = $hash2([], {});
      $send(self, 'each', [], function $$62($a){var $post_args, args, $b, value = nil, produced = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        produced = ((block !== nil) ? (Opal.yield1(block, value)) : (value));
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          return ($b = [produced, value], $send(hash, '[]=', $b), $b[$b.length - 1])
        };}, -1);
      return hash.$values();
    }, 0);
    
    $def(self, '$tally', function $$tally(hash) {
      var self = this, out = nil;

      
      ;
      if (hash && hash !== nil) { $deny_frozen_access(hash); };
      out = $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc());
      if ($truthy(hash)) {
        
        $send(out, 'each', [], function $$63(k, v){var $a;

          
          if (k == null) k = nil;
          if (v == null) v = nil;
          return ($a = [k, $rb_plus(hash.$fetch(k, 0), v)], $send(hash, '[]=', $a), $a[$a.length - 1]);}, 2);
        return hash;
      } else {
        return out
      };
    }, -1);
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      $$to_h.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);
        var ary = $Opal['$coerce_to?'](param, $$$('Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      others = $post_args;
      return $send(self.$to_a(), 'zip', $to_a(others));
    }, -1);
    $alias(self, "find", "detect");
    $alias(self, "filter", "find_all");
    $alias(self, "flat_map", "collect_concat");
    $alias(self, "map", "collect");
    $alias(self, "member?", "include?");
    $alias(self, "reduce", "inject");
    $alias(self, "select", "find_all");
    return $alias(self, "to_a", "entries");
  })('::')
};

Opal.modules["corelib/nil"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_val = Opal.return_val, $ensure_kwargs = Opal.ensure_kwargs, $NilClass = Opal.NilClass, $slice = Opal.slice, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,new,>,length,Rational,to_i');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      }, 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$!', $return_val(true), 0);
    
    $def(self, '$&', $return_val(false), 0);
    
    $def(self, '$|', function $NilClass_$$1(other) {
      
      return other !== false && other !== nil;
    }, 1);
    
    $def(self, '$^', function $NilClass_$$2(other) {
      
      return other !== false && other !== nil;
    }, 1);
    
    $def(self, '$==', function $NilClass_$eq_eq$3(other) {
      
      return other === nil;
    }, 1);
    
    $def(self, '$dup', $return_val(nil), 0);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $kwargs.$$smap["freeze"];if (freeze == null) freeze = true;
      return nil;
    }, -1);
    
    $def(self, '$inspect', $return_val("nil"), 0);
    
    $def(self, '$nil?', $return_val(true), 0);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      
      return $NilClass
    }, 0);
    
    $def(self, '$to_a', function $$to_a() {
      
      return []
    }, 0);
    
    $def(self, '$to_h', function $$to_h() {
      
      return Opal.hash();
    }, 0);
    
    $def(self, '$to_i', $return_val(0), 0);
    
    $def(self, '$to_s', $return_val(""), 0);
    
    $def(self, '$to_c', function $$to_c() {
      
      return $$$('Complex').$new(0, 0)
    }, 0);
    
    $def(self, '$rationalize', function $$rationalize($a) {
      var $post_args, args;

      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy($rb_gt(args.$length(), 1))) {
        $Kernel.$raise($$$('ArgumentError'))
      };
      return $Kernel.$Rational(0, 1);
    }, -1);
    
    $def(self, '$to_r', function $$to_r() {
      
      return $Kernel.$Rational(0, 1)
    }, 0);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    }, 0);
    return $alias(self, "to_f", "to_i");
  })('::', null, $nesting)
};

Opal.modules["corelib/helpers"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $Opal = Opal.Opal, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('===,raise,respond_to?,nil?,__send__,<=>,class,coerce_to!,new,to_s,__id__');
  return (function($base) {
    var self = $module($base, 'Opal');

    
    
    $defs(self, '$bridge', function $$bridge(constructor, klass) {
      
      return Opal.bridge(constructor, klass);
    }, 2);
    $defs(self, '$coerce_to!', function $Opal_coerce_to$excl$1(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice.call(arguments, 3);
      args = $post_args;
      coerced = $coerce_to(object, type, method, args);
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$coerce_to?', function $Opal_coerce_to$ques$2(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice.call(arguments, 3);
      args = $post_args;
      if (!$truthy(object['$respond_to?'](method))) {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil
      };
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$try_convert', function $$try_convert(object, type, method) {
      
      
      if ($eqeqeq(type, object)) {
        return object
      };
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, 3);
    $defs(self, '$compare', function $$compare(a, b) {
      var compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")
      };
      return compare;
    }, 2);
    $defs(self, '$destructure', function $$destructure(args) {
      
      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, 1);
    $defs(self, '$respond_to?', function $Opal_respond_to$ques$3(obj, method, include_all) {
      
      
      if (include_all == null) include_all = false;
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, -3);
    $defs(self, '$instance_variable_name!', function $Opal_instance_variable_name$excl$4(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if (!$truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        $Kernel.$raise($$$('NameError').$new("'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, 1);
    $defs(self, '$class_variable_name!', function $Opal_class_variable_name$excl$5(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        $Kernel.$raise($$$('NameError').$new("`" + (name) + "' is not allowed as a class variable name", name))
      };
      return name;
    }, 1);
    $defs(self, '$const_name?', function $Opal_const_name$ques$6(const_name) {
      
      
      if (typeof const_name !== 'string') {
        (const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str"))
      }

      return const_name[0] === const_name[0].toUpperCase()
    
    }, 1);
    $defs(self, '$const_name!', function $Opal_const_name$excl$7(const_name) {
      var $a, self = this;

      
      if ($truthy((($a = $$$('::', 'String', 'skip_raise')) ? 'constant' : nil))) {
        const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str")
      };
      
      if (!const_name || const_name[0] != const_name[0].toUpperCase()) {
        self.$raise($$$('NameError'), "wrong constant name " + (const_name))
      }
    ;
      return const_name;
    }, 1);
    $defs(self, '$pristine', function $$pristine(owner_class, $a) {
      var $post_args, method_names;

      
      $post_args = $slice.call(arguments, 1);
      method_names = $post_args;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, -2);
    var inspect_stack = [];
    return $defs(self, '$inspect', function $$inspect(value) {
      var e = nil;

      
      ;
      var pushed = false;
      
      return (function() { try {
      try {
        
        
        if (value === null) {
          // JS null value
          return 'null';
        }
        else if (value === undefined) {
          // JS undefined value
          return 'undefined';
        }
        else if (typeof value.$$class === 'undefined') {
          // JS object / other value that is not bridged
          return Object.prototype.toString.apply(value);
        }
        else if (typeof value.$inspect !== 'function' || value.$inspect.$$stub) {
          // BasicObject and friends
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else if (inspect_stack.indexOf(value.$__id__()) !== -1) {
          // inspect recursing inside inspect to find out about the
          // same object
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else {
          // anything supporting Opal
          inspect_stack.push(value.$__id__());
          pushed = true;
          return value.$inspect();
        }
      ;
        return nil;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {(e = $err)
          try {
            return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, -1);
  })('::')
};

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.load_normalized("opal");

Opal.modules["browser/setup/full"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("paggio");
  self.$require("browser/setup/large");
  self.$require("browser/event/all");
  self.$require("browser/dom/builder");
  self.$require("browser/dom/mutation_observer");
  self.$require("browser/dom/element/custom");
  return self.$require("browser/canvas");
};

Opal.modules["promise"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $defs = Opal.defs, $slice = Opal.slice, $hash2 = Opal.hash2, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $return_ivar = Opal.return_ivar, $not = Opal.not, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_le = Opal.rb_le, $rb_minus = Opal.rb_minus, $const_set = Opal.const_set, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil;

  Opal.add_stubs('resolve,new,reject,attr_reader,===,value,key?,keys,!=,==,<<,>>,exception?,[],resolved?,rejected?,!,error,include?,action,realized?,raise,^,call,resolve!,exception!,any?,each,reject!,there_can_be_only_one!,then,to_proc,fail,always,trace,class,object_id,+,inspect,rescue,to_v2,fail!,then!,always!,itself,nil?,prev,act?,push,concat,it,proc,reverse,pop,<=,length,shift,-,wait,map,reduce,try,tap,all?,find,collect,inject');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Promise');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.value = $proto.action = $proto.realized = $proto.next = $proto.delayed = $proto.error = $proto.prev = nil;
    
    $defs(self, '$value', function $$value(value) {
      var self = this;

      return self.$new().$resolve(value)
    }, 1);
    $defs(self, '$error', function $$error(value) {
      var self = this;

      return self.$new().$reject(value)
    }, 1);
    $defs(self, '$when', function $$when($a) {
      var $post_args, promises;

      
      $post_args = $slice.call(arguments);
      promises = $post_args;
      return $$('When').$new(promises);
    }, -1);
    self.$attr_reader("error", "prev", "next");
    
    $def(self, '$initialize', function $$initialize(action) {
      var self = this;

      
      if (action == null) action = $hash2([], {});
      self.action = action;
      self.realized = false;
      self.exception = false;
      self.value = nil;
      self.error = nil;
      self.delayed = false;
      self.prev = nil;
      return (self.next = []);
    }, -1);
    
    $def(self, '$value', function $$value() {
      var self = this;

      if ($eqeqeq($$('Promise'), self.value)) {
        return self.value.$value()
      } else {
        return self.value
      }
    }, 0);
    
    $def(self, '$act?', function $Promise_act$ques$1() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.action['$key?']("success")))) {
        return $ret_or_1
      } else {
        return self.action['$key?']("always")
      }
    }, 0);
    
    $def(self, '$action', function $$action() {
      var self = this;

      return self.action.$keys()
    }, 0);
    
    $def(self, '$exception?', $return_ivar("exception"), 0);
    
    $def(self, '$realized?', function $Promise_realized$ques$2() {
      var self = this;

      return self.realized['$!='](false)
    }, 0);
    
    $def(self, '$resolved?', function $Promise_resolved$ques$3() {
      var self = this;

      return self.realized['$==']("resolve")
    }, 0);
    
    $def(self, '$rejected?', function $Promise_rejected$ques$4() {
      var self = this;

      return self.realized['$==']("reject")
    }, 0);
    
    $def(self, '$^', function $Promise_$$5(promise) {
      var self = this;

      
      promise['$<<'](self);
      self['$>>'](promise);
      return promise;
    }, 1);
    
    $def(self, '$<<', function $Promise_$lt$lt$6(promise) {
      var self = this;

      
      self.prev = promise;
      return self;
    }, 1);
    
    $def(self, '$>>', function $Promise_$gt$gt$7(promise) {
      var self = this;

      
      self.next['$<<'](promise);
      if ($truthy(self['$exception?']())) {
        promise.$reject(self.delayed['$[]'](0))
      } else if ($truthy(self['$resolved?']())) {
        promise.$resolve(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$value())))
      } else if ($truthy(self['$rejected?']())) {
        if (($not(self.action['$key?']("failure")) || ($eqeqeq($$('Promise'), ($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.error)))))) {
          promise.$reject(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$error())))
        } else if ($truthy(promise.$action()['$include?']("always"))) {
          promise.$reject(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$error())))
        }
      };
      return self;
    }, 1);
    
    $def(self, '$resolve', function $$resolve(value) {
      var self = this, block = nil, $ret_or_1 = nil, e = nil;

      
      if (value == null) value = nil;
      if ($truthy(self['$realized?']())) {
        self.$raise($$('ArgumentError'), "the promise has already been realized")
      };
      if ($eqeqeq($$('Promise'), value)) {
        return value['$<<'](self.prev)['$^'](self)
      };
      
      try {
        
        block = ($truthy(($ret_or_1 = self.action['$[]']("success"))) ? ($ret_or_1) : (self.action['$[]']("always")));
        if ($truthy(block)) {
          value = block.$call(value)
        };
        self['$resolve!'](value);
      } catch ($err) {
        if (Opal.rescue($err, [$$('Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };;
      return self;
    }, -1);
    
    $def(self, '$resolve!', function $Promise_resolve$excl$8(value) {
      var self = this;

      
      self.realized = "resolve";
      self.value = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], function $$9(p){
          
          if (p == null) p = nil;
          return p.$resolve(value);}, 1)
      } else {
        return (self.delayed = [value])
      };
    }, 1);
    
    $def(self, '$reject', function $$reject(value) {
      var self = this, block = nil, $ret_or_1 = nil, e = nil;

      
      if (value == null) value = nil;
      if ($truthy(self['$realized?']())) {
        self.$raise($$('ArgumentError'), "the promise has already been realized")
      };
      if ($eqeqeq($$('Promise'), value)) {
        return value['$<<'](self.prev)['$^'](self)
      };
      
      try {
        
        block = ($truthy(($ret_or_1 = self.action['$[]']("failure"))) ? ($ret_or_1) : (self.action['$[]']("always")));
        if ($truthy(block)) {
          value = block.$call(value)
        };
        if ($truthy(self.action['$key?']("always"))) {
          self['$resolve!'](value)
        } else {
          self['$reject!'](value)
        };
      } catch ($err) {
        if (Opal.rescue($err, [$$('Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };;
      return self;
    }, -1);
    
    $def(self, '$reject!', function $Promise_reject$excl$10(value) {
      var self = this;

      
      self.realized = "reject";
      self.error = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], function $$11(p){
          
          if (p == null) p = nil;
          return p.$reject(value);}, 1)
      } else {
        return (self.delayed = [value])
      };
    }, 1);
    
    $def(self, '$exception!', function $Promise_exception$excl$12(error) {
      var self = this;

      
      self.exception = true;
      return self['$reject!'](error);
    }, 1);
    
    $def(self, '$then', function $$then() {
      var block = $$then.$$p || nil, self = this;

      $$then.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new($hash2(["success"], {"success": block})));
    }, 0);
    
    $def(self, '$then!', function $Promise_then$excl$13() {
      var block = $Promise_then$excl$13.$$p || nil, self = this;

      $Promise_then$excl$13.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'then', [], block.$to_proc());
    }, 0);
    
    $def(self, '$fail', function $$fail() {
      var block = $$fail.$$p || nil, self = this;

      $$fail.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new($hash2(["failure"], {"failure": block})));
    }, 0);
    
    $def(self, '$fail!', function $Promise_fail$excl$14() {
      var block = $Promise_fail$excl$14.$$p || nil, self = this;

      $Promise_fail$excl$14.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'fail', [], block.$to_proc());
    }, 0);
    
    $def(self, '$always', function $$always() {
      var block = $$always.$$p || nil, self = this;

      $$always.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new($hash2(["always"], {"always": block})));
    }, 0);
    
    $def(self, '$always!', function $Promise_always$excl$15() {
      var block = $Promise_always$excl$15.$$p || nil, self = this;

      $Promise_always$excl$15.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'always', [], block.$to_proc());
    }, 0);
    
    $def(self, '$trace', function $$trace(depth) {
      var block = $$trace.$$p || nil, self = this;

      $$trace.$$p = null;
      
      ;
      if (depth == null) depth = nil;
      return self['$^']($$('Trace').$new(depth, block));
    }, -1);
    
    $def(self, '$trace!', function $Promise_trace$excl$16($a) {
      var block = $Promise_trace$excl$16.$$p || nil, $post_args, args, self = this;

      $Promise_trace$excl$16.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      self['$there_can_be_only_one!']();
      return $send(self, 'trace', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$there_can_be_only_one!', function $Promise_there_can_be_only_one$excl$17() {
      var self = this;

      if ($truthy(self.next['$any?']())) {
        return self.$raise($$('ArgumentError'), "a promise has already been chained")
      } else {
        return nil
      }
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, $ret_or_1 = nil;

      
      result = "#<" + (self.$class()) + "(" + (self.$object_id()) + ")";
      if ($truthy(self.next['$any?']())) {
        result = $rb_plus(result, " >> " + (self.next.$inspect()))
      };
      result = $rb_plus(result, ($truthy(self['$realized?']()) ? (": " + (($truthy(($ret_or_1 = self.value)) ? ($ret_or_1) : (self.error)).$inspect()) + ">") : (">")));
      return result;
    }, 0);
    
    $def(self, '$to_v2', function $$to_v2() {
      var self = this, v2 = nil;

      
      v2 = $$('PromiseV2').$new();
      $send($send(self, 'then', [], function $$18(i){
        
        if (i == null) i = nil;
        return v2.$resolve(i);}, 1), 'rescue', [], function $$19(i){
        
        if (i == null) i = nil;
        return v2.$reject(i);}, 1);
      return v2;
    }, 0);
    $alias(self, "await", "to_v2");
    $alias(self, "catch", "fail");
    $alias(self, "catch!", "fail!");
    $alias(self, "do", "then");
    $alias(self, "do!", "then!");
    $alias(self, "ensure", "always");
    $alias(self, "ensure!", "always!");
    $alias(self, "finally", "always");
    $alias(self, "finally!", "always!");
    $alias(self, "rescue", "fail");
    $alias(self, "rescue!", "fail!");
    $alias(self, "to_n", "to_v2");
    $alias(self, "to_v1", "itself");
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Trace');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$it', function $$it(promise) {
        var self = this, current = nil, prev = nil;

        
        current = [];
        if (($truthy(promise['$act?']()) || ($truthy(promise.$prev()['$nil?']())))) {
          current.$push(promise.$value())
        };
        prev = promise.$prev();
        if ($truthy(prev)) {
          return current.$concat(self.$it(prev))
        } else {
          return current
        };
      }, 1);
      return $def(self, '$initialize', function $$initialize(depth, block) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        self.depth = depth;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [$hash2(["success"], {"success": $send(self, 'proc', [], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s, trace = nil;

          
          trace = $$('Trace').$it(self).$reverse();
          trace.$pop();
          if (($truthy(depth) && ($truthy($rb_le(depth, trace.$length()))))) {
            trace.$shift($rb_minus(trace.$length(), depth))
          };
          return $send(block, 'call', $to_a(trace));}, {$$arity: 0, $$s: self})})], null);
      }, 2);
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'When');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.wait = nil;
      
      
      $def(self, '$initialize', function $$initialize(promises) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (promises == null) promises = [];
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [], null);
        self.wait = [];
        return $send(promises, 'each', [], function $$21(promise){var self = $$21.$$s == null ? this : $$21.$$s;

          
          if (promise == null) promise = nil;
          return self.$wait(promise);}, {$$arity: 1, $$s: self});
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        if (!$truthy(block)) {
          self.$raise($$('ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], function $$22(values){
          
          if (values == null) values = nil;
          return $send(values, 'each', [], block.$to_proc());}, 1);
      }, 0);
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        $$collect.$$p = null;
        
        ;
        if (!$truthy(block)) {
          self.$raise($$('ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], function $$23(values){
          
          if (values == null) values = nil;
          return $$('When').$new($send(values, 'map', [], block.$to_proc()));}, 1);
      }, 0);
      
      $def(self, '$inject', function $$inject($a) {
        var block = $$inject.$$p || nil, $post_args, args, self = this;

        $$inject.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        return $send(self, 'then', [], function $$24(values){
          
          if (values == null) values = nil;
          return $send(values, 'reduce', $to_a(args), block.$to_proc());}, 1);
      }, -1);
      
      $def(self, '$wait', function $$wait(promise) {
        var self = this;

        
        if (!$eqeqeq($$('Promise'), promise)) {
          promise = $$('Promise').$value(promise)
        };
        if ($truthy(promise['$act?']())) {
          promise = promise.$then()
        };
        self.wait['$<<'](promise);
        $send(promise, 'always', [], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;
          if (self.next == null) self.next = nil;

          if ($truthy(self.next['$any?']())) {
            return self.$try()
          } else {
            return nil
          }}, {$$arity: 0, $$s: self});
        return self;
      }, 1);
      
      $def(self, '$>>', function $When_$gt$gt$26($a) {
        var $post_args, $rest_arg, $yield = $When_$gt$gt$26.$$p || nil, self = this;

        $When_$gt$gt$26.$$p = null;
        
        $post_args = $slice.call(arguments);
        $rest_arg = $post_args;
        return $send($send2(self, $find_super(self, '>>', $When_$gt$gt$26, false, true), '>>', $to_a($rest_arg), $yield), 'tap', [], function $$27(){var self = $$27.$$s == null ? this : $$27.$$s;

          return self.$try()}, {$$arity: 0, $$s: self});
      }, -1);
      
      $def(self, '$try', function $When_try$28() {
        var self = this, promise = nil;

        if ($truthy($send(self.wait, 'all?', [], "realized?".$to_proc()))) {
          
          promise = $send(self.wait, 'find', [], "rejected?".$to_proc());
          if ($truthy(promise)) {
            return self.$reject(promise.$error())
          } else {
            return self.$resolve($send(self.wait, 'map', [], "value".$to_proc()))
          };
        } else {
          return nil
        }
      }, 0);
      $alias(self, "map", "collect");
      $alias(self, "reduce", "inject");
      return $alias(self, "and", "wait");
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
  return $const_set($nesting[0], 'PromiseV1', $$('Promise'));
};

Opal.modules["native"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send, $Kernel = Opal.Kernel, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $range = Opal.range, $to_a = Opal.to_a, $def = Opal.def, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $klass = Opal.klass, $rb_minus = Opal.rb_minus, $return_val = Opal.return_val, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeqeq = Opal.eqeqeq, $rb_ge = Opal.rb_ge, $return_self = Opal.return_self, $gvars = Opal.gvars, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('try_convert,native?,respond_to?,to_n,raise,inspect,Native,proc,map!,end_with?,define_method,[],convert,call,to_proc,new,each,native_reader,native_writer,extend,warn,include,is_a?,map,Array,to_a,_Array,method_missing,bind,instance_method,[]=,slice,-,length,has_key?,enum_for,===,>=,<<,each_pair,method_defined?,initialize,_initialize,name,native_module');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$is_a?', function $Native_is_a$ques$1(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    }, 2);
    $defs(self, '$try_convert', function $$try_convert(value, default$) {
      var self = this;

      
      if (default$ == null) default$ = nil;
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, -2);
    $defs(self, '$convert', function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$('ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    }, 1);
    $defs(self, '$call', function $$call(obj, key, $a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 2);
      args = $post_args;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, -3);
    $defs(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil, self = this;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        self.$raise($$('LocalJumpError'), "no block given")
      };
      return $send($Kernel, 'proc', [], function $$2($a){var $post_args, args, self = $$2.$$s == null ? this : $$2.$$s, instance = nil;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        $send(args, 'map!', [], function $$3(arg){var self = $$3.$$s == null ? this : $$3.$$s;

          
          if (arg == null) arg = nil;
          return self.$Native(arg);}, {$$arity: 1, $$s: self});
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, {$$arity: -1, $$s: self});
    }, 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$alias_native', function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $yield = $$alias_native.$$p || nil, self = this;

        $$alias_native.$$p = null;
        
        $post_args = $slice.call(arguments, 1);
        $kwargs = $extract_kwargs($post_args);
        $kwargs = $ensure_kwargs($kwargs);
        
        if ($post_args.length > 0) old = $post_args.shift();if (old == null) old = new$;
        
        as = $kwargs.$$smap["as"];if (as == null) as = nil;
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], function $$4(value){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (value == null) value = nil;
            self["native"][old['$[]']($range(0, -2, false))] = $$('Native').$convert(value);
            return value;}, {$$arity: 1, $$s: self})
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], function $$5($c){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, value = nil;
            if (self["native"] == null) self["native"] = nil;

            $$5.$$p = null;
            
            ;
            $post_args = $slice.call(arguments);
            args = $post_args;
            value = $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, {$$arity: -1, $$s: self})
        } else {
          return $send(self, 'define_method', [new$], function $$6($c){var block = $$6.$$p || nil, $post_args, args, self = $$6.$$s == null ? this : $$6.$$s;
            if (self["native"] == null) self["native"] = nil;

            $$6.$$p = null;
            
            ;
            $post_args = $slice.call(arguments);
            args = $post_args;
            return $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());}, {$$arity: -1, $$s: self})
        };
      }, -2);
      
      $def(self, '$native_reader', function $$native_reader($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice.call(arguments);
        names = $post_args;
        return $send(names, 'each', [], function $$7(name){var self = $$7.$$s == null ? this : $$7.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;
            if (self["native"] == null) self["native"] = nil;

            return self.$Native(self["native"][name])}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self});
      }, -1);
      
      $def(self, '$native_writer', function $$native_writer($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice.call(arguments);
        names = $post_args;
        return $send(names, 'each', [], function $$9(name){var self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', ["" + (name) + "="], function $$10(value){var self = $$10.$$s == null ? this : $$10.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (value == null) value = nil;
            return self.$Native(self["native"][name] = value);}, {$$arity: 1, $$s: self});}, {$$arity: 1, $$s: self});
      }, -1);
      return $def(self, '$native_accessor', function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice.call(arguments);
        names = $post_args;
        $send(self, 'native_reader', $to_a(names));
        return $send(self, 'native_writer', $to_a(names));
      }, -1);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$initialize', function $$initialize(native$) {
        var self = this;

        
        if (!$truthy($Kernel['$native?'](native$))) {
          $Kernel.$raise($$('ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      }, 1);
      
      $def(self, '$to_n', $return_ivar("native"), 0);
      return $defs(self, '$included', function $$included(klass) {
        
        return klass.$extend($$('Helpers'))
      }, 1);
    })($nesting[0], $nesting);
    return $defs(self, '$included', function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$('Wrapper'));
    }, 1);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native?', function $Kernel_native$ques$11(value) {
      
      return value == null || !value.$$class;
    }, 1);
    
    $def(self, '$Native', function $$Native(obj) {
      var $yield = $$Native.$$p || nil, self = this;

      $$Native.$$p = null;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$('Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$('Array')))) {
        return $send(obj, 'map', [], function $$12(o){var self = $$12.$$s == null ? this : $$12.$$s;

          
          if (o == null) o = nil;
          return self.$Native(o);}, {$$arity: 1, $$s: self})
      } else if ($truthy(obj['$is_a?']($$('Proc')))) {
        return $send(self, 'proc', [], function $$13($a){var block = $$13.$$p || nil, $post_args, args, self = $$13.$$s == null ? this : $$13.$$s;

          $$13.$$p = null;
          
          ;
          $post_args = $slice.call(arguments);
          args = $post_args;
          return self.$Native($send(obj, 'call', $to_a(args), block.$to_proc()));}, {$$arity: -1, $$s: self})
      } else {
        return obj
      }
    }, 1);
    $alias(self, "_Array", "Array");
    return $def(self, '$Array', function $$Array(object, $a) {
      var block = $$Array.$$p || nil, $post_args, args, self = this;

      $$Array.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$('Native'), 'Array'), 'new', [object].concat($to_a(args)), block.$to_proc()).$to_a()
      };
      return self.$_Array(object);
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    var $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$$('Native'), 'Wrapper'));
    
    $def(self, '$==', function $Object_$eq_eq$14(other) {
      var self = this;

      return self["native"] === $$$('Native').$try_convert(other)
    }, 1);
    
    $def(self, '$has_key?', function $Object_has_key$ques$15(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    }, 1);
    
    $def(self, '$each', function $$each($a) {
      var $post_args, args, $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      $post_args = $slice.call(arguments);
      args = $post_args;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat($to_a(args)))
      };
    }, -1);
    
    $def(self, '$[]', function $Object_$$$16(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('Native').$call(self["native"], key)
      }
    
    }, 1);
    
    $def(self, '$[]=', function $Object_$$$eq$17(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    }, 2);
    
    $def(self, '$merge!', function $Object_merge$excl$18(other) {
      var self = this;

      
      
      other = $$$('Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    }, 1);
    
    $def(self, '$respond_to?', function $Object_respond_to$ques$19(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      return $Kernel.$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Object_respond_to_missing$ques$20(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      return Opal.hasOwnProperty.call(self["native"], name);
    }, -2);
    
    $def(self, '$method_missing', function $$method_missing(mid, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, $b, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return ($b = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)], $send(self, '[]=', $b), $b[$b.length - 1]);
      }
      else {
        return $send($$$('Native'), 'call', [self["native"], mid].concat($to_a(args)), block.$to_proc());
      }
    ;
    }, -2);
    
    $def(self, '$nil?', $return_val(false), 0);
    
    $def(self, '$is_a?', function $Object_is_a$ques$21(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    }, 1);
    
    $def(self, '$instance_of?', function $Object_instance_of$ques$22(klass) {
      var self = this;

      return self.$$class === klass;
    }, 1);
    
    $def(self, '$class', function $Object_class$23() {
      var self = this;

      return self.$$class;
    }, 0);
    
    $def(self, '$to_a', function $$to_a(options) {
      var block = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      ;
      if (options == null) options = $hash2([], {});
      return $send($$$($$$('Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Native:" + (String(self["native"])) + ">"
    }, 0);
    $alias(self, "include?", "has_key?");
    $alias(self, "key?", "has_key?");
    $alias(self, "kind_of?", "is_a?");
    return $alias(self, "member?", "has_key?");
  })($$('Native'), $$('BasicObject'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.named = $proto["native"] = $proto.get = $proto.block = $proto.set = $proto.length = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    self.$include($$('Enumerable'));
    
    $def(self, '$initialize', function $$initialize(native$, options) {
      var block = $$initialize.$$p || nil, self = this, $ret_or_1 = nil;

      $$initialize.$$p = null;
      
      ;
      if (options == null) options = $hash2([], {});
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [native$], null);
      self.get = ($truthy(($ret_or_1 = options['$[]']("get"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.named = options['$[]']("named");
      self.set = ($truthy(($ret_or_1 = options['$[]']("set"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.length = ($truthy(($ret_or_1 = options['$[]']("length"))) ? ($ret_or_1) : ("length"));
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$('ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    }, 0);
    
    $def(self, '$[]', function $Array_$$$24(index) {
      var self = this, result = nil, $ret_or_1 = nil;

      
      result = (($eqeqeq($$('String'), ($ret_or_1 = index)) || ($eqeqeq($$('Symbol'), $ret_or_1))) ? (($truthy(self.named) ? (self["native"][self.named](index)) : (self["native"][index]))) : ($eqeqeq($$('Integer'), $ret_or_1) ? (($truthy(self.get) ? (self["native"][self.get](index)) : (self["native"][index]))) : (nil)));
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    }, 1);
    
    $def(self, '$[]=', function $Array_$$$eq$25(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$('Native').$convert(value))
      } else {
        return self["native"][index] = $$('Native').$convert(value)
      }
    }, 2);
    
    $def(self, '$last', function $$last(count) {
      var self = this, index = nil, result = nil;

      
      if (count == null) count = nil;
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
        
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self["native"][self.length]
    }, 0);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    }, 0);
    return $alias(self, "to_ary", "to_a");
  })($$('Native'), null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    return $def(self, '$to_n', $return_self, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Regexp');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'MatchData');

    
    return $def(self, '$to_n', $return_ivar("matches"), 0)
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], function $$26(name, value){
        
        if (name == null) name = nil;
        if (value == null) value = nil;
        return result[name] = $$('Native').$try_convert(value, value);}, 2);
      return result;
    }, 0)
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$('Native').$try_convert(obj, obj));
      }

      return result;
    
    }, 0)
  })($nesting[0], null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_n', $return_self, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_n', function $$to_n() {
      
      return null;
    }, 0)
  })($nesting[0], null);
  if (!$truthy($$('Hash')['$method_defined?']("_initialize"))) {
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Hash');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $alias(self, "_initialize", "initialize");
      
      $def(self, '$initialize', function $$initialize(defaults) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        ;
        
        if (defaults != null &&
             (defaults.constructor === undefined ||
               defaults.constructor === Object)) {
          var smap = self.$$smap,
              keys = self.$$keys,
              key, value;

          for (key in defaults) {
            value = defaults[key];

            if (value &&
                 (value.constructor === undefined ||
                   value.constructor === Object)) {
              smap[key] = $$('Hash').$new(value);
            } else if (value && value.$$is_array) {
              value = value.map(function(item) {
                if (item &&
                     (item.constructor === undefined ||
                       item.constructor === Object)) {
                  return $$('Hash').$new(item);
                }

                return self.$Native(item);
              });
              smap[key] = value
            } else {
              smap[key] = self.$Native(value);
            }

            keys.push(key);
          }

          return self;
        }

        return $send(self, '_initialize', [defaults], block.$to_proc());
      ;
      }, -1);
      return $def(self, '$to_n', function $$to_n() {
        var self = this;

        
        var result = {},
            keys = self.$$keys,
            smap = self.$$smap,
            key, value;

        for (var i = 0, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = smap[key];
          } else {
            key = key.key;
            value = key.value;
          }

          result[key] = $$('Native').$try_convert(value, value);
        }

        return result;
      
      }, 0);
    })($nesting[0], null, $nesting)
  };
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    return $def(self, '$native_module', function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    }, 0)
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native_alias', function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype['$' + existing_mid];
      if (!aliased) {
        self.$raise($$('NameError').$new("undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    }, 2);
    return $def(self, '$native_class', function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    }, 0);
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.modules["browser/canvas"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $gvars = Opal.gvars, $neqeq = Opal.neqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $alias = Opal.alias, $to_ary = Opal.to_ary, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,attr_reader,===,first,shift,create_element,[]=,width,height,!=,node_name,raise,to_n,new,draw_image,to_i,[],append_to,on,resolve,DOM,to_proc,move_to,line_to,length,quadratic_curve_to,bezier_curve_to,element,is_a?,save,instance_eval,restore,path,one,off,for');
  
  self.$require("browser/canvas/style");
  self.$require("browser/canvas/text");
  self.$require("browser/canvas/data");
  self.$require("browser/canvas/gradient");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.element = $proto.image = $proto["native"] = nil;
      
      self.$include($$$($$('Native'), 'Wrapper'));
      self.$attr_reader("element", "style", "text");
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, args, $yield = $$initialize.$$p || nil, self = this, element = nil;
        if ($gvars.document == null) $gvars.document = nil;

        $$initialize.$$p = null;
        
        $post_args = $slice.call(arguments);
        args = $post_args;
        if ($eqeqeq($$$($$('DOM'), 'Element'), args.$first())) {
          
          element = args.$shift();
          if ($eqeqeq($$$($$$($$('DOM'), 'Element'), 'Image'), element)) {
            self.image = element
          } else {
            self.element = element
          };
        } else if ($eqeqeq($$('Canvas'), args.$first())) {
          self.image = args.$first()
        };
        if (!$truthy(self.element)) {
          
          self.element = $gvars.document.$create_element("canvas");
          if ($truthy(self.image)) {
            
            self.element['$[]=']("width", self.image.$width());
            self.element['$[]=']("height", self.image.$height());
          } else {
            
            self.element['$[]=']("width", args.$shift());
            self.element['$[]=']("height", args.$shift());
          };
        };
        if ($neqeq(self.element.$node_name(), "CANVAS")) {
          self.$raise($$('ArgumentError'), "the element isn't a <canvas> element")
        };
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.element.$to_n().getContext('2d')], null);
        self.style = $$('Style').$new(self);
        self.text = $$('Text').$new(self);
        if ($truthy(self.image)) {
          return self.$draw_image(self.image)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$width', function $$width() {
        var self = this;

        return self.element['$[]']("width").$to_i()
      }, 0);
      
      $def(self, '$height', function $$height() {
        var self = this;

        return self.element['$[]']("height").$to_i()
      }, 0);
      
      $def(self, '$width=', function $Canvas_width$eq$1(new_width) {
        var $a, self = this;

        return ($a = ["width", new_width.$to_i()], $send(self.element, '[]=', $a), $a[$a.length - 1])
      }, 1);
      
      $def(self, '$height=', function $Canvas_height$eq$2(new_height) {
        var $a, self = this;

        return ($a = ["height", new_height.$to_i()], $send(self.element, '[]=', $a), $a[$a.length - 1])
      }, 1);
      
      $def(self, '$append_to', function $$append_to(parent) {
        var self = this;

        return self.element.$append_to(parent)
      }, 1);
      
      $def(self, '$load', function $$load(path) {
        var promise = nil, image = nil;
        if ($gvars.document == null) $gvars.document = nil;

        
        promise = $$('Promise').$new();
        image = $gvars.document.$create_element("img");
        $send(image, 'on', ["load"], function $$3(){
          return promise.$resolve(image)}, 0);
        image['$[]=']("src", path);
        return promise;
      }, 1);
      
      $def(self, '$data', function $$data(x, y, width, height) {
        var self = this, $ret_or_1 = nil;

        
        if (x == null) x = nil;
        if (y == null) y = nil;
        if (width == null) width = nil;
        if (height == null) height = nil;
        x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
        y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
        width = ($truthy(($ret_or_1 = width)) ? ($ret_or_1) : (self.$width()));
        height = ($truthy(($ret_or_1 = height)) ? ($ret_or_1) : (self.$height()));
        return $$('Data').$new(self, x, y, width, height);
      }, -1);
      
      $def(self, '$pattern', function $$pattern(image, type) {
        var self = this;

        
        if (type == null) type = "repeat";
        return self["native"].createPattern(self.$DOM(image).$to_n(), type);
      }, -2);
      
      $def(self, '$gradient', function $$gradient($a) {
        var block = $$gradient.$$p || nil, $post_args, args, self = this;

        $$gradient.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        return $send($$('Gradient'), 'new', [self].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$clear', function $$clear(x, y, width, height) {
        var self = this, $ret_or_1 = nil;

        
        if (x == null) x = nil;
        if (y == null) y = nil;
        if (width == null) width = nil;
        if (height == null) height = nil;
        x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
        y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
        width = ($truthy(($ret_or_1 = width)) ? ($ret_or_1) : (self.$width()));
        height = ($truthy(($ret_or_1 = height)) ? ($ret_or_1) : (self.$height()));
        return self["native"].clearRect(x, y, width, height);
      }, -1);
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        
        self["native"].beginPath();
        return self;
      }, 0);
      
      $def(self, '$close', function $$close() {
        var self = this;

        
        self["native"].closePath();
        return self;
      }, 0);
      
      $def(self, '$save', function $$save() {
        var self = this;

        
        self["native"].save();
        return self;
      }, 0);
      
      $def(self, '$restore', function $$restore() {
        var self = this;

        
        self["native"].restore();
        return self;
      }, 0);
      
      $def(self, '$move_to', function $$move_to(x, y) {
        var self = this;

        
        self["native"].moveTo(x, y);
        return self;
      }, 2);
      $alias(self, "move", "move_to");
      
      $def(self, '$line_to', function $$line_to(x, y) {
        var self = this;

        
        self["native"].lineTo(x, y);
        return self;
      }, 2);
      
      $def(self, '$line', function $$line(x1, y1, x2, y2) {
        var self = this;

        
        self.$move_to(x1, y1);
        return self.$line_to(x2, y2);
      }, 4);
      
      $def(self, '$rect', function $$rect(x, y, width, height) {
        var self = this;

        
        self["native"].rect(x, y, width, height);
        return self;
      }, 4);
      
      $def(self, '$arc', function $$arc(x, y, radius, angle, clockwise) {
        var self = this;

        
        if (clockwise == null) clockwise = false;
        self["native"].arc(x, y, radius, angle['$[]']("start"), angle['$[]']("end"), !clockwise);
        return self;
      }, -5);
      
      $def(self, '$quadratic_curve_to', function $$quadratic_curve_to(cp1x, cp1y, x, y) {
        var self = this;

        
        self["native"].quadraticCurveTo(cp1x, cp1y, x, y);
        return self;
      }, 4);
      
      $def(self, '$bezier_curve_to', function $$bezier_curve_to(cp1x, cp1y, cp2x, cp2y, x, y) {
        var self = this;

        
        self["native"].bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        return self;
      }, 6);
      
      $def(self, '$curve_to', function $$curve_to($a) {
        var $post_args, args, self = this;

        
        $post_args = $slice.call(arguments);
        args = $post_args;
        
        switch (args.$length()) {
          case 4:
            $send(self, 'quadratic_curve_to', $to_a(args))
            break;
          case 6:
            $send(self, 'bezier_curve_to', $to_a(args))
            break;
          default:
            self.$raise($$('ArgumentError'), "don't know where to dispatch")
        };
        return self;
      }, -1);
      
      $def(self, '$draw_image', function $$draw_image(image, $a) {
        var $post_args, args, $b, $c, self = this, source = nil, destination = nil;

        
        $post_args = $slice.call(arguments, 1);
        args = $post_args;
        if ($eqeqeq($$('Canvas'), image)) {
          image = image.$element()
        } else {
          image = self.$DOM(image)
        };
        if ($truthy(args.$first()['$is_a?']($$('Hash')))) {
          
          $c = args, $b = $to_ary($c), (source = ($b[0] == null ? nil : $b[0])), (destination = ($b[1] == null ? nil : $b[1])), $c;
          self["native"].drawImage(image.$to_n(), source['$[]']("x"), source['$[]']("y"), source['$[]']("width"), source['$[]']("height"), destination['$[]']("x"), destination['$[]']("y"), destination['$[]']("width"), destination['$[]']("height"));
        } else 
        switch (args.$length()) {
          case 0:
            self["native"].drawImage(image.$to_n(), 0, 0)
            break;
          case 2:
            self["native"].drawImage(image.$to_n(), args['$[]'](0), args['$[]'](1))
            break;
          case 4:
            self["native"].drawImage(image.$to_n(), args['$[]'](0), args['$[]'](1), args['$[]'](2), args['$[]'](3))
            break;
          default:
            nil
        };
        return self;
      }, -2);
      
      $def(self, '$translate', function $$translate(x, y) {
        var block = $$translate.$$p || nil, self = this;

        $$translate.$$p = null;
        
        ;
        if ($truthy(block)) {
          
          self.$save();
          self["native"].translate(x, y);
          $send(self, 'instance_eval', [], block.$to_proc());
          self.$restore();
        } else {
          self["native"].translate(x, y)
        };
        return self;
      }, 2);
      
      $def(self, '$rotate', function $$rotate(angle) {
        var block = $$rotate.$$p || nil, self = this;

        $$rotate.$$p = null;
        
        ;
        if ($truthy(block)) {
          
          self.$save();
          self["native"].rotate(angle);
          $send(self, 'instance_eval', [], block.$to_proc());
          self.$restore();
        } else {
          self["native"].rotate(angle)
        };
        return self;
      }, 1);
      
      $def(self, '$scale', function $$scale(x, y) {
        var block = $$scale.$$p || nil, self = this;

        $$scale.$$p = null;
        
        ;
        if ($truthy(block)) {
          
          self.$save();
          self["native"].scale(x, y);
          $send(self, 'instance_eval', [], block.$to_proc());
          self.$restore();
        } else {
          self["native"].scale(x, y)
        };
        return self;
      }, 2);
      
      $def(self, '$transform', function $$transform(m11, m12, m21, m22, dx, dy) {
        var block = $$transform.$$p || nil, self = this;

        $$transform.$$p = null;
        
        ;
        if ($truthy(block)) {
          
          self.$save();
          self["native"].transform(m11, m12, m21, m22, dx, dy);
          $send(self, 'instance_eval', [], block.$to_proc());
          self.$restore();
        } else {
          self["native"].transform(m11, m12, m21, m22, dx, dy)
        };
        return self;
      }, 6);
      
      $def(self, '$path', function $$path() {
        var block = $$path.$$p || nil, self = this;

        $$path.$$p = null;
        
        ;
        self["native"].beginPath();
        $send(self, 'instance_eval', [], block.$to_proc());
        self["native"].closePath();
        return self;
      }, 0);
      
      $def(self, '$fill', function $$fill() {
        var block = $$fill.$$p || nil, self = this;

        $$fill.$$p = null;
        
        ;
        if ($truthy(block)) {
          $send(self, 'path', [], block.$to_proc())
        };
        self["native"].fill();
        return self;
      }, 0);
      
      $def(self, '$stroke', function $$stroke() {
        var block = $$stroke.$$p || nil, self = this;

        $$stroke.$$p = null;
        
        ;
        if ($truthy(block)) {
          $send(self, 'path', [], block.$to_proc())
        };
        self["native"].stroke();
        return self;
      }, 0);
      
      $def(self, '$clip', function $$clip() {
        var block = $$clip.$$p || nil, self = this;

        $$clip.$$p = null;
        
        ;
        if ($truthy(block)) {
          $send(self, 'path', [], block.$to_proc())
        };
        self["native"].clip();
        return self;
      }, 0);
      
      $def(self, '$point_in_path?', function $Canvas_point_in_path$ques$4(x, y) {
        var self = this;

        return self["native"].isPointInPath(x, y)
      }, 2);
      
      $def(self, '$to_data', function $$to_data(type) {
        var self = this;

        
        ;
        return self.element.$to_n().toDataUrl(type);
      }, -1);
      
      $def(self, '$to_dom', function $$to_dom($a) {
        var $post_args, $rest_arg, self = this;

        
        $post_args = $slice.call(arguments);
        $rest_arg = $post_args;
        return self.element;
      }, -1);
      
      $def(self, '$on', function $$on($a) {
        var block = $$on.$$p || nil, $post_args, args, self = this;

        $$on.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        return $send(self.element, 'on', $to_a(args), block.$to_proc());
      }, -1);
      
      $def(self, '$one', function $$one($a) {
        var block = $$one.$$p || nil, $post_args, args, self = this;

        $$one.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        return $send(self.element, 'one', $to_a(args), block.$to_proc());
      }, -1);
      return $def(self, '$off', function $$off($a) {
        var block = $$off.$$p || nil, $post_args, args, self = this;

        $$off.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        return $send(self.element, 'off', $to_a(args), block.$to_proc());
      }, -1);
    })($nesting[0], null, $nesting);
    return $send($$$($$$($$('Browser'), 'DOM'), 'Builder'), 'for', [$$('Canvas')], function $Browser$5(b, item){
      
      if (b == null) b = nil;
      if (item == null) item = nil;
      return item.$element();}, 2);
  })($nesting[0], $nesting);
};

Opal.modules["browser/dom/element/custom"] = function(Opal) {/* Generated by Opal 1.6.0 */
  "use strict";
  var $truthy = Opal.truthy, $module = Opal.module, $klass = Opal.klass, $ensure_kwargs = Opal.ensure_kwargs, $eqeq = Opal.eqeq, $def = Opal.def, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $gvars = Opal.gvars, $hash2 = Opal.hash2, $defs = Opal.defs, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('supports?,==,superclass,include?,ancestors,raise,def_selector,observe,new,each,target,type,observed_attributes,class,name,===,attribute_changed,old,[],added,attached_once,removed,detached_once,css,body,_dispatch_constructor,to_n,private,attr_accessor,attr_reader,extend,attached,detached,include');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Custom');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          if ($truthy($$('Browser')['$supports?']("Custom Elements"))) {
            
    var make_custom_class = Function('self,base_class',
      '"use strict"; \
      var klass = class extends base_class { \
        constructor() { \
          super(); \
          self.$_dispatch_constructor(this); \
        } \
        connectedCallback() { \
          return this.$$opal_native_cached.$attached(); \
        } \
        disconnectedCallback() { \
          return this.$$opal_native_cached.$detached(); \
        } \
        adoptedCallback() { \
          return this.$$opal_native_cached.$adopted(); \
        } \
        attributeChangedCallback(attr, from, to) { \
          if (from === null) from = Opal.nil; \
          if (to === null) to = Opal.nil; \
          return this.$$opal_native_cached.$attribute_changed(attr, from, to); \
        } \
        \
        static get observedAttributes() { \
          return self.$observed_attributes(); \
        } \
      }; \
      klass.$$opal_class = self; \
      return klass;'
    );
  
          };
          (function($base, $parent_nesting) {
            var self = $module($base, 'ClassMethods');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);
            if ($gvars.document == null) $gvars.document = nil;

            
            if ($truthy($$('Browser')['$supports?']("Custom Elements"))) {
              
              $def(self, '$def_custom', function $$def_custom(tag_name, $kwargs) {
                var base_class, extends$, self = this, $ret_or_1 = nil;
                if (self.observed_attributes == null) self.observed_attributes = nil;
                if (self.custom_class == null) self.custom_class = nil;

                
                $kwargs = $ensure_kwargs($kwargs);
                
                base_class = $kwargs.$$smap["base_class"];if (base_class == null) base_class = nil;
                
                extends$ = $kwargs.$$smap["extends"];if (extends$ == null) extends$ = nil;
                if (!$truthy(base_class !== nil)) {
                  if ($eqeq(self.$superclass(), $$('Custom'))) {
                    base_class = HTMLElement
                  } else if ($truthy(self.$ancestors()['$include?']($$('Custom')))) {
                    base_class = self.$superclass().custom_class
                  } else {
                    self.$raise($$('ArgumentError'), "You must define base_class")
                  }
                };
                self.custom_class = make_custom_class(self, base_class);
                self.observed_attributes = ($truthy(($ret_or_1 = self.observed_attributes)) ? ($ret_or_1) : ([]));
                self.$def_selector(tag_name);
                
          if ($truthy(extends$)) customElements.define(tag_name, self.custom_class, {extends: extends$});
          else customElements.define(tag_name, self.custom_class);
        ;
              }, -2)
            } else if ($truthy($$('Browser')['$supports?']("MutationObserver"))) {
              $send($$$($$$($$('Browser'), 'DOM'), 'MutationObserver'), 'new', [], function $ClassMethods$1(obs){
                
                if (obs == null) obs = nil;
                return $send(obs, 'each', [], function $$2(e){var target = nil;

                  
                  if (e == null) e = nil;
                  target = e.$target();
                  
                  switch (e.$type()) {
                    case "attribute":
                      if (($eqeqeq($$$($$('Custom'), 'Mixin'), target) && ($truthy(target.$class().$observed_attributes()['$include?'](e.$name()))))) {
                        return target.$attribute_changed(e.$name(), e.$old(), target['$[]'](e.$name()))
                      } else {
                        return nil
                      }
                      break;
                    case "tree":
                      
                      $send(e.$added(), 'each', [], function $$3(n){
                        
                        if (n == null) n = nil;
                        if ($eqeqeq($$$($$('Custom'), 'Mixin'), n)) {
                          return n.$attached_once()
                        } else {
                          return nil
                        };}, 1);
                      return $send(e.$removed(), 'each', [], function $$4(n){
                        
                        if (n == null) n = nil;
                        if ($eqeqeq($$$($$('Custom'), 'Mixin'), n)) {
                          return n.$detached_once()
                        } else {
                          return nil
                        };}, 1);
                    default:
                      return nil
                  };}, 1);}, 1).$observe($gvars.document, $hash2(["tree", "children", "attributes"], {"tree": true, "children": true, "attributes": "old"}))
            };
            if (!$truthy($$('Browser')['$supports?']("Custom Elements"))) {
              
              $def(self, '$def_custom', function $$def_custom(tag_name, $kwargs) {
                var base_class, extends$, self = this;
                if ($gvars.document == null) $gvars.document = nil;

                
                $kwargs = $ensure_kwargs($kwargs);
                
                base_class = $kwargs.$$smap["base_class"];if (base_class == null) base_class = nil;
                
                extends$ = $kwargs.$$smap["extends"];if (extends$ == null) extends$ = nil;
                self.$def_selector(tag_name);
                return $send($gvars.document.$body().$css(tag_name), 'each', [], function $$5(elem){var $a, self = $$5.$$s == null ? this : $$5.$$s;

                  
                  if (elem == null) elem = nil;
                  return ($a = self.$_dispatch_constructor(elem.$to_n()), ($a === nil || $a == null) ? nil : $a.$attached_once());}, {$$arity: 1, $$s: self});
              }, -2)
            };
            self.$private($def(self, '$_dispatch_constructor', function $$_dispatch_constructor(obj) {
              var self = this;

              
        if (typeof obj.$$opal_native_cached !== 'undefined') {
          delete obj.$$opal_native_cached;
          return self.$new(obj);
        }
        else {
          self.$new(obj);
          return nil;
        }
      
            }, 1));
            self.$attr_accessor("observed_attributes");
            return self.$attr_reader("custom_class");
          })($nesting[0], $nesting);
          (function($base, $parent_nesting) {
            var self = $module($base, 'Mixin');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

            
            $defs(self, '$included', function $$included(klass) {
              
              return klass.$extend($$('ClassMethods'))
            }, 1);
            
            $def(self, '$attached', $return_val(nil), 0);
            
            $def(self, '$detached', $return_val(nil), 0);
            
            $def(self, '$adopted', $return_val(nil), 0);
            
            $def(self, '$attribute_changed', $return_val(nil), 0);
            
            $def(self, '$custom?', $return_val(true), 0);
            if ($truthy($$('Browser')['$supports?']("Custom Elements"))) {
              return nil
            } else {
              
              
              $def(self, '$attached_once', function $$attached_once() {
                var self = this;
                if (self._polyfill_attached == null) self._polyfill_attached = nil;

                
                if (!$truthy(self._polyfill_attached)) {
                  self.$attached()
                };
                return (self._polyfill_attached = true);
              }, 0);
              return $def(self, '$detached_once', function $$detached_once() {
                var self = this;
                if (self._polyfill_attached == null) self._polyfill_attached = nil;

                
                if ($truthy(self._polyfill_attached)) {
                  self.$detached()
                };
                return (self._polyfill_attached = false);
              }, 0);
            };
          })($nesting[0], $nesting);
          return self.$include($$('Mixin'));
        })($nesting[0], $$('Element'), $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/mutation_observer"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $send2 = Opal.send2, $find_super = Opal.find_super, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('supports?,include,==,type,new,[],DOM,alias_native,call,map,convert,private,Native,[]=,to_n');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MutationObserver');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        $defs(self, '$supported?', function $MutationObserver_supported$ques$1() {
          
          return $$('Browser')['$supports?']("MutationObserver")
        }, 0);
        self.$include($$$($$('Native'), 'Wrapper'));
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Record');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
          
          $def(self, '$type', function $$type() {
            var self = this;

            
            switch (self["native"].type) {
              case "attributes":
                return "attribute"
              case "childList":
                return "tree"
              case "characterData":
                return "cdata"
              default:
                return nil
            }
          }, 0);
          
          $def(self, '$attribute?', function $Record_attribute$ques$2() {
            var self = this;

            return self.$type()['$==']("attribute")
          }, 0);
          
          $def(self, '$tree?', function $Record_tree$ques$3() {
            var self = this;

            return self.$type()['$==']("tree")
          }, 0);
          
          $def(self, '$cdata?', function $Record_cdata$ques$4() {
            var self = this;

            return self.$type()['$==']("cdata")
          }, 0);
          
          $def(self, '$added', function $$added() {
            var self = this, array = nil;

            
            array = ($truthy(self["native"].addedNodes != null) ? ($$$($$('Native'), 'Array').$new(self["native"].addedNodes)) : ([]));
            return $$('NodeSet')['$[]'](array);
          }, 0);
          
          $def(self, '$removed', function $$removed() {
            var self = this, array = nil;

            
            array = ($truthy(self["native"].removedNodes != null) ? ($$$($$('Native'), 'Array').$new(self["native"].removedNodes)) : ([]));
            return $$('NodeSet')['$[]'](array);
          }, 0);
          
          $def(self, '$target', function $$target() {
            var self = this;

            return self.$DOM(self["native"].target)
          }, 0);
          self.$alias_native("old", "oldValue");
          self.$alias_native("name", "attributeName");
          return self.$alias_native("namespace", "attributeNamespace");
        })($nesting[0], null, $nesting);
        
        $def(self, '$initialize', function $$initialize() {
          var block = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          ;
          
      var func = function(records) {
        return block.$call($send((records), 'map', [], function $$5(r){
            
            if (r == null) r = nil;
            return $$$($$$($$$($$('Browser'), 'DOM'), 'MutationObserver'), 'Record').$new(r);}, 1));
      }
    ;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new window.MutationObserver(func)], null);
        }, 0);
        
        $def(self, '$observe', function $$observe(target, options) {
          var self = this;

          
          if (options == null) options = nil;
          if (!$truthy(options)) {
            options = $hash2(["children", "tree", "attributes", "cdata"], {"children": true, "tree": true, "attributes": "old", "cdata": "old"})
          };
          self["native"].observe($$('Native').$convert(target), self.$convert(options));
          return self;
        }, -2);
        
        $def(self, '$take', function $$take() {
          var self = this;

          return $send((self["native"].takeRecords()), 'map', [], function $$6(r){
            
            if (r == null) r = nil;
            return $$('Record').$new(r);}, 1)
        }, 0);
        
        $def(self, '$disconnect', function $$disconnect() {
          var self = this;

          return self["native"].disconnect()
        }, 0);
        self.$private();
        return $def(self, '$convert', function $$convert(hash) {
          var self = this, options = nil, attrs = nil, filter = nil, cdata = nil;

          
          options = self.$Native({});
          if ($truthy(hash['$[]']("children"))) {
            options['$[]=']("childList", true)
          };
          if ($truthy(hash['$[]']("tree"))) {
            options['$[]=']("subtree", true)
          };
          if ($truthy((attrs = hash['$[]']("attributes")))) {
            
            options['$[]=']("attributes", true);
            if ($eqeq(attrs, "old")) {
              options['$[]=']("attributeOldValue", true)
            };
          };
          if ($truthy((filter = hash['$[]']("filter")))) {
            options['$[]=']("attributeFilter", filter)
          };
          if ($truthy((cdata = hash['$[]']("cdata")))) {
            
            options['$[]=']("characterData", true);
            if ($eqeq(cdata, "old")) {
              options['$[]=']("characterDataOldValue", true)
            };
          };
          return options.$to_n();
        }, 1);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/setup/large"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("browser/setup/mini");
  self.$require("browser/effects");
  self.$require("browser/http");
  self.$require("browser/delay");
  self.$require("browser/interval");
  self.$require("browser/immediate");
  self.$require("browser/storage");
  self.$require("browser/blob");
  self.$require("browser/animation_frame");
  self.$require("browser/socket");
  self.$require("browser/history");
  return self.$require("browser/navigator");
};

Opal.modules["browser/canvas/data"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('allocate,instance_eval,to_a,to_n,include,attr_reader,length');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Data');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.canvas = $proto["native"] = nil;
        
        $defs(self, '$create', function $$create(canvas, width, height) {
          var self = this, data = nil;

          
          data = self.$allocate();
          $send(data, 'instance_eval', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            
            self.canvas = canvas.$to_a();
            self.x = 0;
            self.y = 0;
            self.width = width;
            self.height = height;
            return (self["native"] = canvas.$to_n().createImageData(width, height));}, {$$arity: 0, $$s: self});
          return data;
        }, 3);
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$attr_reader("x", "y", "width", "height");
        
        $def(self, '$initialize', function $$initialize(canvas, x, y, width, height) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          self.canvas = canvas.$to_n();
          self.x = x;
          self.y = y;
          self.width = width;
          self.height = height;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.canvas.getImageData(x, y, width, height)], null);
        }, 5);
        
        $def(self, '$length', function $$length() {
          var self = this;

          return self["native"].data.length
        }, 0);
        
        $def(self, '$[]', function $Data_$$$2(index) {
          var self = this;

          return self["native"].data[index]
        }, 1);
        
        $def(self, '$[]=', function $Data_$$$eq$3(index, value) {
          var self = this;

          return self["native"].data[index] = value
        }, 2);
        
        $def(self, '$save', function $$save(x, y) {
          var self = this, $ret_or_1 = nil;

          
          if (x == null) x = nil;
          if (y == null) y = nil;
          x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
          y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
          return self.canvas.putImageData(self["native"], x, y);
        }, -1);
        
        $def(self, '$save_to', function $$save_to(canvas, x, y) {
          var self = this, $ret_or_1 = nil;

          
          if (x == null) x = nil;
          if (y == null) y = nil;
          x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
          y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
          return canvas.$to_n().putImageData(self["native"], x, y);
        }, -2);
        return $alias(self, "size", "length");
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/canvas/style"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,to_n,smooth,[],new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StyleObject');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.context = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$attr_reader("context");
        return $def(self, '$initialize', function $$initialize(context) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          self.context = context;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.context.$to_n()], null);
        }, 1);
      })($nesting[0], null, $nesting);
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Style');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        (function($base, $super) {
          var self = $klass($base, $super, 'Line');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$attr_reader("width", "cap", "join", "miter_limit");
          
          $def(self, '$width=', function $Line_width$eq$1(value) {
            var self = this;

            return self["native"].lineWidth = (self.width = value)
          }, 1);
          
          $def(self, '$cap=', function $Line_cap$eq$2(value) {
            var self = this;

            return self["native"].lineCap = (self.cap = value)
          }, 1);
          
          $def(self, '$join=', function $Line_join$eq$3(value) {
            var self = this;

            return self["native"].lineJoin = (self.join = value)
          }, 1);
          return $def(self, '$miter_limit=', function $Line_miter_limit$eq$4(value) {
            var self = this;

            return self["native"].miterLimit = (self.miter_limit = value)
          }, 1);
        })($nesting[0], $$('StyleObject'));
        (function($base, $super) {
          var self = $klass($base, $super, 'Text');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$attr_reader("font", "align", "baseline");
          
          $def(self, '$font=', function $Text_font$eq$5(value) {
            var self = this;

            return self["native"].font = (self.font = value)
          }, 1);
          
          $def(self, '$align=', function $Text_align$eq$6(value) {
            var self = this;

            return self["native"].textAlign = (self.align = value)
          }, 1);
          return $def(self, '$baseline=', function $Text_baseline$eq$7(value) {
            var self = this;

            return self["native"].textBaseline = (self.baseline = value)
          }, 1);
        })($nesting[0], $$('StyleObject'));
        (function($base, $super) {
          var self = $klass($base, $super, 'Image');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$attr_reader("smooth");
          $alias(self, "smooth?", "smooth");
          
          $def(self, '$smooth!', function $Image_smooth$excl$8() {
            var self = this;

            
            self["native"].mozImageSmoothingEnabled = (self.smooth = true);
            return self["native"].imageSmoothingEnabled = (self.smooth = true);
          }, 0);
          return $def(self, '$no_smooth!', function $Image_no_smooth$excl$9() {
            var self = this;

            
            self["native"].mozImageSmoothingEnabled = (self.smooth = false);
            return self["native"].imageSmoothingEnabled = (self.smooth = false);
          }, 0);
        })($nesting[0], $$('StyleObject'));
        (function($base, $super) {
          var self = $klass($base, $super, 'Shadow');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$attr_reader("offset", "blur", "color");
          
          $def(self, '$offset=', function $Shadow_offset$eq$10(value) {
            var self = this;

            
            self["native"].shadowOffsetX = value['$[]']("x");
            self["native"].shadowOffsetY = value['$[]']("y");
            return (self.offset = value);
          }, 1);
          
          $def(self, '$blur=', function $Shadow_blur$eq$11(value) {
            var self = this;

            return self["native"].shadowBlur = (self.blur = value)
          }, 1);
          return $def(self, '$color=', function $Shadow_color$eq$12(value) {
            var self = this;

            return self["native"].shadowColor = (self.color = value)
          }, 1);
        })($nesting[0], $$('StyleObject'));
        self.$attr_reader("line", "text", "image", "shadow", "fill", "stroke", "alpha", "composite_operation");
        
        $def(self, '$initialize', function $$initialize(context) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [context], null);
          self.line = $$('Line').$new(context);
          self.text = $$('Text').$new(context);
          self.image = $$('Image').$new(context);
          return (self.shadow = $$('Shadow').$new(context));
        }, 1);
        
        $def(self, '$fill=', function $Style_fill$eq$13(value) {
          var self = this;

          return self["native"].fillStyle = (self.fill = value).$to_n()
        }, 1);
        
        $def(self, '$stroke=', function $Style_stroke$eq$14(value) {
          var self = this;

          return self["native"].strokeStyle = (self.stroke = value).$to_n()
        }, 1);
        
        $def(self, '$alpha=', function $Style_alpha$eq$15(value) {
          var self = this;

          return self["native"].globalAlpha = (self.alpha = value)
        }, 1);
        return $def(self, '$composite_operation=', function $Style_composite_operation$eq$16(value) {
          var self = this;

          return self["native"].globalCompositeOperation = (self.composite_operation = value)
        }, 1);
      })($nesting[0], $$('StyleObject'), $nesting);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/builder"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $defs = Opal.defs, $klass = Opal.klass, $slice = Opal.slice, $truthy = Opal.truthy, $def = Opal.def, $hash2 = Opal.hash2, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $thrower = Opal.thrower, $const_set = Opal.const_set, $return_ivar = Opal.return_ivar, $hash = Opal.hash, $to_a = Opal.to_a, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('<<,[]=,to_h,[],each,===,call,raise,attr_reader,instance_method,new,to_proc,proc,build!,!,map,build,extend!,for,create_text,document,create_element,on,inner_html=');
  
  (function($base) {
    var self = $module($base, 'Utils');

    
    return $defs(self, '$heredoc', function $$heredoc(string) {
      
      return string
    }, 1)
  })($$('Paggio'));
  (function($base, $super) {
    var self = $klass($base, $super, 'Element');

    var $proto = self.$$prototype;

    $proto.on = nil;
    return $def(self, '$on', function $$on($a) {
      var block = $$on.$$p || nil, $post_args, args, self = this, $ret_or_1 = nil;

      $$on.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      return (self.on = ($truthy(($ret_or_1 = self.on)) ? ($ret_or_1) : ([])))['$<<']([args, block]);
    }, -1)
  })($$$($$('Paggio'), 'HTML'), $$('BasicObject'));
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Builder');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.builder = nil;
        
        $defs(self, '$to_h', function $$to_h() {
          var self = this, $ret_or_1 = nil;
          if (self.builders == null) self.builders = nil;

          return (self.builders = ($truthy(($ret_or_1 = self.builders)) ? ($ret_or_1) : ($hash2([], {}))))
        }, 0);
        $defs(self, '$for', function $Builder_for$1(klass) {
          var block = $Builder_for$1.$$p || nil, $a, self = this;

          $Builder_for$1.$$p = null;
          
          ;
          if ($truthy(block)) {
            return ($a = [klass, block], $send(self.$to_h(), '[]=', $a), $a[$a.length - 1])
          } else {
            return self.$to_h()['$[]'](klass)
          };
        }, 1);
        $defs(self, '$build', function $$build(builder, item) {try { var $t_return = $thrower('return'); 
          var self = this;

          
          $send(self.$to_h(), 'each', [], function $$2(klass, block){
            
            if (klass == null) klass = nil;
            if (block == null) block = nil;
            if ($eqeqeq(klass, item)) {
              $t_return.$throw(block.$call(builder, item))
            } else {
              return nil
            };}, {$$arity: 2, $$ret: $t_return});
          return self.$raise($$('ArgumentError'), "cannot build unknown item " + (item));} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          }
        }, 2);
        self.$attr_reader("document", "element");
        $const_set($nesting[0], 'NEW_PAGGIO', (function() { try {
          return $$$($$('Paggio'), 'HTML').$instance_method("build!")
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return false
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }})());
        
        $def(self, '$initialize', function $$initialize(document, builder) {
          var block = $$initialize.$$p || nil, self = this, build = nil;

          $$initialize.$$p = null;
          
          ;
          if (builder == null) builder = nil;
          self.document = document;
          if ($truthy($$('NEW_PAGGIO'))) {
            
            self.builder = $send($$$($$('Paggio'), 'HTML'), 'new', [$hash2(["defer"], {"defer": true})], block.$to_proc());
            build = $send(self, 'proc', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
              if (self.builder == null) self.builder = nil;

              
              self.builder['$build!']($hash2(["force_call"], {"force_call": builder['$!']()['$!']()}));
              return (self.roots = $send(self.builder.$each(), 'map', [], function $$4(e){var self = $$4.$$s == null ? this : $$4.$$s;

                
                if (e == null) e = nil;
                return $$('Builder').$build(self, e);}, {$$arity: 1, $$s: self}));}, {$$arity: 0, $$s: self});
            if ($truthy(builder)) {
              return $send(builder, 'extend!', [self.builder], build.$to_proc())
            } else {
              return build.$call()
            };
          } else {
            
            self.builder = $send($$$($$('Paggio'), 'HTML'), 'new', [], block.$to_proc());
            return (self.roots = $send(self.builder.$each(), 'map', [], function $$5(e){var self = $$5.$$s == null ? this : $$5.$$s;

              
              if (e == null) e = nil;
              return $$('Builder').$build(self, e);}, {$$arity: 1, $$s: self}));
          };
        }, -2);
        return $def(self, '$to_a', $return_ivar("roots"), 0);
      })($nesting[0], null, $nesting);
      $send($$('Builder'), 'for', [$$('String')], function $DOM$6(b, item){
        
        if (b == null) b = nil;
        if (item == null) item = nil;
        return b.$document().$create_text(item);}, 2);
      $send($$('Builder'), 'for', [$$$($$$($$('Paggio'), 'HTML'), 'Element')], function $DOM$7(b, item){var options = nil, dom = nil, on = nil, inner = nil;

        
        if (b == null) b = nil;
        if (item == null) item = nil;
        options = $hash2([], {});
        if ($eqeqeq($$('Hash'), item.attributes)) {
          options['$[]=']("attrs", item.attributes)
        };
        options['$[]=']("classes", item.class_names);
        dom = b.$document().$create_element(item.name, Opal.to_hash(options));
        if ($truthy((on = item.on || nil))) {
          $send(on, 'each', [], function $$8(args, block){
            
            if (args == null) args = nil;
            if (block == null) block = nil;
            return $send(dom, 'on', $to_a(args), block.$to_proc());}, 2)
        };
        if ($truthy((inner = item.inner_html || nil))) {
          dom['$inner_html='](inner)
        } else {
          $send(item, 'each', [], function $$9(child){
            
            if (child == null) child = nil;
            return dom['$<<']($$('Builder').$build(b, child));}, 1)
        };
        return dom;}, 2);
      return $send($$('Builder'), 'for', [$$$($$('DOM'), 'Node')], function $DOM$10(b, item){
        
        if (b == null) b = nil;
        if (item == null) item = nil;
        return item;}, 2);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/animation_frame"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('any?,supports?,to_n,request,raise,new,to_proc');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AnimationFrame');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = $proto.id = nil;
      
      $defs(self, '$supported?', function $AnimationFrame_supported$ques$1() {
        
        return $send(["Animation.request", "Animation.request (Chrome)", "Animation.request (Firefox)", "Animation.request (Opera)", "Animation.request (Internet Explorer)"], 'any?', [], function $$2(feature){
          
          if (feature == null) feature = nil;
          return $$('Browser')['$supports?'](feature);}, 1)
      }, 0);
      
      $def(self, '$initialize', function $$initialize(window) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.window = window;
        self["native"] = window.$to_n();
        return (self.id = self.$request(block));
      }, 1);
      if ($truthy($$('Browser')['$supports?']("Animation.request"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].requestAnimationFrame(block.$to_n())
        }, 1)
      } else if ($truthy($$('Browser')['$supports?']("Animation.request (Chrome)"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].webkitRequestAnimationFrame(block.$to_n())
        }, 1)
      } else if ($truthy($$('Browser')['$supports?']("Animation.request (Firefox)"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].mozRequestAnimationFrame(block.$to_n())
        }, 1)
      } else if ($truthy($$('Browser')['$supports?']("Animation.request (Opera)"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].oRequestAnimationFrame(block.$to_n())
        }, 1)
      } else if ($truthy($$('Browser')['$supports?']("Animation.request (Internet Explorer)"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].msRequestAnimationFrame(block.$to_n())
        }, 1)
      } else {
        
        $def(self, '$request', function $$request() {
          var self = this;

          return self.$raise($$('NotImplementedError'), "window requestAnimationFrame unsupported")
        }, 0)
      };
      if ($truthy($$('Browser')['$supports?']("Animation.cancel"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].cancelAnimationFrame(self.id)
        }, 0)
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancel (Chrome)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].webkitCancelAnimationFrame(self.id)
        }, 0)
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancelRequest (Chrome)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].webkitCancelRequestAnimationFrame(self.id)
        }, 0)
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancel (Firefox)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].mozCancelAnimationFrame(self.id)
        }, 0)
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancelRequest (Firefox)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].mozCancelRequestAnimationFrame(self.id)
        }, 0)
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancel (Opera)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].oCancelAnimationFrame(self.id)
        }, 0)
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancelRequest (Opera)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].oCancelRequestAnimationFrame(self.id)
        }, 0)
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancel (Internet Explorer)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].msCancelAnimationFrame(self.id)
        }, 0)
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancelRequest (Internet Explorer)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].msCancelRequestAnimationFrame(self.id)
        }, 0)
      } else {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self.$raise($$('NotImplementedError'), "window cancelAnimationFrame unsupported")
        }, 0)
      };
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$animation_frame', function $$animation_frame() {
      var block = $$animation_frame.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $$animation_frame.$$p = null;
      
      ;
      return $send($$$($$('Browser'), 'AnimationFrame'), 'new', [$gvars.window], block.$to_proc());
    }, 0)
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$animation_frame', function $$animation_frame() {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($$$($$('Browser'), 'AnimationFrame'), 'new', [$gvars.window], self.$to_proc())
    }, 0)
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/interval"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $return_ivar = Opal.return_ivar, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,convert,nil?,stopped?,aborted?,raise,call,tap,new,to_proc,every,every!');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Interval');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.id = $proto.window = $proto.block = $proto.every = nil;
      
      self.$attr_reader("every");
      
      $def(self, '$initialize', function $$initialize(window, time) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.window = $$('Native').$convert(window);
        self.every = time;
        self.block = block;
        return (self.aborted = false);
      }, 2);
      
      $def(self, '$stopped?', function $Interval_stopped$ques$1() {
        var self = this;

        return self.id['$nil?']()
      }, 0);
      
      $def(self, '$aborted?', $return_ivar("aborted"), 0);
      
      $def(self, '$abort', function $$abort() {
        var self = this;

        
        self.window.clearInterval(self.id);
        self.aborted = true;
        return (self.id = nil);
      }, 0);
      
      $def(self, '$stop', function $$stop() {
        var self = this;

        
        if ($truthy(self['$stopped?']())) {
          return nil
        };
        self.window.clearInterval(self.id);
        self.stopped = true;
        return (self.id = nil);
      }, 0);
      
      $def(self, '$start', function $$start() {
        var self = this;

        
        if ($truthy(self['$aborted?']())) {
          self.$raise("the interval has been aborted")
        };
        if (!$truthy(self['$stopped?']())) {
          return nil
        };
        return (self.id = self.window.setInterval(self.block, self.every * 1000));
      }, 0);
      return $def(self, '$call', function $$call() {
        var self = this;

        return self.block.$call()
      }, 0);
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      
      $def(self, '$every', function $$every(time) {
        var block = $$every.$$p || nil, self = this;

        $$every.$$p = null;
        
        ;
        return $send($send($$('Interval'), 'new', [self["native"], time], block.$to_proc()), 'tap', [], "start".$to_proc());
      }, 1);
      return $def(self, '$every!', function $Window_every$excl$2(time) {
        var block = $Window_every$excl$2.$$p || nil, self = this;

        $Window_every$excl$2.$$p = null;
        
        ;
        return $send($$('Interval'), 'new', [self["native"], time], block.$to_proc());
      }, 1);
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$every', function $$every(time) {
      var block = $$every.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $$every.$$p = null;
      
      ;
      return $send($gvars.window, 'every', [time], block.$to_proc());
    }, 1);
    return $def(self, '$every!', function $Kernel_every$excl$3(time) {
      var block = $Kernel_every$excl$3.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $Kernel_every$excl$3.$$p = null;
      
      ;
      return $send($gvars.window, 'every!', [time], block.$to_proc());
    }, 1);
  })($nesting[0]);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    
    $def(self, '$every', function $$every(time) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($gvars.window, 'every', [time], self.$to_proc())
    }, 1);
    return $def(self, '$every!', function $Proc_every$excl$4(time) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($gvars.window, 'every!', [time], self.$to_proc())
    }, 1);
  })($nesting[0], null);
};

Opal.modules["browser/event/all"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("browser/event/focus");
  self.$require("browser/event/wheel");
  self.$require("browser/event/data_transfer");
  self.$require("browser/event/composition");
  self.$require("browser/event/animation");
  self.$require("browser/event/audio_processing");
  self.$require("browser/event/before_unload");
  self.$require("browser/event/composition");
  self.$require("browser/event/clipboard");
  self.$require("browser/event/device_light");
  self.$require("browser/event/device_motion");
  self.$require("browser/event/device_orientation");
  self.$require("browser/event/device_proximity");
  self.$require("browser/event/drag");
  self.$require("browser/event/gamepad");
  self.$require("browser/event/hash_change");
  self.$require("browser/event/progress");
  self.$require("browser/event/page_transition");
  self.$require("browser/event/pop_state");
  self.$require("browser/event/storage");
  self.$require("browser/event/touch");
  self.$require("browser/event/sensor");
  self.$require("browser/event/message");
  return self.$require("browser/event/close");
};

Opal.modules["browser/delay"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,convert,to_n,tap,new,to_proc,start,resolve,after,after!,resolve_after');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Delay');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.window = $proto.id = $proto.block = $proto.after = nil;
      
      self.$attr_reader("after");
      
      $def(self, '$initialize', function $$initialize(window, time) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.window = $$('Native').$convert(window);
        self.after = time;
        return (self.block = block);
      }, 2);
      
      $def(self, '$abort', function $$abort() {
        var self = this;

        return self.window.clearTimeout(self.id)
      }, 0);
      return $def(self, '$start', function $$start() {
        var self = this;

        return (self.id = self.window.setTimeout(self.block.$to_n(), self.after * 1000))
      }, 0);
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      
      $def(self, '$after', function $$after(time) {
        var block = $$after.$$p || nil, self = this;

        $$after.$$p = null;
        
        ;
        return $send($send($$('Delay'), 'new', [self["native"], time], block.$to_proc()), 'tap', [], "start".$to_proc());
      }, 1);
      
      $def(self, '$after!', function $Window_after$excl$1(time) {
        var block = $Window_after$excl$1.$$p || nil, self = this;

        $Window_after$excl$1.$$p = null;
        
        ;
        return $send($$('Delay'), 'new', [self["native"], time], block.$to_proc());
      }, 1);
      return $def(self, '$resolve_after', function $$resolve_after(time) {
        var self = this, promise = nil;

        
        promise = $$('Promise').$new();
        $send($$('Delay'), 'new', [self["native"], time], function $$2(){
          return promise.$resolve()}, 0).$start();
        return promise;
      }, 1);
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$after', function $$after(time) {
      var block = $$after.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $$after.$$p = null;
      
      ;
      return $send($gvars.window, 'after', [time], block.$to_proc());
    }, 1);
    
    $def(self, '$after!', function $Kernel_after$excl$3(time) {
      var block = $Kernel_after$excl$3.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $Kernel_after$excl$3.$$p = null;
      
      ;
      return $send($gvars.window, 'after!', [time], block.$to_proc());
    }, 1);
    return $def(self, '$resolve_after', function $$resolve_after(time) {
            if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$resolve_after(time)
    }, 1);
  })($nesting[0]);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    
    $def(self, '$after', function $$after(time) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($gvars.window, 'after', [time], self.$to_proc())
    }, 1);
    return $def(self, '$after!', function $Proc_after$excl$4(time) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($gvars.window, 'after!', [time], self.$to_proc())
    }, 1);
  })($nesting[0], null);
};

Opal.modules["browser/history"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $gvars = Opal.gvars, $truthy = Opal.truthy, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,supports?,include,alias_native,to_n,full_path,location,raise,new');
  
  self.$require("browser/location");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'History');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      $defs(self, '$supported?', function $History_supported$ques$1() {
        
        return $$('Browser')['$supports?']("History")
      }, 0);
      self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
      self.$alias_native("length");
      
      $def(self, '$back', function $$back(number) {
        var self = this;

        
        if (number == null) number = 1;
        return self["native"].go(-number);
      }, -1);
      
      $def(self, '$forward', function $$forward(number) {
        var self = this;

        
        if (number == null) number = 1;
        return self["native"].go(number);
      }, -1);
      
      $def(self, '$push', function $$push(item, data) {
        var self = this;

        
        if (data == null) data = nil;
        return self["native"].pushState(data.$to_n(), null, item);
      }, -2);
      
      $def(self, '$replace', function $$replace(item, data) {
        var self = this;

        
        if (data == null) data = nil;
        return self["native"].replaceState(data.$to_n(), null, item);
      }, -2);
      
      $def(self, '$current', function $$current() {
                if ($gvars.window == null) $gvars.window = nil;

        return $gvars.window.$location().$full_path()
      }, 0);
      if ($truthy($$('Browser')['$supports?']("History.state"))) {
        return $def(self, '$state', function $$state() {
          var self = this;

          
        var state = self["native"].state;

        if (state == null) {
          return nil;
        }
        else {
          return state;
        }
      
        }, 0)
      } else {
        return $def(self, '$state', function $$state() {
          var self = this;

          return self.$raise($$('NotImplementedError'), "history state unsupported")
        }, 0)
      };
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      return $def(self, '$history', function $$history() {
        var self = this;

        if ($truthy(self["native"].history)) {
          return $$('History').$new(self["native"].history)
        } else {
          return nil
        }
      }, 0)
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["browser/setup/mini"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("browser/setup/base");
  self.$require("browser/event");
  self.$require("browser/window");
  self.$require("browser/dom");
  return self.$require("browser/css");
};

Opal.modules["browser/socket"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeq = Opal.eqeq, $def = Opal.def, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('supports?,include,target,is_a?,new,native?,to_s,to_n,==,arity,instance_exec,to_proc,call,alias_native,split,state,write');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Socket');

      var $a, $b, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      $defs(self, '$supported?', function $Socket_supported$ques$1() {
        
        return $$('Browser')['$supports?']("WebSocket")
      }, 0);
      self.$include($$$($$('Native'), 'Wrapper'));
      if ($truthy((($b = $$('IO', 'skip_raise')) && ($a = $$$($b, 'Writable', 'skip_raise')) ? 'constant' : nil))) {
        self.$include($$$($$('IO'), 'Writable'))
      };
      self.$include($$$($$('Event'), 'Target'));
      $send(self, 'target', [], function $Socket$2(value){
        
        if (value == null) value = nil;
        if ($truthy($$('Native')['$is_a?'](value, window.WebSocket))) {
          return $$('Socket').$new(value)
        } else {
          return nil
        };}, 1);
      
      $def(self, '$initialize', function $$initialize(url, protocol) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        if (protocol == null) protocol = nil;
        if ($truthy(self['$native?'](url))) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [url], null)
        } else if ($truthy(protocol)) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new window.WebSocket(url.$to_s(), protocol.$to_n())], null)
        } else {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new window.WebSocket(url.$to_s())], null)
        };
        if ($truthy(block)) {
          if ($eqeq(block.$arity(), 0)) {
            return $send(self, 'instance_exec', [], block.$to_proc())
          } else {
            return block.$call(self)
          }
        } else {
          return nil
        };
      }, -2);
      self.$alias_native("protocol");
      self.$alias_native("url");
      self.$alias_native("buffered", "bufferedAmount");
      
      $def(self, '$type', function $$type() {
        var self = this;

        
      switch (self["native"].binaryType) {
        case "blob":
          return "blob";

        case "arraybuffer":
          return "buffer";

        default:
          return "string";
      }
    
      }, 0);
      
      $def(self, '$state', function $$state() {
        var self = this;

        
      switch (self["native"].readyState) {
        case window.WebSocket.CONNECTING:
          return "connecting";

        case window.WebSocket.OPEN:
          return "open";

        case window.WebSocket.CLOSING:
          return "closing";

        case window.WebSocket.CLOSED:
          return "closed";
      }
    
      }, 0);
      
      $def(self, '$extensions', function $$extensions() {
        var self = this;

        return (self["native"].extensions).$split(/\s*,\s*/)
      }, 0);
      
      $def(self, '$alive?', function $Socket_alive$ques$3() {
        var self = this;

        return self.$state()['$==']("open")
      }, 0);
      
      $def(self, '$write', function $$write(data) {
        var self = this;

        return self["native"].send(data.$to_n())
      }, 1);
      $alias(self, "<<", "write");
      $alias(self, "send", "write");
      return $def(self, '$close', function $$close(code, reason) {
        var self = this;

        
        if (code == null) code = nil;
        if (reason == null) reason = nil;
        return self["native"].close(code.$to_n(), reason.$to_n());
      }, -1);
    })($nesting[0], $$('IO'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/touch"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native,==,downcase,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Touch');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("touchcancel", "touchend", "touchleave", "touchmove", "touchstart");
        $defs(self, '$supported?', function $Touch_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Touch")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$alt!', function $Definition_alt$excl$2() {
            var self = this;

            return self["native"].altKey = true
          }, 0);
          
          $def(self, '$ctrl!', function $Definition_ctrl$excl$3() {
            var self = this;

            return self["native"].ctrlKey = true
          }, 0);
          
          $def(self, '$meta!', function $Definition_meta$excl$4() {
            var self = this;

            return self["native"].metaKey = true
          }, 0);
          return $def(self, '$shift!', function $Definition_shift$excl$5() {
            var self = this;

            return self["native"].shiftKey = true
          }, 0);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new TouchEvent(name, desc)
            }, 2)
          }
        };
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        
        $def(self, '$cancel?', function $Touch_cancel$ques$6() {
          var self = this;

          return self.$name().$downcase()['$==']("touchcancel")
        }, 0);
        
        $def(self, '$end?', function $Touch_end$ques$7() {
          var self = this;

          return self.$name().$downcase()['$==']("touchend")
        }, 0);
        
        $def(self, '$leave?', function $Touch_leave$ques$8() {
          var self = this;

          return self.$name().$downcase()['$==']("touchleave")
        }, 0);
        
        $def(self, '$move?', function $Touch_move$ques$9() {
          var self = this;

          return self.$name().$downcase()['$==']("touchmove")
        }, 0);
        return $def(self, '$start?', function $Touch_start$ques$10() {
          var self = this;

          return self.$name().$downcase()['$==']("touchstart")
        }, 0);
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/location"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,to_s,alias_native,+,path,query,fragment,new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Location');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
      
      $def(self, '$assign', function $$assign(url) {
        var self = this;

        return self["native"].assign(url.$to_s())
      }, 1);
      
      $def(self, '$replace', function $$replace(url) {
        var self = this;

        return self["native"].replace(url.$to_s())
      }, 1);
      
      $def(self, '$reload', function $$reload(force) {
        var self = this;

        
        if (force == null) force = false;
        return self["native"].reload(force);
      }, -1);
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return self["native"].toString()
      }, 0);
      self.$alias_native("fragment", "hash");
      self.$alias_native("fragment=", "hash=");
      self.$alias_native("host");
      self.$alias_native("host=");
      self.$alias_native("uri", "href");
      self.$alias_native("uri=", "href=");
      self.$alias_native("path", "pathname");
      self.$alias_native("path=", "pathname=");
      self.$alias_native("port");
      self.$alias_native("port=");
      self.$alias_native("scheme", "protocol");
      self.$alias_native("scheme=", "protocol=");
      self.$alias_native("query", "search");
      self.$alias_native("query=", "search=");
      return $def(self, '$full_path', function $$full_path() {
        var self = this;

        return $rb_plus($rb_plus(self.$path(), self.$query()), self.$fragment())
      }, 0);
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      return $def(self, '$location', function $$location() {
        var self = this;

        if ($truthy(self["native"].location)) {
          return $$('Location').$new(self["native"].location)
        } else {
          return nil
        }
      }, 0)
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Document');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      return $def(self, '$location', function $$location() {
        var self = this;

        if ($truthy(self["native"].location)) {
          return $$('Location').$new(self["native"].location)
        } else {
          return nil
        }
      }, 0)
    })($$('DOM'), $$$($$('DOM'), 'Element'), $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["browser/storage"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $hash2 = Opal.hash2, $def = Opal.def, $return_ivar = Opal.return_ivar, $assign_ivar_val = Opal.assign_ivar_val, $truthy = Opal.truthy, $slice = Opal.slice, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $gvars = Opal.gvars, $rb_times = Opal.rb_times, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,delete,create_id,[],map,parse,attr_reader,autosave!,reload,include,enum_for,each,to_proc,__send__,[]=,autosave?,save,tap,clear,===,replace,call,raise,supports?,dump,options,cookies,*,<<,new,to_json,name,class,to_s,seek,string,to_n');
  
  self.$require("json");
  self.$require("stringio");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Storage');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.data = $proto.autosave = $proto.window = $proto.name = $proto.element = nil;
      
      $defs(self, '$json_create', function $$json_create(data) {
        
        
        data.$delete($$('JSON').$create_id());
        return $$('Hash')['$[]']($send(data, 'map', [], function $$1(key, value){
          
          if (key == null) key = nil;
          if (value == null) value = nil;
          return [$$('JSON').$parse(key), value];}, 2));
      }, 1);
      self.$attr_reader("name");
      
      $def(self, '$initialize', function $$initialize(window, name) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [], null);
        self.window = window;
        self.name = name;
        self.data = $hash2([], {});
        self['$autosave!']();
        return self.$reload();
      }, 2);
      
      $def(self, '$autosave?', $return_ivar("autosave"), 0);
      
      $def(self, '$autosave!', $assign_ivar_val("autosave", true), 0);
      
      $def(self, '$no_autosave!', $assign_ivar_val("autosave", false), 0);
      self.$include($$('Enumerable'));
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        if (!$truthy(block)) {
          return self.$enum_for("each")
        };
        $send(self.data, 'each', [], block.$to_proc());
        return self;
      }, 0);
      
      $def(self, '$method_missing', function $$method_missing($a) {
        var block = $$method_missing.$$p || nil, $post_args, args, self = this;

        $$method_missing.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        return $send(self.data, '__send__', $to_a(args), block.$to_proc());
      }, -1);
      
      $def(self, '$[]=', function $Storage_$$$eq$2(key, value) {
        var self = this;

        
        self.data['$[]='](key, value);
        if ($truthy(self['$autosave?']())) {
          return self.$save()
        } else {
          return nil
        };
      }, 2);
      
      $def(self, '$delete', function $Storage_delete$3(key) {
        var self = this;

        return $send(self.data.$delete(key), 'tap', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          if ($truthy(self['$autosave?']())) {
            return self.$save()
          } else {
            return nil
          }}, {$$arity: 0, $$s: self})
      }, 1);
      
      $def(self, '$clear', function $$clear() {
        var self = this;

        return $send(self.data.$clear(), 'tap', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

          if ($truthy(self['$autosave?']())) {
            return self.$save()
          } else {
            return nil
          }}, {$$arity: 0, $$s: self})
      }, 0);
      
      $def(self, '$replace', function $$replace(new$) {
        var self = this;

        if ($eqeqeq($$('String'), new$)) {
          return self.data.$replace($$('JSON').$parse(new$))
        } else {
          return self.data.$replace(new$)
        }
      }, 1);
      
      $def(self, '$commit', function $$commit() {
        var block = $$commit.$$p || nil, self = this, autosave = nil, result = nil;

        $$commit.$$p = null;
        
        ;
        autosave = self.autosave;
        self.autosave = false;
        result = nil;
        self.$reload();
        
        try {
        try {
          
          result = block.$call();
          self.$save();
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              
              self.$reload();
              self.$raise();
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }
        } finally {
          self.autosave = autosave
        };;
        return result;
      }, 0);
      
      $def(self, '$to_h', $return_ivar("data"), 0);
      if ($truthy($$('Browser')['$supports?']("Storage.local"))) {
        
        
        $def(self, '$reload', function $$reload() {
          var self = this;

          return self.$replace(self.window.localStorage[self.name] || '{}')
        }, 0);
        
        $def(self, '$save', function $$save() {
          var self = this;

          return self.window.localStorage[self.name] = $$('JSON').$dump(self)
        }, 0);
      } else if ($truthy($$('Browser')['$supports?']("Storage.global"))) {
        
        
        $def(self, '$reload', function $$reload() {
          var self = this;

          return self.$replace(self.window.globalStorage[self.window.location.hostname][self.name] || '{}')
        }, 0);
        
        $def(self, '$save', function $$save() {
          var self = this;

          return self.window.globalStorage[self.window.location.hostname][self.name] = $$('JSON').$dump(self)
        }, 0);
      } else if ($truthy($$('Browser')['$supports?']("Element.addBehavior"))) {
        
        
        $def(self, '$reload', function $$reload() {
          var self = this;

          
          
        self.element = self.window.document.createElement('link');
        self.element.addBehavior('#default#userData');

        self.window.document.getElementsByTagName('head')[0].appendChild(self.element);

        self.element.load(self.name);
      ;
          return self.$replace(self.element.getAttribute(self.name) || '{}');
        }, 0);
        
        $def(self, '$save', function $$save() {
          var self = this;

          
        self.element.setAttribute(self.name, $$('JSON').$dump(self));
        self.element.save(self.name);
      
        }, 0);
      } else {
        
        
        $def(self, '$reload', function $$reload() {
          var self = this;
          if ($gvars.document == null) $gvars.document = nil;

          
          $gvars.document.$cookies().$options($hash2(["expires"], {"expires": $rb_times($rb_times($rb_times(60, 60), 24), 365)}));
          return self.$replace($gvars.document.$cookies()['$[]'](self.name));
        }, 0);
        
        $def(self, '$save', function $$save() {
          var $a, self = this;
          if ($gvars.document == null) $gvars.document = nil;

          return ($a = [self.name, $$('JSON').$dump(self)], $send($gvars.document.$cookies(), '[]=', $a), $a[$a.length - 1])
        }, 0);
      };
      return $def(self, '$to_json', function $$to_json() {
        var self = this, io = nil;

        
        io = $$('StringIO').$new()['$<<']("{");
        io['$<<']($$('JSON').$create_id().$to_json())['$<<'](":")['$<<'](self.$class().$name().$to_json())['$<<'](",");
        $send(self.data, 'each', [], function $$6(key, value){
          
          if (key == null) key = nil;
          if (value == null) value = nil;
          return io['$<<'](key.$to_json().$to_s())['$<<'](":")['$<<'](value.$to_json())['$<<'](",");}, 2);
        io.$seek(-1, $$$($$('IO'), 'SEEK_CUR'));
        io['$<<']("}");
        return io.$string();
      }, 0);
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SessionStorage');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.window = $proto.name = nil;
      
      $defs(self, '$supported?', function $SessionStorage_supported$ques$7() {
        
        return $$('Browser')['$supports?']("Storage.session")
      }, 0);
      
      $def(self, '$reload', function $$reload() {
        var self = this;

        return self.$replace(self.window.sessionStorage[self.name] || '{}')
      }, 0);
      return $def(self, '$save', function $$save() {
        var self = this;

        return self.window.sessionStorage[self.name] = $$('JSON').$dump(self)
      }, 0);
    })($nesting[0], $$('Storage'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$storage', function $$storage(name) {
        var self = this;

        
        if (name == null) name = "default";
        return $$('Storage').$new(self.$to_n(), name);
      }, -1);
      return $def(self, '$session_storage', function $$session_storage(name) {
        var self = this;

        
        if (name == null) name = "default";
        return $$('SessionStorage').$new(self.$to_n(), name);
      }, -1);
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["browser/event/message"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,handles,supports?,convert,supported?,new,alias_native');
  
  self.$require("buffer");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Message');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("message");
        $defs(self, '$supported?', function $Message_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Message")
        }, 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$data=', function $Definition_data$eq$2(value) {
            var self = this;

            return self["native"].data = value
          }, 1);
          
          $def(self, '$origin=', function $Definition_origin$eq$3(value) {
            var self = this;

            return self["native"].origin = value
          }, 1);
          return $def(self, '$source=', function $Definition_source$eq$4(value) {
            var self = this;

            return self["native"].source = $$('Native').$convert(value)
          }, 1);
        })($nesting[0], $$('Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new MessageEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("MessageEvent");
            event.initMessageEvent(name, desc.bubbles, desc.cancelable,
              desc.data, desc.origin, "", desc.source || window);

        return event;
      
            }, 2)
          }
        };
        
        $def(self, '$data', function $$data() {
          var self = this;

          
      if (window.ArrayBuffer && self["native"].data instanceof ArrayBuffer) {
        return $$('Buffer').$new(self["native"].data);
      }
      else if (window.Blob && self["native"].data instanceof Blob) {
        return $$('Blob').$new(self["native"].data);
      }
      else {
        return self["native"].data;
      }
    
        }, 0);
        self.$alias_native("origin");
        return $def(self, '$source', function $$source() {
          var self = this;

          
      var source = self["native"].source;

      if (window.Window && source instanceof window.Window) {
        return $$('Window').$new(source);
      }
      else {
        return nil;
      }
    
        }, 0);
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/event/gamepad"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Gamepad');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("gamepadconnected", "gamepaddisconnected");
        $defs(self, '$supported?', function $Gamepad_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Gamepad")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$id=', function $Definition_id$eq$2(value) {
            var self = this;

            return self["native"].id = value
          }, 1);
          
          $def(self, '$index=', function $Definition_index$eq$3(value) {
            var self = this;

            return self["native"].index = value
          }, 1);
          
          $def(self, '$at=', function $Definition_at$eq$4(value) {
            var self = this;

            return self["native"].timestamp = value
          }, 1);
          
          $def(self, '$axes=', function $Definition_axes$eq$5(value) {
            var self = this;

            return self["native"].axes = value
          }, 1);
          return $def(self, '$buttons=', function $Definition_buttons$eq$6(value) {
            var self = this;

            return self["native"].buttons = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new GamepadEvent(name, {
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        gamepad:    desc })
            }, 2)
          }
        };
        
        $def(self, '$id', function $$id() {
          var self = this;

          return self["native"].gamepad.id
        }, 0);
        
        $def(self, '$index', function $$index() {
          var self = this;

          return self["native"].gamepad.index
        }, 0);
        
        $def(self, '$at', function $$at() {
          var self = this;

          return self["native"].gamepad.timestamp
        }, 0);
        
        $def(self, '$axes', function $$axes() {
          var self = this;

          return self["native"].gamepad.axes
        }, 0);
        return $def(self, '$buttons', function $$buttons() {
          var self = this;

          return self["native"].gamepad.buttons
        }, 0);
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/blob"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $rb_divide = Opal.rb_divide, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,new,convert,to_n,proc,resolve,call,create,type,respond_to?,last_modified,now,at,/');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Blob');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$('NativeCachedWrapper'));
      $defs(self, '$create', function $$create(from, options) {
        var self = this;

        
        if (options == null) options = $hash2([], {});
        return self.$new(new Blob($$('Native').$convert(from), options.$to_n()));
      }, -2);
      
      $def(self, '$size', function $$size() {
        var self = this;

        return self["native"].size
      }, 0);
      
      $def(self, '$type', function $$type() {
        var self = this;

        return self["native"].type
      }, 0);
      
      $def(self, '$text', function $$text() {
        var block = $$text.$$p || nil, self = this, promise = nil;

        $$text.$$p = null;
        
        ;
        promise = nil;
        if (!(block !== nil)) {
          
          promise = $$('Promise').$new();
          block = $send(self, 'proc', [], function $$1(i){
            
            if (i == null) i = nil;
            return promise.$resolve(i);}, 1);
        };
        self["native"].text().then(block.$to_n());
        return promise;
      }, 0);
      
      $def(self, '$buffer', function $$buffer() {
        var $yield = $$buffer.$$p || nil, self = this, promise = nil, block = nil, resblock = nil;

        $$buffer.$$p = null;
        
        promise = nil;
        if (!($yield !== nil)) {
          
          promise = $$('Promise').$new();
          block = $send(self, 'proc', [], function $$2(i){
            
            if (i == null) i = nil;
            return promise.$resolve(i);}, 1);
        };
        resblock = $send(self, 'proc', [], function $$3(i){
          
          if (i == null) i = nil;
          return block.$call($$('Buffer').$new(i));}, 1);
        self["native"].arrayBuffer().then(resblock.$to_n());
        return promise;
      }, 0);
      
      $def(self, '$slice', function $$slice(start, finish) {
        var self = this;

        
        if (finish == null) finish = nil;
        return $$('Blob').$new(self["native"].slice(start, finish));
      }, -2);
      
      $def(self, '$to_url', function $$to_url(window) {
        var self = this;
        if ($gvars.window == null) $gvars.window = nil;

        
        if (window == null) window = $gvars.window;
        return window.$to_n().URL.createObjectURL(self["native"]);
      }, -1);
      return $def(self, '$rename', function $$rename(new_filename) {
        var self = this;

        return $$('File').$create([self], new_filename, $hash2(["type", "lastModified"], {"type": self.$type(), "lastModified": ($truthy(self['$respond_to?']("last_modified")) ? (self.$last_modified()) : ($$('Time').$now()))}))
      }, 1);
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'File');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      $defs(self, '$create', function $$create(from, name, options) {
        var self = this;

        
        if (options == null) options = $hash2([], {});
        return self.$new(new File($$('Native').$convert(from), name, options.$to_n()));
      }, -3);
      
      $def(self, '$last_modified', function $$last_modified() {
        var self = this;

        return $$('Time').$at($rb_divide(self["native"].lastModified, 1000.0))
      }, 0);
      return $def(self, '$name', function $$name() {
        var self = this;

        return self["native"].name
      }, 0);
    })($nesting[0], $$('Blob'), $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/close"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Close');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("close");
        $defs(self, '$supported?', function $Close_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Close")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$code=', function $Definition_code$eq$2(value) {
            var self = this;

            return self["native"].code = value
          }, 1);
          
          $def(self, '$reason=', function $Definition_reason$eq$3(value) {
            var self = this;

            return self["native"].reason = value
          }, 1);
          
          $def(self, '$clean!', function $Definition_clean$excl$4(value) {
            var self = this;

            return self["native"].wasClean = true
          }, 1);
          return $def(self, '$not_clean!', function $Definition_not_clean$excl$5(value) {
            var self = this;

            return self["native"].wasClean = false
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new CloseEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("CloseEvent");
            event.initCloseEvent(name, desc.bubbles, desc.cancelable,
              desc.wasClean, desc.code, desc.reason);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("code");
        self.$alias_native("reason");
        return self.$alias_native("clean?", "wasClean");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $hash2 = Opal.hash2, $slice = Opal.slice, $to_a = Opal.to_a, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,options,to_proc,to_s,format,new,tap,each');
  
  self.$require("paggio/utils");
  self.$require("paggio/html");
  self.$require("paggio/css");
  self.$require("paggio/formatter");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$options', function $$options(options) {
      var block = $$options.$$p || nil;

      $$options.$$p = null;
      
      ;
      return $send($$('Formatter'), 'options', [options], block.$to_proc());
    }, 1);
    $defs(self, '$indent', function $$indent(options) {
      var block = $$indent.$$p || nil, self = this;

      $$indent.$$p = null;
      
      ;
      return $send(self, 'options', [$hash2(["indent"], {"indent": options})], block.$to_proc());
    }, 1);
    $defs(self, '$css', function $$css($a) {
      var block = $$css.$$p || nil, $post_args, args;

      $$css.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $$('Formatter').$new().$format($send($$('CSS'), 'new', $to_a(args), block.$to_proc())).$to_s();
    }, -1);
    $defs(self, '$html', function $$html($a) {
      var block = $$html.$$p || nil, $post_args, args;

      $$html.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $$('Formatter').$new().$format($send($$('HTML'), 'new', $to_a(args), block.$to_proc())).$to_s();
    }, -1);
    return $defs(self, '$html!', function $Paggio_html$excl$1() {
      var block = $Paggio_html$excl$1.$$p || nil;

      $Paggio_html$excl$1.$$p = null;
      
      ;
      return $send($$('Formatter').$new(), 'tap', [], function $$2(f){
        
        if (f == null) f = nil;
        return $send($send($$('HTML'), 'new', [], block.$to_proc()), 'each', [], function $$3(root){
          
          if (root == null) root = nil;
          return f.$format(root);}, 1);}, 1).$to_s();
    }, 0);
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/http"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $truthy = Opal.truthy, $defs = Opal.defs, $send = Opal.send, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,supports?,tap,new,send,open,to_proc,on,resolve,reject,send!');
  
  self.$require("browser/http/binary");
  self.$require("browser/http/headers");
  self.$require("browser/http/request");
  self.$require("browser/http/response");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$supported?', function $HTTP_supported$ques$1() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$('Browser')['$supports?']("XHR")))) {
          return $ret_or_1
        } else {
          return $$('Browser')['$supports?']("ActiveXObject")
        }
      }, 0);
      $defs(self, '$send', function $$send(method, url, data) {
        var block = $$send.$$p || nil;

        $$send.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send($$('Promise').$new(), 'tap', [], function $$2(promise){
          
          if (promise == null) promise = nil;
          return $send($send($$('Request'), 'new', [], block.$to_proc()), 'tap', [], function $$3(req){
            
            if (req == null) req = nil;
            $send(req, 'on', ["success"], function $$4(res){
              
              if (res == null) res = nil;
              return promise.$resolve(res);}, 1);
            return $send(req, 'on', ["failure"], function $$5(res){
              
              if (res == null) res = nil;
              return promise.$reject(res);}, 1);}, 1).$open(method, url).$send(data);}, 1);
      }, -3);
      $defs(self, '$get', function $$get(url) {
        var block = $$get.$$p || nil, self = this;

        $$get.$$p = null;
        
        ;
        return $send(self, 'send', ["get", url], block.$to_proc());
      }, 1);
      $defs(self, '$head', function $$head(url) {
        var block = $$head.$$p || nil, self = this;

        $$head.$$p = null;
        
        ;
        return $send(self, 'send', ["head", url], block.$to_proc());
      }, 1);
      $defs(self, '$post', function $$post(url, data) {
        var block = $$post.$$p || nil, self = this;

        $$post.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send', ["post", url, data], block.$to_proc());
      }, -2);
      $defs(self, '$put', function $$put(url, data) {
        var block = $$put.$$p || nil, self = this;

        $$put.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send', ["put", url, data], block.$to_proc());
      }, -2);
      $defs(self, '$delete', function $HTTP_delete$6(url, data) {
        var block = $HTTP_delete$6.$$p || nil, self = this;

        $HTTP_delete$6.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send', ["delete", url, data], block.$to_proc());
      }, -2);
      $defs(self, '$send!', function $HTTP_send$excl$7(method, url, data) {
        var block = $HTTP_send$excl$7.$$p || nil;

        $HTTP_send$excl$7.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send($$('Request'), 'new', [], block.$to_proc()).$open(method, url, false).$send(data);
      }, -3);
      $defs(self, '$get!', function $HTTP_get$excl$8(url) {
        var block = $HTTP_get$excl$8.$$p || nil, self = this;

        $HTTP_get$excl$8.$$p = null;
        
        ;
        return $send(self, 'send!', ["get", url], block.$to_proc());
      }, 1);
      $defs(self, '$head!', function $HTTP_head$excl$9(url) {
        var block = $HTTP_head$excl$9.$$p || nil, self = this;

        $HTTP_head$excl$9.$$p = null;
        
        ;
        return $send(self, 'send!', ["head", url], block.$to_proc());
      }, 1);
      $defs(self, '$post!', function $HTTP_post$excl$10(url, data) {
        var block = $HTTP_post$excl$10.$$p || nil, self = this;

        $HTTP_post$excl$10.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send!', ["post", url, data], block.$to_proc());
      }, -2);
      $defs(self, '$put!', function $HTTP_put$excl$11(url, data) {
        var block = $HTTP_put$excl$11.$$p || nil, self = this;

        $HTTP_put$excl$11.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send!', ["put", url, data], block.$to_proc());
      }, -2);
      return $defs(self, '$delete!', function $HTTP_delete$excl$12(url, data) {
        var block = $HTTP_delete$excl$12.$$p || nil, self = this;

        $HTTP_delete$excl$12.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send!', ["delete", url, data], block.$to_proc());
      }, -2);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/event/device_orientation"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceOrientation');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("deviceorientation");
        $defs(self, '$supported?', function $DeviceOrientation_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.DeviceOrientation")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$absolute=', function $Definition_absolute$eq$2(value) {
            var self = this;

            return self["native"].absolute = value
          }, 1);
          
          $def(self, '$alpha=', function $Definition_alpha$eq$3(value) {
            var self = this;

            return self["native"].alpha = value
          }, 1);
          
          $def(self, '$beta=', function $Definition_beta$eq$4(value) {
            var self = this;

            return self["native"].beta = value
          }, 1);
          return $def(self, '$gamma=', function $Definition_gamma$eq$5(value) {
            var self = this;

            return self["native"].gamma = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DeviceOrientationEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("DeviceOrientationEvent");
            event.initDeviceOrientationEvent(name, desc.bubbles, desc.cancelable,
              desc.alpha, desc.beta, desc.gamma, desc.absolute);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("absolute");
        self.$alias_native("alpha");
        self.$alias_native("beta");
        return self.$alias_native("gamma");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/audio_processing"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'AudioProcessing');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("audioprocess");
        $defs(self, '$supported?', function $AudioProcessing_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.AudioProcessing")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$time=', function $Definition_time$eq$2(value) {
            var self = this;

            return self["native"].playbackTime = value
          }, 1);
          
          $def(self, '$input=', function $Definition_input$eq$3(value) {
            var self = this;

            return self["native"].inputBuffer = value
          }, 1);
          return $def(self, '$output=', function $Definition_output$eq$4(value) {
            var self = this;

            return self["native"].outputBuffer = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new AudioProcessingEvent(name, desc)
            }, 2)
          }
        };
        self.$alias_native("time", "playbackTime");
        self.$alias_native("input", "inputBuffer");
        return self.$alias_native("output", "outputBuffer");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/hash_change"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'HashChange');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("hashchange");
        $defs(self, '$supported?', function $HashChange_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.HashChange")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$old=', function $Definition_old$eq$2(value) {
            var self = this;

            return self["native"].oldURL = value
          }, 1);
          return $def(self, '$new=', function $Definition_new$eq$3(value) {
            var self = this;

            return self["native"].newURL = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new HashChangeEvent(name, desc)
            }, 2)
          }
        };
        self.$alias_native("old", "oldURL");
        return self.$alias_native("new", "newURL");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/sensor"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Sensor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("compassneedscalibration", "userproximity");
        $defs(self, '$supported?', function $Sensor_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Sensor")
        }, 0);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            return $defs(self, '$construct', function $$construct(name, desc) {
              
              return new SensorEvent(name, desc)
            }, 2)
          } else {
            return nil
          }
        } else {
          return nil
        };
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/canvas/gradient"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeqeq = Opal.eqeqeq, $send = Opal.send, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,===,length,to_n,raise,instance_eval,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Gradient');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.context = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$attr_reader("context");
        
        $def(self, '$initialize', function $$initialize(context, $a) {
          var block = $$initialize.$$p || nil, $post_args, args, self = this, $ret_or_1 = nil;

          $$initialize.$$p = null;
          
          ;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          self.context = context;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [($eqeqeq(4, ($ret_or_1 = args.$length())) ? (self.context.$to_n().createLinearGradient.apply(self, args)) : ($eqeqeq(6, $ret_or_1) ? (self.context.$to_n().createRadialGradient.apply(self, args)) : (self.$raise($$('ArgumentError'), "don't know where to dispatch"))))], null);
          return $send(self, 'instance_eval', [], block.$to_proc());
        }, -2);
        return $def(self, '$add', function $$add(position, color) {
          var self = this;

          
          self.context.$to_n().addColorStop(position, color);
          return self;
        }, 2);
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/effects"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $not = Opal.not, $truthy = Opal.truthy, $send = Opal.send, $eqeq = Opal.eqeq, $ensure_kwargs = Opal.ensure_kwargs, $to_a = Opal.to_a, $slice = Opal.slice, $kwrestargs = Opal.kwrestargs, $hash = Opal.hash, $hash2 = Opal.hash2, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,DOM,[]=,style,!,nil?,!=,[],style!,visible?,hide,show,new,proc,==,resolve,then,value,animation_frame,s,animation_queue,join,compact,map,keys,each,one,call,animate,fade_out,to_proc,fade_in,height,size,px,slide_up,slide_down');
  
  self.$require("browser/animation_frame");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'Document');

        var $proto = self.$$prototype;

        $proto["native"] = nil;
        return $def(self, '$active_element', function $$active_element() {
          var self = this;

          return self.$DOM(self["native"].activeElement)
        }, 0)
      })($nesting[0], $$('Element'));
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.virtually_visible = $proto["native"] = $proto.animation_promise = nil;
        
        
        $def(self, '$show', function $$show(what) {
          var self = this;

          
          if (what == null) what = "block";
          self.$style()['$[]=']("display", what);
          return self;
        }, -1);
        
        $def(self, '$hide', function $$hide() {
          var self = this;

          
          self.$style()['$[]=']("display", "none");
          return self;
        }, 0);
        
        $def(self, '$visible?', function $Element_visible$ques$1() {
          var self = this;

          if ($not(self.virtually_visible['$nil?']())) {
            return self.virtually_visible
          } else {
            return self['$style!']()['$[]']("display")['$!=']("none")
          }
        }, 0);
        
        $def(self, '$toggle', function $$toggle(what) {
          var self = this;

          
          if (what == null) what = "block";
          if ($truthy(self['$visible?']())) {
            self.$hide()
          } else {
            self.$show(what)
          };
          return self;
        }, -1);
        
        $def(self, '$focus', function $$focus() {
          var self = this;

          
          self["native"].focus();
          return self;
        }, 0);
        
        $def(self, '$blur', function $$blur() {
          var self = this;

          
          self["native"].blur();
          return self;
        }, 0);
        
        $def(self, '$focused?', function $Element_focused$ques$2() {
          var self = this;

          return self["native"].hasFocus
        }, 0);
        
        $def(self, '$animation_queue', function $$animation_queue() {
          var block = $$animation_queue.$$p || nil, self = this, promise = nil, promise_resolve = nil, $ret_or_1 = nil;

          $$animation_queue.$$p = null;
          
          ;
          promise = $$('Promise').$new();
          promise_resolve = $send(self, 'proc', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
            if (self.animation_promise == null) self.animation_promise = nil;

            
            if ($eqeq(self.animation_promise, promise)) {
              self.animation_promise = nil
            };
            return promise.$resolve();}, {$$arity: 0, $$s: self});
          return (self.animation_promise = $send(($truthy(($ret_or_1 = self.animation_promise)) ? ($ret_or_1) : ($$('Promise').$value(true))), 'then', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            
            $send(self, 'animation_frame', [], function $$5(){
              return Opal.yield1(block, promise_resolve);}, 0);
            return promise;}, {$$arity: 0, $$s: self}));
        }, 0);
        
        $def(self, '$animate', function $$animate(properties, $kwargs) {
          var block = $$animate.$$p || nil, duration, easing, resolve, self = this;

          $$animate.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          
          duration = $kwargs.$$smap["duration"];if (duration == null) duration = (0.4).$s();
          
          easing = $kwargs.$$smap["easing"];if (easing == null) easing = "ease";
          
          resolve = $kwargs.$$smap["resolve"];if (resolve == null) resolve = false;
          $send(self, 'animation_queue', [resolve], function $$6(res){var self = $$6.$$s == null ? this : $$6.$$s, original_value = nil, promise = nil;

            
            if (res == null) res = nil;
            if ($eqeq(duration, "slow")) {
              duration = (0.6).$s()
            };
            if ($eqeq(duration, "fast")) {
              duration = (0.2).$s()
            };
            original_value = self.$style()['$[]']("transition");
            self.$style()['$[]=']("transition", [original_value].concat($to_a($send(properties.$keys(), 'map', [], function $$7(key){
              
              if (key == null) key = nil;
              return "" + (key) + " " + (duration) + " " + (easing);}, 1))).$compact().$join(", "));
            $send(properties, 'each', [], function $$8(key, value){var $a, self = $$8.$$s == null ? this : $$8.$$s;

              
              if (key == null) key = nil;
              if (value == null) value = nil;
              return ($a = [key, value], $send(self.$style(), '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
            promise = $$('Promise').$new();
            return $send(self, 'one', ["transitionend"], function $$9($a){var $post_args, args, self = $$9.$$s == null ? this : $$9.$$s;

              
              $post_args = $slice.call(arguments);
              args = $post_args;
              self.$style()['$[]=']("transition", original_value);
              if ((block !== nil)) {
                Opal.yieldX(block, $to_a(args))
              };
              return res.$call();}, {$$arity: -1, $$s: self});}, {$$arity: 1, $$s: self});
          return self;
        }, -2);
        
        $def(self, '$fade_in', function $$fade_in($kwargs) {
          var block = $$fade_in.$$p || nil, kwargs, self = this;

          $$fade_in.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          $send(self, 'animation_queue', [], function $$10(resolve){var self = $$10.$$s == null ? this : $$10.$$s;

            
            if (resolve == null) resolve = nil;
            if ($not(self['$visible?']())) {
              
              self.virtually_visible = true;
              self.$show();
              self.$style()['$[]=']("opacity", 0.0);
              $send(self, 'animate', [$hash2(["opacity"], {"opacity": 1.0}).$merge(Opal.to_hash(kwargs))], function $$11($a){var $post_args, args, self = $$11.$$s == null ? this : $$11.$$s;

                
                $post_args = $slice.call(arguments);
                args = $post_args;
                self.virtually_visible = nil;
                self.$style()['$[]=']("opacity", nil);
                if ((block !== nil)) {
                  return Opal.yieldX(block, $to_a(args));
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self});
            };
            return resolve.$call();}, {$$arity: 1, $$s: self});
          return self;
        }, -1);
        
        $def(self, '$fade_out', function $$fade_out($kwargs) {
          var block = $$fade_out.$$p || nil, kwargs, self = this;

          $$fade_out.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          $send(self, 'animation_queue', [], function $$12(resolve){var self = $$12.$$s == null ? this : $$12.$$s;

            
            if (resolve == null) resolve = nil;
            if ($truthy(self['$visible?']())) {
              
              self.virtually_visible = false;
              self.$style()['$[]=']("opacity", 1.0);
              $send(self, 'animate', [$hash2(["opacity"], {"opacity": 0.0}).$merge(Opal.to_hash(kwargs))], function $$13($a){var $post_args, args, self = $$13.$$s == null ? this : $$13.$$s;

                
                $post_args = $slice.call(arguments);
                args = $post_args;
                self.virtually_visible = nil;
                self.$style()['$[]=']("opacity", nil);
                self.$hide();
                if ((block !== nil)) {
                  return Opal.yieldX(block, $to_a(args));
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self});
            };
            return resolve.$call();}, {$$arity: 1, $$s: self});
          return self;
        }, -1);
        
        $def(self, '$fade_toggle', function $$fade_toggle($kwargs) {
          var block = $$fade_toggle.$$p || nil, kwargs, self = this;

          $$fade_toggle.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          if ($truthy(self['$visible?']())) {
            $send(self, 'fade_out', [Opal.to_hash(kwargs)], block.$to_proc())
          } else {
            $send(self, 'fade_in', [Opal.to_hash(kwargs)], block.$to_proc())
          };
          return self;
        }, -1);
        
        $def(self, '$slide_down', function $$slide_down($kwargs) {
          var block = $$slide_down.$$p || nil, kwargs, self = this;

          $$slide_down.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          $send(self, 'animation_queue', [], function $$14(resolve){var self = $$14.$$s == null ? this : $$14.$$s, height = nil, orig_height = nil;

            
            if (resolve == null) resolve = nil;
            if ($not(self['$visible?']())) {
              
              self.virtually_visible = true;
              self.$show();
              height = self.$size().$height();
              orig_height = self.$style()['$[]']("height");
              self.$style()['$[]=']("height", (0).$px());
              $send(self, 'animate', [$hash2(["height"], {"height": height.$px()}).$merge(Opal.to_hash(kwargs))], function $$15($a){var $post_args, args, self = $$15.$$s == null ? this : $$15.$$s;

                
                $post_args = $slice.call(arguments);
                args = $post_args;
                self.virtually_visible = nil;
                self.$style()['$[]=']("height", orig_height);
                if ((block !== nil)) {
                  return Opal.yieldX(block, $to_a(args));
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self});
            };
            return resolve.$call();}, {$$arity: 1, $$s: self});
          return self;
        }, -1);
        
        $def(self, '$slide_up', function $$slide_up($kwargs) {
          var block = $$slide_up.$$p || nil, kwargs, self = this;

          $$slide_up.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          $send(self, 'animation_queue', [], function $$16(resolve){var self = $$16.$$s == null ? this : $$16.$$s, orig_height = nil;

            
            if (resolve == null) resolve = nil;
            if ($truthy(self['$visible?']())) {
              
              self.virtually_visible = false;
              orig_height = self.$style()['$[]']("height");
              $send(self, 'animate', [$hash2(["height"], {"height": (0).$px()}).$merge(Opal.to_hash(kwargs))], function $$17($a){var $post_args, args, self = $$17.$$s == null ? this : $$17.$$s;

                
                $post_args = $slice.call(arguments);
                args = $post_args;
                self.virtually_visible = nil;
                self.$style()['$[]=']("height", orig_height);
                self.$hide();
                if ((block !== nil)) {
                  return Opal.yieldX(block, $to_a(args));
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self});
            };
            return resolve.$call();}, {$$arity: 1, $$s: self});
          return self;
        }, -1);
        return $def(self, '$slide_toggle', function $$slide_toggle($kwargs) {
          var block = $$slide_toggle.$$p || nil, kwargs, self = this;

          $$slide_toggle.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          if ($truthy(self['$visible?']())) {
            $send(self, 'slide_up', [Opal.to_hash(kwargs)], block.$to_proc())
          } else {
            $send(self, 'slide_down', [Opal.to_hash(kwargs)], block.$to_proc())
          };
          return self;
        }, -1);
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/event/clipboard"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native,new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Clipboard');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("copy", "cut", "paste");
        $defs(self, '$supported?', function $Clipboard_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Clipboard")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$data=', function $Definition_data$eq$2(value) {
            var self = this;

            return self["native"].data = value
          }, 1);
          return $def(self, '$type=', function $Definition_type$eq$3(value) {
            var self = this;

            return self["native"].dataType = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new ClipboardEvent(name, desc)
            }, 2)
          }
        };
        self.$alias_native("data");
        self.$alias_native("type", "dataType");
        return $def(self, '$transfer', function $$transfer() {
          var self = this;

          return $$('DataTransfer').$new(self["native"].clipboardData)
        }, 0);
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/canvas/text"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,to_n');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Text');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.context = $proto["native"] = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$attr_reader("context");
        
        $def(self, '$initialize', function $$initialize(context) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          self.context = context;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.context.$to_n()], null);
        }, 1);
        
        $def(self, '$measure', function $$measure(text) {
          var self = this;

          return self["native"].measureText(text)
        }, 1);
        
        $def(self, '$fill', function $$fill(text, x, y, max_width) {
          var self = this, $ret_or_1 = nil;

          
          if (x == null) x = nil;
          if (y == null) y = nil;
          if (max_width == null) max_width = nil;
          x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
          y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
          if ($truthy(max_width)) {
            self["native"].fillText(text, x, y, max_width)
          } else {
            self["native"].fillText(text, x, y)
          };
          return self.context;
        }, -2);
        return $def(self, '$stroke', function $$stroke(text, x, y, max_width) {
          var self = this, $ret_or_1 = nil;

          
          if (x == null) x = nil;
          if (y == null) y = nil;
          if (max_width == null) max_width = nil;
          x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
          y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
          if ($truthy(max_width)) {
            self["native"].strokeText(text, x, y, max_width)
          } else {
            self["native"].strokeText(text, x, y)
          };
          return self.context;
        }, -2);
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/wheel"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,!,nil?,[],===,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Wheel');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("wheel", "mousewheel");
        $defs(self, '$supported?', function $Wheel_supported$ques$1() {
                    if ($gvars.$ == null) $gvars.$ = nil;

          return $gvars.$['$[]']("WheelEvent")['$nil?']()['$!']()
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$x=', function $Definition_x$eq$2(value) {
            var self = this;

            return self["native"].deltaX = value
          }, 1);
          
          $def(self, '$y=', function $Definition_y$eq$3(value) {
            var self = this;

            return self["native"].deltaY = value
          }, 1);
          
          $def(self, '$z=', function $Definition_z$eq$4(value) {
            var self = this;

            return self["native"].deltaZ = value
          }, 1);
          return $def(self, '$mode=', function $Definition_mode$eq$5(value) {
            var self = this, $ret_or_1 = nil;

            
            value = ($eqeqeq("pixel", ($ret_or_1 = value)) ? (WheelEvent.DOM_DELTA_PIXEL) : ($eqeqeq("line", $ret_or_1) ? (WheelEvent.DOM_DELTA_LINE) : ($eqeqeq("page", $ret_or_1) ? (WheelEvent.DOM_DELTA_PAGE) : (nil))));
            return self["native"].deltaMode = value;
          }, 1);
        })($nesting[0], $$('Definition'));
        $defs(self, '$construct', function $$construct(name, desc) {
          
          return new WheelEvent(name, desc)
        }, 2);
        self.$alias_native("x", "deltaX");
        self.$alias_native("y", "deltaY");
        self.$alias_native("z", "deltaZ");
        return $def(self, '$mode', function $$mode() {
          var self = this, $ret_or_1 = nil;

          if ($eqeqeq(WheelEvent.DOM_DELTA_PIXEL, ($ret_or_1 = self["native"].deltaMode))) {
            return "pixel"
          } else if ($eqeqeq(WheelEvent.DOM_DELTA_LINE, $ret_or_1)) {
            return "line"
          } else if ($eqeqeq(WheelEvent.DOM_DELTA_PAGE, $ret_or_1)) {
            return "page"
          } else {
            return nil
          }
        }, 0);
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/storage"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Storage');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("storage");
        $defs(self, '$supported?', function $Storage_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Storage")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$key=', function $Definition_key$eq$2(value) {
            var self = this;

            return self["native"].key = value
          }, 1);
          
          $def(self, '$new=', function $Definition_new$eq$3(value) {
            var self = this;

            return self["native"].newValue = value
          }, 1);
          
          $def(self, '$old=', function $Definition_old$eq$4(value) {
            var self = this;

            return self["native"].oldValue = value
          }, 1);
          
          $def(self, '$area=', function $Definition_area$eq$5(value) {
            var self = this;

            return self["native"].storageArea = value
          }, 1);
          return $def(self, '$url=', function $Definition_url$eq$6(value) {
            var self = this;

            return self["native"].url = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new StorageEvent(name, desc)
            }, 2)
          }
        };
        self.$alias_native("key");
        self.$alias_native("new", "newValue");
        self.$alias_native("old", "oldValue");
        self.$alias_native("area", "storageArea");
        return self.$alias_native("url");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/drag"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,supports?,include,new,convert,supported?,alias_native,x,screen,y,DOM');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Drag');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("drag", "dragend", "dragenter", "dragexit", "dragleave", "dragover", "dragstart", "drop");
        $defs(self, '$supported?', function $Drag_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Drag")
        }, 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Client');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Client_x$eq$2(value) {
              var self = this;

              return self["native"].clientX = value
            }, 1);
            return $def(self, '$y=', function $Client_y$eq$3(value) {
              var self = this;

              return self["native"].clientY = value
            }, 1);
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Screen');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Screen_x$eq$4(value) {
              var self = this;

              return self["native"].screenX = value
            }, 1);
            return $def(self, '$y=', function $Screen_y$eq$5(value) {
              var self = this;

              return self["native"].screenY = value
            }, 1);
          })($nesting[0], null, $nesting);
          
          $def(self, '$alt!', function $Definition_alt$excl$6() {
            var self = this;

            return self["native"].altKey = true
          }, 0);
          
          $def(self, '$ctrl!', function $Definition_ctrl$excl$7() {
            var self = this;

            return self["native"].ctrlKey = true
          }, 0);
          
          $def(self, '$meta!', function $Definition_meta$excl$8() {
            var self = this;

            return self["native"].metaKey = true
          }, 0);
          
          $def(self, '$button=', function $Definition_button$eq$9(value) {
            var self = this;

            return self["native"].button = value
          }, 1);
          
          $def(self, '$client', function $$client() {
            var self = this;

            return $$('Client').$new(self["native"])
          }, 0);
          
          $def(self, '$screen', function $$screen() {
            var self = this;

            return $$('Screen').$new(self["native"])
          }, 0);
          
          $def(self, '$related=', function $Definition_related$eq$10(elem) {
            var self = this;

            return self["native"].relatedTarget = $$('Native').$convert(elem)
          }, 1);
          return $def(self, '$transfer=', function $Definition_transfer$eq$11(value) {
            var self = this;

            return self["native"].dataTransfer = $$('Native').$convert(value)
          }, 1);
        })($nesting[0], $$('Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DragEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("DragEvent");
            event.initDragEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, 0,
              desc.screenX || 0, desc.screenY || 0,
              desc.clientX || 0, desc.clientY || 0,
              desc.ctrlKey, desc.altKey, desc.shiftKey, desc.metaKey,
              desc.button || 0, desc.relatedTarget, desc.dataTransfer);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("button");
        
        $def(self, '$client', function $$client() {
          var self = this;

          return $$('Position').$new(self["native"].clientX, self["native"].clientY)
        }, 0);
        
        $def(self, '$screen', function $$screen() {
          var self = this;

          if ($truthy((typeof(self["native"].screenX) !== "undefined"))) {
            return $$('Position').$new(self["native"].screenX, self["native"].screenY)
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$x', function $$x() {
          var self = this;

          return self.$screen().$x()
        }, 0);
        
        $def(self, '$y', function $$y() {
          var self = this;

          return self.$screen().$y()
        }, 0);
        
        $def(self, '$related', function $$related() {
          var self = this;

          return self.$DOM(self["native"].relatedTarget)
        }, 0);
        return $def(self, '$transfer', function $$transfer() {
          var self = this;

          return $$('DataTransfer').$new(self["native"].dataTransfer)
        }, 0);
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/window"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs, $truthy = Opal.truthy, $gvars = Opal.gvars, $def = Opal.def, $hash2 = Opal.hash2, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,delete,join,map,===,new,include,target,supports?,[],raise,alert,prompt,confirm');
  
  self.$require("browser/window/view");
  self.$require("browser/window/size");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = $proto.parent = $proto.top = $proto.opener = $proto.view = $proto.size = $proto.scroll = nil;
      
      $defs(self, '$open', function $$open(url, options) {
        var self = this, name = nil, features = nil;

        
        name = options.$delete("name");
        features = $send(options, 'map', [], function $$1(key, value){var $ret_or_1 = nil;

          
          if (key == null) key = nil;
          if (value == null) value = nil;
          value = ($eqeqeq(true, ($ret_or_1 = value)) ? ("yes") : ($eqeqeq(false, $ret_or_1) ? ("no") : (value)));
          return "" + (key) + "=" + (value);}, 2).$join(",");
        
      var win = window.open(url, name, features);

      if (win == null) {
        return nil;
      }

      return self.$new(win);
    ;
      }, 2);
      self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
      self.$include($$$($$('Event'), 'Target'));
      $send(self, 'target', [], function $Window$2(value){        if ($gvars.window == null) $gvars.window = nil;

        
        if (value == null) value = nil;
        if ($truthy(value == window)) {
          return $gvars.window
        } else {
          return nil
        };}, 1);
      
      $def(self, '$alert', function $$alert(value) {
        var self = this;

        
        self["native"].alert(value);
        return value;
      }, 1);
      
      $def(self, '$prompt', function $$prompt(value, default$) {
        var self = this, $ret_or_1 = nil;

        
        if (default$ == null) default$ = nil;
        return self["native"].prompt(value, ($truthy(($ret_or_1 = default$)) ? ($ret_or_1) : (""))) || nil;
      }, -2);
      
      $def(self, '$confirm', function $$confirm(value) {
        var self = this;

        return self["native"].confirm(value) || false
      }, 1);
      
      $def(self, '$parent', function $$parent() {
        var self = this, $ret_or_1 = nil;

        return (self.parent = ($truthy(($ret_or_1 = self.parent)) ? ($ret_or_1) : ($$$($$('Browser'), 'Window').$new(self["native"].parent))))
      }, 0);
      
      $def(self, '$top', function $$top() {
        var self = this, $ret_or_1 = nil;

        return (self.top = ($truthy(($ret_or_1 = self.top)) ? ($ret_or_1) : ($$$($$('Browser'), 'Window').$new(self["native"].top))))
      }, 0);
      
      $def(self, '$opener', function $$opener() {
        var self = this, $ret_or_1 = nil;

        return (self.opener = ($truthy(($ret_or_1 = self.opener)) ? ($ret_or_1) : ($$$($$('Browser'), 'Window').$new(self["native"].opener))))
      }, 0);
      
      $def(self, '$view', function $$view() {
        var self = this, $ret_or_1 = nil;

        return (self.view = ($truthy(($ret_or_1 = self.view)) ? ($ret_or_1) : ($$('View').$new(self))))
      }, 0);
      
      $def(self, '$size', function $$size() {
        var self = this, $ret_or_1 = nil;

        return (self.size = ($truthy(($ret_or_1 = self.size)) ? ($ret_or_1) : ($$('Size').$new(self))))
      }, 0);
      
      $def(self, '$scroll', function $$scroll() {
        var self = this, $ret_or_1 = nil;

        return (self.scroll = ($truthy(($ret_or_1 = self.scroll)) ? ($ret_or_1) : ($$$($$$($$('DOM'), 'Element'), 'Scroll').$new(self))))
      }, 0);
      if ($truthy($$('Browser')['$supports?']("Window.send"))) {
        
        $def(self, '$send', function $$send(message, options) {
          var self = this, $ret_or_1 = nil;

          
          if (options == null) options = $hash2([], {});
          return self["native"].postMessage(message, ($truthy(($ret_or_1 = options['$[]']("to"))) ? ($ret_or_1) : ("*")));
        }, -2)
      } else {
        
        $def(self, '$send', function $$send(message, options) {
          var self = this;

          
          if (options == null) options = $hash2([], {});
          return self.$raise($$('NotImplementedError'), "message sending unsupported");
        }, -2)
      };
      return $def(self, '$close', function $$close() {
        var self = this;

        return self["native"].close()
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  $gvars.window = $$$($$('Browser'), 'Window').$new(window);
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$alert', function $$alert(value) {
            if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$alert(value)
    }, 1);
    
    $def(self, '$prompt', function $$prompt(value, default$) {
            if ($gvars.window == null) $gvars.window = nil;

      
      if (default$ == null) default$ = nil;
      return $gvars.window.$prompt(value, default$);
    }, -2);
    return $def(self, '$confirm', function $$confirm(value) {
            if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$confirm(value)
    }, 1);
  })($nesting[0]);
};

Opal.modules["browser/http/binary"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,===,to_a,include,enum_for,length,<,call,[],+,==');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Binary');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.type = $proto.data = nil;
        
        self.$attr_reader("type");
        
        $def(self, '$initialize', function $$initialize(value) {
          var self = this;

          if ($eqeqeq($$('String'), value)) {
            
            self.type = "string";
            return (self.data = value);
          } else {
            
            self.type = "buffer";
            return (self.data = value.$to_a());
          }
        }, 1);
        self.$include($$('Enumerable'));
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this, index = nil, length = nil;

          $$each.$$p = null;
          
          ;
          if (!$truthy(block)) {
            return self.$enum_for("each")
          };
          index = 0;
          length = self.$length();
          while ($truthy($rb_lt(index, length))) {
          
            block.$call(self['$[]'](index));
            index = $rb_plus(index, 1);
          };
          return self;
        }, 0);
        
        $def(self, '$[]', function $Binary_$$$1(index) {
          var self = this;

          if ($eqeq(self.type, "string")) {
            return self.data.charCodeAt(index) & 0xff
          } else {
            return self.data['$[]'](index)
          }
        }, 1);
        return $def(self, '$length', function $$length() {
          var self = this;

          return self.data.$length()
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/utils"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $module = Opal.module, $regexp = Opal.regexp, $defs = Opal.defs, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('size,min,scan,gsub,proc,===,merge,to_proc,merge!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Utils');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$heredoc', function $$heredoc(string) {
        var indent = nil;

        
        indent = (function() { try {
          return string.$scan(/^[ \t]*(?=\S)/).$min().$size()
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return 0
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }})();
        return string.$gsub($regexp(["^[ \\t]{", indent, "}"]), "");
      }, 1);
      $defs(self, '$deep_merge', function $$deep_merge(a, b) {
        var self = this, merger = nil;

        
        merger = $send(self, 'proc', [], function $$1(key, v1, v2){
          
          if (key == null) key = nil;
          if (v1 == null) v1 = nil;
          if (v2 == null) v2 = nil;
          if (($eqeqeq($$('Hash'), v1) && ($eqeqeq($$('Hash'), v2)))) {
            return $send(v1, 'merge', [v2], merger.$to_proc())
          } else {
            return v2
          };}, 3);
        return $send(a, 'merge', [b], merger.$to_proc());
      }, 2);
      return $defs(self, '$deep_merge!', function $Utils_deep_merge$excl$2(a, b) {
        var self = this, merger = nil;

        
        merger = $send(self, 'proc', [], function $$3(key, v1, v2){
          
          if (key == null) key = nil;
          if (v1 == null) v1 = nil;
          if (v2 == null) v2 = nil;
          if (($eqeqeq($$('Hash'), v1) && ($eqeqeq($$('Hash'), v2)))) {
            
            $send(v1, 'merge!', [v2], merger.$to_proc());
            return v1;
          } else {
            return v2
          };}, 3);
        return $send(a, 'merge!', [b], merger.$to_proc());
      }, 2);
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["browser/navigator"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $hash2 = Opal.hash2, $alias = Opal.alias, $truthy = Opal.truthy, $ensure_kwargs = Opal.ensure_kwargs, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,new,alias_native,split,operating_system,proc,resolve,reject,Native,to_n,call');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Navigator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
      $const_set($nesting[0], 'Version', $$('Struct').$new("major", "minor", "build"));
      $const_set($nesting[0], 'Product', $$('Struct').$new("name", "version"));
      $const_set($nesting[0], 'Vendor', $$('Struct').$new("name", "version"));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MimeType');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        
        $def(self, '$plugin', function $$plugin() {
          var self = this;

          return $$('Plugin').$new(self["native"].enabledPlugin)
        }, 0);
        self.$alias_native("description");
        
        $def(self, '$extensions', function $$extensions() {
          var self = this;

          return (self["native"].suffixes).$split(/\s*/)
        }, 0);
        return self.$alias_native("type");
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Plugin');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$initialize', function $$initialize(plugin) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [plugin], function $$1(m){
            
            if (m == null) m = nil;
            return $$('MimeType').$new(m);}, 1)
        }, 1);
        self.$alias_native("description");
        self.$alias_native("file", "filename");
        self.$alias_native("name");
        return self.$alias_native("version");
      })($nesting[0], $$$($$('Native'), 'Array'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Plugins');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        
        $def(self, '$initialize', function $$initialize(plugins) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [plugins], function $$2(p){
            
            if (p == null) p = nil;
            return $$('Plugin').$new(p);}, 1)
        }, 1);
        
        $def(self, '$refresh', function $$refresh() {
          var self = this;

          return self["native"].refresh(false)
        }, 0);
        return $def(self, '$refresh!', function $Plugins_refresh$excl$3() {
          var self = this;

          return self["native"].refresh(true)
        }, 0);
      })($nesting[0], $$$($$('Native'), 'Array'), $nesting);
      self.$alias_native("code", "appCodeName");
      self.$alias_native("name", "appName");
      
      $def(self, '$version', function $$version() {
        var self = this;

        return $$('Version').$new(self["native"].appVersion, self["native"].appMinorVersion, self["native"].buildID)
      }, 0);
      self.$alias_native("cookies?", "cookieEnabled");
      
      $def(self, '$track?', function $Navigator_track$ques$4() {
        var self = this;

        return !self["native"].doNotTrack
      }, 0);
      self.$alias_native("language");
      
      $def(self, '$mime_types', function $$mime_types() {
        var self = this;

        return $send($$$($$('Native'), 'Array'), 'new', [self["native"].mimeTypes, $hash2(["get", "named"], {"get": "item", "named": "namedItem"})], function $$5(m){
          
          if (m == null) m = nil;
          return $$('MimeType').$new(m);}, 1)
      }, 0);
      
      $def(self, '$offline?', function $Navigator_offline$ques$6() {
        var self = this;

        return !self["native"].onLine
      }, 0);
      self.$alias_native("operating_system", "oscpu");
      $alias(self, "os", "operating_system");
      self.$alias_native("platform");
      
      $def(self, '$plugins', function $$plugins() {
        var self = this;

        return $$('Plugins').$new(self["native"].plugins)
      }, 0);
      
      $def(self, '$product', function $$product() {
        var self = this;

        return $$('Product').$new(self["native"].product, self["native"].productSub)
      }, 0);
      self.$alias_native("user_agent", "userAgent");
      
      $def(self, '$vendor', function $$vendor() {
        var self = this;

        return $$('Vendor').$new(self["native"].vendor, self["native"].vendorSub)
      }, 0);
      
      $def(self, '$java?', function $Navigator_java$ques$7() {
        var self = this;

        try {
          return self["native"].javaEnabled()
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return false
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }
      }, 0);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Position');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.coords = $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Coords');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          self.$include($$$($$('Native'), 'Wrapper'));
          self.$alias_native("latitude");
          self.$alias_native("longitude");
          self.$alias_native("altitude");
          self.$alias_native("accuracy");
          self.$alias_native("altitude_accuracy", "altitudeAccuracy");
          self.$alias_native("heading");
          return self.$alias_native("speed");
        })($nesting[0], null, $nesting);
        self.$alias_native("timestamp");
        return $def(self, '$coords', function $$coords() {
          var self = this, $ret_or_1 = nil;

          return (self.coords = ($truthy(($ret_or_1 = self.coords)) ? ($ret_or_1) : ($$('Coords').$new(self["native"].coords))))
        }, 0);
      })($nesting[0], null, $nesting);
      
      $def(self, '$geolocate', function $$geolocate($kwargs) {
        var max_age, timeout, high_accuracy, self = this, promise = nil, succ = nil, fail = nil, opts = nil;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        max_age = $kwargs.$$smap["max_age"];if (max_age == null) max_age = 0;
        
        timeout = $kwargs.$$smap["timeout"];if (timeout == null) timeout = $$$($$('Float'), 'INFINITY');
        
        high_accuracy = $kwargs.$$smap["high_accuracy"];if (high_accuracy == null) high_accuracy = false;
        promise = $$('Promise').$new();
        succ = $send(self, 'proc', [], function $$8(i){
          
          if (i == null) i = nil;
          return promise.$resolve($$('Position').$new(i));}, 1);
        fail = $send(self, 'proc', [], function $$9(i){var self = $$9.$$s == null ? this : $$9.$$s;

          
          if (i == null) i = nil;
          return promise.$reject(self.$Native(i));}, {$$arity: 1, $$s: self});
        opts = $hash2(["maxAge", "timeout", "enableHighAccuracy"], {"maxAge": max_age, "timeout": timeout, "enableHighAccuracy": high_accuracy});
        self["native"].geolocation.getCurrentPosition(succ.$to_n(), fail.$to_n(), opts.$to_n());
        return promise;
      }, -1);
      
      $def(self, '$track', function $$track($kwargs) {
        var block = $$track.$$p || nil, max_age, timeout, high_accuracy, error, self = this, opts = nil, succ = nil, fail = nil;

        $$track.$$p = null;
        
        ;
        $kwargs = $ensure_kwargs($kwargs);
        
        max_age = $kwargs.$$smap["max_age"];if (max_age == null) max_age = 0;
        
        timeout = $kwargs.$$smap["timeout"];if (timeout == null) timeout = $$$($$('Float'), 'INFINITY');
        
        high_accuracy = $kwargs.$$smap["high_accuracy"];if (high_accuracy == null) high_accuracy = false;
        
        error = $kwargs.$$smap["error"];if (error == null) error = $send(self, 'proc', [], function $$10(i){
          
          if (i == null) i = nil;
          return nil;}, 1);
        opts = $hash2(["maxAge", "timeout", "enableHighAccuracy"], {"maxAge": max_age, "timeout": timeout, "enableHighAccuracy": high_accuracy});
        succ = $send(self, 'proc', [], function $$11(i){
          
          if (i == null) i = nil;
          return block.$call($$('Position').$new(i));}, 1);
        fail = $send(self, 'proc', [], function $$12(i){var self = $$12.$$s == null ? this : $$12.$$s;

          
          if (i == null) i = nil;
          return error.$call(self.$Native(i));}, {$$arity: 1, $$s: self});
        return self["native"].geolocation.watchPosition(succ.$to_n(), fail.$to_n(), opts.$to_n());
      }, -1);
      
      $def(self, '$stop_tracking', function $$stop_tracking(id) {
        var self = this;

        return self["native"].geolocation.clearWatch(id)
      }, 1);
      
      $def(self, '$vibrate', function $$vibrate(pattern) {
        var self = this;

        return self["native"].vibrate(pattern.$to_n())
      }, 1);
      
      $def(self, '$get_battery', function $$get_battery() {
        var self = this, promise = nil, yes = nil, no = nil;

        
        promise = $$('Promise').$new();
        yes = $send(self, 'proc', [], function $$13(r){var self = $$13.$$s == null ? this : $$13.$$s;

          
          if (r == null) r = nil;
          return promise.$resolve(self.$Native(r));}, {$$arity: 1, $$s: self});
        no = $send(self, 'proc', [], function $$14(r){var self = $$14.$$s == null ? this : $$14.$$s;

          
          if (r == null) r = nil;
          return promise.$reject(self.$Native(r));}, {$$arity: 1, $$s: self});
        self["native"].getBattery().then(yes.$to_n()).catch(no.$to_n());
        return promise;
      }, 0);
      return $def(self, '$send_beacon', function $$send_beacon(url, payload) {
        var self = this;

        
        if (payload == null) payload = nil;
        return self["native"].sendBeacon(url, payload.$to_n());
      }, -2);
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = $proto.navigator = nil;
      return $def(self, '$navigator', function $$navigator() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(self["native"].navigator)) {
          return (self.navigator = ($truthy(($ret_or_1 = self.navigator)) ? ($ret_or_1) : ($$('Navigator').$new(self["native"].navigator))))
        } else {
          return nil
        }
      }, 0)
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/device_light"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceLight');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("devicelight");
        $defs(self, '$supported?', function $DeviceLight_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.DeviceLight")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$value=', function $Definition_value$eq$2(value) {
            var self = this;

            return self["native"].value = value
          }, 1)
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DeviceLightEvent(name, desc)
            }, 2)
          }
        };
        return self.$alias_native("value");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/device_proximity"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceProximity');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("deviceproximity");
        $defs(self, '$supported?', function $DeviceProximity_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.DeviceProximity")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$value=', function $Definition_value$eq$2(value) {
            var self = this;

            return self["native"].value = value
          }, 1);
          
          $def(self, '$min=', function $Definition_min$eq$3(value) {
            var self = this;

            return self["native"].min = value
          }, 1);
          return $def(self, '$max=', function $Definition_max$eq$4(value) {
            var self = this;

            return self["native"].max = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DeviceProximityEvent(name, desc)
            }, 2)
          }
        };
        self.$alias_native("value");
        self.$alias_native("min");
        return self.$alias_native("max");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/css"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $slice = Opal.slice, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $gvars = Opal.gvars, $send = Opal.send, $def = Opal.def, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,>,length,pop,create_element,[]=,inner_text=,css,to_proc,join');
  
  self.$require("browser/css/declaration");
  self.$require("browser/css/style_sheet");
  self.$require("browser/css/rule");
  self.$require("browser/css/rule/style");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$CSS', function $$CSS($a) {
      var block = $$CSS.$$p || nil, $post_args, args, document = nil, $ret_or_1 = nil, style = nil;
      if ($gvars.document == null) $gvars.document = nil;

      $$CSS.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      document = ($truthy(($ret_or_1 = (($truthy($rb_gt(args.$length(), 1)) || ((block !== nil))) ? (args.$pop()) : nil))) ? ($ret_or_1) : ($gvars.document));
      style = document.$create_element("style");
      style['$[]=']("type", "text/css");
      if ($truthy(block)) {
        style['$inner_text=']($send($$('Paggio'), 'css', [], block.$to_proc()))
      } else {
        style['$inner_text='](args.$join(""))
      };
      return style;
    }, -1)
  })($nesting[0], $nesting);
};

Opal.modules["browser/setup/base"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("browser/version");
  self.$require("browser/utils");
  self.$require("browser/form_data");
  return self.$require("browser/support");
};

Opal.modules["browser/event/progress"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Progress');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("progress", "load", "loadend", "loadstart");
        $defs(self, '$supported?', function $Progress_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Progress")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$computable=', function $Definition_computable$eq$2(value) {
            var self = this;

            return self["native"].computableLength = value
          }, 1);
          
          $def(self, '$loaded=', function $Definition_loaded$eq$3(value) {
            var self = this;

            return self["native"].loaded = value
          }, 1);
          return $def(self, '$total=', function $Definition_total$eq$4(value) {
            var self = this;

            return self["native"].total = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new ProgressEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("ProgressEvent");
            event.initProgressEvent(name, desc.bubbles, desc.cancelable,
              desc.computable, desc.loaded, desc.total);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("computable?", "computableLength");
        self.$alias_native("loaded");
        return self.$alias_native("total");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/immediate"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $to_a = Opal.to_a, $class_variable_set = Opal.class_variable_set, $hash2 = Opal.hash2, $gvars = Opal.gvars, $class_variable_get = Opal.class_variable_get, $eqeqeq = Opal.eqeqeq, $return_val = Opal.return_val, $return_ivar = Opal.return_ivar, $slice = Opal.slice, $defs = Opal.defs, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('supports?,call,to_proc,rand,on,start_with?,data,===,delete,[],length,to_s,[]=,send,aborted?,prevent,tap,new,defer,proc,resolve,reject');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Immediate');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;
      if ($gvars.window == null) $gvars.window = nil;

      $proto["function"] = $proto["arguments"] = $proto.block = $proto.id = nil;
      
      
      $def(self, '$initialize', function $$initialize(func, args) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.aborted = false;
        self["function"] = func;
        self["arguments"] = args;
        return (self.block = block);
      }, 2);
      if ($truthy($$('Browser')['$supports?']("Immediate"))) {
        
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;

          return (self.id = window.setImmediate(function() {
        $send(self["function"], 'call', $to_a(self["arguments"]), self.block.$to_proc());
      }))
        }, 0);
        
        $def(self, '$prevent', function $$prevent() {
          var self = this;

          return window.clearImmediate(self.id)
        }, 0);
      } else if ($truthy($$('Browser')['$supports?']("Immediate (Internet Explorer)"))) {
        
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;

          return (self.id = window.msSetImmediate(function() {
        $send(self["function"], 'call', $to_a(self["arguments"]), self.block.$to_proc());
      }))
        }, 0);
        
        $def(self, '$prevent', function $$prevent() {
          var self = this;

          return window.msClearImmediate(self.id)
        }, 0);
      } else if ($truthy($$('Browser')['$supports?']("Window.send (Asynchronous)"))) {
        
        $class_variable_set($nesting[0], '@@tasks', $hash2([], {}));
        $class_variable_set($nesting[0], '@@prefix', "opal.browser.immediate." + (self.$rand(1000000)) + ".");
        $send($gvars.window, 'on', ["message"], function $Immediate$1(e){var task = nil;

          
          if (e == null) e = nil;
          if (($eqeqeq($$('String'), e.$data()) && ($truthy(e.$data()['$start_with?']($class_variable_get($nesting[0], '@@prefix', false)))))) {
            if ($truthy((task = $class_variable_get($nesting[0], '@@tasks', false).$delete(e.$data()['$[]'](Opal.Range.$new($class_variable_get($nesting[0], '@@prefix', false).$length(), -1, false)))))) {
              return $send(task['$[]'](0), 'call', $to_a(task['$[]'](1)), task['$[]'](2).$to_proc())
            } else {
              return nil
            }
          } else {
            return nil
          };}, 1);
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;
          if ($gvars.window == null) $gvars.window = nil;

          
          self.id = self.$rand(1000000).$to_s();
          $class_variable_get($nesting[0], '@@tasks', false)['$[]='](self.id, [self["function"], self["arguments"], self.block]);
          return $gvars.window.$send("" + ($class_variable_get($nesting[0], '@@prefix', false)) + (self.id));
        }, 0);
        
        $def(self, '$prevent', function $$prevent() {
          var self = this;

          return $class_variable_get($nesting[0], '@@tasks', false).$delete(self.id)
        }, 0);
      } else if ($truthy($$('Browser')['$supports?']("Event.readystatechange"))) {
        
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;

          
        var script = document.createElement("script");

        script.onreadystatechange = function() {
          if (!self['$aborted?']()) {
            $send(self["function"], 'call', $to_a(self["arguments"]), self.block.$to_proc());
          }

          script.onreadystatechange = null;
          script.parentNode.removeChild(script);
        };

        document.documentElement.appendChild(script);
      
        }, 0);
        
        $def(self, '$prevent', $return_val(nil), 0);
      } else {
        
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;

          return (self.id = window.setTimeout(function() {
        $send(self["function"], 'call', $to_a(self["arguments"]), self.block.$to_proc());
      }, 0))
        }, 0);
        
        $def(self, '$prevent', function $$prevent() {
          var self = this;

          return window.clearTimeout(self.id)
        }, 0);
      };
      
      $def(self, '$abort', function $$abort() {
        var self = this;

        
        if ($truthy(self['$aborted?']())) {
          return nil
        };
        self.aborted = true;
        self.$prevent();
        return self;
      }, 0);
      return $def(self, '$aborted?', $return_ivar("aborted"), 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$defer', function $$defer($a) {
      var block = $$defer.$$p || nil, $post_args, args;

      $$defer.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($$$($$('Browser'), 'Immediate').$new(block, args), 'tap', [], "dispatch".$to_proc());
    }, -1)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$defer', function $$defer($a) {
      var block = $$defer.$$p || nil, $post_args, args, self = this;

      $$defer.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send($send($$$($$('Browser'), 'Immediate'), 'new', [self, args], block.$to_proc()), 'tap', [], "dispatch".$to_proc());
    }, -1)
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Promise');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $defs(self, '$defer', function $$defer($a) {
      var block = $$defer.$$p || nil, $post_args, args, self = this;

      $$defer.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      return $send(self.$new(), 'tap', [], function $$2(promise){var self = $$2.$$s == null ? this : $$2.$$s;

        
        if (promise == null) promise = nil;
        return $send(self, 'proc', [], function $$3(){var e = nil;

          try {
            return promise.$resolve($send(block, 'call', $to_a(args)))
          } catch ($err) {
            if (Opal.rescue($err, [$$('Exception')])) {(e = $err)
              try {
                return promise.$reject(e)
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          }}, 0).$defer();}, {$$arity: 1, $$s: self});
    }, -1)
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/event/composition"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,supports?,supported?,alias_native,==,downcase,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Composition');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("compositionend", "compositionstart", "compositionupdate");
        $defs(self, '$supported?', function $Composition_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Composition")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$data=', function $Definition_data$eq$2(value) {
            var self = this;

            return self["native"].data = value
          }, 1);
          return $def(self, '$locale=', function $Definition_locale$eq$3(value) {
            var self = this;

            return self["native"].locale = value
          }, 1);
        })($nesting[0], $$$($$('UI'), 'Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new CompositionEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("CompositionEvent");
            event.initCompositionEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.data, desc.locale);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("data");
        self.$alias_native("locale");
        
        $def(self, '$start?', function $Composition_start$ques$4() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionstart")
        }, 0);
        
        $def(self, '$update?', function $Composition_update$ques$5() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionupdate")
        }, 0);
        return $def(self, '$end?', function $Composition_end$ques$6() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionend")
        }, 0);
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/css/style_sheet"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $eqeqeq = Opal.eqeqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,===,to_n,alias_native,new,DOM,join,map,insert,length,find,rules,log,==,id,__send__,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StyleSheet');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        
        $def(self, '$initialize', function $$initialize(what) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          if ($eqeqeq($$$($$('DOM'), 'Element'), what)) {
            return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [what.$to_n().sheet], null)
          } else {
            return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [what], null)
          }
        }, 1);
        self.$alias_native("disabled?", "disabled");
        self.$alias_native("href");
        self.$alias_native("title");
        self.$alias_native("type");
        
        $def(self, '$media', function $$media() {
          var self = this;

          if ($truthy(self["native"].media != null)) {
            return $$('Media').$new(self["native"].media)
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$owner', function $$owner() {
          var self = this;

          return self.$DOM(self["native"].ownerNode)
        }, 0);
        
        $def(self, '$parent', function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentStyleSheet != null)) {
            return $$('Sheet').$new(self["native"].parentStyleSheet)
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$rules', function $$rules() {
          var self = this;

          return $send($$$($$('Native'), 'Array'), 'new', [self["native"].cssRules], function $$1(e){
            
            if (e == null) e = nil;
            return $$('Rule').$new(e);}, 1)
        }, 0);
        
        $def(self, '$delete', function $StyleSheet_delete$2(index) {
          var self = this;

          return self["native"].deleteRule(index)
        }, 1);
        
        $def(self, '$insert', function $$insert(index, rule) {
          var self = this;

          return self["native"].insertRule(rule, index)
        }, 2);
        
        $def(self, '$rule', function $$rule(selector, body) {
          var self = this;

          
          if (!$eqeqeq($$('String'), selector)) {
            selector = selector.$join(", ")
          };
          if (!$eqeqeq($$('String'), body)) {
            body = $send(body, 'map', [], function $$3(name, value){
              
              if (name == null) name = nil;
              if (value == null) value = nil;
              return "" + (name) + ": " + (value) + ";";}, 2).$join("\n")
          };
          return self.$insert(self.$length(), "" + (selector) + " { " + (body) + " }");
        }, 2);
        
        $def(self, '$[]', function $StyleSheet_$$$4(id) {
          var self = this;

          return $send(self.$rules(), 'find', [], function $$5(r){var self = $$5.$$s == null ? this : $$5.$$s;

            
            if (r == null) r = nil;
            self.$log(r);
            return r.$id()['$=='](id);}, {$$arity: 1, $$s: self})
        }, 1);
        
        $def(self, '$method_missing', function $$method_missing($a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice.call(arguments);
          args = $post_args;
          return $send(self.$rules(), '__send__', $to_a(args), block.$to_proc());
        }, -1);
        return (function($base, $super) {
          var self = $klass($base, $super, 'Media');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$alias_native("text", "mediaText");
          self.$alias_native("to_s", "mediaText");
          
          $def(self, '$push', function $$push(medium) {
            var self = this;

            
            self["native"].appendMedium(medium);
            return self;
          }, 1);
          return $def(self, '$delete', function $Media_delete$6(medium) {
            var self = this;

            return self["native"].deleteMedium(medium)
          }, 1);
        })($nesting[0], $$$($$('Native'), 'Array'));
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["stringio"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $alias = Opal.alias, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,call,close,attr_accessor,check_readable,==,length,===,>=,raise,>,+,-,seek,check_writable,String,[],eof?,write,read,tell');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.position = $proto.string = nil;
    
    $defs(self, '$open', function $$open(string, mode) {
      var block = $$open.$$p || nil, self = this, io = nil, res = nil;

      $$open.$$p = null;
      
      ;
      if (string == null) string = "";
      if (mode == null) mode = nil;
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, -1);
    self.$attr_accessor("string");
    
    $def(self, '$initialize', function $$initialize(string, mode) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (string == null) string = "";
      if (mode == null) mode = "rw";
      self.string = string;
      self.position = 0;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [nil, mode], null);
    }, -1);
    
    $def(self, '$eof?', function $StringIO_eof$ques$1() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, 0);
    
    $def(self, '$seek', function $$seek(pos, whence) {
      var self = this, $ret_or_1 = nil;

      
      if (whence == null) whence = $$$($$('IO'), 'SEEK_SET');
      self.read_buffer = "";
      if ($eqeqeq($$$($$('IO'), 'SEEK_SET'), ($ret_or_1 = whence))) {
        
        if (!$truthy($rb_ge(pos, 0))) {
          self.$raise($$$($$('Errno'), 'EINVAL'))
        };
        self.position = pos;
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_CUR'), $ret_or_1)) {
        if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
          self.position = self.string.$length()
        } else {
          self.position = $rb_plus(self.position, pos)
        }
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_END'), $ret_or_1)) {
        if ($truthy($rb_gt(pos, self.string.$length()))) {
          self.position = 0
        } else {
          self.position = $rb_minus(self.position, pos)
        }
      } else {
        nil
      };
      return 0;
    }, -2);
    
    $def(self, '$tell', $return_ivar("position"), 0);
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, 0);
    
    $def(self, '$write', function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      self.read_buffer = "";
      string = self.$String(string);
      if ($eqeq(self.string.$length(), self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, 1);
    
    $def(self, '$read', function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      if (length == null) length = nil;
      if (outbuf == null) outbuf = nil;
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil
      };
      string = ($truthy(length) ? (((str = self.string['$[]'](self.position, length)), (self.position = $rb_plus(self.position, length)), ($truthy($rb_gt(self.position, self.string.$length())) ? ((self.position = self.string.$length())) : nil), str)) : (((str = self.string['$[]'](Opal.Range.$new(self.position, -1, false))), (self.position = self.string.$length()), str)));
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, -1);
    
    $def(self, '$sysread', function $$sysread(length) {
      var self = this;

      
      self.$check_readable();
      return self.$read(length);
    }, 1);
    $alias(self, "eof", "eof?");
    $alias(self, "pos", "tell");
    $alias(self, "pos=", "seek");
    return $alias(self, "readpartial", "read");
  })($nesting[0], $$('IO'), $nesting)
};

Opal.modules["browser/event/pop_state"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'PopState');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("popstate");
        $defs(self, '$supported?', function $PopState_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.PopState")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$state=', function $Definition_state$eq$2(value) {
            var self = this;

            return self["native"].state = value
          }, 1)
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new PopStateEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent('PopStateEvent');
            event.initPopStateEvent(name, desc.bubbles, desc.cancelable,
              desc.state);

        return event;
      
            }, 2)
          }
        };
        return self.$alias_native("state");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/data_transfer"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $truthy = Opal.truthy, $not = Opal.not, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,convert,to_n,map,new,==,kind,to_file,!,proc,resolve');
  
  self.$require("browser/blob");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DataTransfer');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$('NativeCachedWrapper'));
        
        $def(self, '$effect', function $$effect() {
          var self = this;

          return self["native"].dropEffect
        }, 0);
        
        $def(self, '$effect=', function $DataTransfer_effect$eq$1(effect) {
          var self = this;

          return self["native"].dropEffect = effect
        }, 1);
        
        $def(self, '$[]', function $DataTransfer_$$$2(type) {
          var self = this;

          return self["native"].getData(type)
        }, 1);
        
        $def(self, '$[]=', function $DataTransfer_$$$eq$3(type, value) {
          var self = this;

          return self["native"].setData(type, $$('Native').$convert(value))
        }, 2);
        
        $def(self, '$clear', function $$clear(type) {
          var self = this;

          
          if (type == null) type = nil;
          return self["native"].clearData(type.$to_n());
        }, -1);
        
        $def(self, '$drag_image=', function $DataTransfer_drag_image$eq$4(image) {
          var self = this;

          return self["native"].setDragImage($$('Native').$convert(image))
        }, 1);
        
        $def(self, '$files', function $$files() {
          var self = this;

          return $send($$$($$('Native'), 'Array').$new(self["native"].files), 'map', [], function $$5(f){
            
            if (f == null) f = nil;
            return $$('File').$new(f.$to_n());}, 1)
        }, 0);
        
        $def(self, '$items', function $$items() {
          var self = this;

          return $send($$$($$('Native'), 'Array').$new(self["native"].items), 'map', [], function $$6(i){
            
            if (i == null) i = nil;
            return $$('Item').$new(i.$to_n());}, 1)
        }, 0);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Item');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$include($$('NativeCachedWrapper'));
          
          $def(self, '$kind', function $$kind() {
            var self = this;

            return self["native"].kind
          }, 0);
          
          $def(self, '$string?', function $Item_string$ques$7() {
            var self = this;

            return self.$kind()['$==']("string")
          }, 0);
          
          $def(self, '$file?', function $Item_file$ques$8() {
            var self = this, $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = self.$kind()['$==']("file")))) {
              return self.$to_file()
            } else {
              return $ret_or_1
            }
          }, 0);
          
          $def(self, '$type', function $$type() {
            var self = this;

            return self["native"].type
          }, 0);
          
          $def(self, '$to_string', function $$to_string() {
            var block = $$to_string.$$p || nil, self = this, promise = nil;

            $$to_string.$$p = null;
            
            ;
            promise = nil;
            if ($not(block)) {
              
              promise = $$('Promise').$new();
              block = $send(self, 'proc', [], function $$9(i){
                
                if (i == null) i = nil;
                return promise.$resolve(i);}, 1);
            };
            self["native"].getAsString(block.$to_n());
            return promise;
          }, 0);
          return $def(self, '$to_file', function $$to_file() {
            var self = this, as_file = nil;

            
            as_file = self["native"].getAsFile();
            if ($truthy(as_file)) {
              return $$('File').$new(as_file)
            } else {
              return nil
            };
          }, 0);
        })($nesting[0], null, $nesting);
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/event/before_unload"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BeforeUnload');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("beforeunload");
        $defs(self, '$supported?', function $BeforeUnload_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.BeforeUnload")
        }, 0);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            return $defs(self, '$construct', function $$construct(name, desc) {
              
              return new BeforeUnloadEvent(name, desc)
            }, 2)
          } else {
            return nil
          }
        } else {
          return nil
        };
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $return_val = Opal.return_val, $eqeq = Opal.eqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,gsub,[],aliases,each,[]=,handlers,handles,name_for,class_for,new,construct,const_get,to_proc,arguments=,supports?,merge!,Native,to_n,==,name,attr_reader,attr_writer,convert,alias_native,off,prevent,stop');
  
  self.$require("browser/event/base");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = $proto.on = $proto.callback = nil;
      
      $defs(self, '$aliases', function $$aliases() {
        var self = this, $ret_or_1 = nil;
        if (self.aliases == null) self.aliases = nil;

        return (self.aliases = ($truthy(($ret_or_1 = self.aliases)) ? ($ret_or_1) : ($hash2(["dom:load", "hover"], {"dom:load": "DOMContentLoaded", "hover": "mouse:over"}))))
      }, 0);
      $defs(self, '$name_for', function $$name_for(name) {
        var self = this, $ret_or_1 = nil;

        return ($truthy(($ret_or_1 = self.$aliases()['$[]'](name))) ? ($ret_or_1) : (name)).$gsub(":", "")
      }, 1);
      $defs(self, '$handlers', function $$handlers() {
        var self = this, $ret_or_1 = nil;
        if (self.handlers == null) self.handlers = nil;

        return (self.handlers = ($truthy(($ret_or_1 = self.handlers)) ? ($ret_or_1) : ($hash2([], {}))))
      }, 0);
      $defs(self, '$handles', function $$handles($a) {
        var $post_args, events, self = this;

        
        $post_args = $slice.call(arguments);
        events = $post_args;
        return $send(events, 'each', [], function $$1(event){var $b, self = $$1.$$s == null ? this : $$1.$$s;

          
          if (event == null) event = nil;
          return ($b = [event, self], $send($$('Event').$handlers(), '[]=', $b), $b[$b.length - 1]);}, {$$arity: 1, $$s: self});
      }, -1);
      self.$handles("abort", "afterprint", "beforeprint", "cached", "canplay", "canplaythrough", "change", "chargingchange", "chargingtimechange", "checking", "close", "dischargingtimechange", "DOMContentLoaded", "downloading", "durationchange", "emptied", "ended", "error", "fullscreenchange", "fullscreenerror", "input", "invalid", "levelchange", "loadeddata", "loadedmetadata", "noupdate", "obsolete", "offline", "online", "open", "orientationchange", "pause", "pointerlockchange", "pointerlockerror", "play", "playing", "ratechange", "readystatechange", "reset", "seeked", "seeking", "stalled", "submit", "success", "suspend", "timeupdate", "updateready", "visibilitychange", "volumechange", "waiting");
      $defs(self, '$class_for', function $$class_for(name) {
        var self = this, $ret_or_1 = nil;
        if (self.handlers == null) self.handlers = nil;

        if ($truthy(($ret_or_1 = self.handlers['$[]'](self.$name_for(name))))) {
          return $ret_or_1
        } else {
          return $$('Custom')
        }
      }, 1);
      $defs(self, '$supported?', $return_val(true), 0);
      $defs(self, '$create', function $$create(name, $a) {
        var block = $$create.$$p || nil, $post_args, args, self = this, klass = nil, event = nil;

        $$create.$$p = null;
        
        ;
        $post_args = $slice.call(arguments, 1);
        args = $post_args;
        name = self.$name_for(name);
        klass = self.$class_for(name);
        event = klass.$new(klass.$construct(name, $send(klass.$const_get("Definition"), 'new', [], block.$to_proc())));
        event['$arguments='](args);
        return event;
      }, -2);
      if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
        $defs(self, '$construct', function $$construct(name, desc) {
          
          return new Event(name, desc)
        }, 2)
      } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
        $defs(self, '$construct', function $$construct(name, desc) {
          var self = this;

          
        var event = document.createEvent("HTMLEvents");
            event.initEvent(name, desc.bubbles, desc.cancelable);

        return self.$Native(event)['$merge!'](desc);
      
        }, 2)
      } else if ($truthy($$('Browser')['$supports?']("Event.createObject"))) {
        $defs(self, '$construct', function $$construct(name, desc) {
          var self = this;

          return self.$Native(document.createEventObject())['$merge!'](desc)['$merge!']({ type: name }).$to_n()
        }, 2)
      } else {
        $defs(self, '$construct', function $$construct(name, desc) {
          var self = this;

          return self.$Native(desc)['$merge!']({ type: name }).$to_n()
        }, 2)
      };
      $defs(self, '$new', function $Event_new$2(value, callback) {
        var $yield = $Event_new$2.$$p || nil, self = this, klass = nil;

        $Event_new$2.$$p = null;
        
        if (callback == null) callback = nil;
        if (!$eqeq(self, $$('Event'))) {
          return $send2(self, $find_super(self, 'new', $Event_new$2, false, true), 'new', [value, callback], $yield)
        };
        klass = self.$class_for(($truthy(callback) ? (callback.$name()) : (value.type)));
        if ($eqeq(klass, $$('Event'))) {
          return $send2(self, $find_super(self, 'new', $Event_new$2, false, true), 'new', [value, callback], $yield)
        } else {
          return klass.$new(value, callback)
        };
      }, -2);
      self.$attr_reader("callback");
      self.$attr_writer("on");
      
      $def(self, '$initialize', function $$initialize(event, callback) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (callback == null) callback = nil;
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [event], null);
        return (self.callback = callback);
      }, -2);
      
      $def(self, '$name', function $$name() {
        var self = this;

        return self["native"].type
      }, 0);
      
      $def(self, '$on', function $$on() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.on))) {
          return $ret_or_1
        } else {
          return $$('Target').$convert(self["native"].currentTarget)
        }
      }, 0);
      
      $def(self, '$target', function $$target() {
        var self = this;

        return $$('Target').$convert(self["native"].srcElement || self["native"].target)
      }, 0);
      
      $def(self, '$arguments', function $Event_arguments$3() {
        var self = this;

        return self["native"].arguments || []
      }, 0);
      
      $def(self, '$arguments=', function $Event_arguments$eq$4(args) {
        var self = this;

        return self["native"].arguments = args
      }, 1);
      self.$alias_native("bubbles?", "bubbles");
      self.$alias_native("cancelable?", "cancelable");
      self.$alias_native("data");
      self.$alias_native("phase", "eventPhase");
      self.$alias_native("at", "timeStamp");
      
      $def(self, '$off', function $$off() {
        var self = this;

        if ($truthy(self.callback)) {
          return self.callback.$off()
        } else {
          return nil
        }
      }, 0);
      
      $def(self, '$stopped?', function $Event_stopped$ques$5() {
        var self = this;

        return !!self["native"].stopped
      }, 0);
      
      $def(self, '$stop', function $$stop() {
        var self = this;

        
        if ($truthy((typeof(self["native"].stopPropagation) !== "undefined"))) {
          self["native"].stopPropagation()
        };
        return self["native"].stopped = true;
      }, 0);
      
      $def(self, '$prevent', function $$prevent() {
        var self = this;

        
        if ($truthy((typeof(self["native"].preventDefault) !== "undefined"))) {
          self["native"].preventDefault()
        };
        return self["native"].prevented = true;
      }, 0);
      
      $def(self, '$prevented?', function $Event_prevented$ques$6() {
        var self = this;

        return !!self["native"].prevented
      }, 0);
      return $def(self, '$stop!', function $Event_stop$excl$7() {
        var self = this;

        
        self.$prevent();
        return self.$stop();
      }, 0);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  self.$require("browser/event/ui");
  self.$require("browser/event/mouse");
  self.$require("browser/event/keyboard");
  return self.$require("browser/event/custom");
};

Opal.modules["browser/http/headers"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $const_set = Opal.const_set, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,[],map,lines,split,chomp,each,[]=,include,clear,enum_for,call,name,value,downcase,<<,length');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $const_set($nesting[0], 'Header', $$('Struct').$new("name", "value"));
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Headers');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.hash = nil;
        
        $defs(self, '$parse', function $$parse(string) {
          var self = this;

          return self['$[]']($send(string.$lines(), 'map', [], function $$1(l){
            
            if (l == null) l = nil;
            return l.$chomp().$split(/\s*:\s*/);}, 1))
        }, 1);
        $defs(self, '$[]', function $Headers_$$$2(hash) {
          var self = this, result = nil;

          
          result = self.$new();
          $send(hash, 'each', [], function $$3(name, value){var $a;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return ($a = [name, value], $send(result, '[]=', $a), $a[$a.length - 1]);}, 2);
          return result;
        }, 1);
        self.$include($$('Enumerable'));
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;

          return (self.hash = $$('Hash').$new())
        }, 0);
        
        $def(self, '$clear', function $$clear() {
          var self = this;

          return self.hash.$clear()
        }, 0);
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this;

          $$each.$$p = null;
          
          ;
          if (!$truthy(block)) {
            return self.$enum_for("each")
          };
          $send(self.hash, 'each', [], function $$4(_, header){
            
            if (_ == null) _ = nil;
            if (header == null) header = nil;
            return block.$call([header.$name(), header.$value()]);}, 2);
          return self;
        }, 0);
        
        $def(self, '$[]', function $Headers_$$$5(name) {
          var self = this;

          return self.hash['$[]'](name.$downcase())
        }, 1);
        
        $def(self, '$[]=', function $Headers_$$$eq$6(name, value) {
          var $a, self = this, header = nil;

          
          header = $$('Header').$new(name, value);
          return ($a = [name.$downcase(), header], $send(self.hash, '[]=', $a), $a[$a.length - 1]);
        }, 2);
        
        $def(self, '$<<', function $Headers_$lt$lt$7(header) {
          var self = this;

          
          self.hash['$[]='](header.$name().$downcase(), header);
          return self;
        }, 1);
        $alias(self, "push", "<<");
        
        $def(self, '$merge!', function $Headers_merge$excl$8(other) {
          var self = this;

          
          $send(other, 'each', [], function $$9(name, value){var $a, self = $$9.$$s == null ? this : $$9.$$s;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return ($a = [name, value], $send(self, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
          return self;
        }, 1);
        return $def(self, '$length', function $$length() {
          var self = this;

          return self.hash.$length()
        }, 0);
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/page_transition"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'PageTransition');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("pagehide", "pageshow");
        $defs(self, '$supported?', function $PageTransition_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.PageTransition")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$persisted=', function $Definition_persisted$eq$2(value) {
            var self = this;

            return self["native"].persisted = value
          }, 1)
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.PageTransition"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new PageTransitionEvent(name, desc);
            }, 2)
          }
        };
        return self.$alias_native("persisted?", "persisted");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/http/request"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $def = Opal.def, $return_ivar = Opal.return_ivar, $assign_ivar_val = Opal.assign_ivar_val, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $not = Opal.not, $lambda = Opal.lambda, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,transport,[],new,[]=,==,arity,instance_exec,to_proc,call,supports?,raise,!,===,include?,<<,opened?,nil?,cacheable?,rand,empty?,+,build_query,upcase,to_s,to_n,callback,sent?,each,binary?,supported?,mime_type,contain_files?,build_form_data,private,response,code,status,success?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Request');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.asynchronous = $proto.user = $proto.password = $proto.mime_type = $proto.content_type = $proto.encoding = $proto.parameters = $proto.query = $proto.callbacks = $proto.url = $proto["native"] = $proto.method = $proto.headers = $proto.response = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$include($$$($$('Event'), 'Target'));
        $const_set($nesting[0], 'HEADERS', $hash2(["X-Requested-With", "X-Opal-Version", "Accept"], {"X-Requested-With": "XMLHttpRequest", "X-Opal-Version": $$('RUBY_ENGINE_VERSION'), "Accept": "text/javascript, text/html, application/xml, text/xml, */*"}));
        $const_set($nesting[0], 'STATES', ["uninitialized", "loading", "loaded", "interactive", "complete"]);
        self.$attr_reader("headers");
        self.$attr_reader("response");
        self.$attr_reader("method");
        self.$attr_reader("url");
        
        $def(self, '$initialize', function $$initialize() {
          var block = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          ;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.$transport()], null);
          self.parameters = $hash2([], {});
          self.query = $hash2([], {});
          self.headers = $$('Headers')['$[]']($$('HEADERS'));
          self.method = "get";
          self.asynchronous = true;
          self.binary = false;
          self.cacheable = true;
          self.opened = false;
          self.sent = false;
          self.completed = false;
          self.callbacks = $send($$('Hash'), 'new', [], function $$1(h, k){var $a;

            
            if (h == null) h = nil;
            if (k == null) k = nil;
            return ($a = [k, []], $send(h, '[]=', $a), $a[$a.length - 1]);}, 2);
          if ($truthy(block)) {
            if ($eqeq(block.$arity(), 0)) {
              return $send(self, 'instance_exec', [], block.$to_proc())
            } else {
              return block.$call(self)
            }
          } else {
            return nil
          };
        }, 0);
        if ($truthy($$('Browser')['$supports?']("XHR"))) {
          
          $def(self, '$transport', function $$transport() {
            
            return new XMLHttpRequest();
          }, 0)
        } else if ($truthy($$('Browser')['$supports?']("ActiveX"))) {
          
          $def(self, '$transport', function $$transport() {
            
            return new ActiveXObject("MSXML2.XMLHTTP.3.0");
          }, 0)
        } else {
          
          $def(self, '$transport', function $$transport() {
            var self = this;

            return self.$raise($$('NotImplementedError'))
          }, 0)
        };
        
        $def(self, '$opened?', $return_ivar("opened"), 0);
        
        $def(self, '$sent?', $return_ivar("sent"), 0);
        
        $def(self, '$completed?', $return_ivar("completed"), 0);
        
        $def(self, '$asynchronous?', $return_ivar("asynchronous"), 0);
        
        $def(self, '$synchronous?', function $Request_synchronous$ques$2() {
          var self = this;

          return self.asynchronous['$!']()
        }, 0);
        
        $def(self, '$asynchronous!', $assign_ivar_val("asynchronous", true), 0);
        
        $def(self, '$synchronous!', $assign_ivar_val("asynchronous", false), 0);
        
        $def(self, '$binary?', $return_ivar("binary"), 0);
        
        $def(self, '$binary!', $assign_ivar_val("binary", true), 0);
        
        $def(self, '$cacheable?', $return_ivar("cacheable"), 0);
        
        $def(self, '$no_cache!', $assign_ivar_val("cacheable", false), 0);
        
        $def(self, '$user', function $$user(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.user = value)
          } else {
            return self.user
          };
        }, -1);
        
        $def(self, '$password', function $$password(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.password = value)
          } else {
            return self.password
          };
        }, -1);
        
        $def(self, '$mime_type', function $$mime_type(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.mime_type = value)
          } else {
            return self.mime_type
          };
        }, -1);
        
        $def(self, '$content_type', function $$content_type(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.content_type = value)
          } else {
            return self.content_type
          };
        }, -1);
        
        $def(self, '$encoding', function $$encoding(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.encoding = value)
          } else {
            return self.encoding
          };
        }, -1);
        
        $def(self, '$parameters', function $$parameters(hash) {
          var self = this;

          
          if (hash == null) hash = nil;
          if ($truthy(hash)) {
            return (self.parameters = hash)
          } else {
            return self.parameters
          };
        }, -1);
        
        $def(self, '$query', function $$query(hash) {
          var self = this;

          
          if (hash == null) hash = nil;
          if ($truthy(hash)) {
            return (self.query = hash)
          } else {
            return self.query
          };
        }, -1);
        
        $def(self, '$on', function $$on(what, $a) {
          var block = $$on.$$p || nil, $post_args, $rest_arg, self = this;

          $$on.$$p = null;
          
          ;
          $post_args = $slice.call(arguments, 1);
          $rest_arg = $post_args;
          if ((($truthy($$('STATES')['$include?'](what)) || ($truthy(["success", "failure"]['$include?'](what)))) || ($eqeqeq($$('Integer'), what)))) {
            return self.callbacks['$[]'](what)['$<<'](block)
          } else {
            return $send2(self, $find_super(self, 'on', $$on, false, true), 'on', [what].concat($to_a($rest_arg)), block)
          };
        }, -2);
        
        $def(self, '$open', function $$open(method, url, asynchronous, user, password) {
          var self = this;

          
          if (method == null) method = nil;
          if (url == null) url = nil;
          if (asynchronous == null) asynchronous = nil;
          if (user == null) user = nil;
          if (password == null) password = nil;
          if ($truthy(self['$opened?']())) {
            self.$raise("the request has already been opened")
          };
          if (!$truthy(method['$nil?']())) {
            self.method = method
          };
          if (!$truthy(url['$nil?']())) {
            self.url = url
          };
          if (!$truthy(asynchronous['$nil?']())) {
            self.asynchronous = asynchronous
          };
          if (!$truthy(user['$nil?']())) {
            self.user = user
          };
          if (!$truthy(password['$nil?']())) {
            self.password = password
          };
          url = self.url;
          if (!$truthy(self['$cacheable?']())) {
            self.query['$[]=']("_", self.$rand())
          };
          if (!$truthy(self.query['$empty?']())) {
            
            if ($truthy(url['$include?']("?"))) {
              url = $rb_plus(url, "&")
            } else {
              url = $rb_plus(url, "?")
            };
            url = $rb_plus(url, $$('FormData').$build_query(self.query));
          };
          self["native"].open(self.method.$to_s().$upcase(), url.$to_s(), self.asynchronous, self.user.$to_n(), self.password.$to_n());
          if (!$truthy(self.callbacks['$empty?']())) {
            self["native"].onreadystatechange = self.$callback()
          };
          self.opened = true;
          return self;
        }, -1);
        
        $def(self, '$send', function $$send(parameters) {
          var self = this, header = nil, data = nil;

          
          if (parameters == null) parameters = self.parameters;
          if (!$truthy(self['$opened?']())) {
            self.$raise("the request has not been opened")
          };
          if ($truthy(self['$sent?']())) {
            self.$raise("the request has already been sent")
          };
          if (!$truthy(self['$cacheable?']())) {
            self["native"].setRequestHeader("If-Modified-Since", "Tue, 11 Sep 2001 12:46:00 GMT")
          };
          $send(self.headers, 'each', [], function $$3(name, value){var self = $$3.$$s == null ? this : $$3.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return self["native"].setRequestHeader(name.$to_s(), value.$to_s());}, {$$arity: 2, $$s: self});
          if ($truthy(self.content_type)) {
            
            header = self.content_type;
            if ($truthy(self.encoding)) {
              header = $rb_plus(header, "; charset=" + (self.encoding))
            };
            self["native"].setRequestHeader('Content-Type', header);
          };
          if ($truthy(self['$binary?']())) {
            if ($truthy($$('Buffer')['$supported?']())) {
              self["native"].responseType = 'arraybuffer'
            } else {
              self["native"].overrideMimeType('text/plain; charset=x-user-defined')
            }
          };
          if (($truthy(self.$mime_type()) && ($not(self['$binary?']())))) {
            self["native"].overrideMimeType(self.mime_type)
          };
          self.sent = true;
          self.response = $$('Response').$new(self);
          if ($eqeqeq($$('String'), parameters)) {
            data = parameters
          } else if ((($eqeqeq($$('Hash'), parameters) && ($not(parameters['$empty?']()))) || ($eqeqeq($$('FormData'), parameters)))) {
            
            data = ($eqeqeq($$('Hash'), parameters) ? (($truthy($$('FormData')['$contain_files?'](parameters)) ? ($$('FormData').$build_form_data(parameters)) : ($$('FormData').$build_query(parameters)))) : (parameters));
            if (!$truthy(self.content_type)) {
              if (!$eqeqeq($$('FormData'), data)) {
                self["native"].setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
              }
            };
            data = data.$to_n();
          } else {
            data = null
          };
          self["native"].send(data);
          return self.response;
        }, -1);
        
        $def(self, '$abort', function $$abort() {
          var self = this;

          return self["native"].abort()
        }, 0);
        self.$private();
        return $def(self, '$callback', function $$callback() {
          var self = this;

          return $lambda(function $$4(event){var self = $$4.$$s == null ? this : $$4.$$s, state = nil, res = nil;
            if (self["native"] == null) self["native"] = nil;
            if (self.callbacks == null) self.callbacks = nil;

            
            if (event == null) event = nil;
            state = $$('STATES')['$[]'](self["native"].readyState);
            res = self.$response();
            $send(self.callbacks['$[]'](state), 'each', [], function $$5(b){
              
              if (b == null) b = nil;
              return b.$call(res);}, 1);
            if ($eqeq(state, "complete")) {
              
              self.completed = true;
              $send(self.callbacks['$[]'](res.$status().$code()), 'each', [], function $$6(b){
                
                if (b == null) b = nil;
                return b.$call(res);}, 1);
              if ($truthy(res['$success?']())) {
                return $send(self.callbacks['$[]']("success"), 'each', [], function $$7(b){
                  
                  if (b == null) b = nil;
                  return b.$call(res);}, 1)
              } else {
                return $send(self.callbacks['$[]']("failure"), 'each', [], function $$8(b){
                  
                  if (b == null) b = nil;
                  return b.$call(res);}, 1)
              };
            } else {
              return nil
            };}, {$$arity: 1, $$s: self})
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $def = Opal.def, $slice = Opal.slice, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $klass = Opal.klass, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;
  if ($gvars.window == null) $gvars.window = nil;

  Opal.add_stubs('require,DOM,shift,to_a,new,to_proc,==,length,first,respond_to?,to_dom,raise,native?,===,tap,create_element,<<,try_convert,document');
  
  self.$require("browser/dom/node_set");
  self.$require("browser/dom/node");
  self.$require("browser/dom/attribute");
  self.$require("browser/dom/character_data");
  self.$require("browser/dom/text");
  self.$require("browser/dom/cdata");
  self.$require("browser/dom/comment");
  self.$require("browser/dom/element");
  self.$require("browser/dom/document_or_shadow_root");
  self.$require("browser/dom/document");
  self.$require("browser/dom/document_fragment");
  self.$require("browser/dom/shadow_root");
  self.$require("browser/dom/mutation_observer");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$XML', function $$XML(what) {
      var self = this;

      
      
      var doc;

      if (window.DOMParser) {
        doc = new DOMParser().parseFromString(what, 'text/xml');
      }
      else {
        doc       = new ActiveXObject('Microsoft.XMLDOM');
        doc.async = 'false';
        doc.loadXML(what);
      }
    ;
      return self.$DOM(doc);
    }, 1);
    return $def(self, '$DOM', function $$DOM($a) {
      var block = $$DOM.$$p || nil, $post_args, args, self = this, document = nil, $ret_or_1 = nil, roots = nil, what = nil;
      if ($gvars.document == null) $gvars.document = nil;

      $$DOM.$$p = null;
      
      ;
      $post_args = $slice.call(arguments);
      args = $post_args;
      if ($truthy(block)) {
        
        document = ($truthy(($ret_or_1 = args.$shift())) ? ($ret_or_1) : ($gvars.document));
        roots = $send($$$($$$($$('Browser'), 'DOM'), 'Builder'), 'new', [document], block.$to_proc()).$to_a();
        if ($eqeq(roots.$length(), 1)) {
          return roots.$first()
        } else {
          return $$$($$$($$('Browser'), 'DOM'), 'NodeSet').$new(roots)
        };
      } else {
        
        what = args.$shift();
        document = ($truthy(($ret_or_1 = args.$shift())) ? ($ret_or_1) : ($gvars.document));
        if ($truthy($$('Opal')['$respond_to?'](what, "to_dom"))) {
          what = what.$to_dom(document)
        };
        if ($truthy(typeof(what) === 'undefined' || what === null)) {
          return self.$raise($$('ArgumentError'), "argument is null")
        } else if ($truthy(self['$native?'](what))) {
          return $$$($$$($$('Browser'), 'DOM'), 'Node').$new(what)
        } else if ($eqeqeq($$$($$$($$('Browser'), 'DOM'), 'Node'), what)) {
          return what
        } else if ($truthy($$('Opal')['$respond_to?'](what, "each"))) {
          return $send(document.$create_element("DIV"), 'tap', [], function $$1(div){
            
            if (div == null) div = nil;
            return div['$<<'](what);}, 1)
        } else if ($eqeqeq($$('String'), what)) {
          
          var doc = $$('Native').$try_convert(document).createElement('div');
          doc.innerHTML = what;

          return self.$DOM(doc.childNodes.length == 1 ? doc.childNodes[0] : doc);
        
        } else {
          return self.$raise($$('ArgumentError'), "argument is not DOM convertible")
        };
      };
    }, -1);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Window');

      var $proto = self.$$prototype;

      $proto["native"] = nil;
      return $def(self, '$document', function $$document() {
        var self = this;

        return self.$DOM(self["native"].document)
      }, 0)
    })($nesting[0], null)
  })($nesting[0], $nesting);
  return ($gvars.document = $gvars.window.$document());
};

Opal.modules["browser/http/response"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_lt = Opal.rb_lt, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,new,attr_reader,to_n,parse,code,status,>=,<,==,!,success?,alias_native,DOM,binary?,request,supported?,text');
  
  self.$require("json");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Response');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.headers = $proto["native"] = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        $const_set($nesting[0], 'Status', $$('Struct').$new("code", "text"));
        self.$attr_reader("request");
        
        $def(self, '$initialize', function $$initialize(request) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [request.$to_n()], null);
          return (self.request = request);
        }, 1);
        
        $def(self, '$headers', function $$headers() {
          var self = this, $ret_or_1 = nil;

          return (self.headers = ($truthy(($ret_or_1 = self.headers)) ? ($ret_or_1) : ($$('Headers').$parse(self["native"].getAllResponseHeaders()))))
        }, 0);
        
        $def(self, '$status', function $$status() {
          var self = this;

          return $$('Status').$new(self["native"].status || nil, self["native"].statusText || nil)
        }, 0);
        
        $def(self, '$success?', function $Response_success$ques$1() {
          var self = this, code = nil, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy((code = self.$status().$code()))) {
            if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $rb_ge(code, 200))) ? ($rb_lt(code, 300)) : ($ret_or_2))))) {
              return $ret_or_1
            } else {
              return code['$=='](304)
            }
          } else {
            return false
          }
        }, 0);
        
        $def(self, '$failure?', function $Response_failure$ques$2() {
          var self = this;

          return self['$success?']()['$!']()
        }, 0);
        self.$alias_native("url", "responseURL");
        
        $def(self, '$text', function $$text() {
          var self = this;

          
      var result = self["native"].responseText;

      if (!result) {
        return nil;
      }

      return result;
    
        }, 0);
        
        $def(self, '$json', function $$json() {
          var self = this;

          
      var result = self["native"].responseText;

      if (!result) {
        return nil;
      }

      return $$('JSON').$parse(result);
    
        }, 0);
        
        $def(self, '$xml', function $$xml() {
          var self = this;

          
          
      var result = self["native"].responseXML;

      if (!result) {
        return nil;
      }
    ;
          return self.$DOM(result);
        }, 0);
        return $def(self, '$binary', function $$binary() {
          var self = this;

          
          if (!$truthy(self.$request()['$binary?']())) {
            return nil
          };
          if ($truthy($$('Buffer')['$supported?']())) {
            
            
        var result = self["native"].response;

        if (!result) {
          return nil;
        }
      ;
            return $$('Binary').$new($$('Buffer').$new(result));
          } else {
            
            if (!$truthy(self.$text())) {
              return nil
            };
            return $$('Binary').$new(self.$text());
          };
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/window/view"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('to_n,supports?,raise');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'View');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        
        $def(self, '$initialize', function $$initialize(window) {
          var self = this;

          
          self.window = window;
          return (self["native"] = window.$to_n());
        }, 1);
        if ($truthy($$('Browser')['$supports?']("Window.innerSize"))) {
          
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].innerWidth
          }, 0);
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].innerHeight
          }, 0);
        } else if ($truthy($$('Browser')['$supports?']("Element.clientSize"))) {
          
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].document.documentElement.clientHeight
          }, 0);
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].document.documentElement.clientWidth
          }, 0);
        } else {
          
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window size unsupported")
          }, 0);
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window size unsupported")
          }, 0);
        };
        
        $def(self, '$zoom', function $$zoom() {
          var self = this;

          return self["native"].devicePixelRatio
        }, 0);
        return $def(self, '$on_zoom', function $$on_zoom() {
          var block = $$on_zoom.$$p || nil, self = this;

          $$on_zoom.$$p = null;
          
          ;
          
      var mqString = "(resolution: " + self["native"].devicePixelRatio + "dppx)";
      self["native"].matchMedia(mqString).addListener(block.$to_n());
    ;
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/device_motion"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $const_set = Opal.const_set, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,new,to_n,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceMotion');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("devicemotion");
        $defs(self, '$supported?', function $DeviceMotion_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.DeviceMotion")
        }, 0);
        $const_set($nesting[0], 'Acceleration', $$('Struct').$new("x", "y", "z"));
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$acceleration=', function $Definition_acceleration$eq$2(value) {
            var self = this;

            return self["native"].acceleration = value.$to_n()
          }, 1);
          
          $def(self, '$acceleration_with_gravity=', function $Definition_acceleration_with_gravity$eq$3(value) {
            var self = this;

            return self["native"].accelerationIncludingGravity = value.$to_n()
          }, 1);
          
          $def(self, '$rotation=', function $Definition_rotation$eq$4(value) {
            var self = this;

            return self["native"].rotationRate = value
          }, 1);
          return $def(self, '$interval=', function $Definition_interval$eq$5(value) {
            var self = this;

            return self["native"].interval = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DeviceMotionEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("DeviceMotionEvent");
            event.initDeviceMotionEvent(name, desc.bubbles, desc.cancelable,
              desc.acceleration, desc.accelerationIncludingGravity,
              desc.rotationRate, desc.interval);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("acceleration");
        self.$alias_native("acceleration_with_gravity", "accelerationIncludingGravity");
        self.$alias_native("rotation", "rotationRate");
        return self.$alias_native("interval");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/version"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return $const_set($nesting[0], 'VERSION', "0.3.3")
  })($nesting[0], $nesting)
};

Opal.modules["browser/css/rule"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $defs = Opal.defs, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,==,[],new,raise,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rule');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        $const_set($nesting[0], 'STYLE_RULE', 1);
        $const_set($nesting[0], 'CHARSET_RULE', 2);
        $const_set($nesting[0], 'IMPORT_RULE', 3);
        $const_set($nesting[0], 'MEDIA_RULE', 4);
        $const_set($nesting[0], 'FONT_FACE_RULE', 5);
        $const_set($nesting[0], 'PAGE_RULE', 6);
        $const_set($nesting[0], 'KEYFRAMES_RULE', 7);
        $const_set($nesting[0], 'KEYFRAME_RULE', 8);
        $const_set($nesting[0], 'NAMESPACE_RULE', 10);
        $const_set($nesting[0], 'COUNTER_STYLE_RULE', 11);
        $const_set($nesting[0], 'SUPPORTS_RULE', 12);
        $const_set($nesting[0], 'DOCUMENT_RULE', 13);
        $const_set($nesting[0], 'FONT_FEATURE_VALUES_RULE', 14);
        $const_set($nesting[0], 'VIEWPORT_RULE', 15);
        $const_set($nesting[0], 'REGION_STYLE_RULE', 16);
        $defs(self, '$new', function $Rule_new$1(rule) {
          var $yield = $Rule_new$1.$$p || nil, self = this, $ret_or_1 = nil, klass = nil;
          if (self.classes == null) self.classes = nil;

          $Rule_new$1.$$p = null;
          if ($eqeq(self, $$('Rule'))) {
            
            self.classes = ($truthy(($ret_or_1 = self.classes)) ? ($ret_or_1) : ([nil, $$('Style')]));
            if ($truthy((klass = self.classes['$[]'](rule.type)))) {
              return klass.$new(rule)
            } else {
              return self.$raise($$('ArgumentError'), "cannot instantiate a non derived Rule object")
            };
          } else {
            return $send2(self, $find_super(self, 'new', $Rule_new$1, false, true), 'new', [rule], null)
          }
        }, 1);
        self.$alias_native("text", "cssText");
        self.$alias_native("to_s", "cssText");
        
        $def(self, '$parent', function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentRule != null)) {
            return $$('Rule').$new(self["native"].parentRule)
          } else {
            return nil
          }
        }, 0);
        return $def(self, '$style_sheet', function $$style_sheet() {
          var self = this;

          if ($truthy(self["native"].parentStyleSheet != null)) {
            return $$('StyleSheet').$new(self["native"].parentStyleSheet)
          } else {
            return nil
          }
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/css/declaration"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $range = Opal.range, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,new,each,[]=,to_proc,important,name,value,to_s,enum_for,[],alias_native,end_with?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Declaration');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        self.$include($$('Enumerable'));
        
        $def(self, '$rule', function $$rule() {
          var self = this;

          if ($truthy((typeof(self["native"].parentRule) !== "undefined"))) {
            return $$('Rule').$new(self["native"].parentRule)
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$assign', function $$assign(data) {
          var self = this;

          
          $send(data, 'each', [], function $$1(name, value){var $a, self = $$1.$$s == null ? this : $$1.$$s;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return ($a = [name, value], $send(self, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
          return self;
        }, 1);
        
        $def(self, '$replace', function $$replace(string) {
          var self = this;

          return self["native"].cssText = string
        }, 1);
        
        $def(self, '$apply', function $$apply() {
          var block = $$apply.$$p || nil, self = this;

          $$apply.$$p = null;
          
          ;
          return $send($send($$$($$$($$('Paggio'), 'CSS'), 'Definition'), 'new', [], block.$to_proc()), 'each', [], function $$2(style){var self = $$2.$$s == null ? this : $$2.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (style == null) style = nil;
            if ($truthy(style.$important())) {
              return self["native"].setProperty(style.$name(), style.$value(), "important")
            } else {
              return self["native"].setProperty(style.$name(), style.$value(), "")
            };}, {$$arity: 1, $$s: self});
        }, 0);
        
        $def(self, '$delete', function $Declaration_delete$3(name) {
          var self = this;

          return self["native"].removeProperty(name)
        }, 1);
        
        $def(self, '$[]', function $Declaration_$$$4(name) {
          var self = this;

          
      var result = self["native"].getPropertyValue(name);

      if (result == null || result === "") {
        return nil;
      }

      return result;
    
        }, 1);
        
        $def(self, '$[]=', function $Declaration_$$$eq$5(name, value) {
          var self = this;

          return self["native"].setProperty(name, value.$to_s(), "")
        }, 2);
        
        $def(self, '$important?', function $Declaration_important$ques$6(name) {
          var self = this;

          return self["native"].getPropertyPriority(name) == "important"
        }, 1);
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this;

          $$each.$$p = null;
          
          ;
          if (!(block !== nil)) {
            return self.$enum_for("each")
          };
          
      for (var i = 0, length = self["native"].length; i < length; i++) {
        var name  = self["native"].item(i);

        Opal.yieldX(block, [name, self['$[]'](name)])
      }
    ;
          return self;
        }, 0);
        self.$alias_native("length");
        self.$alias_native("to_s", "cssText");
        return $def(self, '$method_missing', function $$method_missing(name, value) {
          var $a, self = this;

          
          if (value == null) value = nil;
          if ($truthy(name['$end_with?']("="))) {
            return ($a = [name['$[]']($range(0, -2, false)), value], $send(self, '[]=', $a), $a[$a.length - 1])
          } else {
            return self['$[]'](name)
          };
        }, -2);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/focus"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,supports?,convert,supported?,DOM');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Focus');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("blur", "focus", "focusin", "focusout");
        $defs(self, '$supported?', function $Focus_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Focus")
        }, 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$view=', function $Definition_view$eq$2(value) {
            var self = this;

            return self["native"].view = $$('Native').$convert(value)
          }, 1);
          return $def(self, '$related=', function $Definition_related$eq$3(elem) {
            var self = this;

            return self["native"].relatedTarget = $$('Native').$convert(elem)
          }, 1);
        })($nesting[0], $$$($$('UI'), 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new FocusEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("FocusEvent");
            event.initFocusEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, 0, desc.relatedTarget);

        return event;
      
            }, 2)
          }
        };
        return $def(self, '$related', function $$related() {
          var self = this;

          return self.$DOM(self["native"].relatedTarget)
        }, 0);
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/css/rule/style"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('alias_native,new,__send__,declaration,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rule');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Style');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$alias_native("selector", "selectorText");
          self.$alias_native("id", "selectorText");
          
          $def(self, '$declaration', function $$declaration() {
            var self = this;

            return $$('Declaration').$new(self["native"].style)
          }, 0);
          return $def(self, '$method_missing', function $$method_missing($a) {
            var block = $$method_missing.$$p || nil, $post_args, args, self = this;

            $$method_missing.$$p = null;
            
            ;
            $post_args = $slice.call(arguments);
            args = $post_args;
            return $send(self.$declaration(), '__send__', $to_a(args), block.$to_proc());
          }, -1);
        })($nesting[0], $$('Rule'), $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/animation"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Animation');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("animationend", "animationiteration", "animationstart");
        $defs(self, '$supported?', function $Animation_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Animation")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$animation=', function $Definition_animation$eq$2(value) {
            var self = this;

            return self["native"].animationName = value
          }, 1);
          return $def(self, '$elapsed=', function $Definition_elapsed$eq$3(value) {
            var self = this;

            return self["native"].elapsedTime = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new AnimationEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("AnimationEvent");
            event.initAnimationEvent(name, desc.bubbles, desc.cancelable,
              desc.animationName, desc.elapsedTime);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("name", "animationName");
        return self.$alias_native("elapsed", "elapsedTime");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/html"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $eqeq = Opal.eqeq, $not = Opal.not, $send = Opal.send, $return_ivar = Opal.return_ivar, $eqeqeq = Opal.eqeqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias, $range = Opal.range, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,attr_reader,raise,build!,<<,==,arity,!,instance_exec,to_proc,call,first,===,instance_eval,each,end_with?,to_s,empty?,heredoc,shift,new,method_missing,[],inspect');
  
  self.$require("paggio/html/helpers");
  self.$require("paggio/html/element");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.current = $proto.roots = $proto.block = $proto.version = nil;
      
      self.$attr_reader("version");
      
      $def(self, '$initialize', function $$initialize($a, $b) {
        var block = $$initialize.$$p || nil, $post_args, $kwargs, version, defer, self = this;

        $$initialize.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        $kwargs = $extract_kwargs($post_args);
        $kwargs = $ensure_kwargs($kwargs);
        
        if ($post_args.length > 0) version = $post_args.shift();if (version == null) version = 5;
        
        defer = $kwargs.$$smap["defer"];if (defer == null) defer = false;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "no block given")
        };
        self.version = version;
        self.roots = [];
        self.current = nil;
        self.block = block;
        if ($truthy(defer)) {
          return nil
        } else {
          return self['$build!']()
        };
      }, -1);
      
      $def(self, '$<<', function $HTML_$lt$lt$1(what) {
        var self = this, $ret_or_1 = nil;

        return ($truthy(($ret_or_1 = self.current)) ? ($ret_or_1) : (self.roots))['$<<'](what)
      }, 1);
      
      $def(self, '$build!', function $HTML_build$excl$2($kwargs) {
        var force_call, self = this;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        force_call = $kwargs.$$smap["force_call"];if (force_call == null) force_call = false;
        if (($not(force_call) && ($eqeq(self.block.$arity(), 0)))) {
          $send(self, 'instance_exec', [], self.block.$to_proc())
        } else {
          self.block.$call(self)
        };
        return (self.block = nil);
      }, -1);
      
      $def(self, '$root!', function $HTML_root$excl$3() {
        var self = this;

        return self.roots.$first()
      }, 0);
      
      $def(self, '$roots!', $return_ivar("roots"), 0);
      
      $def(self, '$element!', $return_ivar("current"), 0);
      
      $def(self, '$extend!', function $HTML_extend$excl$4(element) {
        var block = $HTML_extend$excl$4.$$p || nil, $a, self = this, old = nil, result = nil;

        $HTML_extend$excl$4.$$p = null;
        
        ;
        if (element == null) element = nil;
        $a = [self.current, element], (old = $a[0]), (self.current = $a[1]), $a;
        result = block.$call(self);
        if ($eqeqeq($$$('String'), result)) {
          $send(self.current, 'instance_eval', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

            return (self.inner_html = result)}, {$$arity: 0, $$s: self})
        };
        self.current = old;
        return self;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        return $send(self.roots, 'each', [], block.$to_proc());
      }, 0);
      
      $def(self, '$text', function $$text($a) {
        var block = $$text.$$p || nil, $post_args, fragments, self = this;

        $$text.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        fragments = $post_args;
        if ($truthy(block)) {
          fragments['$<<'](Opal.yieldX(block, []))
        };
        return $send(fragments, 'each', [], function $$6(fragment){var self = $$6.$$s == null ? this : $$6.$$s;

          
          if (fragment == null) fragment = nil;
          return self['$<<'](fragment);}, {$$arity: 1, $$s: self});
      }, -1);
      
      $def(self, '$method_missing', function $$method_missing(name, $a) {
        var block = $$method_missing.$$p || nil, $post_args, args, self = this, content = nil, element = nil, parent = nil, result = nil;

        $$method_missing.$$p = null;
        
        ;
        $post_args = $slice.call(arguments, 1);
        args = $post_args;
        if ($truthy(name.$to_s()['$end_with?']("!"))) {
          return $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [name].concat($to_a(args)), block)
        };
        if (!($truthy(args['$empty?']()) || ($eqeqeq($$$('Hash'), args.$first())))) {
          content = $$$($$$('Paggio'), 'Utils').$heredoc(args.$shift().$to_s())
        };
        element = $send($$('Element'), 'new', [self, name].concat($to_a(args)));
        if ($truthy(content)) {
          element['$<<'](content)
        };
        if ($truthy(block)) {
          
          parent = self.current;
          self.current = element;
          result = block.$call(self);
          self.current = parent;
          if ($eqeqeq($$$('String'), result)) {
            $send(element, 'instance_eval', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

              return (self.inner_html = result)}, {$$arity: 0, $$s: self})
          };
        };
        self['$<<'](element);
        return element;
      }, -2);
      $alias(self, "e", "method_missing");
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        if ($truthy(self.roots['$empty?']())) {
          return "#<HTML(" + (self.version) + ")>"
        } else {
          return "#<HTML(" + (self.version) + "): " + (self.roots.$inspect()['$[]']($range(1, -2, false))) + ">"
        }
      }, 0);
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/dom/comment"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('value');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Comment');

        
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<DOM::Comment: " + (self.$value()) + ">"
        }, 0)
      })($nesting[0], $$('CharacterData'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/utils"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $const_set = Opal.const_set, $truthy = Opal.truthy, $defs = Opal.defs, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,include,extend,!,private,restricted?,allocate,instance_variable_set,native?,raise,warn,encode_uri,to_s,encode,decode,decode_uri,parse_query,build_query');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $a, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set($nesting[0], 'Promise', ($truthy((($a = $$('PromiseV2', 'skip_raise')) ? 'constant' : nil)) ? ($$('PromiseV2')) : ($$$('Promise'))));
    $const_set($nesting[0], 'Size', $$('Struct').$new("width", "height"));
    $const_set($nesting[0], 'Position', $$('Struct').$new("x", "y"));
    (function($base, $parent_nesting) {
      var self = $module($base, 'NativeCachedWrapper');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$included', function $$included(klass) {
        
        
        klass.$include($$$($$('Native'), 'Wrapper'));
        return klass.$extend($$('NativeCachedWrapperClassMethods'));
      }, 1);
      
      $def(self, '$restricted?', function $NativeCachedWrapper_restricted$ques$1() {
        var self = this;
        if (self.restricted == null) self.restricted = nil;

        return self.restricted['$!']()['$!']()
      }, 0);
      return $def(self, '$set_native_reference', function $$set_native_reference(native$) {
        var self = this;

        
        native$.$$opal_native_cached = self;
        return (self["native"] = native$);
      }, 1);
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'NativeCachedWrapperClassMethods');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$private($def(self, '$restricted?', function $NativeCachedWrapperClassMethods_restricted$ques$2(native$) {
        
        
        try {
          typeof(native$.$$try_restricted_access);
        } catch (e) {
          if (e.name == 'SecurityError') return true;
        }
        return false;
      
      }, 1));
      return $def(self, '$new', function $NativeCachedWrapperClassMethods_new$3(native$) {
        var $yield = $NativeCachedWrapperClassMethods_new$3.$$p || nil, self = this, obj = nil;

        $NativeCachedWrapperClassMethods_new$3.$$p = null;
        
        if ($truthy(self['$restricted?'](native$))) {
          
          obj = self.$allocate();
          obj.$instance_variable_set("@native", native$);
          obj.$instance_variable_set("@restricted", true);
          return obj;
        };
        if ($not(self['$native?'](native$))) {
          self.$raise($$('ArgumentError'))
        };
        if ($truthy((typeof(native$.$$opal_native_cached) !== "undefined"))) {
          return native$.$$opal_native_cached
        } else {
          return native$.$$opal_native_cached = $send2(self, $find_super(self, 'new', $NativeCachedWrapperClassMethods_new$3, false, true), 'new', [native$], null)
        };
      }, 1);
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$encode_uri', function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: Object#encode_uri is deprecated. Please use FormData.encode_uri");
      return $$('FormData').$encode_uri(self.$to_s());
    }, 0);
    return $def(self, '$encode_uri_component', function $$encode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: Object#encode_uri_component is deprecated. Please use FormData.encode");
      return $$('FormData').$encode(self.$to_s());
    }, 0);
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$encode_uri_component', function $$encode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: String#encode_uri_component is deprecated. Please use FormData.encode");
      return $$('FormData').$encode(self);
    }, 0);
    
    $def(self, '$encode_uri', function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: String#encode_uri is deprecated. Please use FormData.encode_uri");
      return $$('FormData').$encode_uri(self);
    }, 0);
    
    $def(self, '$decode_uri_component', function $$decode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: String#decode_uri_component is deprecated. Please use FormData.decode");
      return $$('FormData').$decode(self);
    }, 0);
    return $def(self, '$decode_uri', function $$decode_uri() {
      var self = this;

      
      self.$warn("opal-browser: String#decode_uri is deprecated. Please use FormData.decode_uri");
      return $$('FormData').$decode_uri(self);
    }, 0);
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$decode_uri', function $$decode_uri(string) {
      var self = this;

      
      self.$warn("opal-browser: Hash.decode_uri is deprecated. Please use FormData.parse_query");
      return $$('FormData').$parse_query(string);
    }, 1);
    return $def(self, '$encode_uri', function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: Hash#encode_uri is deprecated. Please use FormData.build_query");
      return $$('FormData').$build_query(self);
    }, 0);
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/event/mouse"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,!,nil?,[],include,new,try_convert,supported?,supports?,alias_native,x,screen,y,DOM,==,downcase,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Mouse');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("click", "contextmenu", "dblclick", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseout", "mouseover", "mouseup", "show");
        $defs(self, '$supported?', function $Mouse_supported$ques$1() {
                    if ($gvars.$ == null) $gvars.$ = nil;

          return $gvars.$['$[]']("MouseEvent")['$nil?']()['$!']()
        }, 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Client');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Client_x$eq$2(value) {
              var self = this;

              return self["native"].clientX = value
            }, 1);
            return $def(self, '$y=', function $Client_y$eq$3(value) {
              var self = this;

              return self["native"].clientY = value
            }, 1);
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Layer');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Layer_x$eq$4(value) {
              var self = this;

              return self["native"].layerX = value
            }, 1);
            return $def(self, '$y=', function $Layer_y$eq$5(value) {
              var self = this;

              return self["native"].layerY = value
            }, 1);
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Offset');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Offset_x$eq$6(value) {
              var self = this;

              return self["native"].offsetX = value
            }, 1);
            return $def(self, '$y=', function $Offset_y$eq$7(value) {
              var self = this;

              return self["native"].offsetY= value
            }, 1);
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Page');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Page_x$eq$8(value) {
              var self = this;

              return self["native"].pageX = value
            }, 1);
            return $def(self, '$y=', function $Page_y$eq$9(value) {
              var self = this;

              return self["native"].pageY = value
            }, 1);
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Screen');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Screen_x$eq$10(value) {
              var self = this;

              return self["native"].screenX = value
            }, 1);
            return $def(self, '$y=', function $Screen_y$eq$11(value) {
              var self = this;

              return self["native"].screenY = value
            }, 1);
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Ancestor');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Ancestor_x$eq$12(value) {
              var self = this;

              return self["native"].x = value
            }, 1);
            return $def(self, '$y=', function $Ancestor_y$eq$13(value) {
              var self = this;

              return self["native"].y = value
            }, 1);
          })($nesting[0], null, $nesting);
          
          $def(self, '$x=', function $Definition_x$eq$14(value) {
            var self = this;

            return self["native"].screenX = value
          }, 1);
          
          $def(self, '$y=', function $Definition_y$eq$15(value) {
            var self = this;

            return self["native"].screenY = value
          }, 1);
          
          $def(self, '$alt!', function $Definition_alt$excl$16() {
            var self = this;

            return self["native"].altKey = true
          }, 0);
          
          $def(self, '$ctrl!', function $Definition_ctrl$excl$17() {
            var self = this;

            return self["native"].ctrlKey = true
          }, 0);
          
          $def(self, '$meta!', function $Definition_meta$excl$18() {
            var self = this;

            return self["native"].metaKey = true
          }, 0);
          
          $def(self, '$button=', function $Definition_button$eq$19(value) {
            var self = this;

            return self["native"].button = value
          }, 1);
          
          $def(self, '$client', function $$client() {
            var self = this;

            return $$('Client').$new(self["native"])
          }, 0);
          
          $def(self, '$layer', function $$layer() {
            var self = this;

            return $$('Layer').$new(self["native"])
          }, 0);
          
          $def(self, '$offset', function $$offset() {
            var self = this;

            return $$('Offset').$new(self["native"])
          }, 0);
          
          $def(self, '$page', function $$page() {
            var self = this;

            return $$('Page').$new(self["native"])
          }, 0);
          
          $def(self, '$screen', function $$screen() {
            var self = this;

            return $$('Screen').$new(self["native"])
          }, 0);
          
          $def(self, '$ancestor', function $$ancestor() {
            var self = this;

            return $$('Ancestor').$new(self["native"])
          }, 0);
          
          $def(self, '$related=', function $Definition_related$eq$20(elem) {
            var self = this;

            return self["native"].relatedTarget = $$('Native').$try_convert(elem)
          }, 1);
          
          $def(self, '$from=', function $Definition_from$eq$21(elem) {
            var self = this;

            return self["native"].fromElement = $$('Native').$try_convert(elem)
          }, 1);
          return $def(self, '$to=', function $Definition_to$eq$22(elem) {
            var self = this;

            return self["native"].toElement = $$('Native').$try_convert(elem)
          }, 1);
        })($nesting[0], $$$($$('UI'), 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new MouseEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("MouseEvent");
            event.initMouseEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.detail || 0,
              desc.screenX || 0, desc.screenY || 0,
              desc.clientX || 0, desc.clientY || 0,
              desc.ctrlKey || false, desc.altKey || false,
              desc.shiftKey || false, desc.metaKey || false,
              desc.button || 0, desc.relatedTarget || null);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("button");
        
        $def(self, '$client', function $$client() {
          var self = this;

          return $$('Position').$new(self["native"].clientX, self["native"].clientY)
        }, 0);
        
        $def(self, '$layer', function $$layer() {
          var self = this;

          if ($truthy(self["native"].layerX == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].layerX, self["native"].layerY)
          }
        }, 0);
        
        $def(self, '$offset', function $$offset() {
          var self = this;

          if ($truthy(self["native"].offsetX == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].offsetX, self["native"].offsetY)
          }
        }, 0);
        
        $def(self, '$page', function $$page() {
          var self = this;

          if ($truthy(self["native"].pageX == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].pageX, self["native"].pageY)
          }
        }, 0);
        
        $def(self, '$screen', function $$screen() {
          var self = this;

          if ($truthy(self["native"].screenX == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].screenX, self["native"].screenY)
          }
        }, 0);
        
        $def(self, '$ancestor', function $$ancestor() {
          var self = this;

          if ($truthy(self["native"].x == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].x, self["native"].y)
          }
        }, 0);
        
        $def(self, '$x', function $$x() {
          var self = this;

          return self.$screen().$x()
        }, 0);
        
        $def(self, '$y', function $$y() {
          var self = this;

          return self.$screen().$y()
        }, 0);
        
        $def(self, '$related', function $$related() {
          var self = this;

          if ($truthy(self["native"].relatedTarget == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].relatedTarget)
          }
        }, 0);
        
        $def(self, '$from', function $$from() {
          var self = this;

          if ($truthy(self["native"].fromElement == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].fromElement)
          }
        }, 0);
        
        $def(self, '$to', function $$to() {
          var self = this;

          if ($truthy(self["native"].toElement == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].toElement)
          }
        }, 0);
        
        $def(self, '$click?', function $Mouse_click$ques$23() {
          var self = this;

          return self.$name().$downcase()['$==']("click")
        }, 0);
        
        $def(self, '$double_click?', function $Mouse_double_click$ques$24() {
          var self = this;

          return self.$name().$downcase()['$==']("dblclick")
        }, 0);
        
        $def(self, '$down?', function $Mouse_down$ques$25() {
          var self = this;

          return self.$name().$downcase()['$==']("mousedown")
        }, 0);
        
        $def(self, '$enter?', function $Mouse_enter$ques$26() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseenter")
        }, 0);
        
        $def(self, '$leave?', function $Mouse_leave$ques$27() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseleave")
        }, 0);
        
        $def(self, '$move?', function $Mouse_move$ques$28() {
          var self = this;

          return self.$name().$downcase()['$==']("mousemove")
        }, 0);
        
        $def(self, '$out?', function $Mouse_out$ques$29() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseout")
        }, 0);
        
        $def(self, '$over?', function $Mouse_over$ques$30() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseover")
        }, 0);
        
        $def(self, '$up?', function $Mouse_up$ques$31() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseup")
        }, 0);
        return $def(self, '$show?', function $Mouse_show$ques$32() {
          var self = this;

          return self.$name().$downcase()['$==']("show")
        }, 0);
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["json"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $Object = Opal.Object, $hash2 = Opal.hash2, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs, $truthy = Opal.truthy, $def = Opal.def, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,new,push,[]=,[],create_id,json_create,const_get,attr_accessor,create_id=,===,parse,generate,from_object,merge,to_json,responds_to?,to_io,write,to_s,to_a,strftime');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'JSON');

    var $a, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $klass($nesting[0], $$('StandardError'), 'JSONError');
    $klass($nesting[0], $$('JSONError'), 'ParserError');
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$('JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'undefined':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (options.array_class).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (options.object_class).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                ($a = [k, to_opal(value[k], options)], $send((hash), '[]=', $a), $a[$a.length - 1]);
              }
            }

            if (!options.parse && (klass = (hash)['$[]']($$('JSON').$create_id())) != nil) {
              return $Object.$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    self['$create_id=']("json_class");
    $defs(self, '$[]', function $JSON_$$$1(value, options) {
      var self = this;

      
      if (options == null) options = $hash2([], {});
      if ($eqeqeq($$('String'), value)) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, -2);
    $defs(self, '$parse', function $$parse(source, options) {
      var self = this;

      
      if (options == null) options = $hash2([], {});
      return self.$from_object($parse(source), options.$merge($hash2(["parse"], {"parse": true})));
    }, -2);
    $defs(self, '$parse!', function $JSON_parse$excl$2(source, options) {
      var self = this;

      
      if (options == null) options = $hash2([], {});
      return self.$parse(source, options);
    }, -2);
    $defs(self, '$load', function $$load(source, options) {
      var self = this;

      
      if (options == null) options = $hash2([], {});
      return self.$from_object($parse(source), options);
    }, -2);
    $defs(self, '$from_object', function $$from_object(js_object, options) {
      var $ret_or_1 = nil;

      
      if (options == null) options = $hash2([], {});
      if ($truthy(($ret_or_1 = options['$[]']("object_class")))) {
        $ret_or_1
      } else {
        options['$[]=']("object_class", $$('Hash'))
      };
      if ($truthy(($ret_or_1 = options['$[]']("array_class")))) {
        $ret_or_1
      } else {
        options['$[]=']("array_class", $$('Array'))
      };
      return to_opal(js_object, options.$$smap);;
    }, -2);
    $defs(self, '$generate', function $$generate(obj, options) {
      
      
      if (options == null) options = $hash2([], {});
      return obj.$to_json(options);
    }, -2);
    return $defs(self, '$dump', function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      if (io == null) io = nil;
      if (limit == null) limit = nil;
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()
        };
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, 0)
  })($nesting[0], null);
  (function($base) {
    var self = $module($base, 'Enumerable');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    }, 0)
  })($nesting[0]);
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(',') + ']';
    
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Hash');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
      }

      return '{' + result.join(',') + '}';
    
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_json', $return_val("null"), 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.toString();
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return JSON.stringify(self);
    }, 0)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    }, 0)
  })($nesting[0], null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Date');

    
    
    
    $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    }, 0);
    return $def(self, '$as_json', function $$as_json() {
      var self = this;

      return self.$to_s()
    }, 0);
  })($nesting[0], null);
};

Opal.modules["browser/event/base"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $thrower = Opal.thrower, $lambda = Opal.lambda, $to_a = Opal.to_a, $const_set = Opal.const_set, $eqeq = Opal.eqeq, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,call,to_n,<<,converters,native?,each,instance_eval,register,to_proc,attr_reader,new,stopped?,arguments,!,prevented?,class_for,off,target,[],delegated,delete,last,empty?,first,raise,name_for,handlers,[]=,include?,callback=,on!,delegate,on,handlers=,push,callbacks,attach,attach!,supports?,name,==,event,warn,===,detach,gsub,delete_if,=~,clear,none?,is_a?,create,dispatch,trigger,bubbles=,private,nil?,dup,on=,parent');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$$($$('Native'), 'Wrapper'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Definition');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        $defs(self, '$new', function $Definition_new$1() {
          var block = $Definition_new$1.$$p || nil, self = this, data = nil;

          $Definition_new$1.$$p = null;
          
          ;
          data = $send2(self, $find_super(self, 'new', $Definition_new$1, false, true), 'new', [{ bubbles: true, cancelable: true }], null);
          if ($truthy(block)) {
            block.$call(data)
          };
          return data.$to_n();
        }, 0);
        
        $def(self, '$bubbles=', function $Definition_bubbles$eq$2(value) {
          var self = this;

          return self["native"].bubbles = value
        }, 1);
        return $def(self, '$cancelable=', function $Definition_cancelable$eq$3(value) {
          var self = this;

          return self["native"].cancelable = value
        }, 1);
      })($nesting[0], null, $nesting);
      return (function($base, $parent_nesting) {
        var self = $module($base, 'Target');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$converters', function $$converters() {
          var self = this, $ret_or_1 = nil;
          if (self.converters == null) self.converters = nil;

          return (self.converters = ($truthy(($ret_or_1 = self.converters)) ? ($ret_or_1) : ([])))
        }, 0);
        $defs(self, '$register', function $$register() {
          var block = $$register.$$p || nil, self = this;

          $$register.$$p = null;
          
          ;
          return self.$converters()['$<<'](block);
        }, 0);
        $defs(self, '$convert', function $$convert(value) {try { var $t_return = $thrower('return'); 
          var self = this;

          
          if (!$truthy(self['$native?'](value))) {
            return value
          };
          $send(self.$converters(), 'each', [], function $$4(block){var result = nil;

            
            if (block == null) block = nil;
            if ($truthy((result = block.$call(value)))) {
              $t_return.$throw(result)
            } else {
              return nil
            };}, {$$arity: 1, $$ret: $t_return});
          return nil;} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          }
        }, 1);
        $defs(self, '$included', function $$included(klass) {
          var self = this;

          return $send(klass, 'instance_eval', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

            return $defs(self, '$target', function $$target() {
              var block = $$target.$$p || nil;

              $$target.$$p = null;
              
              ;
              return $send($$$($$('Event'), 'Target'), 'register', [], block.$to_proc());
            }, 0)}, {$$arity: 0, $$s: self})
        }, 1);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Callback');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.proc = $proto.name = nil;
          
          self.$attr_reader("target", "name", "selector");
          
          $def(self, '$initialize', function $$initialize(target, name, selector) {
            var block = $$initialize.$$p || nil, self = this;

            $$initialize.$$p = null;
            
            ;
            if (selector == null) selector = nil;
            self.target = target;
            self.name = name;
            self.selector = selector;
            return (self.block = block);
          }, -3);
          
          $def(self, '$call', function $$call(event) {
            var self = this;

            return self.$to_proc().$call(event)
          }, 1);
          
          $def(self, '$to_proc', function $$to_proc() {
            var self = this, $ret_or_1 = nil;

            return (self.proc = (function() {if ($truthy(($ret_or_1 = self.proc))) {
              return $ret_or_1
            } else {
              return $lambda(function $$6(event){var self = $$6.$$s == null ? this : $$6.$$s;
                if (self.block == null) self.block = nil;

                
                if (event == null) event = nil;
                
            if (!event.currentTarget) {
              event.currentTarget = self.target.native;
            }
          ;
                event = $$('Event').$new(event, self);
                if (!$truthy(event['$stopped?']())) {
                  $send(self.block, 'call', [event].concat($to_a(event.$arguments())))
                };
                return event['$prevented?']()['$!']();}, {$$arity: 1, $$s: self})
            }})())
          }, 0);
          
          $def(self, '$event', function $$event() {
            var self = this;

            return $$('Event').$class_for(self.name)
          }, 0);
          return $def(self, '$off', function $$off() {
            var self = this;

            return self.$target().$off(self)
          }, 0);
        })($nesting[0], null, $nesting);
        (function($base, $super) {
          var self = $klass($base, $super, 'Delegate');

          var $proto = self.$$prototype;

          $proto.target = $proto.name = $proto.pair = nil;
          
          
          $def(self, '$initialize', function $$initialize(target, name, pair) {
            var self = this;

            
            self.target = target;
            self.name = name;
            return (self.pair = pair);
          }, 3);
          return $def(self, '$off', function $$off() {
            var self = this, delegate = nil;

            
            delegate = self.target.$delegated()['$[]'](self.name);
            delegate.$last().$delete(self.pair);
            if ($truthy(delegate.$last()['$empty?']())) {
              
              delegate.$first().$off();
              return delegate.$delete(self.name);
            } else {
              return nil
            };
          }, 0);
        })($nesting[0], null);
        $const_set($nesting[0], 'Delegates', $$('Struct').$new("callback", "handlers"));
        
        $def(self, '$on', function $$on(name, selector) {
          var block = $$on.$$p || nil, $a, self = this, delegate = nil, pair = nil, callback = nil;

          $$on.$$p = null;
          
          ;
          if (selector == null) selector = nil;
          if (!$truthy(block)) {
            self.$raise($$('ArgumentError'), "no block has been given")
          };
          name = $$('Event').$name_for(name);
          if ($truthy(selector)) {
            if ($truthy((delegate = self.$delegated()['$[]'](name)))) {
              
              pair = [selector, block];
              delegate.$handlers()['$<<'](pair);
              return $$('Delegate').$new(self, name, pair);
            } else {
              
              delegate = ($a = [name, $$('Delegates').$new()], $send(self.$delegated(), '[]=', $a), $a[$a.length - 1]);
              if ($truthy(["blur", "focus"]['$include?'](name))) {
                delegate['$callback=']($send(self, 'on!', [name], function $$7(e){var self = $$7.$$s == null ? this : $$7.$$s;

                  
                  if (e == null) e = nil;
                  return self.$delegate(delegate, e);}, {$$arity: 1, $$s: self}))
              } else {
                delegate['$callback=']($send(self, 'on', [name], function $$8(e){var self = $$8.$$s == null ? this : $$8.$$s;

                  
                  if (e == null) e = nil;
                  return self.$delegate(delegate, e);}, {$$arity: 1, $$s: self}))
              };
              pair = [selector, block];
              delegate['$handlers=']([pair]);
              return $$('Delegate').$new(self, name, pair);
            }
          } else {
            
            callback = $send($$('Callback'), 'new', [self, name, selector], block.$to_proc());
            self.$callbacks().$push(callback);
            return self.$attach(callback);
          };
        }, -2);
        
        $def(self, '$on!', function $Target_on$excl$9(name) {
          var block = $Target_on$excl$9.$$p || nil, self = this, callback = nil;

          $Target_on$excl$9.$$p = null;
          
          ;
          if (!$truthy(block)) {
            self.$raise($$('ArgumentError'), "no block has been given")
          };
          name = $$('Event').$name_for(name);
          callback = $send($$('Callback'), 'new', [self, name], block.$to_proc());
          self.$callbacks().$push(callback);
          return self['$attach!'](callback);
        }, 1);
        if ($truthy($$('Browser')['$supports?']("Event.addListener"))) {
          
          
          $def(self, '$attach', function $$attach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            self["native"].addEventListener(callback.$name(), callback.$to_proc());
            return callback;
          }, 1);
          
          $def(self, '$attach!', function $Target_attach$excl$10(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            self["native"].addEventListener(callback.$name(), callback.$to_proc(), true);
            return callback;
          }, 1);
        } else if ($truthy($$('Browser')['$supports?']("Event.attach"))) {
          
          
          $def(self, '$attach', function $$attach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            if ($eqeq(callback.$event(), $$('Custom'))) {
              
            if (!self["native"].$custom) {
              self["native"].$custom = function(event) {
                for (var i = 0, length = self["native"].$callbacks.length; i < length; i++) {
                  var callback = self["native"].$callbacks[i];

                  if ((callback).$event()['$==']($$('Custom'))) {
                    event.type = callback.name;

                    (callback).$call(event);
                  }
                }
              };

              self["native"].attachEvent("ondataavailable", self["native"].$custom);
            }
          
            } else {
              self["native"].attachEvent("on" + callback.$name(), callback.$to_proc())
            };
            return callback;
          }, 1);
          
          $def(self, '$attach!', function $Target_attach$excl$11(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            
            switch (callback.$name()) {
              case "blur":
                self["native"].attachEvent("onfocusout", callback.$to_proc())
                break;
              case "focus":
                self["native"].attachEvent("onfocusin", callback.$to_proc())
                break;
              default:
                
                self.$warn("attach: capture doesn't work on this browser");
                self.$attach(callback);
            };
            return callback;
          }, 1);
        } else {
          
          
          $def(self, '$attach', function $$attach($a) {
            var $post_args, $rest_arg, self = this;

            
            $post_args = $slice.call(arguments);
            $rest_arg = $post_args;
            return self.$raise($$('NotImplementedError'));
          }, -1);
          
          $def(self, '$attach!', function $Target_attach$excl$12($a) {
            var $post_args, $rest_arg, self = this;

            
            $post_args = $slice.call(arguments);
            $rest_arg = $post_args;
            return self.$raise($$('NotImplementedError'));
          }, -1);
        };
        
        $def(self, '$one', function $$one(name, selector) {
          var block = $$one.$$p || nil, self = this, cb = nil;

          $$one.$$p = null;
          
          ;
          if (selector == null) selector = nil;
          if (!$truthy(block)) {
            self.$raise($$('ArgumentError'), "no block has been given")
          };
          return (cb = $send(self, 'on', [name, selector], function $$13($a){var $post_args, args, out = nil;

            
            $post_args = $slice.call(arguments);
            args = $post_args;
            out = $send(block, 'call', $to_a(args));
            cb.$off();
            return out;}, -1));
        }, -2);
        
        $def(self, '$off', function $$off(what) {
          var self = this, $ret_or_1 = nil;

          
          if (what == null) what = nil;
          if ($eqeqeq($$('Callback'), ($ret_or_1 = what))) {
            
            self.$callbacks().$delete(what);
            return self.$detach(what);
          } else if ($eqeqeq($$('String'), $ret_or_1)) {
            if (($truthy(what['$include?']("*")) || ($truthy(what['$include?']("?"))))) {
              return self.$off($$('Regexp').$new(what.$gsub(/\*/, ".*?").$gsub(/\?/, ".")))
            } else {
              
              what = $$('Event').$name_for(what);
              return $send(self.$callbacks(), 'delete_if', [], function $$14(callback){var self = $$14.$$s == null ? this : $$14.$$s;

                
                if (callback == null) callback = nil;
                if ($eqeq(callback.$name(), what)) {
                  
                  self.$detach(callback);
                  return true;
                } else {
                  return nil
                };}, {$$arity: 1, $$s: self});
            }
          } else if ($eqeqeq($$('Regexp'), $ret_or_1)) {
            return $send(self.$callbacks(), 'delete_if', [], function $$15(callback){var self = $$15.$$s == null ? this : $$15.$$s;

              
              if (callback == null) callback = nil;
              if ($truthy(callback.$name()['$=~'](what))) {
                
                self.$detach(callback);
                return true;
              } else {
                return nil
              };}, {$$arity: 1, $$s: self})
          } else {
            
            $send(self.$callbacks(), 'each', [], function $$16(callback){var self = $$16.$$s == null ? this : $$16.$$s;

              
              if (callback == null) callback = nil;
              return self.$detach(callback);}, {$$arity: 1, $$s: self});
            return self.$callbacks().$clear();
          };
        }, -1);
        if ($truthy($$('Browser')['$supports?']("Event.removeListener"))) {
          
          $def(self, '$detach', function $$detach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            return self["native"].removeEventListener(callback.$name(), callback.$to_proc(), false)
          }, 1)
        } else if ($truthy($$('Browser')['$supports?']("Event.detach"))) {
          
          $def(self, '$detach', function $$detach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            if ($eqeq(callback.$event(), $$('Custom'))) {
              if ($truthy($send(self.$callbacks(), 'none?', [], function $$17(c){
                
                if (c == null) c = nil;
                return c.$event()['$==']($$('Custom'));}, 1))) {
                
              self["native"].detachEvent("ondataavailable", self["native"].$custom);

              delete self["native"].$custom;
            
              } else {
                return nil
              }
            } else {
              return self["native"].detachEvent("on" + callback.$name(), callback.$to_proc())
            }
          }, 1)
        } else {
          
          $def(self, '$detach', function $$detach(callback) {
            var self = this;

            return self.$raise($$('NotImplementedError'))
          }, 1)
        };
        
        $def(self, '$trigger', function $$trigger(event, $a) {
          var block = $$trigger.$$p || nil, $post_args, args, self = this;

          $$trigger.$$p = null;
          
          ;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          if ($truthy(event['$is_a?']($$('String')))) {
            event = $send($$('Event'), 'create', [event].concat($to_a(args)), block.$to_proc())
          };
          return self.$dispatch(event);
        }, -2);
        
        $def(self, '$trigger!', function $Target_trigger$excl$18(event, $a) {
          var block = $Target_trigger$excl$18.$$p || nil, $post_args, args, self = this;

          $Target_trigger$excl$18.$$p = null;
          
          ;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          return $send(self, 'trigger', [event].concat($to_a(args)), function $$19(e){var $b;

            
            if (e == null) e = nil;
            if ($truthy(block)) {
              block.$call(e)
            };
            return ($b = [false], $send(e, 'bubbles=', $b), $b[$b.length - 1]);}, 1);
        }, -2);
        if ($truthy($$('Browser')['$supports?']("Event.dispatch"))) {
          
          $def(self, '$dispatch', function $$dispatch(event) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            return self["native"].dispatchEvent(event.$to_n())
          }, 1)
        } else if ($truthy($$('Browser')['$supports?']("Event.fire"))) {
          
          $def(self, '$dispatch', function $$dispatch(event) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            if ($eqeqeq($$('Custom'), event)) {
              return self["native"].fireEvent("ondataavailable", event.$to_n())
            } else {
              return self["native"].fireEvent("on" + event.$name(), event.$to_n())
            }
          }, 1)
        } else {
          
          $def(self, '$dispatch', function $$dispatch($a) {
            var $post_args, $rest_arg, self = this;

            
            $post_args = $slice.call(arguments);
            $rest_arg = $post_args;
            return self.$raise($$('NotImplementedError'));
          }, -1)
        };
        self.$private();
        
        $def(self, '$callbacks', function $$callbacks() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          
        if (!self["native"].$callbacks) {
          self["native"].$callbacks = [];
        }

        return self["native"].$callbacks;
      
        }, 0);
        
        $def(self, '$delegated', function $$delegated() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          
        if (!self["native"].$delegated) {
          self["native"].$delegated = $hash2([], {});
        }

        return self["native"].$delegated;
      
        }, 0);
        return $def(self, '$delegate', function $$delegate(delegates, event, element) {
          var self = this;

          
          if (element == null) element = event.$target();
          if (($truthy(element['$nil?']()) || ($eqeq(element, event.$on())))) {
            return nil
          };
          $send(delegates.$handlers(), 'each', [], function $$20(selector, block){var new$ = nil;

            
            if (selector == null) selector = nil;
            if (block == null) block = nil;
            if ($truthy(element['$=~'](selector))) {
              
              new$ = event.$dup();
              new$['$on='](element);
              return $send(block, 'call', [new$].concat($to_a(new$.$arguments())));
            } else {
              return nil
            };}, 2);
          return self.$delegate(delegates, event, element.$parent());
        }, -3);
      })($nesting[0], $nesting);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/custom"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $range = Opal.range, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $slice = Opal.slice, $to_a = Opal.to_a, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,supports?,end_with?,[],to_n,merge!,Native,new,has_key?');
  
  self.$require("ostruct");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Custom');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.detail = nil;
        
        $defs(self, '$supported?', function $Custom_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Custom")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$method_missing', function $$method_missing(name, value) {
            var self = this;

            if ($truthy(name['$end_with?']("="))) {
              return self["native"][name['$[]']($range(0, -2, false))] = value
            } else {
              return nil
            }
          }, 2)
        })($nesting[0], $$('Definition'));
        if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
          $defs(self, '$construct', function $$construct(name, desc) {
            
            return new CustomEvent(name, {
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc })
          }, 2)
        } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
          $defs(self, '$construct', function $$construct(name, desc) {
            
            
        var event = document.createEvent("CustomEvent");
            event.initCustomEvent(name, desc.bubbles, desc.cancelable, desc);

        return event;
      
          }, 2)
        } else if ($truthy($$('Browser')['$supports?']("Event.createObject"))) {
          $defs(self, '$construct', function $$construct(name, desc) {
            var self = this;

            return self.$Native(document.createEventObject())['$merge!']({
        type:       name,
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc }).$to_n()
          }, 2)
        } else {
          $defs(self, '$construct', function $$construct(name, desc) {
            var self = this;

            return self.$Native(desc)['$merge!']({
        type:       name,
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc }).$to_n()
          }, 2)
        };
        
        $def(self, '$initialize', function $$initialize(event, callback) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          if (callback == null) callback = nil;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [event, callback], null);
          return (self.detail = $$('Hash').$new(event.detail));
        }, -2);
        return $def(self, '$method_missing', function $$method_missing(id, $a) {
          var $post_args, $rest_arg, $yield = $$method_missing.$$p || nil, self = this;

          $$method_missing.$$p = null;
          
          $post_args = $slice.call(arguments, 1);
          $rest_arg = $post_args;
          if ($truthy(self.detail['$has_key?'](id))) {
            return self.detail['$[]'](id)
          };
          return $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [id].concat($to_a($rest_arg)), $yield);
        }, -2);
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/window/size"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $truthy = Opal.truthy, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('to_n,===,first,values_at,width,height,supports?,raise,set');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Size');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        
        $def(self, '$initialize', function $$initialize(window) {
          var self = this;

          
          self.window = window;
          return (self["native"] = window.$to_n());
        }, 1);
        
        $def(self, '$set', function $$set($a) {
          var $post_args, args, $b, $c, self = this, width = nil, height = nil, $ret_or_1 = nil;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          if ($eqeqeq($$('Hash'), args.$first())) {
            $c = args.$first().$values_at("width", "height"), $b = $to_ary($c), (width = ($b[0] == null ? nil : $b[0])), (height = ($b[1] == null ? nil : $b[1])), $c
          } else {
            $c = args, $b = $to_ary($c), (width = ($b[0] == null ? nil : $b[0])), (height = ($b[1] == null ? nil : $b[1])), $c
          };
          width = ($truthy(($ret_or_1 = width)) ? ($ret_or_1) : (self.$width()));
          height = ($truthy(($ret_or_1 = height)) ? ($ret_or_1) : (self.$height()));
          self["native"].resizeTo(width, height);
          return self;
        }, -1);
        if ($truthy($$('Browser')['$supports?']("Window.outerSize"))) {
          
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].outerWidth
          }, 0);
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].outerHeight
          }, 0);
        } else {
          
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window outer size not supported")
          }, 0);
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window outer size not supported")
          }, 0);
        };
        
        $def(self, '$width=', function $Size_width$eq$1(value) {
          var self = this;

          return self.$set($hash2(["width"], {"width": value}))
        }, 1);
        
        $def(self, '$height=', function $Size_height$eq$2(value) {
          var self = this;

          return self.$set($hash2(["height"], {"height": value}))
        }, 1);
        
        $def(self, '$inner_width', function $$inner_width() {
          var self = this;

          return self["native"].innerWidth
        }, 0);
        return $def(self, '$inner_height', function $$inner_height() {
          var self = this;

          return self["native"].innerHeight
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/ui"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'UI');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$supported?', function $UI_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.UI")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$detail=', function $Definition_detail$eq$2(value) {
            var self = this;

            return self["native"].detail = value
          }, 1);
          return $def(self, '$view=', function $Definition_view$eq$3(value) {
            var self = this;

            return self["native"].view = value
          }, 1);
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new UIEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("UIEvent");
            event.initUIEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.detail || 0);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("detail");
        return self.$alias_native("view");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/document_fragment"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $defs = Opal.defs, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('==,new,create_document_fragment');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DocumentFragment');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$new', function $DocumentFragment_new$1(node) {
          var $yield = $DocumentFragment_new$1.$$p || nil, self = this;

          $DocumentFragment_new$1.$$p = null;
          if ($eqeq(self, $$('DocumentFragment'))) {
            if ($truthy((typeof(node.mode) !== "undefined"))) {
              return $$('ShadowRoot').$new(node)
            } else {
              return $send2(self, $find_super(self, 'new', $DocumentFragment_new$1, false, true), 'new', [node], $yield)
            }
          } else {
            return $send2(self, $find_super(self, 'new', $DocumentFragment_new$1, false, true), 'new', [node], $yield)
          }
        }, 1);
        return $defs(self, '$create', function $$create() {
                    if ($gvars.document == null) $gvars.document = nil;

          return $gvars.document.$create_document_fragment()
        }, 0);
      })($nesting[0], $$('Element'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/node_set"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $send = Opal.send, $defs = Opal.defs, $assign_ivar = Opal.assign_ivar, $def = Opal.def, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $thrower = Opal.thrower, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,uniq,map,flatten,DOM,convert,respond_to?,each,__send__,to_proc,===,at_css,at_xpath,[],css,select,=~,search,join,xpath,to_ary');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NodeSet');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.literal = nil;
        
        $defs(self, '$[]', function $NodeSet_$$$1($a) {
          var $post_args, nodes, self = this;

          
          $post_args = $slice.call(arguments);
          nodes = $post_args;
          return self.$new($send(nodes.$flatten(), 'map', [], function $$2(x){var self = $$2.$$s == null ? this : $$2.$$s;

            
            if (x == null) x = nil;
            return self.$DOM($$('Native').$convert(x));}, {$$arity: 1, $$s: self}).$uniq());
        }, -1);
        
        $def(self, '$initialize', $assign_ivar("literal"), 0);
        
        $def(self, '$method_missing', function $$method_missing(name, $a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this, result = nil;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          if (!$truthy(self.literal['$respond_to?'](name))) {
            
            $send(self, 'each', [], function $$3(el){
              
              if (el == null) el = nil;
              return $send(el, '__send__', [name].concat($to_a(args)), block.$to_proc());}, 1);
            return self;
          };
          result = $send(self.literal, '__send__', [name].concat($to_a(args)), block.$to_proc());
          if ($truthy(result === self.literal)) {
            return self
          } else if ($eqeqeq($$('Array'), result)) {
            return $$('NodeSet').$new(result)
          } else {
            return result
          };
        }, -2);
        
        $def(self, '$respond_to_missing?', function $NodeSet_respond_to_missing$ques$4(name, $a) {
          var $post_args, $rest_arg, self = this;

          
          $post_args = $slice.call(arguments, 1);
          $rest_arg = $post_args;
          return self.literal['$respond_to?'](name);
        }, -2);
        
        $def(self, '$at_css', function $$at_css($a) {try { var $t_return = $thrower('return'); 
          var $post_args, rules, self = this;

          
          $post_args = $slice.call(arguments);
          rules = $post_args;
          $send(self, 'each', [], function $$5(node){
            
            if (node == null) node = nil;
            if ($truthy((node = $send(node, 'at_css', $to_a(rules))))) {
              $t_return.$throw(node)
            } else {
              return nil
            };}, {$$arity: 1, $$ret: $t_return});
          return nil;} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          }
        }, -1);
        
        $def(self, '$at_xpath', function $$at_xpath($a) {try { var $t_return = $thrower('return'); 
          var $post_args, paths, self = this;

          
          $post_args = $slice.call(arguments);
          paths = $post_args;
          $send(self, 'each', [], function $$6(node){
            
            if (node == null) node = nil;
            if ($truthy((node = $send(node, 'at_xpath', $to_a(paths))))) {
              $t_return.$throw(node)
            } else {
              return nil
            };}, {$$arity: 1, $$ret: $t_return});
          return nil;} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          }
        }, -1);
        
        $def(self, '$css', function $$css(path) {
          var self = this;

          return $$('NodeSet')['$[]']($send(self.literal, 'map', [], function $$7(node){
            
            if (node == null) node = nil;
            return node.$css(path);}, 1))
        }, 1);
        
        $def(self, '$filter', function $$filter(expression) {
          var self = this;

          return $$('NodeSet')['$[]']($send(self.literal, 'select', [], function $$8(node){
            
            if (node == null) node = nil;
            return node['$=~'](expression);}, 1))
        }, 1);
        
        $def(self, '$search', function $$search($a) {
          var $post_args, what, self = this;

          
          $post_args = $slice.call(arguments);
          what = $post_args;
          return $$('NodeSet')['$[]']($send(self.literal, 'map', [], function $$9(node){
            
            if (node == null) node = nil;
            return $send(node, 'search', $to_a(what));}, 1));
        }, -1);
        
        $def(self, '$outer_html', function $$outer_html() {
          var self = this;

          return $send(self.literal, 'map', [], "outer_html".$to_proc()).$join()
        }, 0);
        
        $def(self, '$xpath', function $$xpath(path) {
          var self = this;

          return $$('NodeSet')['$[]']($send(self.literal, 'map', [], function $$10(node){
            
            if (node == null) node = nil;
            return node.$xpath(path);}, 1))
        }, 1);
        
        $def(self, '$to_ary', $return_ivar("literal"), 0);
        return $alias(self, "to_a", "to_ary");
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["buffer"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,!,nil?,[],===,native?,new,pack,to_a,length');
  
  self.$require("native");
  self.$require("buffer/array");
  self.$require("buffer/view");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    $defs(self, '$supported?', function $Buffer_supported$ques$1() {
            if ($gvars.$ == null) $gvars.$ = nil;

      return $gvars.$['$[]']("ArrayBuffer")['$nil?']()['$!']()
    }, 0);
    $defs(self, '$name_for', function $$name_for(bits, type) {
      var part = nil, $ret_or_1 = nil;

      
      part = ($eqeqeq("unsigned", ($ret_or_1 = type)) ? ("Uint") : ($eqeqeq("signed", $ret_or_1) ? ("Int") : ($eqeqeq("float", $ret_or_1) ? ("Float") : (nil))));
      return "" + (part) + (bits);
    }, 2);
    
    $def(self, '$initialize', function $$initialize(size, bits) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (bits == null) bits = 8;
      if ($truthy(self['$native?'](size))) {
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], null)
      } else {
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new ArrayBuffer(size * (bits / 8))], null)
      };
    }, -2);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self["native"].byteLength
    }, 0);
    
    $def(self, '$to_a', function $$to_a(bits, type) {
      var self = this;

      
      if (bits == null) bits = 8;
      if (type == null) type = "unsigned";
      return $$('Array').$new(self, bits, type);
    }, -1);
    
    $def(self, '$view', function $$view(offset, length) {
      var self = this;

      
      if (offset == null) offset = nil;
      if (length == null) length = nil;
      return $$('View').$new(self, offset, length);
    }, -1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.$to_a().$to_a().$pack("c*")
    }, 0);
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/form_data"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, $hash2 = Opal.hash2, $truthy = Opal.truthy, $not = Opal.not, $defs = Opal.defs, $to_ary = Opal.to_ary, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,===,each,!=,+,flatten,first,split,scan,proc,call,<<,last,[],[]=,!,any?,include?,class,join,map,encode,to_s,create,unflatten,to_proc,method,new,extend,build_form_data,to_n,convert,from_native,set,to_a,to_h');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'FormData');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$('NativeCachedWrapper'));
      (function($base, $parent_nesting) {
        var self = $module($base, 'Converter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$encode', function $$encode(string) {
          
          return encodeURIComponent(string)
        }, 1);
        
        $def(self, '$decode', function $$decode(string) {
          
          return decodeURIComponent(string)
        }, 1);
        
        $def(self, '$encode_uri', function $$encode_uri(string) {
          
          return encodeURI(string)
        }, 1);
        
        $def(self, '$decode_uri', function $$decode_uri(string) {
          
          return decodeURI(string)
        }, 1);
        
        $def(self, '$flatten', function $$flatten(value, key) {
          var self = this, $ret_or_1 = nil, out = nil;

          
          if (key == null) key = "";
          if ($eqeqeq($$('Hash'), ($ret_or_1 = value))) {
            
            out = [];
            $send(value, 'each', [], function $$1(k, v){var self = $$1.$$s == null ? this : $$1.$$s;

              
              if (k == null) k = nil;
              if (v == null) v = nil;
              if ($neqeq(key, "")) {
                k = "" + (key) + "[" + (k) + "]"
              };
              return (out = $rb_plus(out, self.$flatten(v, k)));}, {$$arity: 2, $$s: self});
            return out;
          } else if ($eqeqeq($$('Array'), $ret_or_1)) {
            
            out = [];
            $send(value, 'each', [], function $$2(v){var self = $$2.$$s == null ? this : $$2.$$s, k = nil;

              
              if (v == null) v = nil;
              k = "" + (key) + "[]";
              return (out = $rb_plus(out, self.$flatten(v, k)));}, {$$arity: 1, $$s: self});
            return out;
          } else {
            return [[key, value]]
          };
        }, -2);
        
        $def(self, '$unflatten', function $$unflatten(array) {
          var self = this, out = nil;

          
          out = $hash2([], {});
          $send(array, 'each', [], function $$3(k, v){var self = $$3.$$s == null ? this : $$3.$$s, path = nil, c = nil, set = nil;

            
            if (k == null) k = nil;
            if (v == null) v = nil;
            path = $rb_plus([k.$split("[").$first()], k.$scan(/\[(.*?)\]/).$flatten());
            c = out;
            set = $send(self, 'proc', [], function $$4(v, weak){
              
              if (v == null) v = nil;
              if (weak == null) weak = nil;
              return nil;}, 2);
            $send(path, 'each', [], function $$5(i){var self = $$5.$$s == null ? this : $$5.$$s;

              
              if (i == null) i = nil;
              
              switch (i) {
                case "":
                  
                  set.$call([], true);
                  return (set = $send(self, 'proc', [], function $$6(v, weak){
                    
                    if (v == null) v = nil;
                    if (weak == null) weak = nil;
                    c['$<<'](v);
                    return (c = c.$last());}, 2));
                default:
                  
                  set.$call($hash2([], {}), true);
                  return (set = $send(self, 'proc', [], function $$7(v, weak){var $ret_or_2 = nil;

                    
                    if (v == null) v = nil;
                    if (weak == null) weak = nil;
                    if ($truthy(($ret_or_2 = c['$[]'](i)))) {
                      $ret_or_2
                    } else {
                      c['$[]='](i, v)
                    };
                    if ($not(weak)) {
                      c['$[]='](i, v)
                    };
                    return (c = c['$[]'](i));}, 2));
              };}, {$$arity: 1, $$s: self});
            return set.$call(v, false);}, {$$arity: 2, $$s: self});
          return out;
        }, 1);
        
        $def(self, '$contain_files?', function $Converter_contain_files$ques$8(hash) {
          var self = this;

          return $send(self.$flatten(hash), 'any?', [], function $$9(k, v){
            
            if (k == null) k = nil;
            if (v == null) v = nil;
            return [$$('File'), $$('Blob')]['$include?'](v.$class());}, 2)
        }, 1);
        
        $def(self, '$build_query', function $$build_query(hash, sep) {
          var self = this;

          
          if (sep == null) sep = "&";
          return $send(self.$flatten(hash), 'map', [], function $$10(k, v){var self = $$10.$$s == null ? this : $$10.$$s;

            
            if (k == null) k = nil;
            if (v == null) v = nil;
            return $rb_plus($rb_plus(self.$encode(k), "="), self.$encode(v.$to_s()));}, {$$arity: 2, $$s: self}).$join(sep);
        }, -2);
        
        $def(self, '$build_form_data', function $$build_form_data(hash) {
          var self = this, fd = nil;

          
          fd = $$('FormData').$create();
          $send(self.$flatten(hash), 'each', [], function $$11(k, v){
            
            if (k == null) k = nil;
            if (v == null) v = nil;
            return fd['$<<']([k, v]);}, 2);
          return fd;
        }, 1);
        
        $def(self, '$parse_query', function $$parse_query(string, sep) {
          var self = this;

          
          if (sep == null) sep = "&";
          return self.$unflatten($send(string.$split(sep), 'map', [], function $$12(s){var self = $$12.$$s == null ? this : $$12.$$s;

            
            if (s == null) s = nil;
            return $send(s.$split("="), 'map', [], self.$method("decode").$to_proc());}, {$$arity: 1, $$s: self}));
        }, -2);
        return $def(self, '$from_native', function $$from_native(n) {
          
          
          
        var c = n.constructor;
        if (c === File) {
          (n = $$('File').$new(n))
        }
        else if (c === Blob) {
          (n = $$('Blob').$new(n))
        }
      ;
          return n;
        }, 1);
      })($nesting[0], $nesting);
      self.$extend($$('Converter'));
      self.$include($$('Enumerable'));
      $defs(self, '$create', function $$create(hash) {
        var self = this;

        
        if (hash == null) hash = nil;
        if ($eqeqeq($$('Hash'), hash)) {
          return $$('FormData').$build_form_data(hash)
        } else if ($eqeqeq($$$($$$($$('DOM'), 'Element'), 'Form'), hash)) {
          return self.$new(new FormData(hash.$to_n()))
        } else {
          return self.$new(new FormData())
        };
      }, -1);
      
      $def(self, '$<<', function $FormData_$lt$lt$13(tuple) {
        var $a, $b, self = this, key = nil, value = nil, filename = nil;

        
        $b = tuple, $a = $to_ary($b), (key = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), (filename = ($a[2] == null ? nil : $a[2])), $b;
        if ($truthy(filename)) {
          return self["native"].append(key, $$('Native').$convert(value), filename)
        } else {
          return self["native"].append(key, $$('Native').$convert(value))
        };
      }, 1);
      
      $def(self, '$[]', function $FormData_$$$14(key) {
        var self = this;

        return $$('FormData').$from_native(self["native"].get(key))
      }, 1);
      
      $def(self, '$set', function $$set(key, value, filename) {
        var self = this;

        
        if (filename == null) filename = nil;
        if ($truthy(filename)) {
          return self["native"].set(key, $$('Native').$convert(value), filename)
        } else {
          return self["native"].set(key, $$('Native').$convert(value))
        };
      }, -3);
      $alias(self, "[]=", "set");
      
      $def(self, '$to_h', function $$to_h() {
        var $a, self = this, hash = nil;

        
        hash = $hash2([], {});
        
      var pair, v, e = self["native"].entries();
      while (true) {
        v = e.next();
        if (v.done) break;
        pair = v.value;
        ($a = [pair[0], $$('FormData').$from_native(pair[1])], $send(hash, '[]=', $a), $a[$a.length - 1])
      }
    ;
        return hash;
      }, 0);
      
      $def(self, '$to_a', function $$to_a() {
        var self = this;

        return self.$to_h().$to_a()
      }, 0);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        return $send(self.$to_h(), 'each', [], block.$to_proc());
      }, 0);
      
      $def(self, '$include?', function $FormData_include$ques$15(key) {
        var self = this;

        return self["native"].has(key)
      }, 1);
      return $def(self, '$delete', function $FormData_delete$16(key) {
        var self = this;

        return self["native"].delete(key)
      }, 1);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/document_or_shadow_root"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $send = Opal.send, $def = Opal.def, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,style_sheets');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'DocumentOrShadowRoot');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$style_sheets', function $$style_sheets() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          return $send($$$($$('Native'), 'Array'), 'new', [self["native"].styleSheets], function $$1(e){
            
            if (e == null) e = nil;
            return $$$($$('CSS'), 'StyleSheet').$new(e);}, 1)
        }, 0);
        return $alias(self, "stylesheets", "style_sheets");
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/formatter"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $defs = Opal.defs, $send = Opal.send, $const_set = Opal.const_set, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $thrower = Opal.thrower, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $to_ary = Opal.to_ary, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,[]=,to_h,[],dup,deep_merge!,call,replace,===,new,merge,each,string,indent?,+,-,lines,puts,*,chomp,print,gsub,to_s,for,version,indent,format,instance_eval,empty?,map,escape,<<,join,include?,downcase,name,value,important,fonts,animations,steps,reverse,rules,media,selector,deindent');
  
  self.$require("stringio");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.options = $proto.io = nil;
      
      $defs(self, '$to_h', function $$to_h() {
        var self = this, $ret_or_1 = nil;
        if (self.formatters == null) self.formatters = nil;

        return (self.formatters = ($truthy(($ret_or_1 = self.formatters)) ? ($ret_or_1) : ($hash2([], {}))))
      }, 0);
      $defs(self, '$for', function $Formatter_for$1(klass) {
        var block = $Formatter_for$1.$$p || nil, $a, self = this;

        $Formatter_for$1.$$p = null;
        
        ;
        if ($truthy(block)) {
          return ($a = [klass, block], $send(self.$to_h(), '[]=', $a), $a[$a.length - 1])
        } else {
          return self.$to_h()['$[]'](klass)
        };
      }, 1);
      $defs(self, '$options', function $$options(options) {
        var block = $$options.$$p || nil, old = nil, result = nil;

        $$options.$$p = null;
        
        ;
        old = $$('OPTIONS').$dup();
        $$('Utils')['$deep_merge!']($$('OPTIONS'), options);
        result = block.$call();
        $$('OPTIONS').$replace(old);
        return result;
      }, 1);
      $const_set($nesting[0], 'OPTIONS', $hash2(["indent"], {"indent": $hash2(["level", "with"], {"level": 0, "with": "\t"})}));
      
      $def(self, '$initialize', function $$initialize(io, options) {
        var self = this, $ret_or_1 = nil;

        
        if (io == null) io = nil;
        if (options == null) options = $hash2([], {});
        if ($eqeqeq($$('Hash'), io)) {
          
          self.io = $$('StringIO').$new();
          self.options = io;
        } else {
          
          self.io = ($truthy(($ret_or_1 = io)) ? ($ret_or_1) : ($$('StringIO').$new()));
          self.options = options;
        };
        return (self.options = $$('OPTIONS').$merge(self.options));
      }, -1);
      
      $def(self, '$format', function $$format(item) {
        var self = this;

        
        (function(){try { var $t_break = $thrower('break'); return $send($$('Formatter').$to_h(), 'each', [], function $$2(klass, block){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (klass == null) klass = nil;
          if (block == null) block = nil;
          if ($eqeqeq(klass, item)) {
            
            block.$call(self, item);
            $t_break.$throw();
          } else {
            return nil
          };}, {$$arity: 2, $$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})();
        return self;
      }, 1);
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return self.io.$string()
      }, 0);
      
      $def(self, '$indent?', function $Formatter_indent$ques$3() {
        var block = $Formatter_indent$ques$3.$$p || nil, self = this;

        $Formatter_indent$ques$3.$$p = null;
        
        ;
        try {
          return self.options['$[]']("indent")['$[]']("level")
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return false
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      }, 0);
      
      $def(self, '$indent', function $$indent() {
        var block = $$indent.$$p || nil, $a, self = this, $binary_op_recvr_tmp_1 = nil, $binary_op_recvr_tmp_2 = nil, $binary_op_recvr_tmp_3 = nil;

        $$indent.$$p = null;
        
        ;
        if ($truthy(self['$indent?']())) {
          if ($truthy(block)) {
            
            
            $binary_op_recvr_tmp_1 = self.options['$[]']("indent");
            $binary_op_recvr_tmp_1['$[]=']("level", $rb_plus($binary_op_recvr_tmp_1['$[]']("level"), 1));;
            block.$call();
            
            $binary_op_recvr_tmp_2 = self.options['$[]']("indent");
            return ($a = ["level", $rb_minus($binary_op_recvr_tmp_2['$[]']("level"), 1)], $send($binary_op_recvr_tmp_2, '[]=', $a), $a[$a.length - 1]);;
          } else {
            
            $binary_op_recvr_tmp_3 = self.options['$[]']("indent");
            return ($a = ["level", $rb_plus($binary_op_recvr_tmp_3['$[]']("level"), 1)], $send($binary_op_recvr_tmp_3, '[]=', $a), $a[$a.length - 1]);
          }
        } else if ($truthy(block)) {
          return block.$call()
        } else {
          return nil
        };
      }, 0);
      
      $def(self, '$deindent', function $$deindent() {
        var $a, self = this, $binary_op_recvr_tmp_4 = nil;

        if ($truthy(self['$indent?']())) {
          
          $binary_op_recvr_tmp_4 = self.options['$[]']("indent");
          return ($a = ["level", $rb_minus($binary_op_recvr_tmp_4['$[]']("level"), 1)], $send($binary_op_recvr_tmp_4, '[]=', $a), $a[$a.length - 1]);
        } else {
          return nil
        }
      }, 0);
      
      $def(self, '$print', function $$print(text) {
        var self = this, level = nil;

        if ($truthy((level = self['$indent?']()))) {
          return $send(text.$lines(), 'each', [], function $$4(line){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self.io == null) self.io = nil;
            if (self.options == null) self.options = nil;

            
            if (line == null) line = nil;
            return self.io.$puts("" + ($rb_times(self.options['$[]']("indent")['$[]']("with"), level)) + (line.$chomp()));}, {$$arity: 1, $$s: self})
        } else {
          return self.io.$print(text)
        }
      }, 1);
      return $def(self, '$escape', function $$escape(string) {
        
        return string.$to_s().$gsub(/["><']|&(?!([a-zA-Z]+|(#\d+));)/, $hash2(["&", ">", "<", "\"", "'"], {"&": "&amp;", ">": "&gt;", "<": "&lt;", "\"": "&quot;", "'": "&#39;"}))
      }, 1);
    })($nesting[0], null, $nesting);
    $send($$('Formatter'), 'for', [$$('HTML')], function $Paggio$5(f, item){
      
      if (f == null) f = nil;
      if (item == null) item = nil;
      
      switch (item.$version()) {
        case 5:
          f.$print("<!DOCTYPE html>")
          break;
        default:
          nil
      };
      f.$print("<html>");
      $send(f, 'indent', [], function $$6(){
        return $send(item, 'each', [], function $$7(root){
          
          if (root == null) root = nil;
          return f.$format(root);}, 1)}, 0);
      return f.$print("</html>");}, 2);
    $send($$('Formatter'), 'for', [$$$($$('HTML'), 'Element')], function $Paggio$8(f, item){var $a, $b, self = $Paggio$8.$$s == null ? this : $Paggio$8.$$s, name = nil, attributes = nil, class_names = nil, attrs = nil;

      
      if (f == null) f = nil;
      if (item == null) item = nil;
      $b = $send(item, 'instance_eval', [], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;
        if (self.name == null) self.name = nil;
        if (self.attributes == null) self.attributes = nil;
        if (self.class_names == null) self.class_names = nil;

        return [self.name, self.attributes, self.class_names]}, {$$arity: 0, $$s: self}), $a = $to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (attributes = ($a[1] == null ? nil : $a[1])), (class_names = ($a[2] == null ? nil : $a[2])), $b;
      if (($truthy(attributes['$empty?']()) && ($truthy(class_names['$empty?']())))) {
        f.$print("<" + (name) + ">")
      } else {
        
        attrs = $send(attributes, 'map', [], function $$10(key, value){
          
          if (key == null) key = nil;
          if (value == null) value = nil;
          return "" + (f.$escape(key)) + "=\"" + (f.$escape(value)) + "\"";}, 2);
        if (!$truthy(class_names['$empty?']())) {
          attrs['$<<']("class=\"" + (f.$escape(class_names.$join(" "))) + "\"")
        };
        f.$print("<" + (name) + " " + (attrs.$join(" ")) + ">");
      };
      if ($truthy(["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]['$include?'](name.$to_s().$downcase()))) {
        return nil
      };
      $send(f, 'indent', [], function $$11(){var self = $$11.$$s == null ? this : $$11.$$s, inner = nil;

        if ($truthy((inner = $send(item, 'instance_eval', [], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;
          if (self.inner_html == null) self.inner_html = nil;

          return self.inner_html}, {$$arity: 0, $$s: self})))) {
          return f.$print(inner)
        } else {
          return $send(item, 'each', [], function $$13(child){var $ret_or_1 = nil;

            
            if (child == null) child = nil;
            if ($eqeqeq($$('String'), ($ret_or_1 = child))) {
              return f.$print(f.$escape(child))
            } else if ($eqeqeq($$('CSS'), $ret_or_1)) {
              
              f.$print("<style>");
              $send(f, 'indent', [], function $$14(){
                return f.$format(child)}, 0);
              return f.$print("</style>");
            } else {
              return f.$format(child)
            };}, 1)
        }}, {$$arity: 0, $$s: self});
      return f.$print("</" + (name) + ">");}, {$$arity: 2, $$s: self});
    $send($$('Formatter'), 'for', [$$$($$$($$('CSS'), 'Definition'), 'Style')], function $Paggio$15(f, style){
      
      if (f == null) f = nil;
      if (style == null) style = nil;
      return f.$print("" + (style.$name()) + ": " + (style.$value()) + (($truthy(style.$important()) ? (" !important") : nil)) + ";");}, 2);
    return $send($$('Formatter'), 'for', [$$('CSS')], function $Paggio$16(f, item){
      
      if (f == null) f = nil;
      if (item == null) item = nil;
      $send(item.$fonts(), 'each', [], function $$17(font){
        
        if (font == null) font = nil;
        f.$print("@font-face {");
        $send(f, 'indent', [], function $$18(){
          return $send(font, 'each', [], function $$19(style){
            
            if (style == null) style = nil;
            return f.$format(style);}, 1)}, 0);
        return f.$print("}");}, 1);
      $send(item.$animations(), 'each', [], function $$20(animation){
        
        if (animation == null) animation = nil;
        return $send(["", "-webkit-", "-moz-", "-o-"], 'each', [], function $$21(platform){
          
          if (platform == null) platform = nil;
          f.$print("@" + (platform) + "keyframes " + (animation.$name()) + " {");
          $send(animation.$steps(), 'each', [], function $$22(step){
            
            if (step == null) step = nil;
            f.$print("" + (step.$value()) + " {");
            $send(step, 'each', [], function $$23(style){
              
              if (style == null) style = nil;
              return f.$format(style);}, 1);
            return f.$print("}");}, 1);
          return f.$print("}");}, 1);}, 1);
      return $send(item.$rules().$reverse(), 'each', [], function $$24(rule){var m = nil;

        
        if (rule == null) rule = nil;
        if ($truthy(rule['$empty?']())) {
          return nil
        };
        if ($truthy((m = rule.$media()))) {
          
          f.$print("@media " + (m) + " {");
          f.$indent();
        };
        f.$print("" + (rule.$selector()) + " {");
        $send(f, 'indent', [], function $$25(){
          return $send(rule, 'each', [], function $$26(style){
            
            if (style == null) style = nil;
            return f.$format(style);}, 1)}, 0);
        f.$print("}");
        if ($truthy(rule.$media())) {
          
          f.$print("}");
          return f.$deindent();
        } else {
          return nil
        };}, 1);}, 2);
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/dom/element"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $gvars = Opal.gvars, $eqeq = Opal.eqeq, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $hash2 = Opal.hash2, $hash = Opal.hash, $defs = Opal.defs, $return_ivar = Opal.return_ivar, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, $rb_minus = Opal.rb_minus, $to_ary = Opal.to_ary, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('===,first,shift,==,create_element,to_proc,last,pop,upcase,scan,flatten,delete,|,to_h,map,merge,raise,<<,subclasses,=~,native?,[],!,length,create,select,native_is?,new,include,target,DOM,tag_name,native_matches?,selector,supports?,loaded?,xpath,get,attributes,set,+,class_names,empty?,join,uniq,css,each,alias_native,reject,split,assign,height,size,height=,to_s,inner_dom=,to_a,document,clear,downcase,name,id,gsub,class,offset,concat,[]=,replace,apply,to_n,window,-,partition,include?,add_class,remove_class,width,width=,require');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = $proto.position = $proto.scroll = nil;
        
        $defs(self, '$create', function $$create($a) {
          var block = $$create.$$p || nil, $post_args, args, $b, self = this, document = nil, kwargs = nil, custom_attrs = nil, custom_id = nil, custom_classes = nil, tag_name = nil, $ret_or_1 = nil, classes = nil, id = nil, attrs = nil;
          if (self.tag_name == null) self.tag_name = nil;
          if (self.selector == null) self.selector = nil;
          if ($gvars.document == null) $gvars.document = nil;

          $$create.$$p = null;
          
          ;
          $post_args = $slice.call(arguments);
          args = $post_args;
          if ($eqeqeq($$('Document'), args.$first())) {
            document = args.$shift()
          } else {
            document = $gvars.document
          };
          if ($eqeq(self, $$('Element'))) {
            return $send(document, 'create_element', $to_a(args), block.$to_proc())
          } else if ($truthy(self.tag_name)) {
            return $send(document, 'create_element', [self.tag_name].concat($to_a(args)), block.$to_proc())
          } else if ($truthy(self.selector)) {
            
            kwargs = $hash2([], {});
            if ($eqeqeq($$('Hash'), args.$last())) {
              kwargs = args.$pop()
            };
            $b = [nil, nil, nil], (custom_attrs = $b[0]), (custom_id = $b[1]), (custom_classes = $b[2]), $b;
            tag_name = ($truthy(($ret_or_1 = self.selector.$scan(/^[\w-]+/).$first())) ? ($ret_or_1) : ("div")).$upcase();
            classes = self.selector.$scan(/\.([\w-]+)/).$flatten();
            if ($truthy((custom_classes = kwargs.$delete("classes")))) {
              classes = classes['$|'](custom_classes)
            };
            id = self.selector.$scan(/#([\w-]+)/).$flatten().$first();
            if ($truthy((custom_id = kwargs.$delete("id")))) {
              id = custom_id
            };
            attrs = $send(self.selector.$scan(/\[([\w-]+)=((["'])(.*?)\3|[\w_-]*)\]/), 'map', [], function $$1(a, b, _, d){
              
              if (a == null) a = nil;
              if (b == null) b = nil;
              if (_ == null) _ = nil;
              if (d == null) d = nil;
              return [a, ($truthy(($ret_or_1 = d)) ? ($ret_or_1) : (b))];}, 4).$to_h();
            if ($truthy((custom_attrs = kwargs.$delete("attrs")))) {
              attrs = attrs.$merge(custom_attrs)
            };
            return $send(document, 'create_element', [tag_name].concat($to_a(args)).concat([$hash2(["classes", "id", "attrs"], {"classes": classes, "id": id, "attrs": attrs}).$merge(Opal.to_hash(kwargs))]), block.$to_proc());
          } else {
            return self.$raise($$('NotImplementedError'))
          };
        }, -1);
        $defs(self, '$subclasses', function $$subclasses() {
          var self = this, $ret_or_1 = nil;
          if (self.subclasses == null) self.subclasses = nil;

          return (self.subclasses = ($truthy(($ret_or_1 = self.subclasses)) ? ($ret_or_1) : ([])))
        }, 0);
        $defs(self, '$def_selector', function $$def_selector(selector) {
          var self = this;

          
          $$('Element').$subclasses()['$<<'](self);
          self.selector = selector;
          if ($truthy(selector['$=~'](/[^\w-]/))) {
            return nil
          } else {
            return (self.tag_name = selector.$upcase())
          };
        }, 1);
        $defs(self, '$selector', $return_ivar("selector"), 0);
        $defs(self, '$tag_name', $return_ivar("tag_name"), 0);
        $defs(self, '$new', function $Element_new$2($a) {
          var block = $Element_new$2.$$p || nil, $post_args, args, self = this, node = nil, subclass = nil;

          $Element_new$2.$$p = null;
          
          ;
          $post_args = $slice.call(arguments);
          args = $post_args;
          if ((($eqeq(args.$length(), 1) && ($not((block !== nil)))) && ($truthy($$('Opal')['$native?'](args['$[]'](0)))))) {
            node = args['$[]'](0)
          } else {
            return $send(self, 'create', $to_a(args), block.$to_proc())
          };
          if ($eqeq(self, $$('Element'))) {
            
            subclass = $send($$('Element').$subclasses(), 'select', [], function $$3(subclass){
              
              if (subclass == null) subclass = nil;
              return $$('Element')['$native_is?'](node, subclass);}, 1).$last();
            if ($truthy(subclass)) {
              return subclass.$new(node)
            } else {
              return $send2(self, $find_super(self, 'new', $Element_new$2, false, true), 'new', [node], null)
            };
          } else {
            return $send2(self, $find_super(self, 'new', $Element_new$2, false, true), 'new', [node], null)
          };
        }, -1);
        self.$include($$$($$('Event'), 'Target'));
        $send(self, 'target', [], function $Element$4(value){var self = $Element$4.$$s == null ? this : $Element$4.$$s;

          
          if (value == null) value = nil;
          try {
            return self.$DOM(value)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
              try {
                return nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };}, {$$arity: 1, $$s: self});
        $defs(self, '$native_is?', function $Element_native_is$ques$5(native$, klass) {
          var tag_name = nil, is = nil;

          if ($truthy((tag_name = klass.$tag_name()))) {
            
            is = (native$.getAttribute("is") || "");
            return tag_name === is.toUpperCase() || tag_name === native$.nodeName;
          } else {
            return $$('Element')['$native_matches?'](native$, klass.$selector())
          }
        }, 2);
        if ($truthy($$('Browser')['$supports?']("Element.matches"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$6(native$, selector) {
            
            return native$.matches(selector)
          }, 2)
        } else if ($truthy($$('Browser')['$supports?']("Element.matches (Opera)"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$7(native$, selector) {
            
            return native$.oMatchesSelector(selector)
          }, 2)
        } else if ($truthy($$('Browser')['$supports?']("Element.matches (Internet Explorer)"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$8(native$, selector) {
            
            return native$.msMatchesSelector(selector)
          }, 2)
        } else if ($truthy($$('Browser')['$supports?']("Element.matches (Firefox)"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$9(native$, selector) {
            
            return native$.mozMatchesSelector(selector)
          }, 2)
        } else if ($truthy($$('Browser')['$supports?']("Element.matches (Chrome)"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$10(native$, selector) {
            
            return native$.webkitMatchesSelector(selector)
          }, 2)
        } else if ($truthy($$('Browser')['$loaded?']("Sizzle"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$11(native$, selector) {
            
            return Sizzle.matchesSelector(native$, selector)
          }, 2)
        } else {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$12(native$, selector) {
            var self = this;

            return self.$raise($$('NotImplementedError'), "selector matching unsupported")
          }, 2)
        };
        
        $def(self, '$=~', function $Element_$eq_tilde$13(selector) {
          var self = this;

          return $$('Element')['$native_matches?'](self["native"], selector)
        }, 1);
        $alias(self, "===", "=~");
        
        $def(self, '$/', function $Element_$slash$14($a) {
          var $post_args, paths, self = this;

          
          $post_args = $slice.call(arguments);
          paths = $post_args;
          return $$('NodeSet')['$[]']($send(paths, 'map', [], function $$15(path){var self = $$15.$$s == null ? this : $$15.$$s;

            
            if (path == null) path = nil;
            return self.$xpath(path);}, {$$arity: 1, $$s: self}));
        }, -1);
        
        $def(self, '$[]', function $Element_$$$16(name, options) {
          var self = this;

          
          if (options == null) options = $hash2([], {});
          return self.$attributes().$get(name, options);
        }, -2);
        
        $def(self, '$[]=', function $Element_$$$eq$17(name, value, options) {
          var self = this;

          
          if (options == null) options = $hash2([], {});
          return self.$attributes().$set(name, value, options);
        }, -3);
        
        $def(self, '$add_class', function $$add_class($a) {
          var $post_args, names, self = this, classes = nil;

          
          $post_args = $slice.call(arguments);
          names = $post_args;
          classes = $rb_plus(self.$class_names(), names);
          if (!$truthy(classes['$empty?']())) {
            self["native"].className = classes.$uniq().$join(" ")
          };
          return self;
        }, -1);
        
        $def(self, '$at', function $$at(path_or_selector) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$xpath(path_or_selector).$first()))) {
            return $ret_or_1
          } else {
            return self.$css(path_or_selector).$first()
          }
        }, 1);
        
        $def(self, '$at_css', function $$at_css($a) {
          var $post_args, rules, self = this, result = nil;

          
          $post_args = $slice.call(arguments);
          rules = $post_args;
          result = nil;
          (function(){try { var $t_break = $thrower('break'); return $send(rules, 'each', [], function $$18(rule){var self = $$18.$$s == null ? this : $$18.$$s;

            
            if (rule == null) rule = nil;
            if ($truthy((result = self.$css(rule).$first()))) {
              $t_break.$throw()
            } else {
              return nil
            };}, {$$arity: 1, $$s: self})} catch($e) {
            if ($e === $t_break) return $e.$v;
            throw $e;
          }})();
          return result;
        }, -1);
        
        $def(self, '$at_xpath', function $$at_xpath($a) {
          var $post_args, paths, self = this, result = nil;

          
          $post_args = $slice.call(arguments);
          paths = $post_args;
          result = nil;
          (function(){try { var $t_break = $thrower('break'); return $send(paths, 'each', [], function $$19(path){var self = $$19.$$s == null ? this : $$19.$$s;

            
            if (path == null) path = nil;
            if ($truthy((result = self.$xpath(path).$first()))) {
              $t_break.$throw()
            } else {
              return nil
            };}, {$$arity: 1, $$s: self})} catch($e) {
            if ($e === $t_break) return $e.$v;
            throw $e;
          }})();
          return result;
        }, -1);
        $alias(self, "attr", "[]");
        $alias(self, "attribute", "[]");
        
        $def(self, '$attributes', function $$attributes(options) {
          var self = this;

          
          if (options == null) options = $hash2([], {});
          return $$('Attributes').$new(self, options);
        }, -1);
        
        $def(self, '$attribute_nodes', function $$attribute_nodes() {
          var self = this;

          return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].attributes, $hash2(["get"], {"get": "item"})))
        }, 0);
        self.$alias_native("class_name", "className");
        
        $def(self, '$class_names', function $$class_names() {
          var self = this;

          return $send((self["native"].className).$split(/\s+/), 'reject', [], "empty?".$to_proc())
        }, 0);
        if ($truthy($$('Browser')['$supports?']("Query.css"))) {
          
          $def(self, '$css', function $$css(path) {
            var self = this;

            try {
              return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].querySelectorAll(path)))
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
                try {
                  return $$('NodeSet')['$[]']()
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }
          }, 1)
        } else if ($truthy($$('Browser')['$loaded?']("Sizzle"))) {
          
          $def(self, '$css', function $$css(path) {
            var self = this;

            try {
              return $$('NodeSet')['$[]'](Sizzle(path, self["native"]))
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
                try {
                  return $$('NodeSet')['$[]']()
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }
          }, 1)
        } else {
          
          $def(self, '$css', function $$css(selector) {
            var self = this;

            return self.$raise($$('NotImplementedError'), "query by CSS selector unsupported")
          }, 1)
        };
        
        $def(self, '$click', function $$click() {
          var self = this;

          
          self["native"].click();
          return self;
        }, 0);
        
        $def(self, '$data', function $$data(value) {
          var self = this, data = nil;

          
          if (value == null) value = nil;
          data = $$('Data').$new(self);
          if (!$truthy(value)) {
            return data
          };
          if ($eqeqeq($$('Hash'), value)) {
            data.$assign(value)
          } else {
            self.$raise($$('ArgumentError'), "unknown data type")
          };
          return self;
        }, -1);
        $alias(self, "get_attribute", "[]");
        $alias(self, "get", "[]");
        
        $def(self, '$height', function $$height() {
          var self = this;

          return self.$size().$height()
        }, 0);
        
        $def(self, '$height=', function $Element_height$eq$20(value) {
          var $a, self = this;

          return ($a = [value], $send(self.$size(), 'height=', $a), $a[$a.length - 1])
        }, 1);
        
        $def(self, '$id', function $$id() {
          var self = this;

          
      var id = self["native"].id;

      if (id === "") {
        return nil;
      }
      else {
        return id;
      }
    
        }, 0);
        
        $def(self, '$id=', function $Element_id$eq$21(value) {
          var self = this;

          return self["native"].id = value.$to_s()
        }, 1);
        
        $def(self, '$inner_dom', function $$inner_dom(builder) {
          var block = $$inner_dom.$$p || nil, self = this;

          $$inner_dom.$$p = null;
          
          ;
          if (builder == null) builder = nil;
          self['$inner_dom=']($send($$('Builder'), 'new', [self.$document(), builder], block.$to_proc()).$to_a());
          return self;
        }, -1);
        
        $def(self, '$inner_dom=', function $Element_inner_dom$eq$22(node) {
          var self = this;

          
          self.$clear();
          return self['$<<'](node);
        }, 1);
        
        $def(self, '$inner_html', function $$inner_html() {
          var self = this;

          return self["native"].innerHTML
        }, 0);
        
        $def(self, '$inner_html=', function $Element_inner_html$eq$23(value) {
          var self = this;

          return self["native"].innerHTML = value
        }, 1);
        
        $def(self, '$inspect', function $$inspect() {
          var self = this, inspect = nil;

          
          inspect = self.$name().$downcase();
          if ($truthy(self.$id())) {
            inspect = $rb_plus(inspect, $rb_plus($rb_plus(".", self.$id()), "!"))
          };
          if (!$truthy(self.$class_names()['$empty?']())) {
            inspect = $rb_plus(inspect, $rb_plus(".", self.$class_names().$join(".")))
          };
          return "#<" + (self.$class().$name().$gsub("Browser::", "")) + ": " + (inspect) + ">";
        }, 0);
        
        $def(self, '$offset', function $$offset($a) {
          var $post_args, values, self = this, off = nil;

          
          $post_args = $slice.call(arguments);
          values = $post_args;
          off = $$('Offset').$new(self);
          if (!$truthy(values['$empty?']())) {
            $send(off, 'set', $to_a(values))
          };
          return off;
        }, -1);
        
        $def(self, '$offset=', function $Element_offset$eq$24(value) {
          var self = this;

          return $send(self.$offset(), 'set', $to_a(value))
        }, 1);
        
        $def(self, '$outer_html', function $$outer_html() {
          var self = this;

          return self["native"].outerHTML
        }, 0);
        
        $def(self, '$position', function $$position() {
          var self = this, $ret_or_1 = nil;

          return (self.position = ($truthy(($ret_or_1 = self.position)) ? ($ret_or_1) : ($$('Position').$new(self))))
        }, 0);
        
        $def(self, '$scroll', function $$scroll() {
          var self = this, $ret_or_1 = nil;

          return (self.scroll = ($truthy(($ret_or_1 = self.scroll)) ? ($ret_or_1) : ($$('Scroll').$new(self))))
        }, 0);
        
        $def(self, '$search', function $$search($a) {
          var $post_args, selectors, self = this;

          
          $post_args = $slice.call(arguments);
          selectors = $post_args;
          return $$('NodeSet').$new($send(selectors, 'map', [], function $$25(selector){var self = $$25.$$s == null ? this : $$25.$$s;

            
            if (selector == null) selector = nil;
            return self.$xpath(selector).$to_a().$concat(self.$css(selector).$to_a());}, {$$arity: 1, $$s: self}).$flatten().$uniq());
        }, -1);
        $alias(self, "set", "[]=");
        $alias(self, "set_attribute", "[]=");
        
        $def(self, '$shadow', function $$shadow(open) {
          var self = this, root = nil;

          
          if (open == null) open = true;
          if ($truthy((root = self["native"].shadowRoot))) {
            return self.$DOM(root)
          } else {
            return self.$DOM(self["native"].attachShadow({mode: ($truthy(open) ? ("open") : ("closed"))}))
          };
        }, -1);
        
        $def(self, '$shadow?', function $Element_shadow$ques$26() {
          var self = this;

          return !!self["native"].shadowRoot
        }, 0);
        
        $def(self, '$style', function $$style(data) {
          var block = $$style.$$p || nil, self = this, style = nil;

          $$style.$$p = null;
          
          ;
          if (data == null) data = nil;
          style = $$$($$('CSS'), 'Declaration').$new(self["native"].style);
          if (!($truthy(data) || ($truthy(block)))) {
            return style
          };
          if ($eqeqeq($$('String'), data)) {
            style.$replace(data)
          } else if ($eqeqeq($$('Hash'), data)) {
            style.$assign(data)
          } else if ($truthy(block)) {
            $send(style, 'apply', [], block.$to_proc())
          } else {
            self.$raise($$('ArgumentError'), "unknown data type")
          };
          return self;
        }, -1);
        if ($truthy($$('Browser')['$supports?']("CSS.computed"))) {
          
          $def(self, '$style!', function $Element_style$excl$27() {
            var self = this;

            return $$$($$('CSS'), 'Declaration').$new(self.$window().$to_n().getComputedStyle(self["native"], null))
          }, 0)
        } else if ($truthy($$('Browser')['$supports?']("CSS.current"))) {
          
          $def(self, '$style!', function $Element_style$excl$28() {
            var self = this;

            return $$$($$('CSS'), 'Declaration').$new(self["native"].currentStyle)
          }, 0)
        } else {
          
          $def(self, '$style!', function $Element_style$excl$29() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "computed style unsupported")
          }, 0)
        };
        
        $def(self, '$remove_attribute', function $$remove_attribute(name) {
          var self = this;

          return self["native"].removeAttribute(name)
        }, 1);
        
        $def(self, '$remove_class', function $$remove_class($a) {
          var $post_args, names, self = this, classes = nil;

          
          $post_args = $slice.call(arguments);
          names = $post_args;
          classes = $rb_minus(self.$class_names(), names);
          if ($truthy(classes['$empty?']())) {
            self["native"].removeAttribute('class')
          } else {
            self["native"].className = classes.$join(" ")
          };
          return self;
        }, -1);
        
        $def(self, '$size', function $$size($a) {
          var $post_args, inc, self = this;

          
          $post_args = $slice.call(arguments);
          inc = $post_args;
          return $send($$('Size'), 'new', [self].concat($to_a(inc)));
        }, -1);
        
        $def(self, '$toggle_class', function $$toggle_class($a) {
          var $post_args, names, $b, $c, self = this, to_remove = nil, to_add = nil;

          
          $post_args = $slice.call(arguments);
          names = $post_args;
          $c = $send(names, 'partition', [], function $$30(name){var self = $$30.$$s == null ? this : $$30.$$s;

            
            if (name == null) name = nil;
            return self.$class_names()['$include?'](name);}, {$$arity: 1, $$s: self}), $b = $to_ary($c), (to_remove = ($b[0] == null ? nil : $b[0])), (to_add = ($b[1] == null ? nil : $b[1])), $c;
          $send(self, 'add_class', $to_a(to_add));
          return $send(self, 'remove_class', $to_a(to_remove));
        }, -1);
        
        $def(self, '$width', function $$width() {
          var self = this;

          return self.$size().$width()
        }, 0);
        
        $def(self, '$width=', function $Element_width$eq$31(value) {
          var $a, self = this;

          return ($a = [value], $send(self.$size(), 'width=', $a), $a[$a.length - 1])
        }, 1);
        
        $def(self, '$window', function $$window() {
          var self = this;

          return self.$document().$window()
        }, 0);
        if (($truthy($$('Browser')['$supports?']("Query.xpath")) || ($truthy($$('Browser')['$loaded?']("wicked-good-xpath"))))) {
          
          if ($truthy($$('Browser')['$loaded?']("wicked-good-xpath"))) {
            wgxpath.install()
          };
          return $def(self, '$xpath', function $$xpath(path) {
            var self = this;

            try {
              return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new((self["native"].ownerDocument || self["native"]).evaluate(path,
           self["native"], null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null), $hash2(["get", "length"], {"get": "snapshotItem", "length": "snapshotLength"})))
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
                try {
                  return $$('NodeSet')['$[]']()
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }
          }, 1);
        } else {
          return $def(self, '$xpath', function $$xpath(path) {
            var self = this;

            return self.$raise($$('NotImplementedError'), "query by XPath unsupported")
          }, 1)
        };
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  self.$require("browser/dom/element/attributes");
  self.$require("browser/dom/element/data");
  self.$require("browser/dom/element/position");
  self.$require("browser/dom/element/offset");
  self.$require("browser/dom/element/scroll");
  self.$require("browser/dom/element/size");
  self.$require("browser/dom/element/button");
  self.$require("browser/dom/element/image");
  self.$require("browser/dom/element/form");
  self.$require("browser/dom/element/input");
  self.$require("browser/dom/element/select");
  self.$require("browser/dom/element/template");
  self.$require("browser/dom/element/textarea");
  self.$require("browser/dom/element/iframe");
  return self.$require("browser/dom/element/media");
};

Opal.modules["browser/event/keyboard"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $const_set = Opal.const_set, $hash2 = Opal.hash2, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,supports?,supported?,alias_native,[],code,chr,key,==,downcase,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Keyboard');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("keydown", "keypress", "keyup");
        $defs(self, '$supported?', function $Keyboard_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Keyboard")
        }, 0);
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$alt!', function $Definition_alt$excl$2() {
            var self = this;

            return self["native"].altKey = true
          }, 0);
          
          $def(self, '$ctrl!', function $Definition_ctrl$excl$3() {
            var self = this;

            return self["native"].ctrlKey = true
          }, 0);
          
          $def(self, '$meta!', function $Definition_meta$excl$4() {
            var self = this;

            return self["native"].metaKey = true
          }, 0);
          
          $def(self, '$shift!', function $Definition_shift$excl$5() {
            var self = this;

            return self["native"].shiftKey = true
          }, 0);
          
          $def(self, '$code=', function $Definition_code$eq$6(code) {
            var self = this;

            return self["native"].keyCode = self["native"].which = code
          }, 1);
          
          $def(self, '$key=', function $Definition_key$eq$7(key) {
            var self = this;

            return self["native"].key = key
          }, 1);
          
          $def(self, '$char=', function $Definition_char$eq$8(char$) {
            var self = this;

            return self["native"].char = self["native"].charCode = char$
          }, 1);
          
          $def(self, '$repeat!', function $Definition_repeat$excl$9() {
            var self = this;

            return self["native"].repeat = true
          }, 0);
          return $def(self, '$locale=', function $Definition_locale$eq$10(value) {
            var self = this;

            return self["native"].locale = value
          }, 1);
        })($nesting[0], $$$($$('UI'), 'Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new KeyboardEvent(name, desc)
            }, 2)
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var modifiers = "";

        if (desc.altKey) {
          modifiers += "Alt ";
        }

        if (desc.ctrlKey) {
          modifiers += "Ctrl ";
        }

        if (desc.shiftKey) {
          modifiers += "Shift" ;
        }

        if (desc.metaKey) {
          modifiers += "Meta ";
        }

        var event = document.createEvent("KeyboardEvent");
            event.initKeyboardEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.which, 0,
              modifiers, desc.repeat, desc.locale);

        return event;
      
            }, 2)
          }
        };
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("locale");
        self.$alias_native("repeat?", "repeat");
        $const_set($nesting[0], 'IE_MAP', $hash2(["Down", "Up", "Left", "Right", "Esc", "Del"], {"Down": "ArrowDown", "Up": "ArrowUp", "Left": "ArrowLeft", "Right": "ArrowRight", "Esc": "Escape", "Del": "Delete"}));
        
        $def(self, '$key', function $$key() {
          var self = this, key = nil, $ret_or_1 = nil;

          
          key = self["native"].key || self["native"].keyIdentifier || nil;
          if ($truthy(($ret_or_1 = $$('IE_MAP')['$[]'](key)))) {
            return $ret_or_1
          } else {
            return key
          };
        }, 0);
        
        $def(self, '$code', function $$code() {
          var self = this;

          return self["native"].keyCode || self["native"].which || nil
        }, 0);
        
        $def(self, '$char', function $Keyboard_char$11() {
          var self = this;

          return self["native"].char || self["native"].charCode || ($truthy(self.$code()) ? (self.$code().$chr()) : (nil))
        }, 0);
        $alias(self, "to_i", "key");
        
        $def(self, '$down?', function $Keyboard_down$ques$12() {
          var self = this;

          return self.$name().$downcase()['$==']("keydown")
        }, 0);
        
        $def(self, '$press?', function $Keyboard_press$ques$13() {
          var self = this;

          return self.$name().$downcase()['$==']("keypress")
        }, 0);
        return $def(self, '$up?', function $Keyboard_up$ques$14() {
          var self = this;

          return self.$name().$downcase()['$==']("keyup")
        }, 0);
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/cdata"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('value');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'CDATA');

        
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<DOM::CDATA: " + (self.$value()) + ">"
        }, 0)
      })($nesting[0], $$('Text'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/node"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $alias = Opal.alias, $return_val = Opal.return_val, $gvars = Opal.gvars, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,==,[],new,raise,class,convert,set_native_reference,to_n,respond_to?,each,<<,to_dom,document,native?,===,>>,DOM,to_proc,add_next_sibling,parent,last,pop,select!,=~,add_previous_sibling,remove_child,remove,children,supports?,node_type,first,try_convert,elem?,select,element_children,content,content=,to_s,next,!,element?,name,name=,create_element,dup,inner_html,previous,replace');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Node');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        $const_set($nesting[0], 'ELEMENT_NODE', 1);
        $const_set($nesting[0], 'ATTRIBUTE_NODE', 2);
        $const_set($nesting[0], 'TEXT_NODE', 3);
        $const_set($nesting[0], 'CDATA_SECTION_NODE', 4);
        $const_set($nesting[0], 'ENTITY_REFERENCE_NOCE', 5);
        $const_set($nesting[0], 'ENTITY_NODE', 6);
        $const_set($nesting[0], 'PROCESSING_INSTRUCTION_NODE', 7);
        $const_set($nesting[0], 'COMMENT_NODE', 8);
        $const_set($nesting[0], 'DOCUMENT_NODE', 9);
        $const_set($nesting[0], 'DOCUMENT_TYPE_NODE', 10);
        $const_set($nesting[0], 'DOCUMENT_FRAGMENT_NODE', 11);
        $const_set($nesting[0], 'NOTATION_NODE', 12);
        $defs(self, '$new', function $Node_new$1(value) {
          var $yield = $Node_new$1.$$p || nil, self = this, $ret_or_1 = nil, klass = nil;
          if (self.classes == null) self.classes = nil;

          $Node_new$1.$$p = null;
          if ($eqeq(self, $$('Node'))) {
            
            self.classes = ($truthy(($ret_or_1 = self.classes)) ? ($ret_or_1) : ([nil, $$('Element'), $$('Attribute'), $$('Text'), $$('CDATA'), nil, nil, nil, $$('Comment'), $$('Document'), nil, $$('DocumentFragment')]));
            if ($truthy((klass = self.classes['$[]'](value.nodeType)))) {
              return klass.$new(value)
            } else {
              return self.$raise($$('ArgumentError'), "cannot instantiate a non derived Node object")
            };
          } else {
            return $send2(self, $find_super(self, 'new', $Node_new$1, false, true), 'new', [value], $yield)
          }
        }, 1);
        
        $def(self, '$initialize', function $$initialize(node) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          if (!$truthy(node)) {
            self.$raise($$('ArgumentError'), "Please ensure that #initialize of " + (self.$class()) + " accepts one argument")
          };
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [node], $yield);
        }, 1);
        
        $def(self, '$==', function $Node_$eq_eq$2(other) {
          var self = this;

          return self["native"] === $$('Native').$convert(other)
        }, 1);
        
        $def(self, '$initialize_copy', function $$initialize_copy(old) {
          var self = this;

          return self.$set_native_reference(old.$to_n().cloneNode(true))
        }, 1);
        
        $def(self, '$<<', function $Node_$lt$lt$3(node) {
          var self = this;

          
          if ($truthy($$('Opal')['$respond_to?'](node, "each"))) {
            
            $send(node, 'each', [], function $$4(n){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (n == null) n = nil;
              return self['$<<'](n);}, {$$arity: 1, $$s: self});
            return self;
          } else if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          self["native"].appendChild(node);
          return self;
        }, 1);
        
        $def(self, '$>>', function $Node_$gt$gt$5(node) {
          var self = this;

          
          if ($truthy($$('Opal')['$respond_to?'](node, "each"))) {
            
            $send(node, 'each', [], function $$6(n){var self = $$6.$$s == null ? this : $$6.$$s;

              
              if (n == null) n = nil;
              return self['$>>'](n);}, {$$arity: 1, $$s: self});
            return self;
          } else if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          if ($truthy(self["native"].firstChild == null)) {
            self["native"].appendChild(node)
          } else {
            self["native"].insertBefore(node, self["native"].firstChild)
          };
          return self;
        }, 1);
        
        $def(self, '$add_child', function $$add_child(node) {
          var block = $$add_child.$$p || nil, self = this;

          $$add_child.$$p = null;
          
          ;
          if (node == null) node = nil;
          if (!$truthy(node)) {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          return self['$<<'](node);
        }, -1);
        
        $def(self, '$add_next_sibling', function $$add_next_sibling(node) {
          var block = $$add_next_sibling.$$p || nil, self = this;

          $$add_next_sibling.$$p = null;
          
          ;
          if (node == null) node = nil;
          if (!$truthy(node)) {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          return self["native"].parentNode.insertBefore(node, self["native"].nextSibling);
        }, -1);
        
        $def(self, '$add_previous_sibling', function $$add_previous_sibling(node) {
          var block = $$add_previous_sibling.$$p || nil, self = this;

          $$add_previous_sibling.$$p = null;
          
          ;
          if (node == null) node = nil;
          if (!$truthy(node)) {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          return self["native"].parentNode.insertBefore(node, self["native"]);
        }, -1);
        $alias(self, "after", "add_next_sibling");
        
        $def(self, '$append_to', function $$append_to(node) {
          var self = this;

          
          node['$<<'](self);
          return self;
        }, 1);
        
        $def(self, '$ancestors', function $$ancestors(expression) {
          var self = this, parents = nil, parent = nil;

          
          if (expression == null) expression = nil;
          if (!$truthy(self.$parent())) {
            return $$('NodeSet')['$[]']()
          };
          parents = [self.$parent()];
          while ($truthy((parent = parents.$last().$parent()))) {
          parents['$<<'](parent)
          };
          if ($eqeqeq($$('Document'), parents.$last())) {
            parents.$pop()
          };
          if ($truthy(expression)) {
            $send(parents, 'select!', [], function $$7(p){
              
              if (p == null) p = nil;
              return p['$=~'](expression);}, 1)
          };
          return $$('NodeSet').$new(parents);
        }, -1);
        
        $def(self, '$attached?', function $Node_attached$ques$8() {
          var self = this;

          return self["native"].isConnected
        }, 0);
        $alias(self, "before", "add_previous_sibling");
        
        $def(self, '$remove', function $$remove() {
          var self = this;

          
          if ($truthy(self.$parent())) {
            self.$parent().$remove_child(self)
          };
          return self;
        }, 0);
        
        $def(self, '$clear', function $$clear() {
          var self = this;

          return self.$children().$remove()
        }, 0);
        if ($truthy($$('Browser')['$supports?']("Element.textContent"))) {
          
          
          $def(self, '$content', function $$content() {
            var self = this;

            return self["native"].textContent
          }, 0);
          
          $def(self, '$content=', function $Node_content$eq$9(value) {
            var self = this;

            return self["native"].textContent = value
          }, 1);
        } else if ($truthy($$('Browser')['$supports?']("Element.innerText"))) {
          
          
          $def(self, '$content', function $$content() {
            var self = this;

            return self["native"].innerText
          }, 0);
          
          $def(self, '$content=', function $Node_content$eq$10(value) {
            var self = this;

            return self["native"].innerText = value
          }, 1);
        } else {
          
          
          $def(self, '$content', function $$content() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "node text content unsupported")
          }, 0);
          
          $def(self, '$content=', function $Node_content$eq$11(value) {
            var self = this;

            return self.$raise($$('NotImplementedError'), "node text content unsupported")
          }, 1);
        };
        
        $def(self, '$blank?', function $Node_blank$ques$12() {
          var self = this;

          return self.$raise($$('NotImplementedError'))
        }, 0);
        
        $def(self, '$cdata?', function $Node_cdata$ques$13() {
          var self = this;

          return self.$node_type()['$==']($$('CDATA_SECTION_NODE'))
        }, 0);
        
        $def(self, '$child', function $$child() {
          var self = this;

          return self.$children().$first()
        }, 0);
        
        $def(self, '$children', function $$children() {
          var self = this;

          return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].childNodes))
        }, 0);
        
        $def(self, '$children=', function $Node_children$eq$14(node) {
          var self = this;

          return self.$raise($$('NotImplementedError'))
        }, 1);
        
        $def(self, '$comment?', function $Node_comment$ques$15() {
          var self = this;

          return self.$node_type()['$==']($$('COMMENT_NODE'))
        }, 0);
        
        $def(self, '$custom?', $return_val(false), 0);
        
        $def(self, '$document', function $$document() {
          var self = this;

          if ($truthy((typeof(self["native"].ownerDocument) !== "undefined"))) {
            return self.$DOM(self["native"].ownerDocument)
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$document=', function $Node_document$eq$16(new_document) {
          var self = this;

          return $$('Native').$try_convert(new_document, new_document).adoptNode(self["native"])
        }, 1);
        
        $def(self, '$document?', function $Node_document$ques$17() {
          var self = this;

          return self.$node_type()['$==']($$('DOCUMENT_NODE'))
        }, 0);
        
        $def(self, '$elem?', function $Node_elem$ques$18() {
          var self = this;

          return self.$node_type()['$==']($$('ELEMENT_NODE'))
        }, 0);
        $alias(self, "element?", "elem?");
        
        $def(self, '$element_children', function $$element_children() {
          var self = this;

          return $send(self.$children(), 'select', [], "element?".$to_proc())
        }, 0);
        $alias(self, "elements", "element_children");
        
        $def(self, '$first_element_child', function $$first_element_child() {
          var self = this;

          return self.$element_children().$first()
        }, 0);
        
        $def(self, '$fragment?', function $Node_fragment$ques$19() {
          var self = this;

          return self.$node_type()['$==']($$('DOCUMENT_FRAGMENT_NODE'))
        }, 0);
        $alias(self, "inner_text", "content");
        $alias(self, "inner_text=", "content=");
        
        $def(self, '$last_element_child', function $$last_element_child() {
          var self = this;

          return self.$element_children().$last()
        }, 0);
        
        $def(self, '$name', function $$name() {
          var self = this;

          return self["native"].nodeName || nil
        }, 0);
        
        $def(self, '$name=', function $Node_name$eq$20(value) {
          var self = this;

          return self["native"].nodeName = value.$to_s()
        }, 1);
        
        $def(self, '$namespace', function $$namespace() {
          var self = this;

          return self["native"].namespaceURI || nil
        }, 0);
        
        $def(self, '$next', function $$next() {
          var self = this;

          if ($truthy(self["native"].nextSibling != null)) {
            return self.$DOM(self["native"].nextSibling)
          } else {
            return nil
          }
        }, 0);
        $alias(self, "next=", "add_next_sibling");
        
        $def(self, '$next_element', function $$next_element() {
          var self = this, current = nil, $ret_or_1 = nil;

          
          current = self.$next();
          while ($truthy(($truthy(($ret_or_1 = current)) ? (current['$element?']()['$!']()) : ($ret_or_1)))) {
          current = current.$next()
          };
          return current;
        }, 0);
        $alias(self, "next_sibling", "next");
        $alias(self, "node_name", "name");
        $alias(self, "node_name=", "name=");
        
        $def(self, '$node_type', function $$node_type() {
          var self = this;

          return self["native"].nodeType
        }, 0);
        
        $def(self, '$outer_html', function $$outer_html() {
          var self = this, div = nil;
          if ($gvars.document == null) $gvars.document = nil;

          
          div = $gvars.document.$create_element("DIV");
          div['$<<'](self.$dup());
          return div.$inner_html();
        }, 0);
        
        $def(self, '$parent', function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentNode != null)) {
            return self.$DOM(self["native"].parentNode)
          } else {
            return nil
          }
        }, 0);
        
        $def(self, '$parent=', function $Node_parent$eq$21(node) {
          var self = this;

          return self["native"].parentNode = $$('Native').$convert(node)
        }, 1);
        
        $def(self, '$parse', function $$parse(text, options) {
          var self = this;

          
          if (options == null) options = $hash2([], {});
          return self.$raise($$('NotImplementedError'));
        }, -2);
        
        $def(self, '$path', function $$path() {
          var self = this;

          return self.$raise($$('NotImplementedError'))
        }, 0);
        
        $def(self, '$prepend_to', function $$prepend_to(node) {
          var self = this;

          
          node['$>>'](self);
          return self;
        }, 1);
        
        $def(self, '$previous', function $$previous() {
          var self = this;

          if ($truthy(self["native"].previousSibling != null)) {
            return self.$DOM(self["native"].previousSibling)
          } else {
            return nil
          }
        }, 0);
        $alias(self, "previous=", "add_previous_sibling");
        
        $def(self, '$previous_element', function $$previous_element() {
          var self = this, current = nil, $ret_or_1 = nil;

          
          current = self.$previous();
          while ($truthy(($truthy(($ret_or_1 = current)) ? (current['$element?']()['$!']()) : ($ret_or_1)))) {
          current = current.$previous()
          };
          return current;
        }, 0);
        $alias(self, "previous_sibling", "previous");
        
        $def(self, '$remove_child', function $$remove_child(node) {
          var self = this;

          
          self["native"].removeChild($$('Native').$try_convert(node));
          return self;
        }, 1);
        
        $def(self, '$replace', function $$replace(node) {
          var self = this;

          
          if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          self["native"].parentNode.replaceChild(node, self["native"]);
          return self.$DOM(node);
        }, 1);
        $alias(self, "replace_with", "replace");
        $alias(self, "text", "content");
        $alias(self, "text=", "content=");
        
        $def(self, '$text?', function $Node_text$ques$22() {
          var self = this;

          return self.$node_type()['$==']($$('TEXT_NODE'))
        }, 0);
        
        $def(self, '$traverse', function $$traverse() {
          var block = $$traverse.$$p || nil, self = this;

          $$traverse.$$p = null;
          
          ;
          return self.$raise($$('NotImplementedError'));
        }, 0);
        $alias(self, "type", "node_type");
        
        $def(self, '$value', function $$value() {
          var self = this;

          return self["native"].nodeValue || nil
        }, 0);
        
        $def(self, '$value=', function $Node_value$eq$23(value) {
          var self = this;

          return self["native"].nodeValue = value
        }, 1);
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<DOM::Node: " + (self.$name()) + ">"
        }, 0);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/css"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $range = Opal.range, $eqeq = Opal.eqeq, $defs = Opal.defs, $ensure_kwargs = Opal.ensure_kwargs, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $slice = Opal.slice, $to_a = Opal.to_a, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,each,start_with?,+,[],==,attr_reader,raise,build!,arity,!,instance_exec,to_proc,call,any?,include?,<<,new,selector,pop,method_missing,__send__,last');
  
  self.$require("paggio/css/unit");
  self.$require("paggio/css/color");
  self.$require("paggio/css/definition");
  self.$require("paggio/css/rule");
  self.$require("paggio/css/font");
  self.$require("paggio/css/animation");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = $proto.media = $proto.current = $proto.fonts = $proto.animations = nil;
      
      $defs(self, '$selector', function $$selector(list) {
        var result = nil;

        
        result = "";
        $send(list, 'each', [], function $$1(part){
          
          if (part == null) part = nil;
          if ($truthy(part['$start_with?']("&"))) {
            return (result = $rb_plus(result, part['$[]']($range(1, -1, false))))
          } else {
            return (result = $rb_plus(result, $rb_plus(" ", part)))
          };}, 1);
        if ($eqeq(result['$[]'](0), " ")) {
          return result['$[]']($range(1, -1, false))
        } else {
          return result
        };
      }, 1);
      self.$attr_reader("rules", "media", "fonts", "animations");
      
      $def(self, '$initialize', function $$initialize($kwargs) {
        var block = $$initialize.$$p || nil, defer, self = this;

        $$initialize.$$p = null;
        
        ;
        $kwargs = $ensure_kwargs($kwargs);
        
        defer = $kwargs.$$smap["defer"];if (defer == null) defer = false;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "no block given")
        };
        self.selector = [];
        self.current = [];
        self.rules = [];
        self.fonts = [];
        self.animations = [];
        self.block = block;
        if ($truthy(defer)) {
          return nil
        } else {
          return self['$build!']()
        };
      }, -1);
      
      $def(self, '$build!', function $CSS_build$excl$2($kwargs) {
        var force_call, self = this;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        force_call = $kwargs.$$smap["force_call"];if (force_call == null) force_call = false;
        if (($not(force_call) && ($eqeq(self.block.$arity(), 0)))) {
          $send(self, 'instance_exec', [], self.block.$to_proc())
        } else {
          self.block.$call(self)
        };
        return (self.block = nil);
      }, -1);
      
      $def(self, '$rule', function $$rule($a) {
        var block = $$rule.$$p || nil, $post_args, names, self = this;

        $$rule.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        names = $post_args;
        if (!$truthy(block)) {
          return nil
        };
        if ($truthy($send(names, 'any?', [], function $$3(n){
          
          if (n == null) n = nil;
          return n['$include?'](",");}, 1))) {
          $Kernel.$raise($$$('ArgumentError'), "selectors cannot contain commas")
        };
        return $send(names, 'each', [], function $$4(name){var self = $$4.$$s == null ? this : $$4.$$s;
          if (self.selector == null) self.selector = nil;
          if (self.current == null) self.current = nil;
          if (self.media == null) self.media = nil;
          if (self.rules == null) self.rules = nil;

          
          if (name == null) name = nil;
          self.selector['$<<'](name);
          self.current['$<<']($$('Rule').$new($$('CSS').$selector(self.selector), self.media));
          block.$call();
          self.selector.$pop();
          return self.rules['$<<'](self.current.$pop());}, {$$arity: 1, $$s: self});
      }, -1);
      
      $def(self, '$media', function $$media(query, $a) {
        var block = $$media.$$p || nil, $post_args, args, $b, self = this, old = nil;

        $$media.$$p = null;
        
        ;
        $post_args = $slice.call(arguments, 1);
        args = $post_args;
        if ($truthy(block)) {
          
          $b = [self.media, query], (old = $b[0]), (self.media = $b[1]), $b;
          block.$call();
          return (self.media = old);
        } else {
          return $send(self, 'method_missing', ["media", query].concat($to_a(args)))
        };
      }, -2);
      
      $def(self, '$font', function $$font(name, $a) {
        var block = $$font.$$p || nil, $post_args, args, self = this;

        $$font.$$p = null;
        
        ;
        $post_args = $slice.call(arguments, 1);
        args = $post_args;
        if ($truthy(block)) {
          
          self.current['$<<']($$('Font').$new(name));
          block.$call();
          return self.fonts['$<<'](self.current.$pop());
        } else {
          return $send(self, 'method_missing', ["font", name].concat($to_a(args)))
        };
      }, -2);
      
      $def(self, '$animation', function $$animation(name, $a) {
        var block = $$animation.$$p || nil, $post_args, args, self = this;

        $$animation.$$p = null;
        
        ;
        $post_args = $slice.call(arguments, 1);
        args = $post_args;
        if ($truthy(block)) {
          
          self.current['$<<']($$('Animation').$new(name));
          block.$call();
          return self.animations['$<<'](self.current.$pop());
        } else {
          return $send(self, 'method_missing', ["animation", name].concat($to_a(args)))
        };
      }, -2);
      return $def(self, '$method_missing', function $$method_missing($a) {
        var block = $$method_missing.$$p || nil, $post_args, args, self = this;

        $$method_missing.$$p = null;
        
        ;
        $post_args = $slice.call(arguments);
        args = $post_args;
        return $send(self.current.$last(), '__send__', $to_a(args), block.$to_proc());
      }, -1);
    })($nesting[0], $$('BasicObject'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.current = $proto.roots = nil;
      return $def(self, '$style', function $$style() {
        var block = $$style.$$p || nil, self = this, $ret_or_1 = nil;

        $$style.$$p = null;
        
        ;
        return ($truthy(($ret_or_1 = self.current)) ? ($ret_or_1) : (self.roots))['$<<']($send($$('CSS'), 'new', [], block.$to_proc()));
      }, 0)
    })($nesting[0], $$('BasicObject'), $nesting);
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/dom/shadow_root"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,raise');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ShadowRoot');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('DocumentOrShadowRoot'));
        return $defs(self, '$create', function $$create() {
          var self = this;

          return self.$raise($$('ArgumentError'))
        }, 0);
      })($nesting[0], $$('DocumentFragment'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/support"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $const_set = Opal.const_set, $module = Opal.module, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $gvars = Opal.gvars, $defs = Opal.defs, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('downcase,===,!,supports?');
  
  $const_set($nesting[0], 'BROWSER_ENGINE', (function() { try {
    return (/MSIE|WebKit|Presto|Gecko/.exec(navigator.userAgent)[0]).$downcase()
  } catch ($err) {
    if (Opal.rescue($err, [$$('StandardError')])) {
      try {
        return "unknown"
      } finally { Opal.pop_exception(); }
    } else { throw $err; }
  }})());
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.support = {};
    $defs(self, '$supports?', function $Browser_supports$ques$1(feature) {
      var $a, self = this, support = nil, $ret_or_1 = nil;
      if (self.support == null) self.support = nil;

      
      if ($truthy((typeof(self.support[feature]) !== "undefined"))) {
        return self.support[feature]
      };
      support = (function() {if ($eqeqeq("MutationObserver", ($ret_or_1 = feature))) {
        return (typeof(window.MutationObserver) !== "undefined")
      } else if ($eqeqeq("WebSocket", $ret_or_1)) {
        return (typeof(window.WebSocket) !== "undefined")
      } else if ($eqeqeq("EventSource", $ret_or_1)) {
        return (typeof(window.EventSource) !== "undefined")
      } else if ($eqeqeq("XHR", $ret_or_1)) {
        return (typeof(window.XMLHttpRequest) !== "undefined")
      } else if ($eqeqeq("ActiveX", $ret_or_1)) {
        return (typeof(window.ActiveXObject) !== "undefined")
      } else if ($eqeqeq("WebSQL", $ret_or_1)) {
        return (typeof(window.openDatabase) !== "undefined")
      } else if ($eqeqeq("Query.css", $ret_or_1)) {
        return (typeof(document.querySelectorAll) !== "undefined")
      } else if ($eqeqeq("Query.xpath", $ret_or_1)) {
        return (typeof(document.evaluate) !== "undefined")
      } else if ($eqeqeq("Storage.local", $ret_or_1)) {
        return (typeof(window.localStorage) !== "undefined")
      } else if ($eqeqeq("Storage.global", $ret_or_1)) {
        return (typeof(window.globalStorage) !== "undefined")
      } else if ($eqeqeq("Storage.session", $ret_or_1)) {
        return (typeof(window.sessionStorage) !== "undefined")
      } else if ($eqeqeq("Immediate", $ret_or_1)) {
        return (typeof(window.setImmediate) !== "undefined")
      } else if ($eqeqeq("Immediate (Internet Explorer)", $ret_or_1)) {
        return (typeof(window.msSetImmediate) !== "undefined")
      } else if ($eqeqeq("Immediate (Firefox)", $ret_or_1)) {
        return (typeof(window.mozSetImmediate) !== "undefined")
      } else if ($eqeqeq("Immediate (Opera)", $ret_or_1)) {
        return (typeof(window.oSetImmediate) !== "undefined")
      } else if (($eqeqeq("Immediate (Chrome)", $ret_or_1) || ($eqeqeq("setImmediate (Safari)", $ret_or_1)))) {
        return (typeof(window.webkitSetImmediate) !== "undefined")
      } else if ($eqeqeq("CSS.computed", $ret_or_1)) {
        return (typeof(window.getComputedStyle) !== "undefined")
      } else if ($eqeqeq("CSS.current", $ret_or_1)) {
        return (typeof(document.documentElement.currentStyle) !== "undefined")
      } else if ($eqeqeq("Window.send", $ret_or_1)) {
        return (typeof(window.postMessage) !== "undefined")
      } else if ($eqeqeq("Window.send (Asynchronous)", $ret_or_1)) {
        if (($truthy((typeof(window.postMessage) !== "undefined")) && ($not((typeof(window.importScripts) !== "undefined"))))) {
          
            (function() {
              var ok  = true,
                  old = window.onmessage;

              window.onmessage = function() { ok = false; };
              window.postMessage("", "*")
              window.onmessage = old;

              return ok;
            })()
          
        } else {
          return nil
        }
      } else if ($eqeqeq("Window.send (Synchronous)", $ret_or_1)) {
        return self['$supports?']("Window.send (Asynchronous)")['$!']()
      } else if ($eqeqeq("Window.innerSize", $ret_or_1)) {
        return (typeof(window.innerHeight) !== "undefined")
      } else if ($eqeqeq("Window.outerSize", $ret_or_1)) {
        return (typeof(window.outerHeight) !== "undefined")
      } else if ($eqeqeq("Window.scroll", $ret_or_1)) {
        return (typeof(document.documentElement.scrollLeft) !== "undefined")
      } else if ($eqeqeq("Window.scrollBy", $ret_or_1)) {
        return (typeof(document.documentElement.scrollBy) !== "undefined")
      } else if ($eqeqeq("Window.pageOffset", $ret_or_1)) {
        return (typeof(window.pageXOffset) !== "undefined")
      } else if ($eqeqeq("Attr.isId", $ret_or_1)) {
        
          (function() {
            var div = document.createElement('div');
                div.setAttribute('id', 'xxxxxxxxxxxxx');

            return typeof(div.attributes['id'].isId) !== "undefined";
          })()
        
      } else if ($eqeqeq("Element.addBehavior", $ret_or_1)) {
        return (typeof(document.documentElement.addBehavior) !== "undefined")
      } else if ($eqeqeq("Element.className", $ret_or_1)) {
        
          (function() {
            var div = document.createElement("div");
                div.setAttribute('className', 'x');

            return div.className === 'x';
          })()
        
      } else if ($eqeqeq("Element.class", $ret_or_1)) {
        
          (function() {
            var div = document.createElement("div");
                div.setAttribute('class', 'x');

            return div.className === 'x';
          })()
        
      } else if ($eqeqeq("Element.for", $ret_or_1)) {
        
          (function() {
            var label = document.createElement("label");
                label.setAttribute('for', 'x');

            return label.htmlFor === 'x';
          })()
        
      } else if ($eqeqeq("Element.htmlFor", $ret_or_1)) {
        
          (function() {
            var label = document.createElement("label");
                label.setAttribute('htmlFor', 'x');

            return label.htmlFor === 'x';
          })()
        
      } else if ($eqeqeq("Element.clientSize", $ret_or_1)) {
        return (typeof(document.documentElement.clientHeight) !== "undefined")
      } else if ($eqeqeq("Element.scroll", $ret_or_1)) {
        return (typeof(document.documentElement.scrollLeft) !== "undefined")
      } else if ($eqeqeq("Element.textContent", $ret_or_1)) {
        return (typeof(document.documentElement.textContent) !== "undefined")
      } else if ($eqeqeq("Element.innerText", $ret_or_1)) {
        return (typeof(document.documentElement.innerText) !== "undefined")
      } else if ($eqeqeq("Element.matches", $ret_or_1)) {
        return (typeof(document.documentElement.matches) !== "undefined")
      } else if ($eqeqeq("Element.matches (Internet Explorer)", $ret_or_1)) {
        return (typeof(document.documentElement.msMatchesSelector) !== "undefined")
      } else if ($eqeqeq("Element.matches (Firefox)", $ret_or_1)) {
        return (typeof(document.documentElement.mozMatchesSelector) !== "undefined")
      } else if ($eqeqeq("Element.matches (Opera)", $ret_or_1)) {
        return (typeof(document.documentElement.oMatchesSelector) !== "undefined")
      } else if (($eqeqeq("Element.matches (Chrome)", $ret_or_1) || ($eqeqeq("Element.matches (Safari)", $ret_or_1)))) {
        return (typeof(document.documentElement.webkitMatchesSelector) !== "undefined")
      } else if ($eqeqeq("Element.getBoundingClientRect", $ret_or_1)) {
        return (typeof(document.documentElement.getBoundingClientRect) !== "undefined")
      } else if ($eqeqeq("Event.readystatechange", $ret_or_1)) {
        return "onreadystatechange" in window.document.createElement("script");
      } else if ($eqeqeq("Event.constructor", $ret_or_1)) {
        
        try {
          
          new MouseEvent("click");
          return true;
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
            try {
              return false
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      } else if ($eqeqeq("Event.create", $ret_or_1)) {
        return (typeof(document.createEvent) !== "undefined")
      } else if ($eqeqeq("Event.createObject", $ret_or_1)) {
        return (typeof(document.createEventObject) !== "undefined")
      } else if ($eqeqeq("Event.addListener", $ret_or_1)) {
        return (typeof(document.addEventListener) !== "undefined")
      } else if ($eqeqeq("Event.attach", $ret_or_1)) {
        return (typeof(document.attachEvent) !== "undefined")
      } else if ($eqeqeq("Event.removeListener", $ret_or_1)) {
        return (typeof(document.removeEventListener) !== "undefined")
      } else if ($eqeqeq("Event.detach", $ret_or_1)) {
        return (typeof(document.detachEvent) !== "undefined")
      } else if ($eqeqeq("Event.dispatch", $ret_or_1)) {
        return (typeof(document.dispatchEvent) !== "undefined")
      } else if ($eqeqeq("Event.fire", $ret_or_1)) {
        return (typeof(document.fireEvent) !== "undefined")
      } else if ($eqeqeq(/^Event\.([A-Z].*?)$/, $ret_or_1)) {
        return ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)) + "Event") in window
      } else if ($eqeqeq("Document.view", $ret_or_1)) {
        return (typeof(document.defaultView) !== "undefined")
      } else if ($eqeqeq("Document.window", $ret_or_1)) {
        return (typeof(document.parentWindow) !== "undefined")
      } else if ($eqeqeq("History", $ret_or_1)) {
        return (typeof(window.history.pushState) !== "undefined")
      } else if ($eqeqeq("History.state", $ret_or_1)) {
        return (typeof(window.history.state) !== "undefined")
      } else if ($eqeqeq("Animation.request", $ret_or_1)) {
        return (typeof(window.requestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.request (Internet Explorer)", $ret_or_1)) {
        return (typeof(window.msRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.request (Firefox)", $ret_or_1)) {
        return (typeof(window.mozRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.request (Opera)", $ret_or_1)) {
        return (typeof(window.oRequestAnimationFrame) !== "undefined")
      } else if (($eqeqeq("Animation.request (Chrome)", $ret_or_1) || ($eqeqeq("Animation.request (Safari)", $ret_or_1)))) {
        return (typeof(window.webkitRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancel", $ret_or_1)) {
        return (typeof(window.cancelAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancel (Internet Explorer)", $ret_or_1)) {
        return (typeof(window.msCancelAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancel (Firefox)", $ret_or_1)) {
        return (typeof(window.mozCancelAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancel (Opera)", $ret_or_1)) {
        return (typeof(window.oCancelAnimationFrame) !== "undefined")
      } else if (($eqeqeq("Animation.cancel (Chrome)", $ret_or_1) || ($eqeqeq("Animation.cancel (Safari)", $ret_or_1)))) {
        return (typeof(window.webkitCancelAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancelRequest", $ret_or_1)) {
        return (typeof(window.cancelRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancelRequest (Internet Explorer)", $ret_or_1)) {
        return (typeof(window.msCancelRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancelRequest (Firefox)", $ret_or_1)) {
        return (typeof(window.mozCancelRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancelRequest (Opera)", $ret_or_1)) {
        return (typeof(window.oCancelRequestAnimationFrame) !== "undefined")
      } else if (($eqeqeq("Animation.cancelRequest (Chrome)", $ret_or_1) || ($eqeqeq("Animation.cancelRequest (Safari)", $ret_or_1)))) {
        return (typeof(window.webkitCancelRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Audio", $ret_or_1)) {
        return (typeof(window.AudioContext) !== "undefined")
      } else if (($eqeqeq("Audio (Safari)", $ret_or_1) || ($eqeqeq("Audio (Chrome)", $ret_or_1)))) {
        return (typeof(window.webkitAudioContext) !== "undefined")
      } else if ($eqeqeq("Custom Elements", $ret_or_1)) {
        return (typeof(window.customElements) !== "undefined")
      } else {
        return nil
      }})();
      return self.support[feature] = support;
    }, 1);
    return $defs(self, '$loaded?', function $Browser_loaded$ques$2(name) {
      
      
      switch (name) {
        case "Sizzle":
          return (typeof(window.Sizzle) !== "undefined")
        case "wicked-good-xpath":
          return (typeof(window.wgxpath) !== "undefined")
        default:
          return nil
      }
    }, 1);
  })($nesting[0], $nesting);
};

Opal.modules["browser/dom/document"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $alias = Opal.alias, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $kwrestargs = Opal.kwrestargs, $hash2 = Opal.hash2, $send = Opal.send, $return_self = Opal.return_self, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,DOM,first,css,xpath,[],raise,[]=,dig,to_n,join,Array,each,inner_dom,to_proc,<<,supports?,ready?,call,on,off,convert,new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Document');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$('DocumentOrShadowRoot'));
        
        $def(self, '$[]', function $Document_$$$1(what) {
          var self = this, $ret_or_1 = nil;

          
          
      var result = self["native"].getElementById(what);

      if (result) {
        return self.$DOM(result);
      }
    ;
          if ($truthy(($ret_or_1 = self.$css(what).$first()))) {
            return $ret_or_1
          } else {
            return self.$xpath(what).$first()
          };
        }, 1);
        $alias(self, "at", "[]");
        
        $def(self, '$body', function $$body() {
          var self = this;

          try {
            return self.$DOM(self["native"].body)
          } catch ($err) {
            if (Opal.rescue($err, [$$('ArgumentError')])) {
              try {
                return self.$raise("$document.body is not defined; try to wrap your code in $document.ready{}")
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          }
        }, 0);
        
        $def(self, '$create_element', function $$create_element(name, $a, $b) {
          var block = $$create_element.$$p || nil, $post_args, $kwargs, builder, options, $c, self = this, opts = nil, ns = nil, elem = nil, dom = nil;

          $$create_element.$$p = null;
          
          ;
          $post_args = $slice.call(arguments, 1);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          
          if ($post_args.length > 0) builder = $post_args.shift();if (builder == null) builder = nil;
          options = $kwrestargs($kwargs, {});
          opts = $hash2([], {});
          if (($truthy(options['$[]']("is")) || ($truthy(($c = ["is", options.$dig("attrs", "is")], $send(options, '[]=', $c), $c[$c.length - 1]))))) {
            opts['$[]=']("is", options['$[]']("is"))
          };
          if ($truthy((ns = options['$[]']("namespace")))) {
            elem = self["native"].createElementNS(ns, name, opts.$to_n())
          } else {
            elem = self["native"].createElement(name, opts.$to_n())
          };
          if ($truthy(options['$[]']("classes"))) {
            elem.className = self.$Array(options['$[]']("classes")).$join(" ")
          };
          if ($truthy(options['$[]']("id"))) {
            elem.id = options['$[]']("id")
          };
          if ($truthy(options['$[]']("attrs"))) {
            $send(options['$[]']("attrs"), 'each', [], function $$2(k, v){
              
              if (k == null) k = nil;
              if (v == null) v = nil;
              if (!$truthy(v)) {
                return nil
              };
              return elem.setAttribute(k, v);}, 2)
          };
          dom = self.$DOM(elem);
          if ((block !== nil)) {
            $send(dom, 'inner_dom', [builder], block.$to_proc())
          };
          if ($truthy(builder)) {
            builder['$<<'](dom)
          };
          return dom;
        }, -2);
        
        $def(self, '$create_document_fragment', function $$create_document_fragment() {
          var self = this;

          return self.$DOM(self["native"].createDocumentFragment())
        }, 0);
        
        $def(self, '$create_text', function $$create_text(content) {
          var self = this;

          return self.$DOM(self["native"].createTextNode(content))
        }, 1);
        
        $def(self, '$create_comment', function $$create_comment(content) {
          var self = this;

          return self.$DOM(self["native"].createComment(content))
        }, 1);
        
        $def(self, '$document', $return_self, 0);
        
        $def(self, '$head', function $$head() {
          var self = this;

          return self.$DOM(self["native"].getElementsByTagName("head")[0])
        }, 0);
        
        $def(self, '$inspect', $return_val("#<DOM::Document>"), 0);
        if ($truthy($$('Browser')['$supports?']("Event.addListener"))) {
          
          $def(self, '$ready', function $$ready() {
            var block = $$ready.$$p || nil, self = this;

            $$ready.$$p = null;
            
            ;
            if (!$truthy(block)) {
              self.$raise($$('ArgumentError'), "no block given")
            };
            if ($truthy(self['$ready?']())) {
              return block.$call()
            };
            return $send(self, 'on', ["dom:load"], function $$3(e){
              
              if (e == null) e = nil;
              e.$off();
              return block.$call();}, 1);
          }, 0)
        } else if ($truthy($$('Browser')['$supports?']("Event.attach"))) {
          
          $def(self, '$ready', function $$ready() {
            var block = $$ready.$$p || nil, self = this;

            $$ready.$$p = null;
            
            ;
            if (!$truthy(block)) {
              self.$raise($$('ArgumentError'), "no block given")
            };
            if ($truthy(self['$ready?']())) {
              return block.$call()
            };
            return $send(self, 'on', ["ready:state:change"], function $$4(e){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (e == null) e = nil;
              if ($truthy(self['$ready?']())) {
                
                e.$off();
                return block.$call();
              } else {
                return nil
              };}, {$$arity: 1, $$s: self});
          }, 0)
        } else {
          
          $def(self, '$ready', function $$ready() {
            var block = $$ready.$$p || nil, self = this;

            $$ready.$$p = null;
            
            ;
            return self.$raise($$('NotImplementedError'), "document ready unsupported");
          }, 0)
        };
        
        $def(self, '$ready?', function $Document_ready$ques$5() {
          var self = this;

          return self["native"].readyState === "complete" || self["native"].readyState === "interactive"
        }, 0);
        
        $def(self, '$referrer', function $$referrer() {
          var self = this;

          return self["native"].referrer
        }, 0);
        
        $def(self, '$root', function $$root() {
          var self = this;

          return self.$DOM(self["native"].documentElement)
        }, 0);
        
        $def(self, '$root=', function $Document_root$eq$6(element) {
          var self = this;

          return self["native"].documentElement = $$('Native').$convert(element)
        }, 1);
        
        $def(self, '$title', function $$title() {
          var self = this;

          return self["native"].title
        }, 0);
        
        $def(self, '$title=', function $Document_title$eq$7(value) {
          var self = this;

          return self["native"].title = value
        }, 1);
        
        $def(self, '$hidden?', function $Document_hidden$ques$8() {
          var self = this;

          return self["native"].hidden
        }, 0);
        
        $def(self, '$visibility', function $$visibility() {
          var self = this;

          return self["native"].visibilityState
        }, 0);
        if ($truthy($$('Browser')['$supports?']("Document.view"))) {
          return $def(self, '$window', function $$window() {
            var self = this;

            return $$('Window').$new(self["native"].defaultView)
          }, 0)
        } else if ($truthy($$('Browser')['$supports?']("Document.window"))) {
          return $def(self, '$window', function $$window() {
            var self = this;

            return $$('Window').$new(self["native"].parentWindow)
          }, 0)
        } else {
          return $def(self, '$window', function $$window() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window from document unsupported")
          }, 0)
        };
      })($nesting[0], $$('Element'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["ostruct"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $slice = Opal.slice, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each_pair,[]=,new_ostruct_member,[],to_sym,>,length,raise,new,end_with?,!=,chomp,to_s,key?,enum_for,is_a?,==,instance_variable_get,===,eql?,dup,to_n,hash,attr_reader,__send__,singleton_class,delete,respond_to?,define_singleton_method,__id__,class,any?,+,join,map,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'OpenStruct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.table = nil;
    
    
    $def(self, '$initialize', function $$initialize(hash) {
      var self = this;

      
      if (hash == null) hash = nil;
      self.table = $hash2([], {});
      if ($truthy(hash)) {
        return $send(hash, 'each_pair', [], function $$1(key, value){var $a, self = $$1.$$s == null ? this : $$1.$$s;
          if (self.table == null) self.table = nil;

          
          if (key == null) key = nil;
          if (value == null) value = nil;
          return ($a = [self.$new_ostruct_member(key), value], $send(self.table, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self})
      } else {
        return nil
      };
    }, -1);
    
    $def(self, '$[]', function $OpenStruct_$$$2(name) {
      var self = this;

      return self.table['$[]'](name.$to_sym())
    }, 1);
    
    $def(self, '$[]=', function $OpenStruct_$$$eq$3(name, value) {
      var $a, self = this;

      return ($a = [self.$new_ostruct_member(name), value], $send(self.table, '[]=', $a), $a[$a.length - 1])
    }, 2);
    
    $def(self, '$method_missing', function $$method_missing(name, $a) {
      var $post_args, args, $b, self = this;

      
      $post_args = $slice.call(arguments, 1);
      args = $post_args;
      if ($truthy($rb_gt(args.$length(), 2))) {
        self.$raise($$('NoMethodError').$new("undefined method `" + (name) + "' for #<OpenStruct>", name))
      };
      if ($truthy(name['$end_with?']("="))) {
        
        if ($neqeq(args.$length(), 1)) {
          self.$raise($$('ArgumentError'), "wrong number of arguments (0 for 1)")
        };
        return ($b = [self.$new_ostruct_member(name['$[]']($range(0, -2, false))), args['$[]'](0)], $send(self.table, '[]=', $b), $b[$b.length - 1]);
      } else {
        return self.table['$[]'](name.$to_sym())
      };
    }, -2);
    
    $def(self, '$respond_to_missing?', function $OpenStruct_respond_to_missing$ques$4(mid, include_private) {
      var $a, $yield = $OpenStruct_respond_to_missing$ques$4.$$p || nil, self = this, mname = nil, $ret_or_1 = nil;

      $OpenStruct_respond_to_missing$ques$4.$$p = null;
      
      if (include_private == null) include_private = false;
      mname = mid.$to_s().$chomp("=").$to_sym();
      if ($truthy(($ret_or_1 = ($a = self.table, ($a === nil || $a == null) ? nil : $a['$key?'](mname))))) {
        return $ret_or_1
      } else {
        return $send2(self, $find_super(self, 'respond_to_missing?', $OpenStruct_respond_to_missing$ques$4, false, true), 'respond_to_missing?', [mid, include_private], $yield)
      };
    }, -2);
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      $$each_pair.$$p = null;
      
      if (!($yield !== nil)) {
        return self.$enum_for("each_pair")
      };
      return $send(self.table, 'each_pair', [], function $$5(pair){
        
        if (pair == null) pair = nil;
        return Opal.yield1($yield, pair);;}, 1);
    }, 0);
    
    $def(self, '$==', function $OpenStruct_$eq_eq$6(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$=='](other.$instance_variable_get("@table"));
    }, 1);
    
    $def(self, '$===', function $OpenStruct_$eq_eq_eq$7(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$==='](other.$instance_variable_get("@table"));
    }, 1);
    
    $def(self, '$eql?', function $OpenStruct_eql$ques$8(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$eql?'](other.$instance_variable_get("@table"));
    }, 1);
    
    $def(self, '$to_h', function $$to_h() {
      var self = this;

      return self.table.$dup()
    }, 0);
    
    $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.table.$to_n()
    }, 0);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.table.$hash()
    }, 0);
    self.$attr_reader("table");
    
    $def(self, '$delete_field', function $$delete_field(name) {
      var self = this, sym = nil;

      
      sym = name.$to_sym();
      
      try {
        self.$singleton_class().$__send__("remove_method", sym, "" + (sym) + "=")
      } catch ($err) {
        if (Opal.rescue($err, [$$('NameError')])) {
          try {
            nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };;
      return self.table.$delete(sym);
    }, 1);
    
    $def(self, '$new_ostruct_member', function $$new_ostruct_member(name) {
      var self = this;

      
      name = name.$to_sym();
      if (!$truthy(self['$respond_to?'](name))) {
        
        $send(self, 'define_singleton_method', [name], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;
          if (self.table == null) self.table = nil;

          return self.table['$[]'](name)}, {$$arity: 0, $$s: self});
        $send(self, 'define_singleton_method', ["" + (name) + "="], function $$10(x){var $a, self = $$10.$$s == null ? this : $$10.$$s;
          if (self.table == null) self.table = nil;

          
          if (x == null) x = nil;
          return ($a = [name, x], $send(self.table, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});
      };
      return name;
    }, 1);
    var ostruct_ids;;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      
      var top = (ostruct_ids === undefined),
          ostruct_id = self.$__id__();
    ;
      
      return (function() { try {
      
      result = "#<" + (self.$class());
      
        if (top) {
          ostruct_ids = {};
        }
        if (ostruct_ids.hasOwnProperty(ostruct_id)) {
          return result + ' ...>';
        }
        ostruct_ids[ostruct_id] = true;
      ;
      if ($truthy(self.table['$any?']())) {
        result = $rb_plus(result, " ")
      };
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$11(name, value){
        
        if (name == null) name = nil;
        if (value == null) value = nil;
        return "" + (name) + "=" + (value.$inspect());}, 2).$join(", "));
      result = $rb_plus(result, ">");
      return result;
      } finally {
        
        if (top) {
          ostruct_ids = undefined;
        }
      
      }; })();;
    }, 0);
    return $alias(self, "to_s", "inspect");
  })($nesting[0], null, $nesting)
};

Opal.modules["browser/dom/text"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('create_text,DOM,data');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Text');

        var $proto = self.$$prototype;

        $proto["native"] = nil;
        
        $defs(self, '$create', function $$create(content) {
                    if ($gvars.document == null) $gvars.document = nil;

          return $gvars.document.$create_text(content)
        }, 1);
        
        $def(self, '$whole', function $$whole() {
          var self = this;

          return self["native"].wholeText
        }, 0);
        
        $def(self, '$split', function $$split(offset) {
          var self = this;

          return self.$DOM(self["native"].splitText(offset))
        }, 1);
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<DOM::Text: " + (self.$data()) + ">"
        }, 0);
      })($nesting[0], $$('CharacterData'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/attribute"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,alias_native,supports?,==,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Attribute');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        self.$alias_native("name");
        self.$alias_native("value");
        self.$alias_native("value=");
        if ($truthy($$('Browser')['$supports?']("Attr.isId"))) {
          return self.$alias_native("id?", "isId")
        } else {
          return $def(self, '$id?', function $Attribute_id$ques$1() {
            var self = this;

            return self.$name()['$==']("id")
          }, 0)
        };
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/select"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('def_selector,to_n,[],new,DOM,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Select');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("select");
          
          $def(self, '$value', function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          }, 0);
          
          $def(self, '$value=', function $Select_value$eq$1(value) {
            var self = this;

            return self["native"].value = value.$to_n()
          }, 1);
          
          $def(self, '$labels', function $$labels() {
            var self = this;

            return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].labels))
          }, 0);
          
          $def(self, '$options', function $$options() {
            var self = this;

            return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].options))
          }, 0);
          
          $def(self, '$option', function $$option() {
            var self = this;

            return self.$DOM(self["native"].options[self["native"].selectedIndex])
          }, 0);
          
          $def(self, '$index', function $$index() {
            var self = this;

            return self["native"].selectedIndex
          }, 0);
          self.$alias_native("multiple?", "multiple");
          self.$alias_native("required?", "required");
          return self.$alias_native("length");
        })($nesting[0], $$('Element'), $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/input"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('def_selector,map,new,to_n');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Input');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("input");
          
          $def(self, '$value', function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          }, 0);
          
          $def(self, '$value=', function $Input_value$eq$1(value) {
            var self = this;

            return self["native"].value = value
          }, 1);
          
          $def(self, '$name_', function $$name_() {
            var self = this;

            return self["native"].name
          }, 0);
          
          $def(self, '$type', function $$type() {
            var self = this;

            return self["native"].type
          }, 0);
          
          $def(self, '$checked?', function $Input_checked$ques$2() {
            var self = this;

            return self["native"].checked
          }, 0);
          
          $def(self, '$check!', function $Input_check$excl$3() {
            var self = this;

            return self["native"].checked = 'checked'
          }, 0);
          
          $def(self, '$uncheck!', function $Input_uncheck$excl$4() {
            var self = this;

            return self["native"].checked = ''
          }, 0);
          
          $def(self, '$enabled?', function $Input_enabled$ques$5() {
            var self = this;

            return self["native"].enabled
          }, 0);
          
          $def(self, '$disable!', function $Input_disable$excl$6() {
            var self = this;

            return self["native"].disabled = 'disabled'
          }, 0);
          
          $def(self, '$enable!', function $Input_enable$excl$7() {
            var self = this;

            return self["native"].disabled = ''
          }, 0);
          
          $def(self, '$clear', function $$clear() {
            var self = this;

            return self["native"].value = ''
          }, 0);
          return $def(self, '$files', function $$files() {
            var self = this;

            return $send($$$($$('Native'), 'Array').$new(self["native"].files), 'map', [], function $$8(f){
              
              if (f == null) f = nil;
              return $$('File').$new(f.$to_n());}, 1)
          }, 0);
        })($nesting[0], $$('Element'), $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/template"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector,DOM');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Template');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("template");
          return $def(self, '$content', function $$content() {
            var self = this;

            return self.$DOM(self["native"].content)
          }, 0);
        })($nesting[0], $$('Element'))
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/image"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        (function($base, $super) {
          var self = $klass($base, $super, 'Image');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("img");
          
          $def(self, '$complete?', function $Image_complete$ques$1() {
            var self = this;

            return self["native"].complete
          }, 0);
          
          $def(self, '$cross?', function $Image_cross$ques$2() {
            var self = this;

            return self["native"].crossOrigin
          }, 0);
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].naturalHeight
          }, 0);
          return $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].naturalWidth
          }, 0);
        })($nesting[0], $$('Element'));
        return $const_set($nesting[0], 'Img', $$('Image'));
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/character_data"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'CharacterData');

        var $proto = self.$$prototype;

        $proto["native"] = nil;
        
        
        $def(self, '$append', function $$append(string) {
          var self = this;

          
          self["native"].appendData(string);
          return self;
        }, 1);
        
        $def(self, '$data', function $$data() {
          var self = this;

          return self["native"].data
        }, 0);
        
        $def(self, '$delete', function $CharacterData_delete$1(count, offset) {
          var self = this;

          
          if (offset == null) offset = 0;
          self["native"].deleteData(offset, count);
          return self;
        }, -2);
        
        $def(self, '$insert', function $$insert(string, offset) {
          var self = this;

          
          if (offset == null) offset = 0;
          self["native"].insertData(offset, string);
          return self;
        }, -2);
        self.$alias_native("length");
        
        $def(self, '$replace', function $$replace(string, offset, count) {
          var self = this;

          
          if (offset == null) offset = 0;
          if (count == null) count = self["native"].length;
          self["native"].replaceData(offset, count, string);
          return self;
        }, -2);
        return $def(self, '$substring', function $$substring(count, offset) {
          var self = this;

          
          if (offset == null) offset = 0;
          return self["native"].substringData(offset, count);
        }, -2);
      })($nesting[0], $$('Node'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/media"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        (function($base, $super) {
          var self = $klass($base, $super, 'Media');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$play', function $$play() {
            var self = this;

            return self["native"].play()
          }, 0)
        })($nesting[0], $$('Element'));
        (function($base, $super) {
          var self = $klass($base, $super, 'Video');

          
          return self.$def_selector("video")
        })($nesting[0], $$('Media'));
        return (function($base, $super) {
          var self = $klass($base, $super, 'Audio');

          
          return self.$def_selector("audio")
        })($nesting[0], $$('Media'));
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/button"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Button');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("button");
          
          $def(self, '$disabled?', function $Button_disabled$ques$1() {
            var self = this;

            return self["native"].disabled
          }, 0);
          
          $def(self, '$disabled=', function $Button_disabled$eq$2(value) {
            var self = this;

            return self["native"].disabled = value
          }, 1);
          
          $def(self, '$autofocus?', function $Button_autofocus$ques$3() {
            var self = this;

            return self["native"].autofocus
          }, 0);
          
          $def(self, '$autofocus=', function $Button_autofocus$eq$4(value) {
            var self = this;

            return self["native"].autofocus = value
          }, 1);
          
          $def(self, '$name_', function $$name_() {
            var self = this;

            return self["native"].name
          }, 0);
          return $def(self, '$name_=', function $Button_name_$eq$5(value) {
            var self = this;

            return self["native"].name = value
          }, 1);
        })($nesting[0], $$('Element'))
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/textarea"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Textarea');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("textarea");
          
          $def(self, '$value', function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          }, 0);
          
          $def(self, '$value=', function $Textarea_value$eq$1(value) {
            var self = this;

            return self["native"].value = value
          }, 1);
          return $def(self, '$clear', function $$clear() {
            var self = this;

            return self["native"].value = ''
          }, 0);
        })($nesting[0], $$('Element'))
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/html/element"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $not = Opal.not, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $range = Opal.range, $eqeqeq = Opal.eqeqeq, $to_a = Opal.to_a, $slice = Opal.slice, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,==,capitalize,const_defined?,!,include?,to_s,new,const_get,each,to_proc,<<,end_with?,[]=,[],===,has_key?,unshift,|,split,delete,to_a,deep_merge!,>>,extend!,pop,join,heredoc,defhelper,map,empty?,upcase,inspect');
  
  self.$require("paggio/html/element/a");
  self.$require("paggio/html/element/base");
  self.$require("paggio/html/element/blockquote");
  self.$require("paggio/html/element/button");
  self.$require("paggio/html/element/canvas");
  self.$require("paggio/html/element/embed");
  self.$require("paggio/html/element/img");
  self.$require("paggio/html/element/input");
  self.$require("paggio/html/element/link");
  self.$require("paggio/html/element/object");
  self.$require("paggio/html/element/option");
  self.$require("paggio/html/element/optgroup");
  self.$require("paggio/html/element/select");
  self.$require("paggio/html/element/td");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.children = $proto.attributes = $proto.class_names = $proto.owner = $proto.name = nil;
        
        $defs(self, '$new', function $Element_new$1(owner, name, attributes) {
          var $yield = $Element_new$1.$$p || nil, self = this, const$ = nil;

          $Element_new$1.$$p = null;
          
          if (attributes == null) attributes = $hash2([], {});
          if (!$eqeq(self, $$('Element'))) {
            return $send2(self, $find_super(self, 'new', $Element_new$1, false, true), 'new', [owner, name, attributes], $yield)
          };
          const$ = name.$capitalize();
          if (($not(const$.$to_s()['$include?']("-")) && ($truthy(self['$const_defined?'](const$))))) {
            return self.$const_get(const$).$new(owner, name, attributes)
          } else {
            return $send2(self, $find_super(self, 'new', $Element_new$1, false, true), 'new', [owner, name, attributes], $yield)
          };
        }, -3);
        
        $def(self, '$initialize', function $$initialize(owner, name, attributes) {
          var self = this;

          
          if (attributes == null) attributes = $hash2([], {});
          self.owner = owner;
          self.name = name;
          self.attributes = attributes;
          self.children = [];
          return (self.class_names = []);
        }, -3);
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this;

          $$each.$$p = null;
          
          ;
          return $send(self.children, 'each', [], block.$to_proc());
        }, 0);
        
        $def(self, '$<<', function $Element_$lt$lt$2(what) {
          var self = this;

          
          self.children['$<<'](what);
          return self;
        }, 1);
        
        $def(self, '$method_missing', function $$method_missing(name, content) {
          var block = $$method_missing.$$p || nil, self = this;

          $$method_missing.$$p = null;
          
          ;
          if (content == null) content = nil;
          if ($truthy(name.$to_s()['$end_with?']("!"))) {
            self.attributes['$[]=']("id", name['$[]']($range(0, -2, false)))
          } else {
            self.class_names['$<<'](name)
          };
          if ($eqeqeq($$$('Hash'), content)) {
            
            if (($truthy(content['$has_key?']("class")) || ($truthy(content['$has_key?']("classes"))))) {
              $send(self.class_names, 'unshift', $to_a(content.$delete("class").$to_s().$split()['$|'](content.$delete("classes").$to_a())))
            };
            $$$($$$('Paggio'), 'Utils')['$deep_merge!'](self.attributes, content);
          } else if ($truthy(content)) {
            self['$>>'](content)
          };
          if ($truthy(block)) {
            $send(self.owner, 'extend!', [self], block.$to_proc())
          };
          return self;
        }, -2);
        
        $def(self, '$[]', function $Element_$$$3($a) {
          var $post_args, names, self = this, last = nil;

          
          $post_args = $slice.call(arguments);
          names = $post_args;
          if ($truthy((last = self.class_names.$pop()))) {
            self.class_names['$<<']([last].concat($to_a(names)).$join("-"))
          };
          return self;
        }, -1);
        
        $def(self, '$do', function $Element_do$4() {
          var block = $Element_do$4.$$p || nil, self = this;

          $Element_do$4.$$p = null;
          
          ;
          $send(self.owner, 'extend!', [self], block.$to_proc());
          return self;
        }, 0);
        
        $def(self, '$>>', function $Element_$gt$gt$5(content) {
          var self = this;

          
          self['$<<']($$$($$$('Paggio'), 'Utils').$heredoc(content.$to_s()));
          return self;
        }, 1);
        $send(self, 'defhelper', ["style"], function $Element$6(hash){var $a, self = $Element$6.$$s == null ? this : $Element$6.$$s;
          if (self.attributes == null) self.attributes = nil;

          
          if (hash == null) hash = nil;
          return ($a = ["style", $send(hash, 'map', [], function $$7(name, value){
            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return "" + (name) + ": " + (value);}, 2).$join(";")], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});
        $send(self, 'defhelper', ["data"], function $Element$8(hash){var self = $Element$8.$$s == null ? this : $Element$8.$$s;

          
          if (hash == null) hash = nil;
          return $send(hash, 'each', [], function $$9(name, value){var $a, self = $$9.$$s == null ? this : $$9.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return ($a = ["data-" + (name), value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});}, {$$arity: 1, $$s: self});
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          if ($truthy(self.children['$empty?']())) {
            return "#<HTML::Element(" + (self.name.$upcase()) + ")>"
          } else {
            return "#<HTML::Element(" + (self.name.$upcase()) + "): " + (self.children.$inspect()['$[]']($range(1, -2, false))) + ">"
          }
        }, 0);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
};

Opal.modules["paggio/css/color"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,map,to_proc,define_method,new');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Color');

        
        return $def(self, '$initialize', function $$initialize(value, type) {
          var self = this;

          
          self.internal = value;
          return (self.type = type);
        }, 2)
      })($nesting[0], null)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $send($send(["rgb", "rgba", "hsl", "hsla"], 'map', [], "to_sym".$to_proc()), 'each', [], function $String$1(name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      if (name == null) name = nil;
      return $send(self, 'define_method', [name], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return $$$($$$($$('Paggio'), 'CSS'), 'Color').$new(self, name)}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self})
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $send($send(["rgb", "rgba", "hsl", "hsla"], 'map', [], "to_sym".$to_proc()), 'each', [], function $Array$3(name){var self = $Array$3.$$s == null ? this : $Array$3.$$s;

      
      if (name == null) name = nil;
      return $send(self, 'define_method', [name], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

        return $$$($$$($$('Paggio'), 'CSS'), 'Color').$new(self, name)}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self})
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/dom/element/attributes"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $send = Opal.send, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,to_n,[],supports?,==,to_s,[]=,include,enum_for,each,attribute_nodes,name,value,!');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Attributes');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.namespace = $proto["native"] = $proto.element = nil;
          
          self.$attr_reader("namespace");
          
          $def(self, '$initialize', function $$initialize(element, options) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            return (self.namespace = options['$[]']("namespace"));
          }, 2);
          if (($truthy($$('Browser')['$supports?']("Element.className")) || ($truthy($$('Browser')['$supports?']("Element.htmlFor"))))) {
            
            
            $def(self, '$[]', function $Attributes_$$$1(name, options) {
              var self = this, namespace = nil, $ret_or_1 = nil;

              
              if (options == null) options = $hash2([], {});
              if (($eqeq(name, "class") && ($truthy($$('Browser')['$supports?']("Element.className"))))) {
                name = "className"
              } else if (($eqeq(name, "for") && ($truthy($$('Browser')['$supports?']("Element.htmlFor"))))) {
                name = "htmlFor"
              };
              if ($truthy((namespace = ($truthy(($ret_or_1 = options['$[]']("namespace"))) ? ($ret_or_1) : (self.namespace))))) {
                return self["native"].getAttributeNS(namespace.$to_s(), name.$to_s()) || nil
              } else {
                return self["native"].getAttribute(name.$to_s()) || nil
              };
            }, -2);
            
            $def(self, '$[]=', function $Attributes_$$$eq$2(name, value, options) {
              var self = this, namespace = nil, $ret_or_1 = nil;

              
              if (options == null) options = $hash2([], {});
              if (($eqeq(name, "class") && ($truthy($$('Browser')['$supports?']("Element.className"))))) {
                name = "className"
              } else if (($eqeq(name, "for") && ($truthy($$('Browser')['$supports?']("Element.htmlFor"))))) {
                name = "htmlFor"
              };
              if ($truthy((namespace = ($truthy(($ret_or_1 = options['$[]']("namespace"))) ? ($ret_or_1) : (self.namespace))))) {
                if ($truthy(value)) {
                  return self["native"].setAttributeNS(namespace.$to_s(), name.$to_s(), value)
                } else {
                  return self["native"].removeAttributeNS(namespace.$to_s(), name.$to_s())
                }
              } else if ($truthy(value)) {
                return self["native"].setAttribute(name.$to_s(), value.$to_s())
              } else {
                return self["native"].removeAttribute(name.$to_s())
              };
            }, -3);
          } else {
            
            
            $def(self, '$[]', function $Attributes_$$$3(name, options) {
              var self = this, namespace = nil, $ret_or_1 = nil;

              
              if (options == null) options = $hash2([], {});
              if ($truthy((namespace = ($truthy(($ret_or_1 = options['$[]']("namespace"))) ? ($ret_or_1) : (self.namespace))))) {
                return self["native"].getAttributeNS(namespace.$to_s(), name.$to_s()) || nil
              } else {
                return self["native"].getAttribute(name.$to_s()) || nil
              };
            }, -2);
            
            $def(self, '$[]=', function $Attributes_$$$eq$4(name, value, options) {
              var self = this, namespace = nil, $ret_or_1 = nil;

              
              if (options == null) options = $hash2([], {});
              if ($truthy((namespace = ($truthy(($ret_or_1 = options['$[]']("namespace"))) ? ($ret_or_1) : (self.namespace))))) {
                if ($truthy(value)) {
                  return self["native"].setAttributeNS(namespace.$to_s(), name.$to_s(), value)
                } else {
                  return self["native"].removeAttributeNS(namespace.$to_s(), name.$to_s())
                }
              } else if ($truthy(value)) {
                return self["native"].setAttribute(name.$to_s(), value.$to_s())
              } else {
                return self["native"].removeAttribute(name.$to_s())
              };
            }, -3);
          };
          
          $def(self, '$delete', function $Attributes_delete$5(name) {
            var self = this, attr = nil;

            
            attr = self['$[]'](name);
            self['$[]='](name, nil);
            return attr;
          }, 1);
          self.$include($$('Enumerable'));
          
          $def(self, '$each', function $$each() {
            var block = $$each.$$p || nil, self = this;

            $$each.$$p = null;
            
            ;
            if (!(block !== nil)) {
              return self.$enum_for("each")
            };
            $send(self.element.$attribute_nodes(), 'each', [], function $$6(attr){
              
              if (attr == null) attr = nil;
              return Opal.yieldX(block, [attr.$name(), attr.$value()]);;}, 1);
            return self;
          }, 0);
          $alias(self, "get", "[]");
          
          $def(self, '$has_key?', function $Attributes_has_key$ques$7(name) {
            var self = this;

            return self['$[]'](name)['$!']()['$!']()
          }, 1);
          
          $def(self, '$merge!', function $Attributes_merge$excl$8(hash) {
            var self = this;

            
            $send(hash, 'each', [], function $$9(name, value){var $a, self = $$9.$$s == null ? this : $$9.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              return ($a = [name, value], $send(self, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
            return self;
          }, 1);
          return $alias(self, "set", "[]=");
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/scroll"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,to_n,include?,class,===,first,[],set,set_by,supports?,private,+,x,y,new,raise,position');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Scroll');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = $proto.element = $proto.scrolling_native = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            self.scrolling_native = self["native"];
            if ($truthy([$$('Document'), $$('Window')]['$include?'](self.element.$class()))) {
              
              if ($truthy((typeof(self.scrolling_native.document) !== "undefined"))) {
                self.scrolling_native = self.scrolling_native.document
              };
              if ($truthy((typeof(self.scrolling_native.documentElement.scrollTop) !== "undefined"))) {
                return (self.scrolling_native = self.scrolling_native.documentElement)
              } else if ($truthy((typeof(self.scrolling_native.body.scrollTop) !== "undefined"))) {
                return (self.scrolling_native = self.scrolling_native.body)
              } else {
                return nil
              };
            } else {
              return nil
            };
          }, 1);
          
          $def(self, '$to', function $$to($a) {
            var $post_args, args, $b, $c, self = this, x = nil, y = nil, $ret_or_1 = nil;

            
            $post_args = $slice.call(arguments);
            args = $post_args;
            $b = [nil, nil], (x = $b[0]), (y = $b[1]), $b;
            if ($eqeqeq($$('Hash'), ($ret_or_1 = args.$first()))) {
              
              x = args.$first()['$[]']("x");
              y = args.$first()['$[]']("y");
            } else if ($eqeqeq("top", $ret_or_1)) {
              y = 0
            } else if ($eqeqeq("bottom", $ret_or_1)) {
              y = 99999999
            } else {
              $c = args, $b = $to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c
            };
            if (($truthy(x) || ($truthy(y)))) {
              self.$set(x, y)
            };
            return self;
          }, -1);
          
          $def(self, '$by', function $$by($a) {
            var $post_args, args, $b, $c, self = this, $ret_or_1 = nil, x = nil, $ret_or_2 = nil, y = nil;

            
            $post_args = $slice.call(arguments);
            args = $post_args;
            if ($eqeqeq($$('Hash'), ($ret_or_1 = args.$first()))) {
              
              x = ($truthy(($ret_or_2 = args.$first()['$[]']("x"))) ? ($ret_or_2) : (0));
              y = ($truthy(($ret_or_2 = args.$first()['$[]']("y"))) ? ($ret_or_2) : (0));
            } else {
              $c = args, $b = $to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c
            };
            self.$set_by(x, y);
            return self;
          }, -1);
          if ($truthy($$('Browser')['$supports?']("Element.scrollBy"))) {
            self.$private($def(self, '$set_by', function $$set_by(x, y) {
              var self = this;

              return self.scrolling_native.scrollBy(x, y)
            }, 2))
          } else {
            self.$private($def(self, '$set_by', function $$set_by(x, y) {
              var self = this;

              return self.$set($rb_plus(self.$x(), x), $rb_plus(self.$y(), y))
            }, 2))
          };
          if ($truthy($$('Browser')['$supports?']("Element.scroll"))) {
            
            self.$private($def(self, '$set', function $$set(x, y) {
              var self = this;

              
              if (x == null) x = nil;
              if (y == null) y = nil;
              if ($truthy(y)) {
                self.scrolling_native.scrollTop  = y
              };
              if ($truthy(x)) {
                return self.scrolling_native.scrollLeft = x
              } else {
                return nil
              };
            }, -1));
            
            $def(self, '$position', function $$position() {
              var self = this;

              return $$$($$('Browser'), 'Position').$new(self.scrolling_native.scrollLeft, self.scrolling_native.scrollTop)
            }, 0);
          } else {
            
            self.$private($def(self, '$set', function $$set(x, y) {
              var self = this;

              
              if (x == null) x = nil;
              if (y == null) y = nil;
              return self.$raise($$('NotImplementedError'), "scroll on element unsupported");
            }, -1));
            
            $def(self, '$position', function $$position() {
              var self = this;

              return self.$raise($$('NotImplementedError'), "scroll on element unsupported")
            }, 0);
          };
          
          $def(self, '$x', function $$x() {
            var self = this;

            return self.$position().$x()
          }, 0);
          
          $def(self, '$y', function $$y() {
            var self = this;

            return self.$position().$y()
          }, 0);
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self.scrolling_native.scrollHeight
          }, 0);
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self.scrolling_native.scrollWidth
          }, 0);
          if ($truthy($$('Browser')['$supports?']("Element.scrollIntoViewIfNeeded"))) {
            
            $def(self, '$into_view', function $$into_view(align) {
              var self = this;

              
              if (align == null) align = true;
              return self.scrolling_native.scrollIntoViewIfNeeded(align);
            }, -1)
          } else {
            
            $def(self, '$into_view', function $$into_view(align) {
              var self = this;

              
              if (align == null) align = true;
              return self.$raise($$('NotImplementedError'));
            }, -1)
          };
          return $def(self, '$into_view!', function $Scroll_into_view$excl$1(align) {
            var self = this;

            
            if (align == null) align = true;
            return self.scrolling_native.scrollIntoView(align);
          }, -1);
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/html/helpers"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $truthy = Opal.truthy, $defs = Opal.defs, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('define_method,instance_exec,to_proc,do,defhelper,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Element');

        
        
        $defs(self, '$defhelper', function $$defhelper(name) {
          var block = $$defhelper.$$p || nil, self = this;

          $$defhelper.$$p = null;
          
          ;
          return $send(self, 'define_method', [name], function $$1($a){var body = $$1.$$p || nil, $post_args, args, self = $$1.$$s == null ? this : $$1.$$s;

            $$1.$$p = null;
            
            ;
            $post_args = $slice.call(arguments);
            args = $post_args;
            $send(self, 'instance_exec', $to_a(args), block.$to_proc());
            if ($truthy(body)) {
              $send(self, 'do', [], body.$to_proc())
            };
            return self;}, {$$arity: -1, $$s: self});
        }, 1);
        return $defs(self, '$defhelper!', function $Element_defhelper$excl$2(name, attribute) {
          var self = this;

          
          if (attribute == null) attribute = name;
          return $send(self, 'defhelper', ["" + (name) + "!"], function $$3(){var $a, self = $$3.$$s == null ? this : $$3.$$s;
            if (self.attributes == null) self.attributes = nil;

            return ($a = [attribute, true], $send(self.attributes, '[]=', $a), $a[$a.length - 1])}, {$$arity: 0, $$s: self});
        }, -2);
      })($nesting[0], $$('BasicObject'))
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["browser/dom/element/size"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,to_n,[]=,style');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Size');

          var $proto = self.$$prototype;

          $proto["native"] = $proto.element = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element, $a) {
            var $post_args, inc, self = this;

            
            $post_args = $slice.call(arguments, 1);
            inc = $post_args;
            self.element = element;
            self["native"] = element.$to_n();
            return (self.include = inc);
          }, -2);
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].offsetWidth
          }, 0);
          
          $def(self, '$width=', function $Size_width$eq$1(value) {
            var $a, self = this;

            return ($a = ["width", value], $send(self.element.$style(), '[]=', $a), $a[$a.length - 1])
          }, 1);
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].offsetHeight
          }, 0);
          
          $def(self, '$height=', function $Size_height$eq$2(value) {
            var $a, self = this;

            return ($a = ["height", value], $send(self.element.$style(), '[]=', $a), $a[$a.length - 1])
          }, 1);
          
          $def(self, '$client_width', function $$client_width() {
            var self = this;

            return self["native"].clientWidth
          }, 0);
          return $def(self, '$client_height', function $$client_height() {
            var self = this;

            return self["native"].clientHeight
          }, 0);
        })($nesting[0], null)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/offset"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $slice = Opal.slice, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,to_n,DOM,root,document,x,get,set,y,supports?,window,new,[],style!,==,[]=,style,to_u,===,first,+,-,px');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Offset');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = $proto.element = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element) {
            var self = this;

            
            self.element = element;
            return (self["native"] = element.$to_n());
          }, 1);
          
          $def(self, '$parent', function $$parent() {
            var self = this;

            return self.$DOM(self["native"].offsetParent || self.element.$document().$root().$to_n())
          }, 0);
          
          $def(self, '$x', function $$x() {
            var self = this;

            return self.$get().$x()
          }, 0);
          
          $def(self, '$x=', function $Offset_x$eq$1(value) {
            var self = this;

            return self.$set(value, nil)
          }, 1);
          
          $def(self, '$y', function $$y() {
            var self = this;

            return self.$get().$y()
          }, 0);
          
          $def(self, '$y=', function $Offset_y$eq$2(value) {
            var self = this;

            return self.$set(nil, value)
          }, 1);
          if ($truthy($$('Browser')['$supports?']("Element.getBoundingClientRect"))) {
            
            $def(self, '$get', function $$get() {
              var self = this, doc = nil, root = nil, win = nil;

              
              doc = self.element.$document();
              root = doc.$root().$to_n();
              win = doc.$window().$to_n();
              
        var box = self["native"].getBoundingClientRect(),
            y   = box.top + (win.pageYOffset || root.scrollTop) - (root.clientTop || 0),
            x   = box.left + (win.pageXOffset || root.scrollLeft) - (root.clientLeft || 0);
      ;
              return $$$($$('Browser'), 'Position').$new(x, y);
            }, 0)
          } else {
            
            $def(self, '$get', function $$get() {
              var self = this, doc = nil, root = nil, win = nil;

              
              doc = self.$document();
              root = doc.$root().$to_n();
              win = doc.$window().$to_n();
              
        var y = (win.pageYOffset || root.scrollTop) - (root.clientTop || 0),
            x = (win.pageXOffset || root.scrollLeft) - (root.clientLeft || 0);
      ;
              return $$$($$('Browser'), 'Position').$new(x, y);
            }, 0)
          };
          return $def(self, '$set', function $$set($a) {
            var $post_args, value, $b, $c, self = this, position = nil, offset = nil, top = nil, left = nil, x = nil, y = nil;

            
            $post_args = $slice.call(arguments);
            value = $post_args;
            position = self.element['$style!']()['$[]']("position");
            if ($eqeq(position, "static")) {
              self.element.$style()['$[]=']("position", "relative")
            };
            offset = self.$get();
            top = self.element['$style!']()['$[]']("top").$to_u();
            left = self.element['$style!']()['$[]']("left").$to_u();
            if ($eqeqeq($$$($$('Browser'), 'Position'), value.$first())) {
              $b = [value.$first().$x(), value.$first().$y()], (x = $b[0]), (y = $b[1]), $b
            } else if ($eqeqeq($$('Hash'), value.$first())) {
              $b = [value.$first()['$[]']("x"), value.$first()['$[]']("y")], (x = $b[0]), (y = $b[1]), $b
            } else {
              $c = value, $b = $to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c
            };
            if ($truthy(x)) {
              self.element.$style()['$[]=']("left", $rb_plus($rb_minus(x.$px(), offset.$x()), left))
            };
            if ($truthy(y)) {
              return ($b = ["top", $rb_plus($rb_minus(y.$px(), offset.$y()), top)], $send(self.element.$style(), '[]=', $b), $b[$b.length - 1])
            } else {
              return nil
            };
          }, -1);
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["buffer/array"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $eqeq = Opal.eqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,[],name_for,attr_reader,==,for,to_n,enum_for,length');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Array');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Native'), 'Wrapper'));
      $defs(self, '$for', function $Array_for$1(bits, type) {
                if ($gvars.$ == null) $gvars.$ = nil;

        return $gvars.$['$[]']("" + ($$('Buffer').$name_for(bits, type)) + "Array")
      }, 2);
      self.$include($$('Enumerable'));
      self.$attr_reader("buffer", "type");
      
      $def(self, '$initialize', function $$initialize(buffer, bits, type) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (bits == null) bits = nil;
        if (type == null) type = nil;
        if ($eqeq($$('Native'), buffer)) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [buffer], null)
        } else {
          
          var klass = $$('Array').$for(bits, type);

          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new klass(buffer.$to_n())], null)
        
        };
        self.buffer = buffer;
        return (self.type = type);
      }, -2);
      
      $def(self, '$bits', function $$bits() {
        var self = this;

        return self["native"].BYTES_PER_ELEMENT * 8
      }, 0);
      
      $def(self, '$[]', function $Array_$$$2(index, offset) {
        var self = this;

        
        if (offset == null) offset = nil;
        if ($truthy(offset)) {
          return self["native"].subarray(index, offset)
        } else {
          return self["native"][index]
        };
      }, -2);
      
      $def(self, '$[]=', function $Array_$$$eq$3(index, value) {
        var self = this;

        return self["native"][index] = value
      }, 2);
      
      $def(self, '$bytesize', function $$bytesize() {
        var self = this;

        return self["native"].byteLength
      }, 0);
      
      $def(self, '$each', function $$each() {
        var $yield = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        if (!($yield !== nil)) {
          return self.$enum_for("each")
        };
        
        for (var i = 0, length = self["native"].length; i < length; i++) {
          Opal.yield1($yield, self["native"][i])
        }
      ;
        return self;
      }, 0);
      
      $def(self, '$length', function $$length() {
        var self = this;

        return self["native"].length
      }, 0);
      
      $def(self, '$merge!', function $Array_merge$excl$4(other, offset) {
        var self = this;

        
        ;
        return self["native"].set(other.$to_n(), offset);
      }, -2);
      return $alias(self, "size", "length");
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/css/unit"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $alias = Opal.alias, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $return_self = Opal.return_self, $return_val = Opal.return_val, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('map,to_proc,attr_reader,===,respond_to?,raise,class,to_u,new,==,convert,type,number,hash,each,define_method,+,compatible?,-,*,/,to_i,to_f,to_s,private,include?,class_eval,%,old_percent,match,[],__send__,downcase');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Unit');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.type = $proto.number = nil;
        
        $const_set($nesting[0], 'TYPES', $send(["em", "ex", "ch", "rem", "vh", "vw", "vmin", "vmax", "px", "mm", "cm", "in", "pt", "pc", "s", "deg"], 'map', [], "to_sym".$to_proc()));
        $const_set($nesting[0], 'COMPATIBLE', $send(["in", "pt", "mm", "cm", "px", "pc"], 'map', [], "to_sym".$to_proc()));
        self.$attr_reader("type", "number");
        
        $def(self, '$initialize', function $$initialize(number, type) {
          var self = this;

          
          self.number = number;
          return (self.type = type);
        }, 2);
        
        $def(self, '$coerce', function $$coerce(other) {
          var self = this;

          return [self, other]
        }, 1);
        
        $def(self, '$==', function $Unit_$eq_eq$1(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            
            if (!$truthy(other['$respond_to?']("to_u"))) {
              self.$raise($$('TypeError'), "no implicit conversion of " + (other.$class()) + " into Unit")
            };
            other = other.$to_u();
          };
          if (!$eqeqeq($$('Unit'), other)) {
            other = $$('Unit').$new(other, self.type)
          };
          return self.number['$=='](self.$convert(other, self.type));
        }, 1);
        
        $def(self, '$===', function $Unit_$eq_eq_eq$2(other) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.type['$=='](other.$type())))) {
            return self.number['$=='](other.$number())
          } else {
            return $ret_or_1
          }
        }, 1);
        $alias(self, "eql?", "==");
        
        $def(self, '$hash', function $$hash() {
          var self = this;

          return [self.number, self.type].$hash()
        }, 0);
        $send($$('TYPES'), 'each', [], function $Unit$3(name){var self = $Unit$3.$$s == null ? this : $Unit$3.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            return $$('Unit').$new(self.$convert(self, name), name)}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self});
        
        $def(self, '$+', function $Unit_$plus$5(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            return $$('Unit').$new($rb_plus(self.number, other), self.type)
          };
          if ($eqeq(self.type, other.$type())) {
            return $$('Unit').$new($rb_plus(self.number, other.$number()), self.type)
          } else if (($truthy(self['$compatible?'](self)) && ($truthy(self['$compatible?'](other))))) {
            return $$('Unit').$new($rb_plus(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$('ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        }, 1);
        
        $def(self, '$-', function $Unit_$minus$6(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            return $$('Unit').$new($rb_minus(self.number, other), self.type)
          };
          if ($eqeq(self.type, other.$type())) {
            return $$('Unit').$new($rb_minus(self.number, other.$number()), self.type)
          } else if (($truthy(self['$compatible?'](self)) && ($truthy(self['$compatible?'](other))))) {
            return $$('Unit').$new($rb_minus(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$('ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        }, 1);
        
        $def(self, '$*', function $Unit_$$7(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            return $$('Unit').$new($rb_times(self.number, other), self.type)
          };
          if ($eqeq(self.type, other.$type())) {
            return $$('Unit').$new($rb_times(self.number, other.$number()), self.type)
          } else if (($truthy(self['$compatible?'](self)) && ($truthy(self['$compatible?'](other))))) {
            return $$('Unit').$new($rb_times(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$('ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        }, 1);
        
        $def(self, '$/', function $Unit_$slash$8(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            return $$('Unit').$new($rb_divide(self.number, other), self.type)
          };
          if ($eqeq(self.type, other.$type())) {
            return $$('Unit').$new($rb_divide(self.number, other.$number()), self.type)
          } else if (($truthy(self['$compatible?'](self)) && ($truthy(self['$compatible?'](other))))) {
            return $$('Unit').$new($rb_divide(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$('ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        }, 1);
        
        $def(self, '$-@', function $Unit_$minus$$9() {
          var self = this;

          return $$('Unit').$new($rb_times(self.number, -1), self.type)
        }, 0);
        
        $def(self, '$+@', function $Unit_$plus$$10() {
          var self = this;

          return $$('Unit').$new(self.number, self.type)
        }, 0);
        
        $def(self, '$to_i', function $$to_i() {
          var self = this;

          return self.number.$to_i()
        }, 0);
        
        $def(self, '$to_f', function $$to_f() {
          var self = this;

          return self.number.$to_f()
        }, 0);
        
        $def(self, '$to_u', $return_self, 0);
        
        $def(self, '$to_s', function $$to_s() {
          var self = this;

          return "" + (self.number) + (self.type)
        }, 0);
        $alias(self, "to_str", "to_s");
        $alias(self, "inspect", "to_s");
        self.$private();
        
        $def(self, '$compatible?', function $Unit_compatible$ques$11(unit) {
          
          return $$('COMPATIBLE')['$include?'](unit.$type())
        }, 1);
        return $def(self, '$convert', function $$convert(unit, type) {
          var value = nil, px = nil, $ret_or_1 = nil;

          
          value = unit.$number();
          if ($eqeq(unit.$type(), type)) {
            return value
          };
          px = ($eqeqeq("in", ($ret_or_1 = unit.$type())) ? ($rb_times(value, 96)) : ($eqeqeq("pt", $ret_or_1) ? ($rb_divide($rb_times(value, 4.0), 3.0)) : ($eqeqeq("pc", $ret_or_1) ? ($rb_divide($rb_times($rb_divide(value, 12), 4.0), 3.0)) : ($eqeqeq("mm", $ret_or_1) ? ($rb_times(value, 3.77953)) : ($eqeqeq("cm", $ret_or_1) ? ($rb_times($rb_times(value, 10), 3.77953)) : ($eqeqeq("px", $ret_or_1) ? (value) : (nil)))))));
          
          switch (type) {
            case "in":
              return $rb_divide(px, 96.0)
            case "pt":
              return $rb_divide($rb_divide(px, 4.0), 3.0)
            case "pc":
              return $rb_divide($rb_divide($rb_times(px, 12), 4.0), 3.0)
            case "mm":
              return $rb_divide(px, 3.77953)
            case "cm":
              return $rb_divide($rb_divide(px, 10), 3.77953)
            case "px":
              return px
            default:
              return nil
          };
        }, 2);
      })($nesting[0], null, $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $send($$$($$$($$$($$('Paggio'), 'CSS'), 'Unit'), 'TYPES'), 'each', [], function $Numeric$12(name){var self = $Numeric$12.$$s == null ? this : $Numeric$12.$$s;

      
      if (name == null) name = nil;
      return $send(self, 'define_method', [name], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

        return $$$($$$($$('Paggio'), 'CSS'), 'Unit').$new(self, name)}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self});
    return $def(self, '$to_u', $return_self, 0);
  })($nesting[0], null, $nesting);
  $send([$$('Fixnum'), $$('Float')], 'each', [], function $$14(klass){var self = $$14.$$s == null ? this : $$14.$$s;

    
    if (klass == null) klass = nil;
    return $send(klass, 'class_eval', [], function $$15(){var self = $$15.$$s == null ? this : $$15.$$s;

      
      $alias(self, "old_percent", "%");
      return $def(self, '$%', function $percent$16(other) {
        var self = this;

        
        if (other == null) other = nil;
        if ($truthy(other)) {
          return self.$old_percent(other)
        } else {
          return $$$($$$($$('Paggio'), 'CSS'), 'Unit').$new(self, "%")
        };
      }, -1);}, {$$arity: 0, $$s: self});}, {$$arity: 1, $$s: self});
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_u', function $$to_u() {
      var self = this, matches = nil, value = nil, unit = nil;

      if ($truthy((matches = self.$match(/^([\d+.]+)(.+)?$/)))) {
        
        value = matches['$[]'](1).$to_f();
        if ($truthy((unit = matches['$[]'](2)))) {
          return value.$__send__(unit.$downcase())
        } else {
          return value
        };
      } else {
        return 0
      }
    }, 0)
  })($nesting[0], null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_u', $return_val(0), 0)
  })($nesting[0], null);
};

Opal.modules["browser/dom/element/form"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('def_selector,create,alias_native,[],new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Form');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("form");
          
          $def(self, '$form_data', function $$form_data() {
            var self = this;

            return $$('FormData').$create(self)
          }, 0);
          
          $def(self, '$submit', function $$submit() {
            var self = this;

            return self["native"].submit()
          }, 0);
          
          $def(self, '$reset', function $$reset() {
            var self = this;

            return self["native"].reset()
          }, 0);
          self.$alias_native("action");
          self.$alias_native("action=");
          self.$alias_native("method");
          self.$alias_native("method=");
          self.$alias_native("target");
          self.$alias_native("target=");
          self.$alias_native("encoding");
          self.$alias_native("encoding=");
          return $def(self, '$controls', function $$controls() {
            var self = this;

            return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].elements))
          }, 0);
        })($nesting[0], $$('Element'), $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/css/font"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $hash2 = Opal.hash2, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,new,font,__send__,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Font');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.definition = nil;
        
        self.$attr_reader("name");
        
        $def(self, '$initialize', function $$initialize(name) {
          var self = this;

          
          self.name = name;
          self.definition = $$('Definition').$new();
          return self.$font($hash2(["family"], {"family": name}));
        }, 1);
        return $def(self, '$method_missing', function $$method_missing($a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice.call(arguments);
          args = $post_args;
          return $send(self.definition, '__send__', $to_a(args), block.$to_proc());
        }, -1);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/img"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Img');

          
          
          $send($hash2(["src", "url", "alt", "description", "height", "width", "map"], {"src": "src", "url": "src", "alt": "alt", "description": "alt", "height": "height", "width": "width", "map": "usemap"}), 'each', [], function $Img$1(name, attribute){var self = $Img$1.$$s == null ? this : $Img$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self});
          return $send(self, 'defhelper', ["map!"], function $Img$3(){var $a, self = $Img$3.$$s == null ? this : $Img$3.$$s;
            if (self.attributes == null) self.attributes = nil;

            return ($a = ["ismap", true], $send(self.attributes, '[]=', $a), $a[$a.length - 1])}, {$$arity: 0, $$s: self});
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/css/animation"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,new,__send__,to_proc,<<,call,%,last');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Animation');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.steps = nil;
        
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Step');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.definition = nil;
          
          self.$attr_reader("value");
          
          $def(self, '$initialize', function $$initialize(value) {
            var self = this;

            
            self.value = value;
            return (self.definition = $$('Definition').$new());
          }, 1);
          return $def(self, '$method_missing', function $$method_missing($a) {
            var block = $$method_missing.$$p || nil, $post_args, args, self = this;

            $$method_missing.$$p = null;
            
            ;
            $post_args = $slice.call(arguments);
            args = $post_args;
            return $send(self.definition, '__send__', $to_a(args), block.$to_proc());
          }, -1);
        })($nesting[0], $$('BasicObject'), $nesting);
        self.$attr_reader("name", "steps");
        
        $def(self, '$initialize', function $$initialize(name) {
          var self = this;

          
          self.name = name;
          return (self.steps = []);
        }, 1);
        
        $def(self, '$step', function $$step(value) {
          var block = $$step.$$p || nil, self = this;

          $$step.$$p = null;
          
          ;
          self.steps['$<<']($$('Step').$new(value));
          return block.$call();
        }, 1);
        
        $def(self, '$from', function $$from(value) {
          var block = $$from.$$p || nil, self = this;

          $$from.$$p = null;
          
          ;
          self.steps['$<<']($$('Step').$new((0)['$%']()));
          return block.$call();
        }, 1);
        
        $def(self, '$to', function $$to(value) {
          var block = $$to.$$p || nil, self = this;

          $$to.$$p = null;
          
          ;
          self.steps['$<<']($$('Step').$new((100)['$%']()));
          return block.$call();
        }, 1);
        return $def(self, '$method_missing', function $$method_missing($a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice.call(arguments);
          args = $post_args;
          return $send(self.steps.$last(), '__send__', $to_a(args), block.$to_proc());
        }, -1);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["browser/dom/element/iframe"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('def_selector,alias_native,new,DOM,send,content_window');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Iframe');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("iframe");
          self.$alias_native("src");
          self.$alias_native("src=");
          
          $def(self, '$content_window', function $$content_window() {
            var self = this;

            return $$$($$('Browser'), 'Window').$new(self["native"].contentWindow)
          }, 0);
          
          $def(self, '$content_document', function $$content_document() {
            var self = this;

            return self.$DOM(self["native"].contentDocument || self["native"].contentWindow.document)
          }, 0);
          return $def(self, '$send', function $$send(message, options) {
            var self = this;

            
            if (options == null) options = $hash2([], {});
            return self.$content_window().$send(message, options);
          }, -2);
        })($nesting[0], $$('Element'), $nesting);
        return (function($base, $super) {
          var self = $klass($base, $super, 'Object');

          
          return self.$def_selector("object")
        })($nesting[0], $$('Iframe'));
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/html/element/td"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('defhelper,[]=,to_s,join');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Td');

          
          
          $send(self, 'defhelper', ["columns"], function $Td$1(value){var $a, self = $Td$1.$$s == null ? this : $Td$1.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            if (value == null) value = nil;
            return ($a = ["colspan", value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});
          $send(self, 'defhelper', ["rows"], function $Td$2(value){var $a, self = $Td$2.$$s == null ? this : $Td$2.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            if (value == null) value = nil;
            return ($a = ["rowspan", value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});
          return $send(self, 'defhelper', ["headers"], function $Td$3($a){var $post_args, args, $b, self = $Td$3.$$s == null ? this : $Td$3.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            $post_args = $slice.call(arguments);
            args = $post_args;
            return ($b = ["headers", args.$join(" ")], $send(self.attributes, '[]=', $b), $b[$b.length - 1]);}, {$$arity: -1, $$s: self});
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/object"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Object');

          
          return $send($hash2(["type", "data", "name", "height", "width"], {"type": "type", "data": "data", "name": "name", "height": "height", "width": "width"}), 'each', [], function $Object$1(name, attribute){var self = $Object$1.$$s == null ? this : $Object$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/css/definition"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send, $def = Opal.def, $slice = Opal.slice, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $range = Opal.range, $hash2 = Opal.hash2, $not = Opal.not, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,==,arity,instance_exec,to_proc,call,empty?,each,inspect,to_s,define_method,a,===,first,>,length,raise,style,name,value,[],join,map,to_i,*,end_with?,__send__,<<,last,pop,!,other,shift,horizontal?,private');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Definition');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.style = $proto.important = nil;
        
        $const_set($nesting[0], 'Style', $$$('Struct').$new("name", "value", "important"));
        
        $def(self, '$initialize', function $$initialize() {
          var block = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          ;
          self.style = [];
          if ($truthy(block)) {
            if ($eqeq(block.$arity(), 0)) {
              return $send(self, 'instance_exec', [], block.$to_proc())
            } else {
              return block.$call(self)
            }
          } else {
            return nil
          };
        }, 0);
        
        $def(self, '$empty?', function $Definition_empty$ques$1() {
          var self = this;

          return self.style['$empty?']()
        }, 0);
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this;

          $$each.$$p = null;
          
          ;
          return $send(self.style, 'each', [], block.$to_proc());
        }, 0);
        
        $def(self, '$gradient', function $$gradient($a) {
          var $post_args, args;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          return $send($$('Gradient'), 'new', $to_a(args));
        }, -1);
        
        $def(self, '$url', function $$url(value) {
          
          return "url(" + (value.$to_s().$inspect()) + ")"
        }, 1);
        $send(["blur", "brightness", "rotate", "contrast", "grayscale", "invert", "opacity", "saturate", "sepia"], 'each', [], function $Definition$2(name){var self = $Definition$2.$$s == null ? this : $Definition$2.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$3(value){
            
            if (value == null) value = nil;
            return "" + (name) + "(" + (value) + ")";}, 1);}, {$$arity: 1, $$s: self});
        
        $def(self, '$rgb', function $$rgb(r, g, b) {
          var self = this;

          return "rgb(" + (r) + ", " + (g) + ", " + (b) + ", " + (self.$a()) + ")"
        }, 3);
        
        $def(self, '$rgba', function $$rgba(r, g, b, a) {
          
          return "rgba(" + (r) + ", " + (g) + ", " + (b) + ", " + (a) + ")"
        }, 4);
        $send(["scale", "skew", "translate"], 'each', [], function $Definition$4(name){var self = $Definition$4.$$s == null ? this : $Definition$4.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$5(a, b){
            
            if (a == null) a = nil;
            if (b == null) b = nil;
            if ($truthy(b)) {
              return "" + (name) + "(" + (a) + ", " + (b) + ")"
            } else {
              return "" + (name) + "(" + (a) + ")"
            };}, -2);}, {$$arity: 1, $$s: self});
        $send(["translateX", "translateY", "translateZ", "rotateX", "rotateY", "rotateZ", "skewX", "skewY", "scaleX", "scaleY"], 'each', [], function $Definition$6(name){var self = $Definition$6.$$s == null ? this : $Definition$6.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$7(value){
            
            if (value == null) value = nil;
            return "" + (name) + "(" + (value) + ")";}, 1);}, {$$arity: 1, $$s: self});
        
        $def(self, '$background', function $$background($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          if ($eqeqeq($$('Gradient'), args.$first())) {
            
            if ($truthy($rb_gt(args.$length(), 1))) {
              self.$raise($$('NotImplementedError'), "multiple gradients not implemented yet")
            };
            return $send(args.$first(), 'each', [], function $$8(s){var self = $$8.$$s == null ? this : $$8.$$s, $ret_or_1 = nil;

              
              if (s == null) s = nil;
              return self.$style(($truthy(($ret_or_1 = s.$name())) ? ($ret_or_1) : ("background-image")), s.$value());}, {$$arity: 1, $$s: self});
          } else if ($eqeqeq($$$('Hash'), args.$first())) {
            return $send(args.$first(), 'each', [], function $$9(sub, value){var self = $$9.$$s == null ? this : $$9.$$s;

              
              if (sub == null) sub = nil;
              if (value == null) value = nil;
              return self.$style("background-" + (sub), value);}, {$$arity: 2, $$s: self})
          } else {
            return self.$style("background", args)
          };
        }, -1);
        
        $def(self, '$border', function $$border($a) {
          var $post_args, args, self = this, options = nil;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          if ($eqeqeq($$$('Hash'), args.$first())) {
            
            if ($eqeq(args.$length(), 1)) {
              options = args.$first()
            };
            return $send(options, 'each', [], function $$10(name, value){var self = $$10.$$s == null ? this : $$10.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              
              switch (name) {
                case "top":
                case "bottom":
                case "left":
                case "right":
                  if ($eqeqeq($$$('Hash'), value)) {
                    return $send(value, 'each', [], function $$11(n, v){var self = $$11.$$s == null ? this : $$11.$$s;

                      
                      if (n == null) n = nil;
                      if (v == null) v = nil;
                      return self.$style("border-" + (name) + "-" + (n), v);}, {$$arity: 2, $$s: self})
                  } else {
                    return self.$style("border-" + (name), value)
                  }
                  break;
                case "radius":
                  if ($eqeqeq($$$('Hash'), value)) {
                    return $send(value, 'each', [], function $$12(horizontal, value){var self = $$12.$$s == null ? this : $$12.$$s;

                      
                      if (horizontal == null) horizontal = nil;
                      if (value == null) value = nil;
                      return $send(value, 'each', [], function $$13(vertical, value){var self = $$13.$$s == null ? this : $$13.$$s;

                        
                        if (vertical == null) vertical = nil;
                        if (value == null) value = nil;
                        self.$style("-moz-border-radius-" + (horizontal) + (vertical), value);
                        self.$style("-webkit-border-" + (horizontal) + "-" + (vertical) + "-radius", value);
                        return self.$style("border-" + (horizontal) + "-" + (vertical) + "-radius", value);}, {$$arity: 2, $$s: self});}, {$$arity: 2, $$s: self})
                  } else {
                    
                    self.$style("-moz-border-radius", value);
                    self.$style("-webkit-border-radius", value);
                    return self.$style("border-radius", value);
                  }
                  break;
                case "color":
                  if ($eqeqeq($$$('Hash'), value)) {
                    return $send(value, 'each', [], function $$14(name, value){var self = $$14.$$s == null ? this : $$14.$$s;

                      
                      if (name == null) name = nil;
                      if (value == null) value = nil;
                      return self.$style("border-" + (name) + "-color", value);}, {$$arity: 2, $$s: self})
                  } else {
                    return self.$style("border-color", value)
                  }
                  break;
                default:
                  return self.$style("border-" + (name), value)
              };}, {$$arity: 2, $$s: self});
          } else {
            return self.$style("border", args)
          };
        }, -1);
        
        $def(self, '$box', function $$box(options) {
          var self = this;

          if ($eqeqeq($$$('Hash'), options)) {
            return $send(options, 'each', [], function $$15(name, value){var self = $$15.$$s == null ? this : $$15.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              
              switch (name) {
                case "shadow":
                  
                  if ($eqeqeq($$$('Array'), value)) {
                    if ($eqeqeq($$$('Array'), value['$[]'](0))) {
                      value = $send(value, 'map', [], function $$16(v){
                        
                        if (v == null) v = nil;
                        return v.$join(" ");}, 1).$join(", ")
                    } else {
                      value = value.$join(" ")
                    }
                  };
                  self.$style("-moz-box-shadow", value);
                  self.$style("-webkit-box-shadow", value);
                  return self.$style("box-shadow", value);
                default:
                  return self.$style("box-" + (name), value)
              };}, {$$arity: 2, $$s: self})
          } else {
            return self.$style("box", options)
          }
        }, 1);
        
        $def(self, '$opacity', function $$opacity(value) {
          var self = this;

          
          self.$style("opacity", value);
          self.$style("-moz-opacity", value);
          self.$style("-ms-filter", "\"progid:DXImageTransform.Microsoft.Alpha(Opacity=" + ($rb_times(value, 100).$to_i()) + ")\"");
          return self.$style("filter", "alpha(opacity=" + ($rb_times(value, 100).$to_i()) + ")");
        }, 1);
        
        $def(self, '$animation', function $$animation($a) {
          var $post_args, args, self = this, options = nil;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          if ($eqeqeq($$('Hash'), args.$first())) {
            
            if ($eqeq(args.$length(), 1)) {
              options = args.$first()
            };
            return $send(options, 'each', [], function $$17(name, value){var self = $$17.$$s == null ? this : $$17.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              self.$style("-webkit-animation-" + (name), value);
              return self.$style("animation-" + (name), value);}, {$$arity: 2, $$s: self});
          } else {
            
            self.$style("animation", args);
            return self.$style("-webkit-animation", args);
          };
        }, -1);
        
        $def(self, '$transition', function $$transition($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          self.$style("transition", args);
          self.$style("-webkit-transition", args);
          return self.$style("-moz-transition", args);
        }, -1);
        
        $def(self, '$user_select', function $$user_select($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          self.$style("user-select", args);
          self.$style("-webkit-user-select", args);
          self.$style("-moz-user-select", args);
          return self.$style("-ms-user-select", args);
        }, -1);
        
        $def(self, '$transform', function $$transform($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          self.$style("transform", args);
          self.$style("-webkit-transform", args);
          self.$style("-moz-transform", args);
          self.$style("-ms-transform", args);
          return self.$style("-o-transform", args);
        }, -1);
        
        $def(self, '$filter', function $$filter($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice.call(arguments);
          args = $post_args;
          self.$style("filter", args);
          self.$style("-webkit-filter", args);
          self.$style("-moz-filter", args);
          self.$style("-ms-filter", args);
          return self.$style("-o-filter", args);
        }, -1);
        
        $def(self, '$method_missing', function $$method_missing(name, $a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this, argument = nil;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice.call(arguments, 1);
          args = $post_args;
          name = name.$to_s();
          if ($truthy(name['$end_with?']("!"))) {
            
            name = name['$[]']($range(0, -2, false));
            self.important = true;
            $send(self, '__send__', [name].concat($to_a(args)), block.$to_proc());
            self.important = false;
            return nil;
          };
          if ($eqeq(args.$length(), 1)) {
            
            argument = args.$first();
            if ($eqeqeq($$$('Hash'), argument)) {
              $send(argument, 'each', [], function $$18(sub, value){var self = $$18.$$s == null ? this : $$18.$$s;

                
                if (sub == null) sub = nil;
                if (value == null) value = nil;
                return self.$style("" + (name) + "-" + (sub), value);}, {$$arity: 2, $$s: self})
            } else {
              self.$style(name, argument)
            };
          } else {
            self.$style(name, args.$join(" "))
          };
          self.important = false;
          return self;
        }, -2);
        
        $def(self, '$style', function $$style(name, value, important) {
          var self = this;

          
          if (value == null) value = nil;
          if (important == null) important = self.important;
          if ($eqeqeq($$$('Array'), value)) {
            value = value.$join(" ")
          };
          if ($eqeqeq($$('Style'), name)) {
            return self.style['$<<'](name)
          } else {
            return self.style['$<<']($$('Style').$new(name, value, important))
          };
        }, -2);
        
        $def(self, '$style!', function $Definition_style$excl$19(name, value) {
          var self = this;

          
          if (value == null) value = nil;
          return self.$style(name, value, true);
        }, -2);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Gradient');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.from = $proto.to = $proto.start = $proto.end = nil;
          
          
          $def(self, '$initialize', function $$initialize($a) {
            var $post_args, args, self = this, options = nil;

            
            $post_args = $slice.call(arguments);
            args = $post_args;
            options = ($eqeqeq($$$('Hash'), args.$last()) ? (args.$pop()) : ($hash2([], {})));
            self.to = options['$[]']("to");
            self.from = options['$[]']("from");
            if (($truthy(self.to) && ($not(self.from)))) {
              self.from = self.$other(self.to)
            } else if (($truthy(self.from) && ($not(self.to)))) {
              self.to = self.$other(self.from)
            };
            self.start = args.$shift();
            return (self.end = args.$shift());
          }, -1);
          
          $def(self, '$each', function $$each() {
            var block = $$each.$$p || nil, self = this;

            $$each.$$p = null;
            
            ;
            block.$call(self.$style("-moz-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            if ($truthy(self['$horizontal?']())) {
              block.$call(self.$style("-webkit-gradient(linear, " + (self.from) + " top, " + (self.to) + " top, color-stop(0%, " + (self.start) + "), color-stop(100%, " + (self.end) + "))"))
            } else {
              block.$call(self.$style("-webkit-gradient(linear, left " + (self.from) + ", left " + (self.to) + ", color-stop(0%, " + (self.start) + "), color-stop(100%, " + (self.end) + "))"))
            };
            block.$call(self.$style("-webkit-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            block.$call(self.$style("-o-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            block.$call(self.$style("-ms-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            return block.$call(self.$style("linear-gradient(to " + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
          }, 0);
          
          $def(self, '$horizontal?', function $Gradient_horizontal$ques$20() {
            var self = this, $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = self.to['$==']("left")))) {
              return $ret_or_1
            } else {
              return self.to['$==']("right")
            }
          }, 0);
          
          $def(self, '$vertical?', function $Gradient_vertical$ques$21() {
            var self = this, $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = self.to['$==']("top")))) {
              return $ret_or_1
            } else {
              return self.to['$==']("bottom")
            }
          }, 0);
          self.$private();
          
          $def(self, '$other', function $$other(side) {
            
            
            switch (side) {
              case "left":
                return "right"
              case "right":
                return "left"
              case "top":
                return "bottom"
              case "bottom":
                return "top"
              default:
                return nil
            }
          }, 1);
          return $def(self, '$style', function $$style($a) {
            var $post_args, args;

            
            $post_args = $slice.call(arguments);
            args = $post_args;
            if ($eqeq(args.$length(), 1)) {
              return $$('Style').$new(nil, args.$first())
            } else {
              return $send($$('Style'), 'new', $to_a(args))
            };
          }, -1);
        })($nesting[0], null, $nesting);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["browser/dom/element/position"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,to_n,offset,get,parent,new,==,[],style,=~,x=,+,x,to_i,y=,y,-');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Position');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.element = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element) {
            var self = this;

            
            self.element = element;
            return (self["native"] = element.$to_n());
          }, 1);
          
          $def(self, '$get', function $$get() {
            var self = this, offset = nil, position = nil, parent = nil, parent_offset = nil;

            
            offset = self.element.$offset();
            position = offset.$get();
            parent = offset.$parent();
            parent_offset = $$$($$('Browser'), 'Position').$new(0, 0);
            if ($eqeq(self.element.$style()['$[]']("position"), "fixed")) {
              
              if (!$truthy(parent['$=~']("html"))) {
                parent_offset = parent.$offset()
              };
              parent_offset['$x=']($rb_plus(parent_offset.$x(), parent.$style()['$[]']("border-top-width").$to_i()));
              parent_offset['$y=']($rb_plus(parent_offset.$y(), parent.$style()['$[]']("border-left-width").$to_i()));
            };
            return $$$($$('Browser'), 'Position').$new($rb_minus($rb_minus(position.$x(), parent_offset.$x()), self.element.$style()['$[]']("margin-left").$to_i()), $rb_minus($rb_minus(position.$y(), parent_offset.$y()), self.element.$style()['$[]']("margin-top").$to_i()));
          }, 0);
          
          $def(self, '$x', function $$x() {
            var self = this;

            return self.$get().$x()
          }, 0);
          return $def(self, '$y', function $$y() {
            var self = this;

            return self.$get().$y()
          }, 0);
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/html/element/input"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Input');

          
          return $send($hash2(["type", "name", "value", "size", "place_holder", "read_only", "required", "limit"], {"type": "type", "name": "name", "value": "value", "size": "size", "place_holder": "placeholder", "read_only": "readonly", "required": "required", "limit": "maxlength"}), 'each', [], function $Input$1(name, attribute){var self = $Input$1.$$s == null ? this : $Input$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/link"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Link');

          
          return $send($hash2(["cross_origin", "href", "href_lang", "media", "rel", "sizes", "type"], {"cross_origin": "crossorigin", "href": "href", "href_lang": "hreflang", "media": "media", "rel": "rel", "sizes": "sizes", "type": "type"}), 'each', [], function $Link$1(name, attribute){var self = $Link$1.$$s == null ? this : $Link$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/a"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s,defhelper!,<<');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'A');

          
          
          $send($hash2(["href", "url", "rel", "relative", "target", "type", "lang", "language", "media"], {"href": "href", "url": "href", "rel": "rel", "relative": "rel", "target": "target", "type": "type", "lang": "hreflang", "language": "hreflang", "media": "media"}), 'each', [], function $A$1(name, attribute){var self = $A$1.$$s == null ? this : $A$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self});
          self['$defhelper!']("download");
          self['$defhelper!']("ping");
          return $send(self, 'defhelper', ["text"], function $A$3(string){var self = $A$3.$$s == null ? this : $A$3.$$s;

            
            if (string == null) string = nil;
            return self['$<<'](string);}, {$$arity: 1, $$s: self});
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["browser/dom/element/data"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,to_n,include,enum_for,call,each,attributes,=~,[]=,[],include?,respond_to?,to_str,to_s,to_int');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Data');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = $proto.element = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            if ($truthy((typeof(self["native"].$data) !== "undefined"))) {
              return nil
            } else {
              return self["native"].$data = {}
            };
          }, 1);
          self.$include($$('Enumerable'));
          
          $def(self, '$each', function $$each() {
            var block = $$each.$$p || nil, self = this;

            $$each.$$p = null;
            
            ;
            if (!$truthy(block)) {
              return self.$enum_for("each")
            };
            
      var data = self["native"].$data;

      for (var key in data) {
        block.$call(key, data[key]);
      }
    ;
            $send(self.element.$attributes(), 'each', [], function $$1(name, value){var $a;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              if ($truthy(name['$=~'](/^data-(.*)$/))) {
                return block.$call((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), value)
              } else {
                return nil
              };}, 2);
            return self;
          }, 0);
          
          $def(self, '$assign', function $$assign(data) {
            var self = this;

            
            $send(data, 'each', [], function $$2(name, value){var $a, self = $$2.$$s == null ? this : $$2.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              return ($a = [name, value], $send(self, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 2, $$s: self});
            return self;
          }, 1);
          
          $def(self, '$[]', function $Data_$$$3(name) {
            var self = this, data = nil;

            
            if ($truthy((data = self.element['$[]']("data-" + (name))))) {
              return data
            };
            
      var value = self["native"].$data[name];

      if (value === undefined) {
        return nil;
      }
      else {
        return value;
      }
    ;
          }, 1);
          
          $def(self, '$[]=', function $Data_$$$eq$4(name, value) {
            var $a, self = this;

            
            delete self["native"].$data[name];
            if ($truthy([true, false, nil]['$include?'](value))) {
              return ($a = ["data-" + (name), value], $send(self.element, '[]=', $a), $a[$a.length - 1])
            } else if ($truthy(value['$respond_to?']("to_str"))) {
              return ($a = ["data-" + (name), value.$to_str()], $send(self.element, '[]=', $a), $a[$a.length - 1])
            } else if ($truthy(value['$respond_to?']("to_int"))) {
              return ($a = ["data-" + (name), value.$to_int().$to_s()], $send(self.element, '[]=', $a), $a[$a.length - 1])
            } else {
              return self["native"].$data[name] = value
            };
          }, 2);
          return $def(self, '$delete', function $Data_delete$5(name) {
            var self = this, data = nil;

            
            data = self['$[]'](name);
            self['$[]='](name, nil);
            return data;
          }, 1);
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["paggio/css/rule"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,new,__send__,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rule');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.definition = nil;
        
        self.$attr_reader("selector", "media");
        
        $def(self, '$initialize', function $$initialize(selector, media) {
          var self = this;

          
          self.selector = selector;
          self.media = media;
          return (self.definition = $$('Definition').$new());
        }, 2);
        return $def(self, '$method_missing', function $$method_missing($a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice.call(arguments);
          args = $post_args;
          return $send(self.definition, '__send__', $to_a(args), block.$to_proc());
        }, -1);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/option"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,defhelper!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Option');

          
          
          $send(["label", "value"], 'each', [], function $Option$1(name){var self = $Option$1.$$s == null ? this : $Option$1.$$s;

            
            if (name == null) name = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 1, $$s: self});
          self['$defhelper!']("disabled");
          return self['$defhelper!']("selected");
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/blockquote"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Blockquote');

          
          return $send(self, 'defhelper', ["cite"], function $Blockquote$1(value){var $a, self = $Blockquote$1.$$s == null ? this : $Blockquote$1.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            if (value == null) value = nil;
            return ($a = ["cite", value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/button"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s,defhelper!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Button');

          
          
          $send($hash2(["form", "name", "type", "value", "action", "encoding", "method", "target"], {"form": "form", "name": "name", "type": "type", "value": "value", "action": "formaction", "encoding": "formenctype", "method": "formmethod", "target": "formtarget"}), 'each', [], function $Button$1(name, attributes){var self = $Button$1.$$s == null ? this : $Button$1.$$s;

            
            if (name == null) name = nil;
            if (attributes == null) attributes = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self});
          self['$defhelper!']("autofocus");
          return self['$defhelper!']("disabled");
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/canvas"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Canvas');

          
          return $send($hash2(["width", "height"], {"width": "width", "height": "height"}), 'each', [], function $Canvas$1(name, attribute){var self = $Canvas$1.$$s == null ? this : $Canvas$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["buffer/view"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,!,nil?,[],attr_reader,native?,to_n,name_for,get,set,length');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'View');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Native'), 'Wrapper'));
      $defs(self, '$supported?', function $View_supported$ques$1() {
                if ($gvars.$ == null) $gvars.$ = nil;

        return $gvars.$['$[]']("DataView")['$nil?']()['$!']()
      }, 0);
      self.$attr_reader("buffer", "offset");
      
      $def(self, '$initialize', function $$initialize(buffer, offset, length) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (offset == null) offset = nil;
        if (length == null) length = nil;
        if ($truthy(self['$native?'](buffer))) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [buffer], null)
        } else if (($truthy(offset) && ($truthy(length)))) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n(), offset.$to_n(), length.$to_n())], null)
        } else if ($truthy(offset)) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n(), offset.$to_n())], null)
        } else {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n())], null)
        };
        self.buffer = buffer;
        return (self.offset = offset);
      }, -2);
      
      $def(self, '$length', function $$length() {
        var self = this;

        return self["native"].byteLength
      }, 0);
      
      $def(self, '$get', function $$get(offset, bits, type, little) {
        var self = this;

        
        if (bits == null) bits = 8;
        if (type == null) type = "unsigned";
        if (little == null) little = false;
        return self["native"]["get" + $$('Buffer').$name_for(bits, type)](offset, little);
      }, -2);
      $alias(self, "[]", "get");
      
      $def(self, '$set', function $$set(offset, value, bits, type, little) {
        var self = this;

        
        if (bits == null) bits = 8;
        if (type == null) type = "unsigned";
        if (little == null) little = false;
        return self["native"]["set" + $$('Buffer').$name_for(bits, type)](offset, value, little);
      }, -3);
      $alias(self, "[]=", "set");
      
      $def(self, '$get_int8', function $$get_int8(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getInt8(offset, little);
      }, -2);
      
      $def(self, '$set_int8', function $$set_int8(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setInt8(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint8', function $$get_uint8(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getUint8(offset, little);
      }, -2);
      
      $def(self, '$set_uint8', function $$set_uint8(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setUint8(offset, value, little);
      }, -3);
      
      $def(self, '$get_int16', function $$get_int16(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getInt16(offset, little);
      }, -2);
      
      $def(self, '$set_int16', function $$set_int16(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setInt16(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint16', function $$get_uint16(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getUint16(offset, little);
      }, -2);
      
      $def(self, '$set_uint16', function $$set_uint16(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setUint16(offset, value, little);
      }, -3);
      
      $def(self, '$get_int32', function $$get_int32(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getInt32(offset, little);
      }, -2);
      
      $def(self, '$set_int32', function $$set_int32(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setInt32(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint32', function $$get_uint32(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getUint32(offset, little);
      }, -2);
      
      $def(self, '$set_uint32', function $$set_uint32(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setUint32(offset, value, little);
      }, -3);
      
      $def(self, '$get_float32', function $$get_float32(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getFloat32(offset, little);
      }, -2);
      
      $def(self, '$set_float32', function $$set_float32(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setFloat32(offset, value, little);
      }, -3);
      
      $def(self, '$get_float64', function $$get_float64(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getFloat64(offset, little);
      }, -2);
      
      $def(self, '$set_float64', function $$set_float64(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setFloat64(offset, value, little);
      }, -3);
      return $alias(self, "size", "length");
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/embed"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Embed');

          
          return $send($hash2(["type", "height", "width"], {"type": "type", "height": "height", "width": "width"}), 'each', [], function $Embed$1(name, attribute){var self = $Embed$1.$$s == null ? this : $Embed$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/optgroup"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,defhelper!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Optgroup');

          
          
          $send(["label", "value"], 'each', [], function $Optgroup$1(name){var self = $Optgroup$1.$$s == null ? this : $Optgroup$1.$$s;

            
            if (name == null) name = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 1, $$s: self});
          self['$defhelper!']("disabled");
          return self['$defhelper!']("selected");
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/select"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,defhelper!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Select');

          
          
          $send(["form", "name", "size"], 'each', [], function $Select$1(name){var self = $Select$1.$$s == null ? this : $Select$1.$$s;

            
            if (name == null) name = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 1, $$s: self});
          self['$defhelper!']("auto_focus", "autofocus");
          self['$defhelper!']("disabled");
          return self['$defhelper!']("required");
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/base"] = function(Opal) {/* Generated by Opal 1.6.0 */
  var $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Base');

          
          return $send($hash2(["href", "url", "target"], {"href": "href", "url": "href", "target": "target"}), 'each', [], function $Base$1(name, attribute){var self = $Base$1.$$s == null ? this : $Base$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$arity: 1, $$s: self});}, {$$arity: 2, $$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.queue(function(Opal) {/* Generated by Opal 1.6.0 */
  var $gvars = Opal.gvars, self = Opal.top, nil = Opal.nil;
  if ($gvars.window == null) $gvars.window = nil;

  Opal.add_stubs('require,alert');
  
  self.$require("opal");
  self.$require("native");
  self.$require("promise");
  self.$require("browser/setup/full");
  return $gvars.window.$alert("hello world");
});

Opal.queue(function(Opal) {/* Generated by Opal 1.6.0 */
  var $Kernel = Opal.Kernel, nil = Opal.nil;

  Opal.add_stubs('exit');
  return $Kernel.$exit()
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKGdsb2JhbF9vYmplY3QuY29uc29sZSA9PSBudWxsKSB7XG4gICAgZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuY29uc29sZSkgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbF9vYmplY3QuY29uc29sZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlID0ge307XG4gIH1cblxuICBpZiAoISgnbG9nJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uICgpIHt9OyB9XG4gIGlmICghKCd3YXJuJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLndhcm4gPSBjb25zb2xlLmxvZzsgfVxuXG4gIGlmICh0eXBlb2YoZ2xvYmFsX29iamVjdC5PcGFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ09wYWwgYWxyZWFkeSBsb2FkZWQuIExvYWRpbmcgdHdpY2UgY2FuIGNhdXNlIHRyb3VibGVzLCBwbGVhc2UgZml4IHlvdXIgc2V0dXAuJyk7XG4gICAgcmV0dXJuIGdsb2JhbF9vYmplY3QuT3BhbDtcbiAgfVxuXG4gIHZhciBuaWw7XG5cbiAgLy8gVGhlIGFjdHVhbCBjbGFzcyBmb3IgQmFzaWNPYmplY3RcbiAgdmFyIEJhc2ljT2JqZWN0O1xuXG4gIC8vIFRoZSBhY3R1YWwgT2JqZWN0IGNsYXNzLlxuICAvLyBUaGUgbGVhZGluZyB1bmRlcnNjb3JlIGlzIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIHdpbmRvdy5PYmplY3QoKVxuICB2YXIgX09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE1vZHVsZSBjbGFzc1xuICB2YXIgTW9kdWxlO1xuXG4gIC8vIFRoZSBhY3R1YWwgQ2xhc3MgY2xhc3NcbiAgdmFyIENsYXNzO1xuXG4gIC8vIFRoZSBPcGFsLk9wYWwgY2xhc3MgKGhlbHBlcnMgZXRjLilcbiAgdmFyIF9PcGFsO1xuXG4gIC8vIFRoZSBLZXJuZWwgbW9kdWxlXG4gIHZhciBLZXJuZWw7XG5cbiAgLy8gVGhlIE9wYWwgb2JqZWN0IHRoYXQgaXMgZXhwb3NlZCBnbG9iYWxseVxuICB2YXIgT3BhbCA9IGdsb2JhbF9vYmplY3QuT3BhbCA9IHt9O1xuXG4gIC8vIFRoaXMgaXMgYSB1c2VmdWwgcmVmZXJlbmNlIHRvIGdsb2JhbCBvYmplY3QgaW5zaWRlIHJ1YnkgZmlsZXNcbiAgT3BhbC5nbG9iYWwgPSBnbG9iYWxfb2JqZWN0O1xuXG4gIC8vIENvbmZpZ3VyZSBydW50aW1lIGJlaGF2aW9yIHdpdGggcmVnYXJkcyB0byByZXF1aXJlIGFuZCB1bnN1cHBvcnRlZCBmZWF0dXJlc1xuICBPcGFsLmNvbmZpZyA9IHtcbiAgICBtaXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk6ICdlcnJvcicsICAgICAgICAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgdW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHk6ICd3YXJuaW5nJywgLy8gZXJyb3IsIHdhcm5pbmcsIGlnbm9yZVxuICAgIGV4cGVyaW1lbnRhbF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLC8vIHdhcm5pbmcsIGlnbm9yZVxuICAgIGVuYWJsZV9zdGFja190cmFjZTogdHJ1ZSAgICAgICAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlXG4gIH07XG5cbiAgLy8gTWluaWZ5IGNvbW1vbiBmdW5jdGlvbiBjYWxsc1xuICB2YXIgJGhhc19vd24gICA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyICRiaW5kICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcbiAgdmFyICRzZXRfcHJvdG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4gIHZhciAkc2xpY2UgICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICB2YXIgJHNwbGljZSAgICA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2U7XG5cbiAgLy8gTmlsIG9iamVjdCBpZCBpcyBhbHdheXMgNFxuICB2YXIgbmlsX2lkID0gNDtcblxuICAvLyBHZW5lcmF0ZXMgZXZlbiBzZXF1ZW50aWFsIG51bWJlcnMgZ3JlYXRlciB0aGFuIDRcbiAgLy8gKG5pbF9pZCkgdG8gc2VydmUgYXMgdW5pcXVlIGlkcyBmb3IgcnVieSBvYmplY3RzXG4gIHZhciB1bmlxdWVfaWQgPSBuaWxfaWQ7XG5cbiAgLy8gUmV0dXJuIG5leHQgdW5pcXVlIGlkXG4gIGZ1bmN0aW9uICR1aWQoKSB7XG4gICAgdW5pcXVlX2lkICs9IDI7XG4gICAgcmV0dXJuIHVuaXF1ZV9pZDtcbiAgfTtcbiAgT3BhbC51aWQgPSAkdWlkO1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkID09IG51bGwpIHtcbiAgICAgICRwcm9wKG9iaiwgJyQkaWQnLCAkdWlkKCkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICB2YXIgJGd2YXJzID0gT3BhbC5ndmFycyA9IHt9O1xuXG4gIC8vIEV4aXQgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IHBsYXRmb3JtIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gIC8vIChTZWUgbm9kZWpzIGFuZCBjaHJvbWUgZm9yIGV4YW1wbGVzKVxuICBPcGFsLmV4aXQgPSBmdW5jdGlvbihzdGF0dXMpIHsgaWYgKCRndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IE9wYWwuZXhjZXB0aW9ucy5wb3AoKTtcbiAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAkZ3ZhcnNbXCIhXCJdID0gZXhjZXB0aW9uO1xuICAgICAgJGd2YXJzW1wiQFwiXSA9IGV4Y2VwdGlvbi4kYmFja3RyYWNlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJGd2YXJzW1wiIVwiXSA9ICRndmFyc1tcIkBcIl0gPSBuaWw7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uICRwcm9wKG9iamVjdCwgbmFtZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZihvYmplY3QpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yOlxuICAgICAgLy8gICBzID0gXCJzdHJpbmdcIlxuICAgICAgLy8gICBkZWYgcy5tOyBlbmRcbiAgICAgIC8vIFN0cmluZyBjbGFzcyBpcyB0aGUgb25seSBjbGFzcyB0aGF0OlxuICAgICAgLy8gKyBjb21waWxlcyB0byBKUyBwcmltaXRpdmVcbiAgICAgIC8vICsgYWxsb3dzIG1ldGhvZCBkZWZpbml0aW9uIGRpcmVjdGx5IG9uIGluc3RhbmNlc1xuICAgICAgLy8gbnVtYmVycywgdHJ1ZSwgZmFsc2UgYW5kIG51bGwgZG8gbm90IHN1cHBvcnQgaXQuXG4gICAgICBvYmplY3RbbmFtZV0gPSBpbml0aWFsVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwucHJvcCA9ICRwcm9wO1xuXG4gIC8vIEBkZXByZWNhdGVkXG4gIE9wYWwuZGVmaW5lUHJvcGVydHkgPSBPcGFsLnByb3A7XG5cbiAgT3BhbC5zbGljZSA9ICRzbGljZTtcblxuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS1cblxuICB2YXIgJHRydXRoeSA9IE9wYWwudHJ1dGh5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIGZhbHNlICE9PSB2YWwgJiYgbmlsICE9PSB2YWwgJiYgdW5kZWZpbmVkICE9PSB2YWwgJiYgbnVsbCAhPT0gdmFsICYmICghKHZhbCBpbnN0YW5jZW9mIEJvb2xlYW4pIHx8IHRydWUgPT09IHZhbC52YWx1ZU9mKCkpO1xuICB9O1xuXG4gIE9wYWwuZmFsc3kgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gISR0cnV0aHkodmFsKTtcbiAgfTtcblxuICBPcGFsLnR5cGVfZXJyb3IgPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZCkge1xuICAgIG9iamVjdCA9IG9iamVjdC4kJGNsYXNzO1xuXG4gICAgaWYgKGNvZXJjZWQgJiYgbWV0aG9kKSB7XG4gICAgICBjb2VyY2VkID0gY29lcmNlZC4kJGNsYXNzO1xuICAgICAgcmV0dXJuIE9wYWwuVHlwZUVycm9yLiRuZXcoXG4gICAgICAgIFwiY2FuJ3QgY29udmVydCBcIiArIG9iamVjdCArIFwiIGludG8gXCIgKyB0eXBlICtcbiAgICAgICAgXCIgKFwiICsgb2JqZWN0ICsgXCIjXCIgKyBtZXRob2QgKyBcIiBnaXZlcyBcIiArIGNvZXJjZWQgKyBcIilcIlxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5UeXBlRXJyb3IuJG5ldyhcbiAgICAgICAgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGVcbiAgICAgIClcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5jb2VyY2VfdG8gPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncykge1xuICAgIHZhciBib2R5O1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ3RvX2ludCcgJiYgdHlwZSA9PT0gT3BhbC5JbnRlZ2VyICYmIG9iamVjdC4kJGlzX251bWJlcilcbiAgICAgIHJldHVybiBvYmplY3QgPCAwID8gTWF0aC5jZWlsKG9iamVjdCkgOiBNYXRoLmZsb29yKG9iamVjdCk7XG5cbiAgICBpZiAobWV0aG9kID09PSAndG9fc3RyJyAmJiB0eXBlID09PSBPcGFsLlN0cmluZyAmJiBvYmplY3QuJCRpc19zdHJpbmcpXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgaWYgKE9wYWwuaXNfYShvYmplY3QsIHR5cGUpKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgLy8gRmFzdCBwYXRoIGZvciB0aGUgbW9zdCBjb21tb24gc2l0dWF0aW9uXG4gICAgaWYgKG9iamVjdFsnJHJlc3BvbmRfdG8/J10uJCRwcmlzdGluZSAmJiBvYmplY3QuJG1ldGhvZF9taXNzaW5nLiQkcHJpc3RpbmUpIHtcbiAgICAgIGJvZHkgPSBvYmplY3RbJyQnICsgbWV0aG9kXTtcbiAgICAgIGlmIChib2R5ID09IG51bGwgfHwgYm9keS4kJHN0dWIpIHRocm93IE9wYWwudHlwZV9lcnJvcihvYmplY3QsIHR5cGUpO1xuICAgICAgcmV0dXJuIGJvZHkuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICBpZiAoIW9iamVjdFsnJHJlc3BvbmRfdG8/J10obWV0aG9kKSkge1xuICAgICAgdGhyb3cgT3BhbC50eXBlX2Vycm9yKG9iamVjdCwgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MgPT0gbnVsbCkgYXJncyA9IFtdO1xuICAgIHJldHVybiBPcGFsLnNlbmQob2JqZWN0LCBtZXRob2QsIGFyZ3MpO1xuICB9XG5cbiAgT3BhbC5yZXNwb25kX3RvID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBpbmNsdWRlX2FsbCkge1xuICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHJldHVybiBmYWxzZTtcbiAgICBpbmNsdWRlX2FsbCA9ICEhaW5jbHVkZV9hbGw7XG4gICAgdmFyIGJvZHkgPSBvYmpbanNpZF07XG5cbiAgICBpZiAob2JqWyckcmVzcG9uZF90bz8nXS4kJHByaXN0aW5lKSB7XG4gICAgICBpZiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFvYmpbJyRyZXNwb25kX3RvX21pc3Npbmc/J10uJCRwcmlzdGluZSkge1xuICAgICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLnNlbmQob2JqLCBvYmpbJyRyZXNwb25kX3RvPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJhY2VQb2ludCBzdXBwb3J0XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBTdXBwb3J0IGZvciBgVHJhY2VQb2ludC50cmFjZSg6Y2xhc3MpIGRvIC4uLiBlbmRgXG4gIE9wYWwudHJhY2VfY2xhc3MgPSBmYWxzZTtcbiAgT3BhbC50cmFjZXJzX2Zvcl9jbGFzcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhrbGFzc19vcl9tb2R1bGUpIHtcbiAgICB2YXIgaSwgaWksIHRyYWNlcjtcblxuICAgIGZvcihpID0gMCwgaWkgPSBPcGFsLnRyYWNlcnNfZm9yX2NsYXNzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHRyYWNlciA9IE9wYWwudHJhY2Vyc19mb3JfY2xhc3NbaV07XG4gICAgICB0cmFjZXIudHJhY2Vfb2JqZWN0ID0ga2xhc3Nfb3JfbW9kdWxlO1xuICAgICAgdHJhY2VyLmJsb2NrLiRjYWxsKHRyYWNlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlX2F1dG9sb2FkKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoIWNyZWYuJCRhdXRvbG9hZFtuYW1lXS5sb2FkZWQpIHtcbiAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgT3BhbC5LZXJuZWwuJHJlcXVpcmUoY3JlZi4kJGF1dG9sb2FkW25hbWVdLnBhdGgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0uZXhjZXB0aW9uID0gZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5yZXF1aXJlZCA9IHRydWU7XG4gICAgICBpZiAoY3JlZi4kJGNvbnN0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgY3JlZi4kJGF1dG9sb2FkW25hbWVdLnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3JlZi4kJGF1dG9sb2FkW25hbWVdLmxvYWRlZCAmJiAhY3JlZi4kJGF1dG9sb2FkW25hbWVdLnJlcXVpcmVkKSB7XG4gICAgICBpZiAoY3JlZi4kJGF1dG9sb2FkW25hbWVdLmV4Y2VwdGlvbikgeyB0aHJvdyBjcmVmLiQkYXV0b2xvYWRbbmFtZV0uZXhjZXB0aW9uOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29uc3RhbnRzXG4gIC8vIC0tLS0tLS0tLVxuICAvL1xuICAvLyBGb3IgZnV0dXJlIHJlZmVyZW5jZTpcbiAgLy8gLSBUaGUgUmFpbHMgYXV0b2xvYWRpbmcgZ3VpZGUgKGh0dHA6Ly9ndWlkZXMucnVieW9ucmFpbHMub3JnL3Y1LjAvYXV0b2xvYWRpbmdfYW5kX3JlbG9hZGluZ19jb25zdGFudHMuaHRtbClcbiAgLy8gLSBAQ29ucmFkSXJ3aW4ncyAyMDEyIHBvc3Qgb24g4oCcRXZlcnl0aGluZyB5b3UgZXZlciB3YW50ZWQgdG8ga25vdyBhYm91dCBjb25zdGFudCBsb29rdXAgaW4gUnVieeKAnSAoaHR0cDovL2NpcncuaW4vYmxvZy9jb25zdGFudC1sb29rdXAuaHRtbClcbiAgLy9cbiAgLy8gTGVnZW5kIG9mIE1SSSBjb25jZXB0cy9uYW1lczpcbiAgLy8gLSBjb25zdGFudCByZWZlcmVuY2UgKGNyZWYpOiB0aGUgbW9kdWxlL2NsYXNzIHRoYXQgYWN0cyBhcyBhIG5hbWVzcGFjZVxuICAvLyAtIG5lc3Rpbmc6IHRoZSBuYW1lc3BhY2VzIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNjb3BlLCBlLmcuIG5lc3RpbmcgaW5zaWRlXG4gIC8vICAgICAgICAgICAgYG1vZHVsZSBBOyBtb2R1bGUgQjo6QzsgZW5kOyBlbmRgIGlzIGBbQjo6QywgQV1gXG5cbiAgLy8gR2V0IHRoZSBjb25zdGFudCBpbiB0aGUgc2NvcGUgb2YgdGhlIGN1cnJlbnQgY3JlZlxuICBmdW5jdGlvbiBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKSB7XG4gICAgaWYgKGNyZWYpIHtcbiAgICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkgeyByZXR1cm4gY3JlZi4kJGNvbnN0W25hbWVdOyB9XG4gICAgICBpZiAoY3JlZi4kJGF1dG9sb2FkICYmIGNyZWYuJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKGNyZWYsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIG5lc3RpbmcgYXJyYXkgbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGNvbnN0YW50O1xuXG4gICAgaWYgKG5lc3RpbmcubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGUgbmVzdGluZyBpcyBub3QgZW1wdHkgdGhlIGNvbnN0YW50IGlzIGxvb2tlZCB1cCBpbiBpdHMgZWxlbWVudHNcbiAgICAvLyBhbmQgaW4gb3JkZXIuIFRoZSBhbmNlc3RvcnMgb2YgdGhvc2UgZWxlbWVudHMgYXJlIGlnbm9yZWQuXG4gICAgZm9yIChpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0YW50ID0gbmVzdGluZ1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgaWYgKGNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgICAgfSBlbHNlIGlmIChuZXN0aW5nW2ldLiQkYXV0b2xvYWQgJiYgbmVzdGluZ1tpXS4kJGF1dG9sb2FkW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVfYXV0b2xvYWQobmVzdGluZ1tpXSwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudFxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGFuY2VzdG9ycztcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGFuY2VzdG9ycyA9ICRhbmNlc3RvcnMoY3JlZik7XG5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldLiQkY29uc3QgJiYgJGhhc19vd24uY2FsbChhbmNlc3RvcnNbaV0uJCRjb25zdCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgfSBlbHNlIGlmIChhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZCAmJiBhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKGFuY2VzdG9yc1tpXSwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2FsayB1cCBPYmplY3QncyBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50LFxuICAvLyBidXQgb25seSBpZiBjcmVmIGlzIG1pc3Npbmcgb3IgYSBtb2R1bGUuXG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkge1xuICAgIGlmIChjcmVmID09IG51bGwgfHwgY3JlZi4kJGlzX21vZHVsZSkge1xuICAgICAgcmV0dXJuIGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCBjb25zdF9taXNzaW5nIGlmIG5vdGhpbmcgZWxzZSB3b3JrZWRcbiAgZnVuY3Rpb24gY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lKSB7XG4gICAgcmV0dXJuIChjcmVmIHx8IF9PYmplY3QpLiRjb25zdF9taXNzaW5nKG5hbWUpO1xuICB9XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGp1c3QgaW4gdGhlIGN1cnJlbnQgY3JlZiBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2BcbiAgT3BhbC5jb25zdF9nZXRfbG9jYWwgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBPcGFsLlR5cGVFcnJvcihjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsIHx8IHNraXBfbWlzc2luZyA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSk7XG4gIH07XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IHJlbGF0aXZlIHRvIGEgY3JlZiBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2AgKHdoZW4gdGhlXG4gIC8vIGNvbnN0YW50IGlzIHByZWZpeGVkIGJ5IGA6OmApLlxuICBPcGFsLmNvbnN0X2dldF9xdWFsaWZpZWQgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgcmVzdWx0LCBjYWNoZSwgY2FjaGVkLCBjdXJyZW50X3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb247XG5cbiAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAvLyBBIHNob3J0cGF0aCBmb3IgY2FsbHMgbGlrZSA6OlN0cmluZyA9PiAkJCQoXCJTdHJpbmdcIilcbiAgICAgIHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKF9PYmplY3QsIGNyZWYpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkKF9PYmplY3QsIGNyZWYsIHNraXBfbWlzc2luZyk7XG4gICAgfVxuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBPcGFsLlR5cGVFcnJvcihjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XG4gICAgfVxuXG4gICAgaWYgKChjYWNoZSA9IGNyZWYuJCRjb25zdF9jYWNoZSkgPT0gbnVsbCkge1xuICAgICAgJHByb3AoY3JlZiwgJyQkY29uc3RfY2FjaGUnLCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgIGNhY2hlID0gY3JlZi4kJGNvbnN0X2NhY2hlO1xuICAgIH1cbiAgICBjYWNoZWQgPSBjYWNoZVtuYW1lXTtcblxuICAgIGlmIChjYWNoZWQgPT0gbnVsbCB8fCBjYWNoZWRbMF0gIT09IGN1cnJlbnRfdmVyc2lvbikge1xuICAgICAgKChyZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKSkgICAgICAgICAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkpICAgICAgIT0gbnVsbCk7XG4gICAgICBjYWNoZVtuYW1lXSA9IFtjdXJyZW50X3ZlcnNpb24sIHJlc3VsdF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNhY2hlZFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICE9IG51bGwgfHwgc2tpcF9taXNzaW5nID8gcmVzdWx0IDogY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB0b3AgbGV2ZWwgY29uc3RhbnQgY2FjaGUgZ2VuZXJhdGlvbiBjb3VudGVyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGluIHRoZSBvcGVuIHVzaW5nIHRoZSBjdXJyZW50IG5lc3RpbmcgYW5kIHRoZSBuZWFyZXN0XG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlID0gZnVuY3Rpb24obmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIGNyZWYgPSBuZXN0aW5nWzBdLCByZXN1bHQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiwgY2FjaGUsIGNhY2hlZDtcblxuICAgIGlmICgoY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRwcm9wKG5lc3RpbmcsICckJGNvbnN0X2NhY2hlJywgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICBjYWNoZSA9IG5lc3RpbmcuJCRjb25zdF9jYWNoZTtcbiAgICB9XG4gICAgY2FjaGVkID0gY2FjaGVbbmFtZV07XG5cbiAgICBpZiAoY2FjaGVkID09IG51bGwgfHwgY2FjaGVkWzBdICE9PSBjdXJyZW50X3ZlcnNpb24pIHtcbiAgICAgICgocmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkpICAgICAgICAgICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfbmVzdGluZyhuZXN0aW5nLCBuYW1lKSkgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkpICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX09iamVjdChjcmVmLCBuYW1lKSkgICAgICAgICAhPSBudWxsKTtcblxuICAgICAgY2FjaGVbbmFtZV0gPSBbY3VycmVudF92ZXJzaW9uLCByZXN1bHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjYWNoZWRbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsIHx8IHNraXBfbWlzc2luZyA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSk7XG4gIH07XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIGNvbnN0YW50IG9uIGEgY3JlZiBhbmQgb3Bwb3J0dW5pc3RpY2FsbHkgc2V0IHRoZSBuYW1lIG9mXG4gIC8vIHVubmFtZWQgY2xhc3Nlcy9tb2R1bGVzLlxuICBmdW5jdGlvbiAkY29uc3Rfc2V0KGNyZWYsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGNyZWYgPT0gbnVsbCB8fCBjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICh2YWx1ZS4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBpZiAodmFsdWUuJCRuYW1lID09IG51bGwgfHwgdmFsdWUuJCRuYW1lID09PSBuaWwpIHZhbHVlLiQkbmFtZSA9IG5hbWU7XG4gICAgICBpZiAodmFsdWUuJCRiYXNlX21vZHVsZSA9PSBudWxsKSB2YWx1ZS4kJGJhc2VfbW9kdWxlID0gY3JlZjtcbiAgICB9XG5cbiAgICBjcmVmLiQkY29uc3QgPSAoY3JlZi4kJGNvbnN0IHx8IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIGNyZWYuJCRjb25zdFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gQWRkIGEgc2hvcnQgaGVscGVyIHRvIG5hdmlnYXRlIGNvbnN0YW50cyBtYW51YWxseS5cbiAgICAvLyBAZXhhbXBsZVxuICAgIC8vICAgT3BhbC4kJC5SZWdleHAuJCQuSUdOT1JFQ0FTRVxuICAgIGNyZWYuJCQgPSBjcmVmLiQkY29uc3Q7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcblxuICAgIC8vIEV4cG9zZSB0b3AgbGV2ZWwgY29uc3RhbnRzIG9udG8gdGhlIE9wYWwgb2JqZWN0XG4gICAgaWYgKGNyZWYgPT09IF9PYmplY3QpIE9wYWxbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIE5hbWUgbmV3IGNsYXNzIGRpcmVjdGx5IG9udG8gY3VycmVudCBzY29wZSAoT3BhbC5Gb28uQmF6ID0ga2xhc3MpXG4gICAgJHByb3AoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIE9wYWwuY29uc3Rfc2V0ID0gJGNvbnN0X3NldDtcblxuICAvLyBHZXQgYWxsIHRoZSBjb25zdGFudHMgcmVhY2hhYmxlIGZyb20gYSBnaXZlbiBjcmVmLCBieSBkZWZhdWx0IHdpbGwgaW5jbHVkZVxuICAvLyBpbmhlcml0ZWQgY29uc3RhbnRzLlxuICBPcGFsLmNvbnN0YW50cyA9IGZ1bmN0aW9uKGNyZWYsIGluaGVyaXQpIHtcbiAgICBpZiAoaW5oZXJpdCA9PSBudWxsKSBpbmhlcml0ID0gdHJ1ZTtcblxuICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbY3JlZl0sIGksIGlpLCBjb25zdGFudHMgPSB7fSwgY29uc3RhbnQ7XG5cbiAgICBpZiAoaW5oZXJpdCkgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KCRhbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoJGFuY2VzdG9ycyhPcGFsLk9iamVjdCkpO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG5cbiAgICAgIC8vIERvIG5vdCBzaG93IE9iamVjdHMgY29uc3RhbnRzIHVubGVzcyB3ZSdyZSBxdWVyeWluZyBPYmplY3QgaXRzZWxmXG4gICAgICBpZiAoY3JlZiAhPT0gX09iamVjdCAmJiBtb2R1bGUgPT0gX09iamVjdCkgYnJlYWs7XG5cbiAgICAgIGZvciAoY29uc3RhbnQgaW4gbW9kdWxlLiQkY29uc3QpIHtcbiAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobW9kdWxlLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgZm9yIChjb25zdGFudCBpbiBtb2R1bGUuJCRhdXRvbG9hZCkge1xuICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbnN0YW50cyk7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGEgY29uc3RhbnQgZnJvbSBhIGNyZWYuXG4gIE9wYWwuY29uc3RfcmVtb3ZlID0gZnVuY3Rpb24oY3JlZiwgbmFtZSkge1xuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICB2YXIgb2xkID0gY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgZGVsZXRlIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIHJldHVybiBvbGQ7XG4gICAgfVxuXG4gICAgaWYgKGNyZWYuJCRhdXRvbG9hZCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0pIHtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkYXV0b2xvYWRbbmFtZV07XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cblxuICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJjb25zdGFudCBcIitjcmVmK1wiOjpcIitjcmVmLiRuYW1lKCkrXCIgbm90IGRlZmluZWRcIik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBhIGN1cnJpZWQgY29uc3RfZ2V0X3JlbGF0aXZlLlxuICBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZV9mYWN0b3J5ID0gZnVuY3Rpb24obmVzdGluZykge1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiBPcGFsLiQkKG5lc3RpbmcsIG5hbWUsIHNraXBfbWlzc2luZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0dXAgc29tZSBzaG9ydGN1dHMgdG8gcmVkdWNlIGNvbXBpbGVkIHNpemVcbiAgT3BhbC4kJCA9IE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlO1xuICBPcGFsLiQkJCA9IE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZDtcbiAgT3BhbC4kciA9IE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlX2ZhY3Rvcnk7XG5cbiAgLy8gTW9kdWxlcyAmIENsYXNzZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIGBjbGFzcyBGb287IGVuZGAgZXhwcmVzc2lvbiBpbiBydWJ5IGlzIGNvbXBpbGVkIHRvIGNhbGwgdGhpcyBydW50aW1lXG4gIC8vIG1ldGhvZCB3aGljaCBlaXRoZXIgcmV0dXJucyBhbiBleGlzdGluZyBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSwgb3IgY3JlYXRlc1xuICAvLyBhIG5ldyBjbGFzcyBpbiB0aGUgZ2l2ZW4gYGJhc2VgIHNjb3BlLlxuICAvL1xuICAvLyBJZiBhIGNvbnN0YW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLCB0aGVuIHdlIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0XG4gIC8vIGl0IGlzIGEgY2xhc3MgYW5kIGFsc28gdGhhdCB0aGUgc3VwZXJjbGFzc2VzIG1hdGNoLiBJZiBlaXRoZXIgb2YgdGhlc2VcbiAgLy8gZmFpbCwgdGhlbiB3ZSByYWlzZSBhIGBUeXBlRXJyb3JgLiBOb3RlLCBgc3VwZXJjbGFzc2AgbWF5IGJlIG51bGwgaWYgb25lXG4gIC8vIHdhcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBydWJ5IGNvZGUuXG4gIC8vXG4gIC8vIFdlIHBhc3MgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG1ldGhvZCBvZiB0aGUgZm9ybSBgZnVuY3Rpb24gQ2xhc3NOYW1lKCkge31gXG4gIC8vIHNpbXBseSBzbyB0aGF0IGNsYXNzZXMgc2hvdyB1cCB3aXRoIG5pY2VseSBmb3JtYXR0ZWQgbmFtZXMgaW5zaWRlIGRlYnVnZ2Vyc1xuICAvLyBpbiB0aGUgd2ViIGJyb3dzZXIgKG9yIG5vZGUvc3Byb2NrZXRzKS5cbiAgLy9cbiAgLy8gVGhlIGBzY29wZWAgaXMgdGhlIGN1cnJlbnQgYHNlbGZgIHZhbHVlIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIGZyb20uIFdlIHVzZSB0aGlzIHRvIGdldCB0aGUgc2NvcGUgZm9yIHdoZXJlIHRoZSBjbGFzcyBzaG91bGQgYmUgY3JlYXRlZC5cbiAgLy8gSWYgYHNjb3BlYCBpcyBhbiBvYmplY3QgKG5vdCBhIGNsYXNzL21vZHVsZSksIHdlIHNpbXBsZSBnZXQgaXRzIGNsYXNzIGFuZFxuICAvLyB1c2UgdGhhdCBhcyB0aGUgc2NvcGUgaW5zdGVhZC5cbiAgLy9cbiAgLy8gQHBhcmFtIHNjb3BlICAgICAgICBbT2JqZWN0XSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxuICAvLyBAcGFyYW0gc3VwZXJjbGFzcyAgIFtDbGFzcyxudWxsXSBzdXBlcmNsYXNzIG9mIHRoZSBuZXcgY2xhc3MgKG1heSBiZSBudWxsKVxuICAvLyBAcGFyYW0gc2luZ2xldG9uICAgIFtCb29sZWFuLG51bGxdIGEgdHJ1ZSB2YWx1ZSBkZW5vdGVzIHdlIHdhbnQgdG8gYWxsb2NhdGVcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHNpbmdsZXRvblxuICAvL1xuICAvLyBAcmV0dXJuIG5ldyBbQ2xhc3NdICBvciBleGlzdGluZyBydWJ5IGNsYXNzXG4gIC8vXG4gIGZ1bmN0aW9uICRhbGxvY2F0ZV9jbGFzcyhuYW1lLCBzdXBlcmNsYXNzLCBzaW5nbGV0b24pIHtcbiAgICB2YXIga2xhc3M7XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsICYmIHN1cGVyY2xhc3MuJCRicmlkZ2UpIHtcbiAgICAgIC8vIEluaGVyaXRhbmNlIGZyb20gYnJpZGdlZCBjbGFzc2VzIHJlcXVpcmVzXG4gICAgICAvLyBjYWxsaW5nIG9yaWdpbmFsIEpTIGNvbnN0cnVjdG9yc1xuICAgICAga2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgc2VsZiA9IG5ldyAoJGJpbmQuYXBwbHkoc3VwZXJjbGFzcy4kJGNvbnN0cnVjdG9yLCBbbnVsbF0uY29uY2F0KGFyZ3MpKSkoKTtcblxuICAgICAgICAvLyBhbmQgcmVwbGFjaW5nIGEgX19wcm90b19fIG1hbnVhbGx5XG4gICAgICAgICRzZXRfcHJvdG8oc2VsZiwga2xhc3MuJCRwcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2xhc3MgPSBmdW5jdGlvbigpe307XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gbmlsKSB7XG4gICAgICAkcHJvcChrbGFzcywgJ2Rpc3BsYXlOYW1lJywgJzo6JytuYW1lKTtcbiAgICB9XG5cbiAgICAkcHJvcChrbGFzcywgJyQkbmFtZScsIG5hbWUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRjb25zdHJ1Y3RvcicsIGtsYXNzKTtcbiAgICAkcHJvcChrbGFzcywgJyQkcHJvdG90eXBlJywga2xhc3MucHJvdG90eXBlKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3QnLCB7fSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGlzX2NsYXNzJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJHN1cGVyJywgc3VwZXJjbGFzcyk7XG4gICAgJHByb3Aoa2xhc3MsICckJGN2YXJzJywge30pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChrbGFzcywgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRhbmNlc3RvcnMnLCBbXSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG4gICAgJHByb3Aoa2xhc3MsICckJHN1YmNsYXNzZXMnLCBbXSk7XG5cbiAgICAkcHJvcChrbGFzcy4kJHByb3RvdHlwZSwgJyQkY2xhc3MnLCBrbGFzcyk7XG5cbiAgICAvLyBCeSBkZWZhdWx0IGlmIHRoZXJlIGFyZSBubyBzaW5nbGV0b24gY2xhc3MgbWV0aG9kc1xuICAgIC8vIF9fcHJvdG9fXyBpcyBDbGFzcy5wcm90b3R5cGVcbiAgICAvLyBMYXRlciBzaW5nbGV0b24gbWV0aG9kcyBnZW5lcmF0ZSBhIHNpbmdsZXRvbl9jbGFzc1xuICAgIC8vIGFuZCBpbmplY3QgaXQgaW50byBhbmNlc3RvcnMgY2hhaW5cbiAgICBpZiAoT3BhbC5DbGFzcykge1xuICAgICAgJHNldF9wcm90byhrbGFzcywgT3BhbC5DbGFzcy5wcm90b3R5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdXBlcmNsYXNzICE9IG51bGwpIHtcbiAgICAgICRzZXRfcHJvdG8oa2xhc3MuJCRwcm90b3R5cGUsIHN1cGVyY2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gICAgICBpZiAoc2luZ2xldG9uICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIExldCdzIG5vdCBmb3JiaWQgR0MgZnJvbSBjbGVhbmluZyB1cCBvdXJcbiAgICAgICAgLy8gc3ViY2xhc3Nlcy5cbiAgICAgICAgaWYgKHR5cGVvZiBXZWFrUmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIEZpcnN0LCBsZXQncyBjbGVhbiB1cCBvdXIgYXJyYXkgZnJvbSBlbXB0eSBvYmplY3RzLlxuICAgICAgICAgIHZhciBpLCBzdWJjbGFzcywgcmVidWlsdF9zdWJjbGFzc2VzID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdWJjbGFzcyA9IHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzW2ldO1xuICAgICAgICAgICAgaWYgKHN1YmNsYXNzLmRlcmVmKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZWJ1aWx0X3N1YmNsYXNzZXMucHVzaChzdWJjbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdywgbGV0J3MgYWRkIG91ciBjbGFzcy5cbiAgICAgICAgICByZWJ1aWx0X3N1YmNsYXNzZXMucHVzaChuZXcgV2Vha1JlZihrbGFzcykpO1xuICAgICAgICAgIHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzID0gcmVidWlsdF9zdWJjbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN1cGVyY2xhc3MuJCRzdWJjbGFzc2VzLnB1c2goa2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBlcmNsYXNzLiQkbWV0YSkge1xuICAgICAgICAvLyBJZiBzdXBlcmNsYXNzIGhhcyBtZXRhY2xhc3MgdGhlbiB3ZSBoYXZlIGV4cGxpY2l0ZWx5IGluaGVyaXQgaXQuXG4gICAgICAgIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKGtsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG4gIE9wYWwuYWxsb2NhdGVfY2xhc3MgPSAkYWxsb2NhdGVfY2xhc3M7XG5cblxuICBmdW5jdGlvbiBmaW5kX2V4aXN0aW5nX2NsYXNzKHNjb3BlLCBuYW1lKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGNsYXNzIGluIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgdmFyIGtsYXNzID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuXG4gICAgLy8gSWYgdGhlIGNsYXNzIGV4aXN0cyBpbiB0aGUgc2NvcGUsIHRoZW4gd2UgbXVzdCB1c2UgdGhhdFxuICAgIGlmIChrbGFzcykge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBleGlzdGluZyBjb25zdGFudCBpcyBhIGNsYXNzLCBvciByYWlzZSBlcnJvclxuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcobmFtZSArIFwiIGlzIG5vdCBhIGNsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU3VwZXJjbGFzc01hdGNoKGtsYXNzLCBzdXBlcmNsYXNzKSB7XG4gICAgaWYgKGtsYXNzLiQkc3VwZXIgIT09IHN1cGVyY2xhc3MpIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG1pc21hdGNoIGZvciBjbGFzcyBcIiArIGtsYXNzLiQkbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5rbGFzcyA9IGZ1bmN0aW9uKHNjb3BlLCBzdXBlcmNsYXNzLCBuYW1lKSB7XG4gICAgdmFyIGJyaWRnZWQ7XG5cbiAgICBpZiAoc2NvcGUgPT0gbnVsbCB8fCBzY29wZSA9PSAnOjonKSB7XG4gICAgICAvLyBHbG9iYWwgc2NvcGVcbiAgICAgIHNjb3BlID0gX09iamVjdDtcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xuICAgICAgLy8gU2NvcGUgaXMgYW4gb2JqZWN0LCB1c2UgaXRzIGNsYXNzXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHN1cGVyY2xhc3MgaXMgbm90IGFuIE9wYWwtZ2VuZXJhdGVkIGNsYXNzIHRoZW4gd2UncmUgYnJpZGdpbmcgYSBuYXRpdmUgSlMgY2xhc3NcbiAgICBpZiAoXG4gICAgICBzdXBlcmNsYXNzICE9IG51bGwgJiYgKCFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5IHx8IChcbiAgICAgICAgc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSAmJiAhc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpXG4gICAgICApKVxuICAgICkge1xuICAgICAgaWYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5uYW1lID09IFwiRnVuY3Rpb25cIikge1xuICAgICAgICBicmlkZ2VkID0gc3VwZXJjbGFzcztcbiAgICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwic3VwZXJjbGFzcyBtdXN0IGJlIGEgQ2xhc3MgKFwiICsgKFxuICAgICAgICAgIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yICYmIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLm5hbWUgfHwgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci4kJG5hbWUpKSB8fFxuICAgICAgICAgIHR5cGVvZihzdXBlcmNsYXNzKVxuICAgICAgICApICsgXCIgZ2l2ZW4pXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrbGFzcyA9IGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpO1xuXG4gICAgaWYgKGtsYXNzICE9IG51bGwpIHtcbiAgICAgIGlmIChzdXBlcmNsYXNzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBleGlzdGluZyBjbGFzcyBoYXMgc2FtZSBzdXBlcmNsYXNzXG4gICAgICAgIGVuc3VyZVN1cGVyY2xhc3NNYXRjaChrbGFzcywgc3VwZXJjbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gQ2xhc3MgZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZSB3aXRoIGdpdmVuIHN1cGVyY2xhc3MuLi5cblxuICAgICAgLy8gTm90IHNwZWNpZnlpbmcgYSBzdXBlcmNsYXNzIG1lYW5zIHdlIGNhbiBhc3N1bWUgaXQgdG8gYmUgT2JqZWN0XG4gICAgICBpZiAoc3VwZXJjbGFzcyA9PSBudWxsKSB7XG4gICAgICAgIHN1cGVyY2xhc3MgPSBfT2JqZWN0O1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIGNsYXNzIG9iamVjdCAoaW5zdGFuY2Ugb2YgQ2xhc3MpXG4gICAgICBrbGFzcyA9ICRhbGxvY2F0ZV9jbGFzcyhuYW1lLCBzdXBlcmNsYXNzKTtcbiAgICAgICRjb25zdF9zZXQoc2NvcGUsIG5hbWUsIGtsYXNzKTtcblxuICAgICAgLy8gQ2FsbCAuaW5oZXJpdGVkKCkgaG9vayB3aXRoIG5ldyBjbGFzcyBvbiB0aGUgc3VwZXJjbGFzc1xuICAgICAgaWYgKHN1cGVyY2xhc3MuJGluaGVyaXRlZCkge1xuICAgICAgICBzdXBlcmNsYXNzLiRpbmhlcml0ZWQoa2xhc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnJpZGdlZCkge1xuICAgICAgICBPcGFsLmJyaWRnZShicmlkZ2VkLCBrbGFzcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9wYWwudHJhY2VfY2xhc3MpIHsgaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKGtsYXNzKTsgfVxuXG4gICAgcmV0dXJuIGtsYXNzO1xuICB9O1xuXG4gIC8vIERlZmluZSBuZXcgbW9kdWxlIChvciByZXR1cm4gZXhpc3RpbmcgbW9kdWxlKS4gVGhlIGdpdmVuIGBzY29wZWAgaXMgYmFzaWNhbGx5XG4gIC8vIHRoZSBjdXJyZW50IGBzZWxmYCB2YWx1ZSB0aGUgYG1vZHVsZWAgc3RhdGVtZW50IHdhcyBkZWZpbmVkIGluLiBJZiB0aGlzIGlzXG4gIC8vIGEgcnVieSBtb2R1bGUgb3IgY2xhc3MsIHRoZW4gaXQgaXMgdXNlZCwgb3RoZXJ3aXNlIGlmIHRoZSBzY29wZSBpcyBhIHJ1YnlcbiAgLy8gb2JqZWN0IHRoZW4gdGhhdCBvYmplY3RzIHJlYWwgcnVieSBjbGFzcyBpcyB1c2VkIChlLmcuIGlmIHRoZSBzY29wZSBpcyB0aGVcbiAgLy8gbWFpbiBvYmplY3QsIHRoZW4gdGhlIHRvcCBsZXZlbCBgT2JqZWN0YCBjbGFzcyBpcyB1c2VkIGFzIHRoZSBzY29wZSkuXG4gIC8vXG4gIC8vIElmIGEgbW9kdWxlIG9mIHRoZSBnaXZlbiBuYW1lIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgc2NvcGUsIHRoZW4gdGhhdFxuICAvLyBpbnN0YW5jZSBpcyBqdXN0IHJldHVybmVkLlxuICAvL1xuICAvLyBJZiB0aGVyZSBpcyBhIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBzY29wZSwgdGhlbiBhbiBlcnJvciBpc1xuICAvLyBnZW5lcmF0ZWQgaW5zdGVhZCAoY2Fubm90IGhhdmUgYSBjbGFzcyBhbmQgbW9kdWxlIG9mIHNhbWUgbmFtZSBpbiBzYW1lIHNjb3BlKS5cbiAgLy9cbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBtb2R1bGUgaXMgY3JlYXRlZCBpbiB0aGUgc2NvcGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgYW5kIHRoYXRcbiAgLy8gbmV3IGluc3RhbmNlIGlzIHJldHVybmVkIGJhY2sgKHRvIGJlIHJlZmVyZW5jZWQgYXQgcnVudGltZSkuXG4gIC8vXG4gIC8vIEBwYXJhbSAgc2NvcGUgW01vZHVsZSwgQ2xhc3NdIGNsYXNzIG9yIG1vZHVsZSB0aGlzIGRlZmluaXRpb24gaXMgaW5zaWRlXG4gIC8vIEBwYXJhbSAgaWQgICBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgbmV3IChvciBleGlzdGluZykgbW9kdWxlXG4gIC8vXG4gIC8vIEByZXR1cm4gW01vZHVsZV1cbiAgZnVuY3Rpb24gJGFsbG9jYXRlX21vZHVsZShuYW1lKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKXt9O1xuICAgIHZhciBtb2R1bGUgPSBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChuYW1lKVxuICAgICAgJHByb3AoY29uc3RydWN0b3IsICdkaXNwbGF5TmFtZScsIG5hbWUrJy5jb25zdHJ1Y3RvcicpO1xuXG4gICAgJHByb3AobW9kdWxlLCAnJCRuYW1lJywgbmFtZSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRwcm90b3R5cGUnLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkY29uc3QnLCB7fSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRpc19tb2R1bGUnLCB0cnVlKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRjdmFycycsIHt9KTtcbiAgICAkcHJvcChtb2R1bGUsICckJGljbGFzc2VzJywgW10pO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRvd25fcHJlcGVuZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRhbmNlc3RvcnMnLCBbbW9kdWxlXSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJHNldF9wcm90byhtb2R1bGUsIE9wYWwuTW9kdWxlLnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuICBPcGFsLmFsbG9jYXRlX21vZHVsZSA9ICRhbGxvY2F0ZV9tb2R1bGU7XG5cbiAgZnVuY3Rpb24gZmluZF9leGlzdGluZ19tb2R1bGUoc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuICAgIGlmIChtb2R1bGUgPT0gbnVsbCAmJiBzY29wZSA9PT0gX09iamVjdCkgbW9kdWxlID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIGlmICghbW9kdWxlLiQkaXNfbW9kdWxlICYmIG1vZHVsZSAhPT0gX09iamVjdCkge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KG5hbWUgKyBcIiBpcyBub3QgYSBtb2R1bGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuXG4gIE9wYWwubW9kdWxlID0gZnVuY3Rpb24oc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlO1xuXG4gICAgaWYgKHNjb3BlID09IG51bGwgfHwgc2NvcGUgPT0gJzo6Jykge1xuICAgICAgLy8gR2xvYmFsIHNjb3BlXG4gICAgICBzY29wZSA9IF9PYmplY3Q7XG4gICAgfSBlbHNlIGlmICghc2NvcGUuJCRpc19jbGFzcyAmJiAhc2NvcGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIC8vIFNjb3BlIGlzIGFuIG9iamVjdCwgdXNlIGl0cyBjbGFzc1xuICAgICAgc2NvcGUgPSBzY29wZS4kJGNsYXNzO1xuICAgIH1cblxuICAgIG1vZHVsZSA9IGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKTtcblxuICAgIGlmIChtb2R1bGUgPT0gbnVsbCkge1xuICAgICAgLy8gTW9kdWxlIGRvZXNudCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZS4uLlxuICAgICAgbW9kdWxlID0gJGFsbG9jYXRlX21vZHVsZShuYW1lKTtcbiAgICAgICRjb25zdF9zZXQoc2NvcGUsIG5hbWUsIG1vZHVsZSk7XG4gICAgfVxuXG4gICAgaWYgKE9wYWwudHJhY2VfY2xhc3MpIHsgaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKG1vZHVsZSk7IH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIHRoZSBwYXNzZWQgb2JqZWN0LlxuICAvL1xuICAvLyBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGFscmVkeSBoYXMgYSBzaW5nbGV0b24gY2xhc3MsIHRoZW4gaXQgd2lsbCBiZSBzdG9yZWQgb25cbiAgLy8gdGhlIG9iamVjdCBhcyB0aGUgYCQkbWV0YWAgcHJvcGVydHkuIElmIHRoaXMgZXhpc3RzLCB0aGVuIGl0IGlzIHNpbXBseVxuICAvLyByZXR1cm5lZCBiYWNrLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IHNpbmdsZXRvbiBvYmplY3QgZm9yIHRoZSBjbGFzcyBvciBvYmplY3QgaXMgY3JlYXRlZCwgc2V0IG9uXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIHRoZSBydWJ5IG9iamVjdFxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XG4gIE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LiQkbWV0YTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX21vZHVsZScpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyIHRvIHNldCAkJG1ldGEgb24ga2xhc3MsIG1vZHVsZSBvciBpbnN0YW5jZVxuICBmdW5jdGlvbiBzZXRfbWV0YShvYmosIG1ldGEpIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xuICAgICAgb2JqLiQkbWV0YSA9IG1ldGE7XG4gICAgfSBlbHNlIHtcbiAgICAgICRwcm9wKG9iaiwgJyQkbWV0YScsIG1ldGEpO1xuICAgIH1cbiAgICBpZiAob2JqLiQkZnJvemVuKSB7XG4gICAgICAvLyBJZiBhIG9iamVjdCBpcyBmcm96ZW4gKHNlYWxlZCksIGZyZWV6ZSAkJG1ldGEgdG9vLlxuICAgICAgLy8gTm8gbmVlZCB0byBpbmplY3QgJCRtZXRhLiQkcHJvdG90eXBlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4sXG4gICAgICAvLyBhcyAkJG1ldGEgY2Fubm90IGJlIG1vZGlmaWVkIGFueXdheS5cbiAgICAgIG9iai4kJG1ldGEuJGZyZWV6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2V0X3Byb3RvKG9iaiwgbWV0YS4kJHByb3RvdHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEJ1aWxkIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIGFuIGV4aXN0aW5nIGNsYXNzLiBDbGFzcyBvYmplY3QgYXJlIGJ1aWx0XG4gIC8vIHdpdGggdGhlaXIgc2luZ2xldG9uIGNsYXNzIGFscmVhZHkgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgaW5oZXJpdGluZ1xuICAvLyBmcm9tIHRoZWlyIHN1cGVyY2xhc3Mgb2JqZWN0ICh1cCB0byBgQ2xhc3NgIGl0c2VsZikuXG4gIC8vXG4gIC8vIE5PVEU6IEFjdHVhbGx5IGluIE1SSSBhIGNsYXNzJyBzaW5nbGV0b24gY2xhc3MgaW5oZXJpdHMgZnJvbSBpdHNcbiAgLy8gc3VwZXJjbGFzcycgc2luZ2xldG9uIGNsYXNzIHdoaWNoIGluIHR1cm4gaW5oZXJpdHMgZnJvbSBDbGFzcy5cbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzIFtDbGFzc11cbiAgLy8gQHJldHVybiBbQ2xhc3NdXG4gIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24oa2xhc3MpIHtcbiAgICBpZiAoa2xhc3MuJCRtZXRhKSB7XG4gICAgICByZXR1cm4ga2xhc3MuJCRtZXRhO1xuICAgIH1cblxuICAgIC8vIFRoZSBzaW5nbGV0b25fY2xhc3Mgc3VwZXJjbGFzcyBpcyB0aGUgc2luZ2xldG9uX2NsYXNzIG9mIGl0cyBzdXBlcmNsYXNzO1xuICAgIC8vIGJ1dCBCYXNpY09iamVjdCBoYXMgbm8gc3VwZXJjbGFzcyAoaXRzIGAkJHN1cGVyYCBpcyBudWxsKSwgdGh1cyB3ZVxuICAgIC8vIGZhbGxiYWNrIG9uIGBDbGFzc2AuXG4gICAgdmFyIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcblxuICAgIHZhciBtZXRhID0gJGFsbG9jYXRlX2NsYXNzKG51bGwsIHN1cGVyY2xhc3MsIHRydWUpO1xuXG4gICAgJHByb3AobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJHByb3AobWV0YSwgJyQkc2luZ2xldG9uX29mJywga2xhc3MpO1xuICAgIHNldF9tZXRhKGtsYXNzLCBtZXRhKTtcbiAgICAvLyBSZXN0b3JpbmcgQ2xhc3NOYW1lLmNsYXNzXG4gICAgJHByb3Aoa2xhc3MsICckJGNsYXNzJywgT3BhbC5DbGFzcyk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfTtcblxuICBPcGFsLmJ1aWxkX21vZHVsZV9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihtb2QpIHtcbiAgICBpZiAobW9kLiQkbWV0YSkge1xuICAgICAgcmV0dXJuIG1vZC4kJG1ldGE7XG4gICAgfVxuXG4gICAgdmFyIG1ldGEgPSAkYWxsb2NhdGVfY2xhc3MobnVsbCwgT3BhbC5Nb2R1bGUsIHRydWUpO1xuXG4gICAgJHByb3AobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJHByb3AobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICBzZXRfbWV0YShtb2QsIG1ldGEpO1xuICAgIC8vIFJlc3RvcmluZyBNb2R1bGVOYW1lLmNsYXNzXG4gICAgJHByb3AobW9kLCAnJCRjbGFzcycsIE9wYWwuTW9kdWxlKTtcblxuICAgIHJldHVybiBtZXRhO1xuICB9O1xuXG4gIC8vIEJ1aWxkIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIGEgUnVieSAobm9uIGNsYXNzKSBPYmplY3QuXG4gIC8vXG4gIC8vIEBwYXJhbSBvYmplY3QgW09iamVjdF1cbiAgLy8gQHJldHVybiBbQ2xhc3NdXG4gIE9wYWwuYnVpbGRfb2JqZWN0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBzdXBlcmNsYXNzID0gb2JqZWN0LiQkY2xhc3MsXG4gICAgICAgIGtsYXNzID0gJGFsbG9jYXRlX2NsYXNzKG5pbCwgc3VwZXJjbGFzcywgdHJ1ZSk7XG5cbiAgICAkcHJvcChrbGFzcywgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgIHNldF9tZXRhKG9iamVjdCwga2xhc3MpO1xuXG4gICAgcmV0dXJuIGtsYXNzO1xuICB9O1xuXG4gIE9wYWwuaXNfbWV0aG9kID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiAocHJvcFswXSA9PT0gJyQnICYmIHByb3BbMV0gIT09ICckJyk7XG4gIH07XG5cbiAgT3BhbC5pbnN0YW5jZV9tZXRob2RzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgdmFyIGV4Y2x1ZGUgPSBbXSwgcmVzdWx0cyA9IFtdLCBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgICAgIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC4kJHN0dWIgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGUucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViICYmIHJlc3VsdHMuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMob2JqLiQkbWV0YSB8fCBvYmouJCRjbGFzcyk7XG4gIH07XG5cbiAgT3BhbC5vd25fbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmouJCRtZXRhID8gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhvYmouJCRtZXRhKSA6IFtdO1xuICB9O1xuXG4gIE9wYWwucmVjZWl2ZXJfbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBtb2QgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKTtcbiAgICB2YXIgc2luZ2xldG9uX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZCk7XG4gICAgdmFyIGluc3RhbmNlX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZC4kJHN1cGVyKTtcbiAgICByZXR1cm4gc2luZ2xldG9uX21ldGhvZHMuY29uY2F0KGluc3RhbmNlX21ldGhvZHMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHBhaXJzIG9mIG5hbWVzL3ZhbHVlc1xuICAvLyBmb3IgYWxsIGNsYXNzIHZhcmlhYmxlcyBkZWZpbmVkIGluIHByb3ZpZGVkICttb2R1bGUrXG4gIC8vIGFuZCBpdHMgYW5jZXN0b3JzLlxuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEByZXR1cm4gW09iamVjdF1cbiAgT3BhbC5jbGFzc192YXJpYWJsZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXTtcblxuICAgICAgaWYgKCRoYXNfb3duLmNhbGwoYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgYW5jZXN0b3IuJCRjdmFyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZXRzIGNsYXNzIHZhcmlhYmxlIHdpdGggc3BlY2lmaWVkICtuYW1lKyBmcm9tIHByb3ZpZGVkICttb2R1bGUrXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHBhcmFtIG5hbWUgW1N0cmluZ11cbiAgT3BhbC5jbGFzc192YXJpYWJsZV9nZXQgPSBmdW5jdGlvbihtb2R1bGUsIG5hbWUsIHRvbGVyYW50KSB7XG4gICAgaWYgKCRoYXNfb3duLmNhbGwobW9kdWxlLiQkY3ZhcnMsIG5hbWUpKVxuICAgICAgcmV0dXJuIG1vZHVsZS4kJGN2YXJzW25hbWVdO1xuXG4gICAgdmFyIGFuY2VzdG9ycyA9ICRhbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgIGksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXTtcblxuICAgICAgaWYgKCRoYXNfb3duLmNhbGwoYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0b2xlcmFudClcbiAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoJ3VuaW5pdGlhbGl6ZWQgY2xhc3MgdmFyaWFibGUgJytuYW1lKycgaW4gJyttb2R1bGUuJG5hbWUoKSk7XG5cbiAgICByZXR1cm4gbmlsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSb290KHByb3RvKSB7XG4gICAgcmV0dXJuIHByb3RvLmhhc093blByb3BlcnR5KCckJGljbGFzcycpICYmIHByb3RvLmhhc093blByb3BlcnR5KCckJHJvb3QnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bl9pbmNsdWRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgd2hpbGUgKHByb3RvKSB7XG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgICAvLyBzdXBlcmNsYXNzXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICBpZiAobW9kKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZCk7XG4gICAgICB9XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bl9wcmVwZW5kZWRfbW9kdWxlcyhtb2R1bGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIG1vZCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGlmIChtb2R1bGUuJCRwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgd2hpbGUgKHByb3RvKSB7XG4gICAgICAgIGlmIChwcm90byA9PT0gbW9kdWxlLiQkcHJvdG90eXBlLiQkZGVmaW5lX21ldGhvZHNfb24pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgICBpZiAobW9kKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cblxuICAvLyBUaGUgYWN0dWFsIGluY2x1c2lvbiBvZiBhIG1vZHVsZSBpbnRvIGEgY2xhc3MuXG4gIC8vXG4gIC8vICMjIENsYXNzIGAkJHBhcmVudGAgYW5kIGBpY2xhc3NgXG4gIC8vXG4gIC8vIFRvIGhhbmRsZSBgc3VwZXJgIGNhbGxzLCBldmVyeSBjbGFzcyBoYXMgYSBgJCRwYXJlbnRgLiBUaGlzIHBhcmVudCBpc1xuICAvLyB1c2VkIHRvIHJlc29sdmUgdGhlIG5leHQgY2xhc3MgZm9yIGEgc3VwZXIgY2FsbC4gQSBub3JtYWwgY2xhc3Mgd291bGRcbiAgLy8gaGF2ZSB0aGlzIHBvaW50IHRvIGl0cyBzdXBlcmNsYXNzLiBIb3dldmVyLCBpZiBhIGNsYXNzIGluY2x1ZGVzIGEgbW9kdWxlXG4gIC8vIHRoZW4gdGhpcyB3b3VsZCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSBtb2R1bGUuIFRoZSBtb2R1bGUgd291bGRcbiAgLy8gYWxzbyBoYXZlIHRvIHRoZW4gcG9pbnQgaXRzIGAkJHBhcmVudGAgdG8gdGhlIGFjdHVhbCBzdXBlcmNsYXNzLiBXZVxuICAvLyBjYW5ub3QgbW9kaWZ5IG1vZHVsZXMgbGlrZSB0aGlzLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGluY2x1ZGVkIGluIG1vcmVcbiAgLy8gdGhlbiBvbmUgY2xhc3MuIFRvIGZpeCB0aGlzLCB3ZSBhY3R1YWxseSBpbnNlcnQgYW4gYGljbGFzc2AgYXMgdGhlIGNsYXNzJ1xuICAvLyBgJCRwYXJlbnRgIHdoaWNoIGNhbiB0aGVuIHBvaW50IHRvIHRoZSBzdXBlcmNsYXNzLiBUaGUgYGljbGFzc2AgYWN0cyBhc1xuICAvLyBhIHByb3h5IHRvIHRoZSBhY3R1YWwgbW9kdWxlLCBzbyB0aGUgYHN1cGVyYCBjaGFpbiBjYW4gdGhlbiBzZWFyY2ggaXQgZm9yXG4gIC8vIHRoZSByZXF1aXJlZCBtZXRob2QuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV0gdGhlIG1vZHVsZSB0byBpbmNsdWRlXG4gIC8vIEBwYXJhbSBpbmNsdWRlciBbTW9kdWxlXSB0aGUgdGFyZ2V0IGNsYXNzIHRvIGluY2x1ZGUgbW9kdWxlIGludG9cbiAgLy8gQHJldHVybiBbbnVsbF1cbiAgT3BhbC5hcHBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIGluY2x1ZGVyKSB7XG4gICAgdmFyIG1vZHVsZV9hbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRwcm9wKGljbGFzcywgJyQkaW5jbHVkZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG4gICAgdmFyIGluY2x1ZGVyX2FuY2VzdG9ycyA9ICRhbmNlc3RvcnMoaW5jbHVkZXIpLFxuICAgICAgICBjaGFpbiA9IGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSxcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIsXG4gICAgICAgIGVuZF9jaGFpbl9vbjtcblxuICAgIGlmIChpbmNsdWRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xuICAgICAgLy8gZmlyc3QgdGltZSBpbmNsdWRlXG5cbiAgICAgIC8vIGluY2x1ZGVyIC0+IGNoYWluLmZpcnN0IC0+IC4uLmNoYWluLi4uIC0+IGNoYWluLmxhc3QgLT4gaW5jbHVkZXIucGFyZW50XG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGluY2x1ZGVyLiQkcHJvdG90eXBlO1xuICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluY2x1ZGVyLiQkcHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG1vZHVsZSBoYXMgYmVlbiBhbHJlYWR5IGluY2x1ZGVkLFxuICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwdXQgaXQgaW50byB0aGUgYW5jZXN0b3JzIGNoYWluIGFnYWluLFxuICAgICAgLy8gYnV0IHRoaXMgbW9kdWxlIG1heSBoYXZlIG5ldyBpbmNsdWRlZCBtb2R1bGVzLlxuICAgICAgLy8gSWYgaXQncyB0cnVlIHdlIG5lZWQgdG8gY29weSB0aGVtLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBzaW1wbGVzdCB3YXkgaXMgdG8gcmVwbGFjZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxuICAgICAgLy8gICAgICAgICAgcGFyZW50XG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5wcmV2aW9zIGNoYWluIG9mIG1vZHVsZS5pbmNsdWRlZF9tb2R1bGVzIC4uLlxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgXCJuZXh0IGFuY2VzdG9yXCIgKGhhcyBhICQkcm9vdCBmbGFnIG9yIGlzIGEgcmVhbCBjbGFzcylcbiAgICAgIC8vXG4gICAgICAvLyB0b1xuICAgICAgLy8gICAgICAgICAgcGFyZW50XG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgIGBtb2R1bGVgIGljbGFzcyAoaGFzIGEgJCRyb290IGZsYWcpXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgLi4ucmVnZW5lcmF0ZWQgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXNcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGludGVybWVkaWF0ZSBjbGFzc2VzIGJldHdlZW4gYHBhcmVudGAgYW5kIGBuZXh0IGFuY2VzdG9yYC5cbiAgICAgIC8vIEl0IGRvZXNuJ3QgYnJlYWsgYW55IHByb3RvdHlwZXMgb2Ygb3RoZXIgb2JqZWN0cyBhcyB3ZSBkb24ndCBjaGFuZ2UgY2xhc3MgcmVmZXJlbmNlcy5cblxuICAgICAgdmFyIHBhcmVudCA9IGluY2x1ZGVyLiQkcHJvdG90eXBlLCBtb2R1bGVfaWNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG5cbiAgICAgIHdoaWxlIChtb2R1bGVfaWNsYXNzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1vZHVsZV9pY2xhc3MuJCRtb2R1bGUgPT09IG1vZHVsZSAmJiBpc1Jvb3QobW9kdWxlX2ljbGFzcykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IG1vZHVsZV9pY2xhc3M7XG4gICAgICAgIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlX2ljbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2R1bGVfaWNsYXNzKSB7XG4gICAgICAgIC8vIG1vZHVsZSBoYXMgYmVlbiBkaXJlY3RseSBpbmNsdWRlZFxuICAgICAgICB2YXIgbmV4dF9hbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcblxuICAgICAgICAvLyBza2lwIG5vbi1yb290IGljbGFzc2VzICh0aGF0IHdlcmUgcmVjdXJzaXZlbHkgaW5jbHVkZWQpXG4gICAgICAgIHdoaWxlIChuZXh0X2FuY2VzdG9yLmhhc093blByb3BlcnR5KCckJGljbGFzcycpICYmICFpc1Jvb3QobmV4dF9hbmNlc3RvcikpIHtcbiAgICAgICAgICBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5leHRfYW5jZXN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IG5leHRfYW5jZXN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb2R1bGUgaGFzIG5vdCBiZWVuIGRpcmVjdGx5IGluY2x1ZGVkIGJ1dCB3YXMgaW4gYW5jZXN0b3IgY2hhaW4gYmVjYXVzZSBpdCB3YXMgaW5jbHVkZWQgYnkgYW5vdGhlciBtb2R1bGVcbiAgICAgICAgLy8gaW5jbHVkZSBpdCBkaXJlY3RseVxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGluY2x1ZGVyLiQkcHJvdG90eXBlO1xuICAgICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25faW5jbHVkZWRfbW9kdWxlcyBjYWNoZVxuICAgIGluY2x1ZGVyLiQkb3duX2luY2x1ZGVkX21vZHVsZXMgPSBvd25faW5jbHVkZWRfbW9kdWxlcyhpbmNsdWRlcik7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgfTtcblxuICBPcGFsLnByZXBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIHByZXBlbmRlcikge1xuICAgIC8vIEhlcmUgd2UgY2hhbmdlIHRoZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxuICAgIC8vXG4gICAgLy8gICBwcmVwZW5kZXJcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICAvL1xuICAgIC8vIHRvOlxuICAgIC8vXG4gICAgLy8gZHVtbXkocHJlcGVuZGVyKVxuICAgIC8vICAgICAgfFxuICAgIC8vICBpY2xhc3MobW9kdWxlKVxuICAgIC8vICAgICAgfFxuICAgIC8vIGljbGFzcyhwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gICAgcGFyZW50XG4gICAgdmFyIG1vZHVsZV9hbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKHByZXBlbmRlcikgIT09IC0xKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldygnY3ljbGljIHByZXBlbmQgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XG4gICAgICAkcHJvcChpY2xhc3MsICckJHByZXBlbmRlZCcsIHRydWUpO1xuICAgICAgaWNsYXNzZXMucHVzaChpY2xhc3MpO1xuICAgIH1cblxuICAgIHZhciBjaGFpbiA9IGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSxcbiAgICAgICAgZHVtbXlfcHJlcGVuZGVyID0gcHJlcGVuZGVyLiQkcHJvdG90eXBlLFxuICAgICAgICBwcmV2aW91c19wYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZHVtbXlfcHJlcGVuZGVyKSxcbiAgICAgICAgcHJlcGVuZGVyX2ljbGFzcyxcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIsXG4gICAgICAgIGVuZF9jaGFpbl9vbjtcblxuICAgIGlmIChkdW1teV9wcmVwZW5kZXIuaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgLy8gVGhlIG1vZHVsZSBhbHJlYWR5IGhhcyBzb21lIHByZXBlbmRlZCBtb2R1bGVzXG4gICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbWFrZSBpdCBcImR1bW15XCJcbiAgICAgIHByZXBlbmRlcl9pY2xhc3MgPSBkdW1teV9wcmVwZW5kZXIuJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFraW5nIHRoZSBtb2R1bGUgXCJkdW1teVwiXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gY3JlYXRlX2R1bW15X2ljbGFzcyhwcmVwZW5kZXIpO1xuICAgICAgZmx1c2hfbWV0aG9kc19pbihwcmVwZW5kZXIpO1xuICAgICAgJHByb3AoZHVtbXlfcHJlcGVuZGVyLCAnJCRkdW1teScsIHRydWUpO1xuICAgICAgJHByb3AoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xuXG4gICAgICAvLyBDb252ZXJ0aW5nXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAvLyB0b1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IGljbGFzcyhwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xuICAgICAgJHNldF9wcm90byhwcmVwZW5kZXJfaWNsYXNzLCBwcmV2aW91c19wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBwcmVwZW5kZXJfYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhwcmVwZW5kZXIpO1xuXG4gICAgaWYgKHByZXBlbmRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xuICAgICAgLy8gZmlyc3QgdGltZSBwcmVwZW5kXG5cbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gZHVtbXlfcHJlcGVuZGVyO1xuXG4gICAgICAvLyBuZXh0ICQkcm9vdCBvciBwcmVwZW5kZXJfaWNsYXNzIG9yIG5vbi0kJGljbGFzc1xuICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlcik7XG4gICAgICB3aGlsZSAoZW5kX2NoYWluX29uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRyb290JykgfHxcbiAgICAgICAgICBlbmRfY2hhaW5fb24gPT09IHByZXBlbmRlcl9pY2xhc3MgfHxcbiAgICAgICAgICAhZW5kX2NoYWluX29uLmhhc093blByb3BlcnR5KCckJGljbGFzcycpXG4gICAgICAgICkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVuZF9jaGFpbl9vbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJQcmVwZW5kaW5nIGEgbW9kdWxlIG11bHRpcGxlIHRpbWVzIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9wcmVwZW5kZWRfbW9kdWxlcyBjYWNoZVxuICAgIHByZXBlbmRlci4kJG93bl9wcmVwZW5kZWRfbW9kdWxlcyA9IG93bl9wcmVwZW5kZWRfbW9kdWxlcyhwcmVwZW5kZXIpO1xuXG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmx1c2hfbWV0aG9kc19pbihtb2R1bGUpIHtcbiAgICB2YXIgcHJvdG8gPSBtb2R1bGUuJCRwcm90b3R5cGUsXG4gICAgICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICBkZWxldGUgcHJvdG9bcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlX2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJGlzX21vZHVsZSkge1xuICAgICAgbW9kdWxlLiQkaWNsYXNzZXMucHVzaChpY2xhc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBpY2xhc3M7XG4gIH1cblxuICAvLyBEdW1teSBpY2xhc3MgZG9lc24ndCByZWNlaXZlIHVwZGF0ZXMgd2hlbiB0aGUgbW9kdWxlIGdldHMgYSBuZXcgbWV0aG9kLlxuICBmdW5jdGlvbiBjcmVhdGVfZHVtbXlfaWNsYXNzKG1vZHVsZSkge1xuICAgIHZhciBpY2xhc3MgPSB7fSxcbiAgICAgICAgcHJvdG8gPSBtb2R1bGUuJCRwcm90b3R5cGU7XG5cbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgJHByb3AoaWNsYXNzLCBwcm9wLCBwcm90b1twcm9wXSk7XG4gICAgfVxuXG4gICAgJHByb3AoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkcHJvcChpY2xhc3MsICckJG1vZHVsZScsIG1vZHVsZSk7XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpIHtcbiAgICB2YXIgbGVuZ3RoID0gaWNsYXNzZXMubGVuZ3RoLCBmaXJzdCA9IGljbGFzc2VzWzBdO1xuXG4gICAgJHByb3AoZmlyc3QsICckJHJvb3QnLCB0cnVlKTtcblxuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7IGZpcnN0OiBmaXJzdCwgbGFzdDogZmlyc3QgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXMgPSBmaXJzdDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaWNsYXNzZXNbaV07XG4gICAgICAkc2V0X3Byb3RvKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cblxuICAgIHJldHVybiB7IGZpcnN0OiBpY2xhc3Nlc1swXSwgbGFzdDogaWNsYXNzZXNbbGVuZ3RoIC0gMV0gfTtcbiAgfVxuXG4gIC8vIEZvciBwZXJmb3JtYW5jZSwgc29tZSBjb3JlIFJ1YnkgY2xhc3NlcyBhcmUgdG9sbC1mcmVlIGJyaWRnZWQgdG8gdGhlaXJcbiAgLy8gbmF0aXZlIEphdmFTY3JpcHQgY291bnRlcnBhcnRzIChlLmcuIGEgUnVieSBBcnJheSBpcyBhIEphdmFTY3JpcHQgQXJyYXkpLlxuICAvL1xuICAvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldHVwIGEgbmF0aXZlIGNvbnN0cnVjdG9yIChlLmcuIEFycmF5KSwgdG8gaGF2ZVxuICAvLyBpdHMgcHJvdG90eXBlIGFjdCBsaWtlIGEgbm9ybWFsIFJ1YnkgY2xhc3MuIEZpcnN0bHksIGEgbmV3IFJ1YnkgY2xhc3MgaXNcbiAgLy8gY3JlYXRlZCB1c2luZyB0aGUgbmF0aXZlIGNvbnN0cnVjdG9yIHNvIHRoYXQgaXRzIHByb3RvdHlwZSBpcyBzZXQgYXMgdGhlXG4gIC8vIHRhcmdldCBmb3IgdGhlIG5ldyBjbGFzcy4gTm90ZTogYWxsIGJyaWRnZWQgY2xhc3NlcyBhcmUgc2V0IHRvIGluaGVyaXRcbiAgLy8gZnJvbSBPYmplY3QuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgIE9wYWwuYnJpZGdlKHNlbGYsIEZ1bmN0aW9uKTtcbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzICAgICAgIFtDbGFzc10gdGhlIFJ1YnkgY2xhc3MgdG8gYnJpZGdlXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIG5hdGl2ZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIHRvIHVzZVxuICAvLyBAcmV0dXJuIFtDbGFzc10gcmV0dXJucyB0aGUgcGFzc2VkIFJ1YnkgY2xhc3NcbiAgLy9cbiAgT3BhbC5icmlkZ2UgPSBmdW5jdGlvbihuYXRpdmVfa2xhc3MsIGtsYXNzKSB7XG4gICAgaWYgKG5hdGl2ZV9rbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRicmlkZ2UnKSkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJhbHJlYWR5IGJyaWRnZWRcIik7XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0b3IgaXMgYSBKUyBmdW5jdGlvbiB3aXRoIGEgcHJvdG90eXBlIGNoYWluIGxpa2U6XG4gICAgLy8gLSBjb25zdHJ1Y3RvclxuICAgIC8vICAgLSBzdXBlclxuICAgIC8vXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGluamVjdCBvdXIgY2xhc3MgKHdpdGggaXRzIHByb3RvdHlwZSBjaGFpbilcbiAgICAvLyBiZXR3ZWVuIGNvbnN0cnVjdG9yIGFuZCBzdXBlci4gRm9yIGV4YW1wbGUsIGFmdGVyIGluamVjdGluZyA6Ok9iamVjdFxuICAgIC8vIGludG8gSlMgU3RyaW5nIHdlIGdldDpcbiAgICAvL1xuICAgIC8vIC0gY29uc3RydWN0b3IgKHdpbmRvdy5TdHJpbmcpXG4gICAgLy8gICAtIE9wYWwuT2JqZWN0XG4gICAgLy8gICAgIC0gT3BhbC5LZXJuZWxcbiAgICAvLyAgICAgICAtIE9wYWwuQmFzaWNPYmplY3RcbiAgICAvLyAgICAgICAgIC0gc3VwZXIgKHdpbmRvdy5PYmplY3QpXG4gICAgLy8gICAgICAgICAgIC0gbnVsbFxuICAgIC8vXG4gICAgJHByb3AobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRwcm90b3R5cGUnLCBuYXRpdmVfa2xhc3MucHJvdG90eXBlKTtcblxuICAgICRwcm9wKGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRicmlkZ2UnLCB0cnVlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwcm90b1RvTW9kdWxlKHByb3RvKSB7XG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGljbGFzcycpKSB7XG4gICAgICByZXR1cm4gcHJvdG8uJCRtb2R1bGU7XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICByZXR1cm4gcHJvdG8uJCRjbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvd25fYW5jZXN0b3JzKG1vZHVsZSkge1xuICAgIHJldHVybiBtb2R1bGUuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMuY29uY2F0KFttb2R1bGVdKS5jb25jYXQobW9kdWxlLiQkb3duX2luY2x1ZGVkX21vZHVsZXMpO1xuICB9XG5cbiAgLy8gVGhlIEFycmF5IG9mIGFuY2VzdG9ycyBmb3IgYSBnaXZlbiBtb2R1bGUvY2xhc3NcbiAgZnVuY3Rpb24gJGFuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgeyByZXR1cm4gW107IH1cblxuICAgIGlmIChtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9PT0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLiQkYW5jZXN0b3JzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbW9kcywgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbW9kcyA9IG93bl9hbmNlc3RvcnMobW9kdWxlKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2gobW9kc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG1vZHVsZS4kJHN1cGVyKSB7XG4gICAgICBmb3IgKGkgPSAwLCBtb2RzID0gJGFuY2VzdG9ycyhtb2R1bGUuJCRzdXBlciksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb247XG4gICAgbW9kdWxlLiQkYW5jZXN0b3JzID0gcmVzdWx0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgT3BhbC5hbmNlc3RvcnMgPSAkYW5jZXN0b3JzO1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhcImZvbyxiYXIsYmF6PVwiKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuICAgIHZhciBzdHViLCBleGlzdGluZ19tZXRob2Q7XG4gICAgc3R1YnMgPSBzdHVicy5zcGxpdCgnLCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHViID0gJyQnK3N0dWJzW2ldLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICAvLyBPcGFsLnN0dWJfZm9yKHN0dWIpIGlzIHRoZSBtZXRob2RfbWlzc2luZ19zdHViXG4gICAgJHByb3AocHJvdG90eXBlLCBzdHViLCBPcGFsLnN0dWJfZm9yKHN0dWIpKTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSB0aGUgbWV0aG9kX21pc3Npbmcgc3R1YiBmb3IgYSBnaXZlbiBtZXRob2QgbmFtZS5cbiAgLy9cbiAgLy8gQHBhcmFtIG1ldGhvZF9uYW1lIFtTdHJpbmddIFRoZSBqcy1uYW1lIG9mIHRoZSBtZXRob2QgdG8gc3R1YiAoZS5nLiBcIiRmb29cIilcbiAgLy8gQHJldHVybiBbdW5kZWZpbmVkXVxuICBPcGFsLnN0dWJfZm9yID0gZnVuY3Rpb24obWV0aG9kX25hbWUpIHtcblxuICAgIGZ1bmN0aW9uIG1ldGhvZF9taXNzaW5nX3N0dWIoKSB7XG4gICAgICAvLyBDb3B5IGFueSBnaXZlbiBibG9jayBvbnRvIHRoZSBtZXRob2RfbWlzc2luZyBkaXNwYXRjaGVyXG4gICAgICB0aGlzLiRtZXRob2RfbWlzc2luZy4kJHAgPSBtZXRob2RfbWlzc2luZ19zdHViLiQkcDtcblxuICAgICAgLy8gU2V0IGJsb2NrIHByb3BlcnR5IHRvIG51bGwgcmVhZHkgZm9yIHRoZSBuZXh0IGNhbGwgKHN0b3AgZmFsc2UtcG9zaXRpdmVzKVxuICAgICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHAgPSBudWxsO1xuXG4gICAgICAvLyBjYWxsIG1ldGhvZCBtaXNzaW5nIHdpdGggY29ycmVjdCBhcmdzIChyZW1vdmUgJyQnIHByZWZpeCBvbiBtZXRob2QgbmFtZSlcbiAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgICAgcmV0dXJuIHRoaXMuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHRoaXMsIFttZXRob2RfbmFtZS5zbGljZSgxKV0uY29uY2F0KGFyZ3NfYXJ5KSk7XG4gICAgfVxuXG4gICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHN0dWIgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG1ldGhvZF9taXNzaW5nX3N0dWI7XG4gIH07XG5cblxuICAvLyBNZXRob2RzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBtZXRob2RzXG4gIC8vXG4gIC8vIEBwYXJhbSBhY3R1YWwgW0ZpeG51bV0gbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSBvd25lciBvZiB0aGUgbWV0aG9kICttZXRoK1xuICAvLyBAcGFyYW0gbWV0aCBbU3RyaW5nXSBtZXRob2QgbmFtZSB0aGF0IGdvdCB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cbiAgT3BhbC5hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG9iamVjdCwgbWV0aCkge1xuICAgIHZhciBpbnNwZWN0ID0gJyc7XG4gICAgaWYgKG9iamVjdC4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJG5hbWUgKyAnLic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaW5zcGVjdCArPSBvYmplY3QuJCRjbGFzcy4kJG5hbWUgKyAnIyc7XG4gICAgfVxuICAgIGluc3BlY3QgKz0gbWV0aDtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdbJyArIGluc3BlY3QgKyAnXSB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAnICsgYWN0dWFsICsgJywgZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBibG9ja3NcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIGJsb2NrXG4gIC8vIEBwYXJhbSBleHBlY3RlZCBbRml4bnVtXSBleHBlY3RlZCBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEBwYXJhbSBjb250ZXh0IFtPYmplY3RdIGNvbnRleHQgb2YgdGhlIGJsb2NrIGRlZmluaXRpb25cbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmJsb2NrX2FjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgY29udGV4dCkge1xuICAgIHZhciBpbnNwZWN0ID0gXCJgYmxvY2sgaW4gXCIgKyBjb250ZXh0ICsgXCInXCI7XG5cbiAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhpbnNwZWN0ICsgJzogd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gJyArIGFjdHVhbCArICcsIGV4cGVjdGVkICcgKyBleHBlY3RlZCArICcpJyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0X2FuY2VzdG9ycyhvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCckJG1ldGEnKSAmJiBvYmouJCRtZXRhICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJGFuY2VzdG9ycyhvYmouJCRtZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICRhbmNlc3RvcnMob2JqLiQkY2xhc3MpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTdXBlciBkaXNwYXRjaGVyXG4gIE9wYWwuZmluZF9zdXBlciA9IGZ1bmN0aW9uKG9iaiwgbWlkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBhbGxvd19zdHVicykge1xuICAgIHZhciBqc2lkID0gJyQnICsgbWlkLCBhbmNlc3RvcnMsIHN1cGVyX21ldGhvZDtcblxuICAgIGFuY2VzdG9ycyA9IGdldF9hbmNlc3RvcnMob2JqKTtcblxuICAgIHZhciBjdXJyZW50X2luZGV4ID0gYW5jZXN0b3JzLmluZGV4T2YoY3VycmVudF9mdW5jLiQkb3duZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV0sXG4gICAgICAgICAgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcblxuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoanNpZCkpIHtcbiAgICAgICAgc3VwZXJfbWV0aG9kID0gcHJvdG9banNpZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGVmY2hlY2sgJiYgc3VwZXJfbWV0aG9kICYmIHN1cGVyX21ldGhvZC4kJHN0dWIgJiYgb2JqLiRtZXRob2RfbWlzc2luZy4kJHByaXN0aW5lKSB7XG4gICAgICAvLyBtZXRob2RfbWlzc2luZyBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgIHRocm93IE9wYWwuTm9NZXRob2RFcnJvci4kbmV3KCdzdXBlcjogbm8gc3VwZXJjbGFzcyBtZXRob2QgYCcrbWlkK1wiJyBmb3IgXCIrb2JqLCBtaWQpO1xuICAgIH1cblxuICAgIHJldHVybiAoc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiAhYWxsb3dfc3R1YnMpID8gbnVsbCA6IHN1cGVyX21ldGhvZDtcbiAgfTtcblxuICAvLyBJdGVyIGRpc3BhdGNoZXIgZm9yIHN1cGVyIGluIGEgYmxvY2tcbiAgT3BhbC5maW5kX2Jsb2NrX3N1cGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFxuICAgICAgICBcImltcGxpY2l0IGFyZ3VtZW50IHBhc3Npbmcgb2Ygc3VwZXIgZnJvbSBtZXRob2QgZGVmaW5lZCBieSBkZWZpbmVfbWV0aG9kKCkgaXMgbm90IHN1cHBvcnRlZC4gXCIgK1xuICAgICAgICBcIlNwZWNpZnkgYWxsIGFyZ3VtZW50cyBleHBsaWNpdGx5XCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRfZnVuYy4kJGRlZikge1xuICAgICAgY2FsbF9qc2lkID0gY3VycmVudF9mdW5jLiQkanNpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5maW5kX3N1cGVyKG9iaiwgY2FsbF9qc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrKTtcbiAgfTtcblxuICAvLyBAZGVwcmVjYXRlZFxuICBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlciA9IE9wYWwuZmluZF9zdXBlcjtcblxuICAvLyBAZGVwcmVjYXRlZFxuICBPcGFsLmZpbmRfaXRlcl9zdXBlcl9kaXNwYXRjaGVyID0gT3BhbC5maW5kX2Jsb2NrX3N1cGVyO1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzO1xuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgIGFyZyA9IE9wYWwudG9fYXJ5KGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKChibG9jay5sZW5ndGggPiAxIHx8IChoYXNfdHJhaWxpbmdfY29tbWEgJiYgYmxvY2subGVuZ3RoID09PSAxKSkgJiYgYXJnLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGZvciA+IDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZFggPSBmdW5jdGlvbihibG9jaywgYXJncykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzX2FyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXG4gIC8vIGJlIGEgdmFsdWUsIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gIE9wYWwucmVzY3VlID0gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYW5kaWRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPcGFsLnJlc2N1ZShleGNlcHRpb24sIGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZSA9PT0gT3BhbC5KUy5FcnJvciB8fCBjYW5kaWRhdGVbJyQ9PT0nXShleGNlcHRpb24pKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgT3BhbC5pc19hID0gZnVuY3Rpb24ob2JqZWN0LCBrbGFzcykge1xuICAgIGlmIChrbGFzcyAhPSBudWxsICYmIG9iamVjdC4kJG1ldGEgPT09IGtsYXNzIHx8IG9iamVjdC4kJGNsYXNzID09PSBrbGFzcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdC4kJGlzX251bWJlciAmJiBrbGFzcy4kJGlzX251bWJlcl9jbGFzcykge1xuICAgICAgcmV0dXJuIChrbGFzcy4kJGlzX2ludGVnZXJfY2xhc3MpID8gKG9iamVjdCAlIDEpID09PSAwIDogdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhvYmplY3QuJCRpc19jbGFzcyA/IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpIDogKG9iamVjdC4kJG1ldGEgfHwgb2JqZWN0LiQkY2xhc3MpKTtcblxuICAgIHJldHVybiBhbmNlc3RvcnMuaW5kZXhPZihrbGFzcykgIT09IC0xO1xuICB9O1xuXG4gIC8vIEhlbHBlcnMgZm9yIGV4dHJhY3Rpbmcga3dzcGxhdHNcbiAgLy8gVXNlZCBmb3I6IHsgKipoIH1cbiAgT3BhbC50b19oYXNoID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19oYXNoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9faGFzaCcsIHRydWUpKSB7XG4gICAgICB2YXIgaGFzaCA9IHZhbHVlLiR0b19oYXNoKCk7XG4gICAgICBpZiAoaGFzaC4kJGlzX2hhc2gpIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIkNhbid0IGNvbnZlcnQgXCIgKyB2YWx1ZS4kJGNsYXNzICtcbiAgICAgICAgICBcIiB0byBIYXNoIChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19oYXNoIGdpdmVzIFwiICsgaGFzaC4kJGNsYXNzICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIFwiICsgdmFsdWUuJCRjbGFzcyArIFwiIGludG8gSGFzaFwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGVscGVycyBmb3IgaW1wbGVtZW50aW5nIG11bHRpcGxlIGFzc2lnbm1lbnRcbiAgLy8gT3VyIGNvZGUgZm9yIGV4dHJhY3RpbmcgdGhlIHZhbHVlcyBhbmQgYXNzaWduaW5nIHRoZW0gb25seSB3b3JrcyBpZiB0aGVcbiAgLy8gcmV0dXJuIHZhbHVlIGlzIGEgSlMgYXJyYXkuXG4gIC8vIFNvIGlmIHdlIGdldCBhbiBBcnJheSBzdWJjbGFzcywgZXh0cmFjdCB0aGUgd3JhcHBlZCBKUyBhcnJheSBmcm9tIGl0XG5cbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSBzb21ldGhpbmcgKG5vIHNwbGF0KVxuICBPcGFsLnRvX2FyeSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19hcnknLCB0cnVlKSkge1xuICAgICAgdmFyIGFyeSA9IHZhbHVlLiR0b19hcnkoKTtcbiAgICAgIGlmIChhcnkgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIkNhbid0IGNvbnZlcnQgXCIgKyB2YWx1ZS4kJGNsYXNzICtcbiAgICAgICAgICBcIiB0byBBcnJheSAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9fYXJ5IGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgZm9yOiBhLCBiID0gKnNvbWV0aGluZyAod2l0aCBzcGxhdClcbiAgT3BhbC50b19hID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgLy8gQSBzcGxhdHRlZCBhcnJheSBtdXN0IGJlIGNvcGllZFxuICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9fYScsIHRydWUpKSB7XG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2EoKTtcbiAgICAgIGlmIChhcnkgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIkNhbid0IGNvbnZlcnQgXCIgKyB2YWx1ZS4kJGNsYXNzICtcbiAgICAgICAgICBcIiB0byBBcnJheSAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9fYSBnaXZlcyBcIiArIGFyeS4kJGNsYXNzICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIGZvciBleHRyYWN0aW5nIGtleXdvcmQgYXJndW1lbnRzIGZyb20gYXJndW1lbnRzIHBhc3NlZCB0b1xuICAvLyBKUyBmdW5jdGlvbi4gSWYgcHJvdmlkZWQgK2FyZ3VtZW50cysgbGlzdCBkb2Vzbid0IGhhdmUgYSBIYXNoXG4gIC8vIGFzIGEgbGFzdCBpdGVtLCByZXR1cm5zIGEgYmxhbmsgSGFzaC5cbiAgLy9cbiAgLy8gQHBhcmFtIHBhcmFtZXRlcnMgW0FycmF5XVxuICAvLyBAcmV0dXJuIFtIYXNoXVxuICAvL1xuICBPcGFsLmV4dHJhY3Rfa3dhcmdzID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICAgIHZhciBrd2FyZ3MgPSBwYXJhbWV0ZXJzW3BhcmFtZXRlcnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGt3YXJncyAhPSBudWxsICYmIE9wYWwucmVzcG9uZF90byhrd2FyZ3MsICckdG9faGFzaCcsIHRydWUpKSB7XG4gICAgICAkc3BsaWNlLmNhbGwocGFyYW1ldGVycywgcGFyYW1ldGVycy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiBrd2FyZ3M7XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgdG8gZ2V0IGEgbGlzdCBvZiByZXN0IGtleXdvcmQgYXJndW1lbnRzLiBNZXRob2QgdGFrZXMgdGhlIGdpdmVuXG4gIC8vIGtleXdvcmQgYXJncywgaS5lLiB0aGUgaGFzaCBsaXRlcmFsIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNvbnRhaW5pbmcgYWxsXG4gIC8vIGtleXdvcmQgYXJndWVtbnRzIHBhc3NlZCB0byBtZXRob2QsIGFzIHdlbGwgYXMgdGhlIHVzZWQgYXJncyB3aGljaCBhcmVcbiAgLy8gdGhlIG5hbWVzIG9mIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgZGVmaW5lZC4gVGhpcyBtZXRob2QgdGhlblxuICAvLyBqdXN0IHJldHVybnMgYWxsIGtleS92YWx1ZSBwYWlycyB3aGljaCBoYXZlIG5vdCBiZWVuIHVzZWQsIGluIGEgbmV3XG4gIC8vIGhhc2ggbGl0ZXJhbC5cbiAgLy9cbiAgLy8gQHBhcmFtIGdpdmVuX2FyZ3MgW0hhc2hdIGFsbCBrd2FyZ3MgZ2l2ZW4gdG8gbWV0aG9kXG4gIC8vIEBwYXJhbSB1c2VkX2FyZ3MgW09iamVjdDxTdHJpbmc6IHRydWU+XSBhbGwga2V5cyB1c2VkIGFzIG5hbWVkIGt3YXJnc1xuICAvLyBAcmV0dXJuIFtIYXNoXVxuICAvL1xuICBPcGFsLmt3cmVzdGFyZ3MgPSBmdW5jdGlvbihnaXZlbl9hcmdzLCB1c2VkX2FyZ3MpIHtcbiAgICB2YXIga2V5cyAgICAgID0gW10sXG4gICAgICAgIG1hcCAgICAgICA9IHt9LFxuICAgICAgICBrZXkgICAgICAgICAgICxcbiAgICAgICAgZ2l2ZW5fbWFwID0gZ2l2ZW5fYXJncy4kJHNtYXA7XG5cbiAgICBmb3IgKGtleSBpbiBnaXZlbl9tYXApIHtcbiAgICAgIGlmICghdXNlZF9hcmdzW2tleV0pIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIG1hcFtrZXldID0gZ2l2ZW5fbWFwW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuaGFzaDIoa2V5cywgbWFwKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseV9ibG9ja29wdHMoYmxvY2ssIGJsb2Nrb3B0cykge1xuICAgIGlmICh0eXBlb2YoYmxvY2tvcHRzKSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJsb2NrLiQkYXJpdHkgPSBibG9ja29wdHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihibG9ja29wdHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmFzc2lnbihibG9jaywgYmxvY2tvcHRzKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxscyBwYXNzZWQgbWV0aG9kIG9uIGEgcnVieSBvYmplY3Qgd2l0aCBhcmd1bWVudHMgYW5kIGJsb2NrOlxuICAvL1xuICAvLyBDYW4gdGFrZSBhIG1ldGhvZCBvciBhIG1ldGhvZCBuYW1lLlxuICAvL1xuICAvLyAxLiBXaGVuIG1ldGhvZCBuYW1lIGdldHMgcGFzc2VkIGl0IGludm9rZXMgaXQgYnkgaXRzIG5hbWVcbiAgLy8gICAgYW5kIGNhbGxzICdtZXRob2RfbWlzc2luZycgd2hlbiBvYmplY3QgZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgbWV0aG9kIHRoYXQgdGFrZXMgYSBibG9jayBvciBhIHNwbGF0LlxuICAvLyAyLiBXaGVuIG1ldGhvZCAoaS5lLiBtZXRob2QgYm9keSkgZ2V0cyBwYXNzZWQsIGl0IGRvZXNuJ3QgdHJpZ2dlciAnbWV0aG9kX21pc3NpbmcnXG4gIC8vICAgIGJlY2F1c2UgaXQgZG9lc24ndCBrbm93IHRoZSBuYW1lIG9mIHRoZSBhY3R1YWwgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgJ3N1cGVyJy5cbiAgLy9cbiAgLy8gQGV4YW1wbGVcbiAgLy8gICB2YXIgbXlfYXJyYXkgPSBbMSwgMiwgMywgNF1cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksICdsZW5ndGgnKSAgICAgICAgICAgICAgICAgICAgIyA9PiA0XG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheS4kbGVuZ3RoKSAgICAgICAgICAgICMgPT4gNFxuICAvL1xuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ3JldmVyc2UhJykgICAgICAgICAgICAgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgbXlfYXJyYXlbJyRyZXZlcnNlISddJykgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvL1xuICAvLyBAcGFyYW0gcmVjdiBbT2JqZWN0XSBydWJ5IG9iamVjdFxuICAvLyBAcGFyYW0gbWV0aG9kIFtGdW5jdGlvbiwgU3RyaW5nXSBtZXRob2QgYm9keSBvciBuYW1lIG9mIHRoZSBtZXRob2RcbiAgLy8gQHBhcmFtIGFyZ3MgW0FycmF5XSBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGxcbiAgLy8gQHBhcmFtIGJsb2NrIFtGdW5jdGlvbl0gcnVieSBibG9ja1xuICAvLyBAcGFyYW0gYmxvY2tvcHRzIFtPYmplY3QsIE51bWJlcl0gb3B0aW9uYWwgcHJvcGVydGllcyB0byBzZXQgb24gdGhlIGJsb2NrXG4gIC8vIEByZXR1cm4gW09iamVjdF0gcmV0dXJuaW5nIHZhbHVlIG9mIHRoZSBtZXRob2QgY2FsbFxuICBPcGFsLnNlbmQgPSBmdW5jdGlvbihyZWN2LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICB2YXIgYm9keTtcblxuICAgIGlmICh0eXBlb2YobWV0aG9kKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm9keSA9IG1ldGhvZDtcbiAgICAgIG1ldGhvZCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YobWV0aG9kKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJvZHkgPSByZWN2WyckJyttZXRob2RdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwiUGFzc2VkIG1ldGhvZCBzaG91bGQgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5zZW5kMihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpO1xuICB9O1xuXG4gIE9wYWwuc2VuZDIgPSBmdW5jdGlvbihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBpZiAoYm9keSA9PSBudWxsICYmIG1ldGhvZCAhPSBudWxsICYmIHJlY3YuJG1ldGhvZF9taXNzaW5nKSB7XG4gICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICBhcmdzID0gW21ldGhvZF0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKTtcblxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gIH07XG5cbiAgT3BhbC5yZWZpbmVkX3NlbmQgPSBmdW5jdGlvbihyZWZpbmVtZW50X2dyb3VwcywgcmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKSB7XG4gICAgdmFyIGksIGosIGssIGFuY2VzdG9ycywgYW5jZXN0b3IsIHJlZmluZW1lbnRzLCByZWZpbmVtZW50LCByZWZpbmVfbW9kdWxlcywgcmVmaW5lX21vZHVsZSwgYm9keTtcblxuICAgIGFuY2VzdG9ycyA9IGdldF9hbmNlc3RvcnMocmVjdik7XG5cbiAgICAvLyBGb3IgYWxsIGFuY2VzdG9ycyB0aGF0IHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgY2xvc2VzdCB0byB0aGUgZnVydGhlc3QuLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmNlc3RvciA9IE9wYWwuaWQoYW5jZXN0b3JzW2ldKTtcblxuICAgICAgLy8gRm9yIGFsbCByZWZpbmVtZW50IGdyb3VwcyB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3Qgc2NvcGUgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVmaW5lbWVudF9ncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVmaW5lbWVudHMgPSByZWZpbmVtZW50X2dyb3Vwc1tqXTtcblxuICAgICAgICAvLyBGb3IgYWxsIHJlZmluZW1lbnRzIHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBgdXNpbmdgIGNhbGwgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICAgIGZvciAoayA9IHJlZmluZW1lbnRzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgcmVmaW5lbWVudCA9IHJlZmluZW1lbnRzW2tdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzID09PSAndW5kZWZpbmVkJykgY29udGludWU7XG5cbiAgICAgICAgICAvLyBBIHNpbmdsZSBtb2R1bGUgYmVpbmcgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgb2YgdGhlIGB1c2luZ2AgY2FsbCBjb250YWlucyBtdWx0aXBsZVxuICAgICAgICAgIC8vIHJlZmluZW1lbnQgbW9kdWxlc1xuICAgICAgICAgIHJlZmluZV9tb2R1bGVzID0gcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzO1xuXG4gICAgICAgICAgLy8gRG9lcyB0aGlzIG1vZHVsZSByZWZpbmUgYSBnaXZlbiBjYWxsIGZvciBhIGdpdmVuIGFuY2VzdG9yIG1vZHVsZT9cbiAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZV9tb2R1bGVzW2FuY2VzdG9yXSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuICAgICAgICAgIHJlZmluZV9tb2R1bGUgPSByZWZpbmVfbW9kdWxlc1thbmNlc3Rvcl07XG5cbiAgICAgICAgICAvLyBEb2VzIHRoaXMgbW9kdWxlIGRlZmluZSBhIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGw/XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVfbW9kdWxlLiQkcHJvdG90eXBlWyckJyttZXRob2RdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYm9keSA9IHJlZmluZV9tb2R1bGUuJCRwcm90b3R5cGVbJyQnK21ldGhvZF07XG4gICAgICAgICAgICByZXR1cm4gT3BhbC5zZW5kMihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQocmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKTtcbiAgfTtcblxuICBPcGFsLmxhbWJkYSA9IGZ1bmN0aW9uKGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBibG9jay4kJGlzX2xhbWJkYSA9IHRydWU7XG5cbiAgICBhcHBseV9ibG9ja29wdHMoYmxvY2ssIGJsb2Nrb3B0cyk7XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEBwYXJhbSBibG9ja29wdHMgW09iamVjdCwgTnVtYmVyXSBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgYm9keVxuICAvLyBAcmV0dXJuIFtudWxsXVxuICAvL1xuICBPcGFsLmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSwgYmxvY2tvcHRzKSB7XG4gICAgYXBwbHlfYmxvY2tvcHRzKGJvZHksIGJsb2Nrb3B0cyk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgbWV0aG9kIGRlZmluaXRpb24gaW4gdGhlXG4gICAgLy8gdG9wLWxldmVsIG5hbWVzcGFjZVxuICAgIGlmIChvYmogPT09IE9wYWwudG9wKSB7XG4gICAgICByZXR1cm4gT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgLy8gaWYgaW5zdGFuY2VfZXZhbCBpcyBpbnZva2VkIG9uIGEgbW9kdWxlL2NsYXNzLCBpdCBzZXRzIGluc3RfZXZhbF9tb2RcbiAgICBlbHNlIGlmICghb2JqLiQkZXZhbCAmJiBvYmouJCRpc19hX21vZHVsZSkge1xuICAgICAgcmV0dXJuIE9wYWwuZGVmbihvYmosIGpzaWQsIGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgJGRlbnlfZnJvemVuX2FjY2Vzcyhtb2R1bGUpO1xuXG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIG5hbWUgPSBqc2lkLnN1YnN0cigxKTtcblxuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cbiAgICAkcHJvcChwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRwcm9wKGljbGFzcywganNpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpbmdsZXRvbl9vZiA9IG1vZHVsZS4kJHNpbmdsZXRvbl9vZjtcbiAgICBpZiAobW9kdWxlLiRtZXRob2RfYWRkZWQgJiYgIW1vZHVsZS4kbWV0aG9kX2FkZGVkLiQkc3R1YiAmJiAhc2luZ2xldG9uX29mKSB7XG4gICAgICBtb2R1bGUuJG1ldGhvZF9hZGRlZChuYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2luZ2xldG9uX29mICYmIHNpbmdsZXRvbl9vZi4kc2luZ2xldG9uX21ldGhvZF9hZGRlZCAmJiAhc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkLiQkc3R1Yikge1xuICAgICAgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkKG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIC8vIERlZmluZSBhIHNpbmdsZXRvbiBtZXRob2Qgb24gdGhlIGdpdmVuIG9iamVjdCAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZzID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5LCBibG9ja29wdHMpIHtcbiAgICBhcHBseV9ibG9ja29wdHMoYm9keSwgYmxvY2tvcHRzKTtcblxuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE9wYWwuZGVmbihPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwganNpZCwgYm9keSk7XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3JlbW92ZV9tZXRob2QuXG4gIE9wYWwucmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCkge1xuICAgIGlmICghJGhhc19vd24uY2FsbChvYmouJCRwcm90b3R5cGUsIGpzaWQpKSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwibWV0aG9kICdcIiArIGpzaWQuc3Vic3RyKDEpICsgXCInIG5vdCBkZWZpbmVkIGluIFwiICsgb2JqLiRuYW1lKCkpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBvYmouJCRwcm90b3R5cGVbanNpZF07XG5cbiAgICBpZiAob2JqLiQkaXNfc2luZ2xldG9uKSB7XG4gICAgICBpZiAob2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZChqc2lkLnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKG9iai4kbWV0aG9kX3JlbW92ZWQgJiYgIW9iai4kbWV0aG9kX3JlbW92ZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBDYWxsZWQgZnJvbSAjdW5kZWZfbWV0aG9kLlxuICBPcGFsLnVkZWYgPSBmdW5jdGlvbihvYmosIGpzaWQpIHtcbiAgICBpZiAoIW9iai4kJHByb3RvdHlwZVtqc2lkXSB8fCBvYmouJCRwcm90b3R5cGVbanNpZF0uJCRzdHViKSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwibWV0aG9kICdcIiArIGpzaWQuc3Vic3RyKDEpICsgXCInIG5vdCBkZWZpbmVkIGluIFwiICsgb2JqLiRuYW1lKCkpO1xuICAgIH1cblxuICAgIE9wYWwuYWRkX3N0dWJfZm9yKG9iai4kJHByb3RvdHlwZSwganNpZCk7XG5cbiAgICBpZiAob2JqLiQkaXNfc2luZ2xldG9uKSB7XG4gICAgICBpZiAob2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCAmJiAhb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZChqc2lkLnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKG9iai4kbWV0aG9kX3VuZGVmaW5lZCAmJiAhb2JqLiRtZXRob2RfdW5kZWZpbmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc19tZXRob2RfYm9keShib2R5KSB7XG4gICAgcmV0dXJuICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpO1xuICB9XG5cbiAgT3BhbC5hbGlhcyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2xkKSB7XG4gICAgdmFyIGlkICAgICA9ICckJyArIG5hbWUsXG4gICAgICAgIG9sZF9pZCA9ICckJyArIG9sZCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgYWxpYXM7XG5cbiAgICAvLyBBbGlhc2luZyBvbiBtYWluIG1lYW5zIGFsaWFzaW5nIG9uIE9iamVjdC4uLlxuICAgIGlmICh0eXBlb2Ygb2JqLiQkcHJvdG90eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2JqID0gT3BhbC5PYmplY3Q7XG4gICAgfVxuXG4gICAgYm9keSA9IG9iai4kJHByb3RvdHlwZVsnJCcgKyBvbGRdO1xuXG4gICAgLy8gV2hlbiBydW5uaW5nIGluc2lkZSAjaW5zdGFuY2VfZXZhbCB0aGUgYWxpYXMgcmVmZXJzIHRvIGNsYXNzIG1ldGhvZHMuXG4gICAgaWYgKG9iai4kJGV2YWwpIHtcbiAgICAgIHJldHVybiBPcGFsLmFsaWFzKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBuYW1lLCBvbGQpO1xuICAgIH1cblxuICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkpIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IG9iai4kJHN1cGVyO1xuXG4gICAgICB3aGlsZSAodHlwZW9mKGJvZHkpICE9PSBcImZ1bmN0aW9uXCIgJiYgYW5jZXN0b3IpIHtcbiAgICAgICAgYm9keSAgICAgPSBhbmNlc3RvcltvbGRfaWRdO1xuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLiQkc3VwZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkgJiYgb2JqLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgIC8vIHRyeSB0byBsb29rIGludG8gT2JqZWN0XG4gICAgICAgIGJvZHkgPSBPcGFsLk9iamVjdC4kJHByb3RvdHlwZVtvbGRfaWRdXG4gICAgICB9XG5cbiAgICAgIGlmICghaXNfbWV0aG9kX2JvZHkoYm9keSkpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBtZXRob2QgYFwiICsgb2xkICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBib2R5IGlzIGl0c2VsZiBhbiBhbGlhcyB1c2UgdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAvLyB0byBrZWVwIHRoZSBtYXggZGVwdGggYXQgMS5cbiAgICBpZiAoYm9keS4kJGFsaWFzX29mKSBib2R5ID0gYm9keS4kJGFsaWFzX29mO1xuXG4gICAgLy8gV2UgbmVlZCBhIHdyYXBwZXIgYmVjYXVzZSBvdGhlcndpc2UgcHJvcGVydGllc1xuICAgIC8vIHdvdWxkIGJlIG92ZXJ3cml0dGVuIG9uIHRoZSBvcmlnaW5hbCBib2R5LlxuICAgIGFsaWFzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmxvY2sgPSBhbGlhcy4kJHAsIGFyZ3MsIGksIGlpO1xuXG4gICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKGkgPSAwLCBpaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG5cbiAgICAgIGFsaWFzLiQkcCA9IG51bGw7XG5cbiAgICAgIHJldHVybiBPcGFsLnNlbmQodGhpcywgYm9keSwgYXJncywgYmxvY2spO1xuICAgIH07XG5cbiAgICAvLyBBc3NpZ24gdGhlICdsZW5ndGgnIHZhbHVlIHdpdGggZGVmaW5lUHJvcGVydHkgYmVjYXVzZVxuICAgIC8vIGluIHN0cmljdCBtb2RlIHRoZSBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuXG4gICAgLy8gSXQgZG9lc24ndCB3b3JrIGluIG9sZGVyIGJyb3dzZXJzIChsaWtlIENocm9tZSAzOCksIHdoZXJlXG4gICAgLy8gYW4gZXhjZXB0aW9uIGlzIHRocm93biBicmVha2luZyBPcGFsIGFsdG9nZXRoZXIuXG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbGlhcywgJ2xlbmd0aCcsIHsgdmFsdWU6IGJvZHkubGVuZ3RoIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBUcnkgdG8gbWFrZSB0aGUgYnJvd3NlciBwaWNrIHRoZSByaWdodCBuYW1lXG4gICAgYWxpYXMuZGlzcGxheU5hbWUgICAgICAgPSBuYW1lO1xuXG4gICAgYWxpYXMuJCRhcml0eSAgICAgICAgICAgPSBib2R5LiQkYXJpdHk7XG4gICAgYWxpYXMuJCRwYXJhbWV0ZXJzICAgICAgPSBib2R5LiQkcGFyYW1ldGVycztcbiAgICBhbGlhcy4kJHNvdXJjZV9sb2NhdGlvbiA9IGJvZHkuJCRzb3VyY2VfbG9jYXRpb247XG4gICAgYWxpYXMuJCRhbGlhc19vZiAgICAgICAgPSBib2R5O1xuICAgIGFsaWFzLiQkYWxpYXNfbmFtZSAgICAgID0gbmFtZTtcblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBhbGlhcyk7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIE9wYWwuYWxpYXNfZ3ZhciA9IGZ1bmN0aW9uKG5ld19uYW1lLCBvbGRfbmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkZ3ZhcnMsIG5ld19uYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRndmFyc1tvbGRfbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihuZXdfdmFsdWUpIHtcbiAgICAgICAgJGd2YXJzW29sZF9uYW1lXSA9IG5ld192YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmlsO1xuICB9XG5cbiAgT3BhbC5hbGlhc19uYXRpdmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIG5hdGl2ZV9uYW1lKSB7XG4gICAgdmFyIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW25hdGl2ZV9uYW1lXTtcblxuICAgIGlmICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiB8fCBib2R5LiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBuYXRpdmUgbWV0aG9kIGBcIiArIG5hdGl2ZV9uYW1lICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBib2R5KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cblxuICAvLyBIYXNoZXNcbiAgLy8gLS0tLS0tXG5cbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC4kJHNtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IFtdO1xuICB9O1xuXG4gIE9wYWwuaGFzaF9jbG9uZSA9IGZ1bmN0aW9uKGZyb21faGFzaCwgdG9faGFzaCkge1xuICAgIHRvX2hhc2guJCRub25lID0gZnJvbV9oYXNoLiQkbm9uZTtcbiAgICB0b19oYXNoLiQkcHJvYyA9IGZyb21faGFzaC4kJHByb2M7XG5cbiAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IGZyb21faGFzaC4kJGtleXMsIHNtYXAgPSBmcm9tX2hhc2guJCRzbWFwLCBsZW4gPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICB9XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9wdXQgPSBmdW5jdGlvbihoYXNoLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIGhhc2guJCRrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGhhc2guJCRzbWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBidWNrZXQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICBpZiAoa2V5ID09PSBidWNrZXQua2V5IHx8IGtleVsnJGVxbD8nXShidWNrZXQua2V5KSkge1xuICAgICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnVja2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICB9XG5cbiAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldDtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2dldCA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0O1xuICAgIGtleV9oYXNoID0gaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1Y2tldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2RlbGV0ZSA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIHZhciBpLCBrZXlzID0gaGFzaC4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCB2YWx1ZSwga2V5X3RtcDtcblxuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSBrZXkgPSBrZXkudmFsdWVPZigpO1xuXG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5X3RtcCA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleV90bXAuJCRpc19zdHJpbmcgJiYgdHlwZW9mIGtleV90bXAgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBrZXlfdG1wID0ga2V5X3RtcC52YWx1ZU9mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5X3RtcCA9PT0ga2V5KSB7XG4gICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgZGVsZXRlIGhhc2guJCRzbWFwW2tleV07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGtleV9oYXNoID0ga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdLCBsYXN0X2J1Y2tldDtcblxuICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgIHZhbHVlID0gYnVja2V0LnZhbHVlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXlzW2ldID09PSBidWNrZXQpIHtcbiAgICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RfYnVja2V0ICYmIGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgICAgZGVsZXRlIGxhc3RfYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9yZWhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGhhc2guJCRrZXlzLmxlbmd0aCwga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICBpZiAoaGFzaC4kJGtleXNbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGtleV9oYXNoID0gaGFzaC4kJGtleXNbaV0ua2V5LiRoYXNoKCk7XG5cbiAgICAgIGlmIChrZXlfaGFzaCA9PT0gaGFzaC4kJGtleXNbaV0ua2V5X2hhc2gpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdO1xuICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PT0gaGFzaC4kJGtleXNbaV0pIHtcbiAgICAgICAgICBpZiAobGFzdF9idWNrZXQgJiYgYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXN0X2J1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChidWNrZXQubmV4dCkge1xuICAgICAgICAgICAgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF0gPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaGFzaC4kJGtleXNbaV0ua2V5X2hhc2ggPSBrZXlfaGFzaDtcblxuICAgICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGhhc2guJCRrZXlzW2ldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG4gICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgICBpZiAoYnVja2V0ID09PSBoYXNoLiQka2V5c1tpXSkge1xuICAgICAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBoYXNoLiQka2V5c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3VtZW50c19sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzLCBoYXNoLCBpLCBsZW5ndGgsIGtleSwgdmFsdWU7XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0uJCRpc19oYXNoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgIH1cblxuICAgIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG4gICAgT3BhbC5oYXNoX2luaXQoaGFzaCk7XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKGFyZ3VtZW50c1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcmdzW2ldLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJ2YWx1ZSBub3Qgb2YgbGVuZ3RoIDI6IFwiICsgYXJnc1tpXS4kaW5zcGVjdCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXkgPSBhcmdzW2ldWzBdO1xuICAgICAgICAgIHZhbHVlID0gYXJnc1tpXVsxXTtcblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBmb3IgKGtleSBpbiBhcmdzKSB7XG4gICAgICAgICAgaWYgKCRoYXNfb3duLmNhbGwoYXJncywga2V5KSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2tleV07XG5cbiAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcIm9kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHNfbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBBIGZhc3RlciBIYXNoIGNyZWF0b3IgZm9yIGhhc2hlcyB0aGF0IGp1c3QgdXNlIHN5bWJvbHMgYW5kXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcbiAgLy8gY29tcGlsZSB0aW1lLCBzbyB0aGV5IGFyZSBqdXN0IGFkZGVkIGhlcmUgYnkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICBPcGFsLmhhc2gyID0gZnVuY3Rpb24oa2V5cywgc21hcCkge1xuICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgaGFzaC4kJHNtYXAgPSBzbWFwO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IGtleXM7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgcmFuZ2UgaW5zdGFuY2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCB2YWx1ZXMsIGFuZCB3aGV0aGVyIHRoZVxuICAvLyByYW5nZSBleGNsdWRlcyB0aGUgbGFzdCB2YWx1ZS5cbiAgLy9cbiAgT3BhbC5yYW5nZSA9IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBleGMpIHtcbiAgICB2YXIgcmFuZ2UgICAgICAgICA9IG5ldyBPcGFsLlJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmJlZ2luICAgPSBmaXJzdDtcbiAgICAgICAgcmFuZ2UuZW5kICAgICA9IGxhc3Q7XG4gICAgICAgIHJhbmdlLmV4Y2wgICAgPSBleGM7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgdmFyIHJlc2VydmVkX2l2YXJfbmFtZXMgPSBbXG4gICAgLy8gcHJvcGVydGllc1xuICAgIFwiY29uc3RydWN0b3JcIiwgXCJkaXNwbGF5TmFtZVwiLCBcIl9fY291bnRfX1wiLCBcIl9fbm9TdWNoTWV0aG9kX19cIixcbiAgICBcIl9fcGFyZW50X19cIiwgXCJfX3Byb3RvX19cIixcbiAgICAvLyBtZXRob2RzXG4gICAgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcInZhbHVlT2ZcIlxuICBdO1xuXG4gIC8vIEdldCB0aGUgaXZhciBuYW1lIGZvciBhIGdpdmVuIG5hbWUuXG4gIC8vIE1vc3RseSBhZGRzIGEgdHJhaWxpbmcgJCB0byByZXNlcnZlZCBuYW1lcy5cbiAgLy9cbiAgT3BhbC5pdmFyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChyZXNlcnZlZF9pdmFyX25hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICBuYW1lICs9IFwiJFwiO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIC8vIFN1cHBvcnQgZm9yICNmcmVlemVcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGhlbHBlciB0aGF0IGNhbiBiZSB1c2VkIGZyb20gbWV0aG9kc1xuICBmdW5jdGlvbiAkZGVueV9mcm96ZW5fYWNjZXNzKG9iaikge1xuICAgIGlmIChvYmouJCRmcm96ZW4pIHtcbiAgICAgIHRocm93IE9wYWwuRnJvemVuRXJyb3IuJG5ldyhcImNhbid0IG1vZGlmeSBmcm96ZW4gXCIgKyAob2JqLiRjbGFzcygpKSArIFwiOiBcIiArIChvYmopLCBPcGFsLmhhc2gyKFtcInJlY2VpdmVyXCJdLCB7XCJyZWNlaXZlclwiOiBvYmp9KSk7XG4gICAgfVxuICB9O1xuICBPcGFsLmRlbnlfZnJvemVuX2FjY2VzcyA9ICRkZW55X2Zyb3plbl9hY2Nlc3M7XG5cbiAgLy8gY29tbW9uICNmcmVlemUgcnVudGltZSBzdXBwb3J0XG4gIE9wYWwuZnJlZXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgJHByb3Aob2JqLCBcIiQkZnJvemVuXCIsIHRydWUpO1xuXG4gICAgLy8gc2V0ICQkaWRcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnJCRpZCcpKSB7ICRwcm9wKG9iaiwgJyQkaWQnLCAkdWlkKCkpOyB9XG5cbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xuICAgICAgLy8gZnJlZXplICQkbWV0YSBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHNldFxuICAgICAgb2JqLiQkbWV0YS4kZnJlZXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuc3VyZSAkJG1ldGEgY2FuIGJlIHNldCBsYXppbHksICQkbWV0YSBpcyBmcm96ZW4gd2hlbiBzZXQgaW4gcnVudGltZS5qc1xuICAgICAgJHByb3Aob2JqLCAnJCRtZXRhJywgbnVsbCk7XG4gICAgfVxuXG4gICAgLy8gJCRjb21wYXJhYmxlIGlzIHVzZWQgaW50ZXJuYWxseSBhbmQgc2V0IG11bHRpcGxlIHRpbWVzXG4gICAgLy8gZGVmaW5pbmcgaXQgYmVmb3JlIHNlYWxpbmcgZW5zdXJlcyBpdCBjYW4gYmUgbW9kaWZpZWQgbGF0ZXIgb25cbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnJCRjb21wYXJhYmxlJykpIHsgJHByb3Aob2JqLCAnJCRjb21wYXJhYmxlJywgbnVsbCk7IH1cblxuICAgIC8vIHNlYWwgdGhlIE9iamVjdFxuICAgIE9iamVjdC5zZWFsKG9iaik7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIGZyZXplIHByb3BzLCBtYWtlIHNldHRlcnMgb2YgaW5zdGFuY2UgdmFyaWFibGVzIHRocm93IEZyb3plbkVycm9yXG4gIE9wYWwuZnJlZXplX3Byb3BzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHByb3AsIHByb3BfdHlwZSwgZGVzYztcblxuICAgIGZvcihwcm9wIGluIG9iaikge1xuICAgICAgcHJvcF90eXBlID0gdHlwZW9mKHByb3ApO1xuXG4gICAgICAvLyBwcm9wX3R5cGUgXCJvYmplY3RcIiBoZXJlIGlzIGEgU3RyaW5nKCksIHNraXAgJCBwcm9wc1xuICAgICAgaWYgKChwcm9wX3R5cGUgPT09IFwic3RyaW5nXCIgfHwgcHJvcF90eXBlID09PSBcIm9iamVjdFwiKSAmJiBwcm9wWzBdID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICBpZiAoZGVzYyAmJiBkZXNjLmVudW1lcmFibGUgJiYgZGVzYy53cml0YWJsZSkge1xuICAgICAgICAvLyBjcmVhdGUgY2xvc3VyZSB0byByZXRhaW4gY3VycmVudCB2YWx1ZSBhcyBjdlxuICAgICAgICAvLyBmb3IgT3BhbCAyLjAgbGV0IGZvciBjdiBzaG91bGQgZG8gdGhlIHRyaWNrLCBpbnN0ZWFkIG9mIGEgZnVuY3Rpb25cbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHNldCB2IHRvIHVuZGVmaW5lZCwgYXMgaWYgdGhlIHByb3BlcnR5IGlzIG5vdCBzZXRcbiAgICAgICAgICB2YXIgY3YgPSBvYmpbcHJvcF07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGN2OyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfdmFsKSB7ICRkZW55X2Zyb3plbl9hY2Nlc3Mob2JqKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnZXhwc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gRXNjYXBlIFJlZ2V4cCBzcGVjaWFsIGNoYXJzIGxldHRpbmcgdGhlIHJlc3VsdGluZyBzdHJpbmcgYmUgdXNlZCB0byBidWlsZFxuICAvLyBhIG5ldyBSZWdleHAuXG4gIC8vXG4gIE9wYWwuZXNjYXBlX3JlZ2V4cCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFstW1xcXVxcL3t9KCkqKz8uXiRcXFxcfCBdKS9nLCAnXFxcXCQxJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXG5dL2csICdcXFxcbicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxyXS9nLCAnXFxcXHInKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcZl0vZywgJ1xcXFxmJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHRdL2csICdcXFxcdCcpO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGdsb2JhbCBSZWdleHAgZnJvbSBhIFJlZ0V4cCBvYmplY3QgYW5kIGNhY2hlIHRoZSByZXN1bHRcbiAgLy8gb24gdGhlIG9iamVjdCBpdHNlbGYgKCQkZyBhdHRyaWJ1dGUpLlxuICAvL1xuICBPcGFsLmdsb2JhbF9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICByZXR1cm4gcGF0dGVybjsgLy8gUmVnRXhwIGFscmVhZHkgaGFzIHRoZSBnbG9iYWwgZmxhZ1xuICAgIH1cbiAgICBpZiAocGF0dGVybi4kJGcgPT0gbnVsbCkge1xuICAgICAgcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAocGF0dGVybi5tdWx0aWxpbmUgPyAnZ20nIDogJ2cnKSArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuLiQkZy5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm4uJCRnO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGdsb2JhbCBtdWx0aWxpbmUgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGdtIG9yICQkZyBhdHRyaWJ1dGUpLlxuICAvL1xuICBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciByZXN1bHQsIGZsYWdzO1xuXG4gICAgLy8gUmVnRXhwIGFscmVhZHkgaGFzIHRoZSBnbG9iYWwgYW5kIG11bHRpbGluZSBmbGFnXG4gICAgaWYgKHBhdHRlcm4uZ2xvYmFsICYmIHBhdHRlcm4ubXVsdGlsaW5lKSByZXR1cm4gcGF0dGVybjtcblxuICAgIGZsYWdzID0gJ2dtJyArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJyk7XG4gICAgaWYgKHBhdHRlcm4ubXVsdGlsaW5lKSB7XG4gICAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlICQkZyBhdHRyaWJ1dGUgYmVjYXVzZSB0aGUgUmVnZXhwIGlzIGFscmVhZHkgbXVsdGlsaW5lXG4gICAgICBpZiAocGF0dGVybi4kJGcgPT0gbnVsbCkge1xuICAgICAgICBwYXR0ZXJuLiQkZyA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIGZsYWdzKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0dGVybi4kJGdtID09IG51bGwpIHtcbiAgICAgICAgcGF0dGVybi4kJGdtID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgZmxhZ3MpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtO1xuICAgIH1cbiAgICByZXN1bHQubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb21iaW5lIG11bHRpcGxlIHJlZ2V4cCBwYXJ0cyB0b2dldGhlclxuICBPcGFsLnJlZ2V4cCA9IGZ1bmN0aW9uKHBhcnRzLCBmbGFncykge1xuICAgIHZhciBwYXJ0O1xuICAgIHZhciBpZ25vcmVDYXNlID0gdHlwZW9mIGZsYWdzICE9PSAndW5kZWZpbmVkJyAmJiBmbGFncyAmJiBmbGFncy5pbmRleE9mKCdpJykgPj0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmIChwYXJ0Lmlnbm9yZUNhc2UgIT09IGlnbm9yZUNhc2UpXG4gICAgICAgICAgT3BhbC5LZXJuZWwuJHdhcm4oXG4gICAgICAgICAgICBcImlnbm9yZSBjYXNlIGRvZXNuJ3QgbWF0Y2ggZm9yIFwiICsgcGFydC5zb3VyY2UuJGluc3BlY3QoKSxcbiAgICAgICAgICAgIE9wYWwuaGFzaCh7dXBsZXZlbDogMX0pXG4gICAgICAgICAgKVxuXG4gICAgICAgIHBhcnQgPSBwYXJ0LnNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0ID09PSAnJykgcGFydCA9ICcoPzonICsgcGFydCArICcpJztcbiAgICAgIHBhcnRzW2ldID0gcGFydDtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJycpLCBmbGFncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJycpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVxdWlyZSBzeXN0ZW1cbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICBPcGFsLm1vZHVsZXMgICAgICAgICA9IHt9O1xuICBPcGFsLmxvYWRlZF9mZWF0dXJlcyA9IFsnY29yZWxpYi9ydW50aW1lJ107XG4gIE9wYWwuY3VycmVudF9kaXIgICAgID0gJy4nO1xuICBPcGFsLnJlcXVpcmVfdGFibGUgICA9IHsnY29yZWxpYi9ydW50aW1lJzogdHJ1ZX07XG5cbiAgT3BhbC5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIHBhcnRzLCBwYXJ0LCBuZXdfcGFydHMgPSBbXSwgU0VQQVJBVE9SID0gJy8nO1xuXG4gICAgaWYgKE9wYWwuY3VycmVudF9kaXIgIT09ICcuJykge1xuICAgICAgcGF0aCA9IE9wYWwuY3VycmVudF9kaXIucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcGF0aDtcbiAgICB9XG5cbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwuXFwvLywgJycpO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLihyYnxvcGFsfGpzKSQvLCAnJyk7XG4gICAgcGFydHMgPSBwYXRoLnNwbGl0KFNFUEFSQVRPUik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgKHBhcnQgPT09ICcuLicpID8gbmV3X3BhcnRzLnBvcCgpIDogbmV3X3BhcnRzLnB1c2gocGFydClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3X3BhcnRzLmpvaW4oU0VQQVJBVE9SKTtcbiAgfTtcblxuICBPcGFsLmxvYWRlZCA9IGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgdmFyIGksIGwsIHBhdGg7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aHNbaV0pO1xuXG4gICAgICBpZiAoT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBPcGFsLmxvYWRlZF9mZWF0dXJlcy5wdXNoKHBhdGgpO1xuICAgICAgT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5sb2FkX25vcm1hbGl6ZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgT3BhbC5sb2FkZWQoW3BhdGhdKTtcblxuICAgIHZhciBtb2R1bGUgPSBPcGFsLm1vZHVsZXNbcGF0aF07XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICB2YXIgcmV0dmFsID0gbW9kdWxlKE9wYWwpO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiByZXR2YWwgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIC8vIEEgc3BlY2lhbCBjYXNlIG9mIHJlcXVpcmUgaGF2aW5nIGFuIGFzeW5jIHRvcDpcbiAgICAgICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGF3YWl0IGl0LlxuICAgICAgICByZXR1cm4gcmV0dmFsLnRoZW4oJHJldHVybl92YWwodHJ1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzZXZlcml0eSA9IE9wYWwuY29uZmlnLm1pc3NpbmdfcmVxdWlyZV9zZXZlcml0eTtcbiAgICAgIHZhciBtZXNzYWdlICA9ICdjYW5ub3QgbG9hZCBzdWNoIGZpbGUgLS0gJyArIHBhdGg7XG5cbiAgICAgIGlmIChzZXZlcml0eSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIGlmIChPcGFsLkxvYWRFcnJvcikge1xuICAgICAgICAgIHRocm93IE9wYWwuTG9hZEVycm9yLiRuZXcobWVzc2FnZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBtZXNzYWdlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNldmVyaXR5ID09PSBcIndhcm5pbmdcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IExvYWRFcnJvcjogJyArIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIE9wYWwubG9hZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkX25vcm1hbGl6ZWQocGF0aCk7XG4gIH07XG5cbiAgT3BhbC5yZXF1aXJlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkX25vcm1hbGl6ZWQocGF0aCk7XG4gIH07XG5cblxuICAvLyBTdHJpbmdzXG4gIC8vIC0tLS0tLS1cblxuICBPcGFsLmVuY29kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gU2V0cyB0aGUgZW5jb2Rpbmcgb24gYSBzdHJpbmcsIHdpbGwgdHJlYXQgc3RyaW5nIGxpdGVyYWxzIGFzIGZyb3plbiBzdHJpbmdzXG4gIC8vIHJhaXNpbmcgYSBGcm96ZW5FcnJvci5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0ciBbU3RyaW5nXSB0aGUgc3RyaW5nIG9uIHdoaWNoIHRoZSBlbmNvZGluZyBzaG91bGQgYmUgc2V0XG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBjYW5vbmljYWwgbmFtZSBvZiB0aGUgZW5jb2RpbmdcbiAgLy8gQHBhcmFtIHR5cGUgW1N0cmluZ10gcG9zc2libGUgdmFsdWVzIGFyZSBlaXRoZXIgYFwiZW5jb2RpbmdcImAsIGBcImludGVybmFsX2VuY29kaW5nXCJgLCBvciBgdW5kZWZpbmVkXG4gIE9wYWwuc2V0X2VuY29kaW5nID0gZnVuY3Rpb24oc3RyLCBuYW1lLCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInVuZGVmaW5lZFwiKSB0eXBlID0gXCJlbmNvZGluZ1wiO1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIuJCRmcm96ZW4gPT09IHRydWUpXG4gICAgICB0aHJvdyBPcGFsLkZyb3plbkVycm9yLiRuZXcoXCJjYW4ndCBtb2RpZnkgZnJvemVuIFN0cmluZ1wiKTtcblxuICAgIHZhciBlbmNvZGluZyA9IE9wYWwuZmluZF9lbmNvZGluZyhuYW1lKTtcblxuICAgIGlmIChlbmNvZGluZyA9PT0gc3RyW3R5cGVdKSB7IHJldHVybiBzdHI7IH1cblxuICAgIHN0clt0eXBlXSA9IGVuY29kaW5nO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvLyBGZXRjaGVzIHRoZSBlbmNvZGluZyBmb3IgdGhlIGdpdmVuIG5hbWUgb3IgcmFpc2VzIEFyZ3VtZW50RXJyb3IuXG4gIE9wYWwuZmluZF9lbmNvZGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVnaXN0ZXIgPSBPcGFsLmVuY29kaW5ncztcbiAgICB2YXIgZW5jb2RpbmcgPSByZWdpc3RlcltuYW1lXSB8fCByZWdpc3RlcltuYW1lLnRvVXBwZXJDYXNlKCldO1xuICAgIGlmICghZW5jb2RpbmcpIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KFwidW5rbm93biBlbmNvZGluZyBuYW1lIC0gXCIgKyBuYW1lKTtcbiAgICByZXR1cm4gZW5jb2Rpbmc7XG4gIH1cblxuICAvLyBAcmV0dXJucyBhIFN0cmluZyBvYmplY3Qgd2l0aCB0aGUgZW5jb2Rpbmcgc2V0IGZyb20gYSBzdHJpbmcgbGl0ZXJhbFxuICBPcGFsLmVuYyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSkge1xuICAgIHZhciBkdXAgPSBuZXcgU3RyaW5nKHN0cik7XG4gICAgZHVwID0gT3BhbC5zZXRfZW5jb2RpbmcoZHVwLCBuYW1lKTtcbiAgICBkdXAuaW50ZXJuYWxfZW5jb2RpbmcgPSBkdXAuZW5jb2Rpbmc7XG4gICAgcmV0dXJuIGR1cFxuICB9XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGludGVybmFsIGVuY29kaW5nIHNldCB0byBCaW5hcnlcbiAgT3BhbC5iaW5hcnkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIHJldHVybiBPcGFsLnNldF9lbmNvZGluZyhkdXAsIFwiYmluYXJ5XCIsIFwiaW50ZXJuYWxfZW5jb2RpbmdcIik7XG4gIH1cblxuICBPcGFsLmxhc3RfcHJvbWlzZSA9IG51bGw7XG4gIE9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uID0gZmFsc2U7XG5cbiAgLy8gUnVuIGEgYmxvY2sgb2YgY29kZSwgYnV0IGlmIGl0IHJldHVybnMgYSBQcm9taXNlLCBkb24ndCBydW4gdGhlIG5leHRcbiAgLy8gb25lLCBidXQgcXVldWUgaXQuXG4gIE9wYWwucXVldWUgPSBmdW5jdGlvbihwcm9jKSB7XG4gICAgaWYgKE9wYWwubGFzdF9wcm9taXNlKSB7XG4gICAgICAvLyBUaGUgYXN5bmMgcGF0aCBpcyB0YWtlbiBvbmx5IGlmIGFueXRoaW5nIGJlZm9yZSByZXR1cm5lZCBhXG4gICAgICAvLyBQcm9taXNlKFYyKS5cbiAgICAgIE9wYWwubGFzdF9wcm9taXNlID0gT3BhbC5sYXN0X3Byb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFPcGFsLnByb21pc2VfdW5oYW5kbGVkX2V4Y2VwdGlvbikgcmV0dXJuIHByb2MoT3BhbCk7XG4gICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoT3BhbC5yZXNwb25kX3RvKGVycm9yLCAnJGZ1bGxfbWVzc2FnZScpKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvci4kZnVsbF9tZXNzYWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIC8vIEFib3J0IGZ1cnRoZXIgZXhlY3V0aW9uXG4gICAgICAgIE9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgT3BhbC5leGl0KDEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gT3BhbC5sYXN0X3Byb21pc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHJldCA9IHByb2MoT3BhbCk7XG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgcmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBPcGFsLmxhc3RfcHJvbWlzZSA9IHJldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9XG5cbiAgLy8gT3BlcmF0b3IgaGVscGVyc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgZnVuY3Rpb24gYXJlX2JvdGhfbnVtYmVycyhsLHIpIHsgcmV0dXJuIHR5cGVvZihsKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKHIpID09PSAnbnVtYmVyJyB9XG5cbiAgT3BhbC5yYl9wbHVzICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgKyByIDogbFsnJCsnXShyKTsgfVxuICBPcGFsLnJiX21pbnVzICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCAtIHIgOiBsWyckLSddKHIpOyB9XG4gIE9wYWwucmJfdGltZXMgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsICogciA6IGxbJyQqJ10ocik7IH1cbiAgT3BhbC5yYl9kaXZpZGUgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgLyByIDogbFsnJC8nXShyKTsgfVxuICBPcGFsLnJiX2x0ICAgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCA8IHIgOiBsWyckPCddKHIpOyB9XG4gIE9wYWwucmJfZ3QgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsID4gciA6IGxbJyQ+J10ocik7IH1cbiAgT3BhbC5yYl9sZSAgICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgPD0gciA6IGxbJyQ8PSddKHIpOyB9XG4gIE9wYWwucmJfZ2UgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsID49IHIgOiBsWyckPj0nXShyKTsgfVxuXG4gIC8vIE9wdGltaXplZCBoZWxwZXJzIGZvciBjYWxscyBsaWtlICR0cnV0aHkoKGEpWyckPT09J10oYikpIC0+ICRlcWVxZXEoYSwgYilcbiAgZnVuY3Rpb24gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocywgcmhzKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgbGhzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcmhzID09PSAnbnVtYmVyJykgfHxcbiAgICAgICAgICAgKHR5cGVvZiBsaHMgPT09ICdzdHJpbmcnICYmIHR5cGVvZiByaHMgPT09ICdzdHJpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRlcWVxKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGFyZV9ib3RoX251bWJlcnNfb3Jfc3RyaW5ncyhsaHMscmhzKSA/IGxocyA9PT0gcmhzIDogJHRydXRoeSgobGhzKVsnJD09J10ocmhzKSk7XG4gIH07XG4gIE9wYWwuZXFlcSA9ICRlcWVxO1xuICBPcGFsLmVxZXFlcSA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGFyZV9ib3RoX251bWJlcnNfb3Jfc3RyaW5ncyhsaHMscmhzKSA/IGxocyA9PT0gcmhzIDogJHRydXRoeSgobGhzKVsnJD09PSddKHJocykpO1xuICB9O1xuICBPcGFsLm5lcWVxID0gZnVuY3Rpb24obGhzLCByaHMpIHtcbiAgICByZXR1cm4gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocyxyaHMpID8gbGhzICE9PSByaHMgOiAkdHJ1dGh5KChsaHMpWyckIT0nXShyaHMpKTtcbiAgfTtcbiAgT3BhbC5ub3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBhcmcgfHwgbnVsbCA9PT0gYXJnIHx8IGZhbHNlID09PSBhcmcgfHwgbmlsID09PSBhcmcpIHJldHVybiB0cnVlO1xuICAgIGlmICh0cnVlID09PSBhcmcgfHwgYXJnWyckISddLiQkcHJpc3RpbmUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gJHRydXRoeShhcmdbJyQhJ10oKSk7XG4gIH1cblxuICAvLyBTaG9ydGN1dHMgLSBvcHRpbWl6ZWQgZnVuY3Rpb24gZ2VuZXJhdG9ycyBmb3Igc2ltcGxlIGtpbmRzIG9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiAkcmV0dXJuX3ZhbChhcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgfVxuICBPcGFsLnJldHVybl92YWwgPSAkcmV0dXJuX3ZhbDtcblxuICBPcGFsLnJldHVybl9zZWxmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgT3BhbC5yZXR1cm5faXZhciA9IGZ1bmN0aW9uKGl2YXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpc1tpdmFyXSA9PSBudWxsKSB7IHJldHVybiBuaWw7IH1cbiAgICAgIHJldHVybiB0aGlzW2l2YXJdO1xuICAgIH1cbiAgfVxuICBPcGFsLmFzc2lnbl9pdmFyID0gZnVuY3Rpb24oaXZhcikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3ModGhpcyk7XG4gICAgICByZXR1cm4gdGhpc1tpdmFyXSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgT3BhbC5hc3NpZ25faXZhcl92YWwgPSBmdW5jdGlvbihpdmFyLCBzdGF0aWNfdmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2Vzcyh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzW2l2YXJdID0gc3RhdGljX3ZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBQcmltaXRpdmVzIGZvciBoYW5kbGluZyBwYXJhbWV0ZXJzXG4gIE9wYWwuZW5zdXJlX2t3YXJncyA9IGZ1bmN0aW9uKGt3YXJncykge1xuICAgIGlmIChrd2FyZ3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9wYWwuaGFzaDIoW10sIHt9KTtcbiAgICB9IGVsc2UgaWYgKGt3YXJncy4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiBrd2FyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdleHBlY3RlZCBrd2FyZ3MnKTtcbiAgICB9XG4gIH1cblxuICBPcGFsLmdldF9rd2FyZyA9IGZ1bmN0aW9uKGt3YXJncywga2V5KSB7XG4gICAgaWYgKCEkaGFzX293bi5jYWxsKGt3YXJncy4kJHNtYXAsIGtleSkpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdtaXNzaW5nIGtleXdvcmQ6ICcra2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGt3YXJncy4kJHNtYXBba2V5XTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIE9wYWwuQmFzaWNPYmplY3QgPSBCYXNpY09iamVjdCA9ICRhbGxvY2F0ZV9jbGFzcygnQmFzaWNPYmplY3QnLCBudWxsKTtcbiAgT3BhbC5PYmplY3QgICAgICA9IF9PYmplY3QgICAgID0gJGFsbG9jYXRlX2NsYXNzKCdPYmplY3QnLCBPcGFsLkJhc2ljT2JqZWN0KTtcbiAgT3BhbC5Nb2R1bGUgICAgICA9IE1vZHVsZSAgICAgID0gJGFsbG9jYXRlX2NsYXNzKCdNb2R1bGUnLCBPcGFsLk9iamVjdCk7XG4gIE9wYWwuQ2xhc3MgICAgICAgPSBDbGFzcyAgICAgICA9ICRhbGxvY2F0ZV9jbGFzcygnQ2xhc3MnLCBPcGFsLk1vZHVsZSk7XG4gIE9wYWwuT3BhbCAgICAgICAgPSBfT3BhbCAgICAgICA9ICRhbGxvY2F0ZV9tb2R1bGUoJ09wYWwnKTtcbiAgT3BhbC5LZXJuZWwgICAgICA9IEtlcm5lbCAgICAgID0gJGFsbG9jYXRlX21vZHVsZSgnS2VybmVsJyk7XG5cbiAgJHNldF9wcm90byhPcGFsLkJhc2ljT2JqZWN0LCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLk9iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5Nb2R1bGUsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuQ2xhc3MsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gIC8vIEJhc2ljT2JqZWN0IGNhbiByZWFjaCBpdHNlbGYsIGF2b2lkIGNvbnN0X3NldCB0byBza2lwIHRoZSAkJGJhc2VfbW9kdWxlIGxvZ2ljXG4gIEJhc2ljT2JqZWN0LiQkY29uc3QuQmFzaWNPYmplY3QgPSBCYXNpY09iamVjdDtcblxuICAvLyBBc3NpZ24gYmFzaWMgY29uc3RhbnRzXG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJCYXNpY09iamVjdFwiLCAgQmFzaWNPYmplY3QpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiT2JqZWN0XCIsICAgICAgIF9PYmplY3QpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiTW9kdWxlXCIsICAgICAgIE1vZHVsZSk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJDbGFzc1wiLCAgICAgICAgQ2xhc3MpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiT3BhbFwiLCAgICAgICAgIF9PcGFsKTtcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIktlcm5lbFwiLCAgICAgICBLZXJuZWwpO1xuXG4gIC8vIEZpeCBib290ZWQgY2xhc3NlcyB0byBoYXZlIGNvcnJlY3QgLmNsYXNzIHZhbHVlXG4gIEJhc2ljT2JqZWN0LiQkY2xhc3MgPSBDbGFzcztcbiAgX09iamVjdC4kJGNsYXNzICAgICA9IENsYXNzO1xuICBNb2R1bGUuJCRjbGFzcyAgICAgID0gQ2xhc3M7XG4gIENsYXNzLiQkY2xhc3MgICAgICAgPSBDbGFzcztcbiAgX09wYWwuJCRjbGFzcyAgICAgICA9IE1vZHVsZTtcbiAgS2VybmVsLiQkY2xhc3MgICAgICA9IE1vZHVsZTtcblxuICAvLyBGb3J3YXJkIC50b1N0cmluZygpIHRvICN0b19zXG4gICRwcm9wKF9PYmplY3QuJCRwcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b19zID0gdGhpcy4kdG9fcygpO1xuICAgIGlmICh0b19zLiQkaXNfc3RyaW5nICYmIHR5cGVvZih0b19zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGEgc3RyaW5nIGNyZWF0ZWQgdXNpbmcgbmV3IFN0cmluZygnc3RyaW5nJylcbiAgICAgIHJldHVybiB0b19zLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRvX3M7XG4gICAgfVxuICB9KTtcblxuICAvLyBNYWtlIEtlcm5lbCNyZXF1aXJlIGltbWVkaWF0ZWx5IGF2YWlsYWJsZSBhcyBpdCdzIG5lZWRlZCB0byByZXF1aXJlIGFsbCB0aGVcbiAgLy8gb3RoZXIgY29yZWxpYiBmaWxlcy5cbiAgJHByb3AoX09iamVjdC4kJHByb3RvdHlwZSwgJyRyZXF1aXJlJywgT3BhbC5yZXF1aXJlKTtcblxuICAvLyBJbnN0YW50aWF0ZSB0aGUgbWFpbiBvYmplY3RcbiAgT3BhbC50b3AgPSBuZXcgX09iamVjdCgpO1xuICBPcGFsLnRvcC4kdG9fcyA9IE9wYWwudG9wLiRpbnNwZWN0ID0gJHJldHVybl92YWwoJ21haW4nKTtcbiAgT3BhbC50b3AuJGRlZmluZV9tZXRob2QgPSB0b3BfZGVmaW5lX21ldGhvZDtcblxuICAvLyBGb3dhcmQgY2FsbHMgdG8gZGVmaW5lX21ldGhvZCBvbiB0aGUgdG9wIG9iamVjdCB0byBPYmplY3RcbiAgZnVuY3Rpb24gdG9wX2RlZmluZV9tZXRob2QoKSB7XG4gICAgdmFyIGFyZ3MgPSBPcGFsLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgYmxvY2sgPSB0b3BfZGVmaW5lX21ldGhvZC4kJHA7XG4gICAgdG9wX2RlZmluZV9tZXRob2QuJCRwID0gbnVsbDtcbiAgICByZXR1cm4gT3BhbC5zZW5kKF9PYmplY3QsICdkZWZpbmVfbWV0aG9kJywgYXJncywgYmxvY2spXG4gIH07XG5cbiAgLy8gTmlsXG4gIE9wYWwuTmlsQ2xhc3MgPSAkYWxsb2NhdGVfY2xhc3MoJ05pbENsYXNzJywgT3BhbC5PYmplY3QpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsICdOaWxDbGFzcycsIE9wYWwuTmlsQ2xhc3MpO1xuICBuaWwgPSBPcGFsLm5pbCA9IG5ldyBPcGFsLk5pbENsYXNzKCk7XG4gIG5pbC4kJGlkID0gbmlsX2lkO1xuICBuaWwuY2FsbCA9IG5pbC5hcHBseSA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoJ25vIGJsb2NrIGdpdmVuJyk7IH07XG4gIG5pbC4kJGZyb3plbiA9IHRydWU7XG4gIG5pbC4kJGNvbXBhcmFibGUgPSBmYWxzZTtcbiAgT2JqZWN0LnNlYWwobmlsKTtcblxuICBPcGFsLnRocm93ZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHRocm93ZXIgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgJyt0eXBlKTtcbiAgICB0aHJvd2VyLiR0aHJvd2VyX3R5cGUgPSB0eXBlO1xuICAgIHRocm93ZXIuJHRocm93ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB2YWx1ZSA9IG5pbDtcbiAgICAgIHRocm93ZXIuJHYgPSB2YWx1ZTtcbiAgICAgIHRocm93IHRocm93ZXI7XG4gICAgfTtcbiAgICByZXR1cm4gdGhyb3dlcjtcbiAgfTtcblxuICBPcGFsLnRfZXZhbF9yZXR1cm4gPSBPcGFsLnRocm93ZXIoXCJyZXR1cm5cIik7XG5cbiAgVHlwZUVycm9yLiQkc3VwZXIgPSBFcnJvcjtcblxuICAvLyBJZiBlbmFibGUtZmlsZS1zb3VyY2UtZW1iZWQgY29tcGlsZXIgb3B0aW9uIGlzIGVuYWJsZWQsIGVhY2ggbW9kdWxlIGxvYWRlZCB3aWxsIGFkZCBpdHNcbiAgLy8gc291cmNlcyB0byB0aGlzIG9iamVjdFxuICBPcGFsLmZpbGVfc291cmNlcyA9IHt9O1xufSkuY2FsbCh0aGlzKTtcbk9wYWwubG9hZGVkKFtcImNvcmVsaWIvcnVudGltZS5qc1wiXSk7Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVGO0FBQ0U7O0FBRUY7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTs7QUFFSjtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFOztBQUVGO0FBQ0U7O0FBRUY7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOzs7QUFHQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUU7QUFDRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUU7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDVTtBQUNBO0FBQ0E7QUFDQTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUY7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNPO0FBQ1Q7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTg3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pcmIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBEZWJ1ZyBpcyBhIGhlbHBlciBtb2R1bGUgdGhhdCBhbGxvd3MgdXMgdG8gY29uZHVjdCBzb21lIGRlYnVnZ2luZyBvblxuIyBhIGxpdmUgY29kZWJhc2UuIEl0IGdvZXMgd2l0aCBhbiBhc3N1bXB0aW9uLCB0aGF0IG9wYWwtcGFyc2VyIG9yXG4jIG9wYWwtcmVwbHV0aWxzIHdpbGwgbm90IGJlIGxvYWRlZCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGRvIHdoYXQgd2UgY2FuXG4jIHRvIHByb3Zpc2lvbiBpdC5cblxubW9kdWxlIE9wYWxcbiAgbW9kdWxlIElSQlxuICAgIGRlZiBzZWxmLmVuc3VyZV9sb2FkZWQobGlicmFyeSlcbiAgICAgIHJldHVybiBpZiBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgLmluY2x1ZGU/IGxpYnJhcnlcblxuICAgICAgdmVyc2lvbiA9IGlmIFJVQllfRU5HSU5FX1ZFUlNJT04uaW5jbHVkZT8gJ2RldidcbiAgICAgICAgICAgICAgICAgICdtYXN0ZXInXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgUlVCWV9FTkdJTkVfVkVSU0lPTlxuICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB1cmwgPSBcImh0dHBzOi8vY2RuLm9wYWxyYi5jb20vb3BhbC8je3ZlcnNpb259LyN7bGlicmFyeX0uanNcIlxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIGxpYmNvZGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlclxuICAgICAgICAgIHZhciByID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgci5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpO1xuICAgICAgICAgIHIuc2VuZCgnJyk7XG4gICAgICAgICAgbGliY29kZSA9IHIucmVzcG9uc2VUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgXCJZb3UgbmVlZCB0byBwcm92aXNpb24gI3tsaWJyYXJ5fSB5b3Vyc2VsZiBpbiB0aGlzIGVudmlyb25tZW50XCJ9XG4gICAgICAgIH1cblxuICAgICAgICAobmV3IEZ1bmN0aW9uKCdPcGFsJywgbGliY29kZSkpKE9wYWwpO1xuXG4gICAgICAgIE9wYWwucmVxdWlyZShsaWJyYXJ5KTtcbiAgICAgIH1cblxuICAgICAgOjpLZXJuZWwucmFpc2UgXCJDb3VsZCBub3QgbG9hZCAje2xpYnJhcnl9IGZvciBzb21lIHJlYXNvblwiIHVubGVzcyBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgLmluY2x1ZGU/IGxpYnJhcnlcbiAgICBlbmRcblxuICAgIHNpbmdsZXRvbl9jbGFzcy5hdHRyX2FjY2Vzc29yIDpvdXRwdXRcblxuICAgIGRlZiBzZWxmLnByZXBhcmVfY29uc29sZSgmYmxvY2spXG4gICAgICBzZWxmLm91dHB1dCA9ICcnXG5cbiAgICAgIG9yaWdpbmFsID0ge1xuICAgICAgICAkc3Rkb3V0ID0+IC0+KGkpIHsgJHN0ZG91dCA9IGkgfSxcbiAgICAgICAgJHN0ZGVyciA9PiAtPihpKSB7ICRzdGRlcnIgPSBpIH0sXG4gICAgICB9XG5cbiAgICAgICMgUHJlcGFyZSBhIGJldHRlciBwcm9tcHQgZXhwZXJpZW5jZSBmb3IgYSBicm93c2VyXG4gICAgICBpZiBicm93c2VyP1xuICAgICAgICBvcmlnaW5hbC5lYWNoIGRvIHxwaXBlLCBwaXBlX3NldHRlcnxcbiAgICAgICAgICBuZXdfcGlwZSA9IHBpcGUuZHVwXG4gICAgICAgICAgbmV3X3BpcGUud3JpdGVfcHJvYyA9IHByb2MgZG8gfHN0cnxcbiAgICAgICAgICAgIHNlbGYub3V0cHV0ICs9IHN0clxuICAgICAgICAgICAgc2VsZi5vdXRwdXQgPSBvdXRwdXQuc3BsaXQoXCJcXG5cIikubGFzdCgzMCkuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgc2VsZi5vdXRwdXQgKz0gXCJcXG5cIiBpZiBzdHIuZW5kX3dpdGg/IFwiXFxuXCJcblxuICAgICAgICAgICAgcGlwZS53cml0ZV9wcm9jLmNhbGwoc3RyKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIG5ld19waXBlLnR0eSA9IGZhbHNlXG4gICAgICAgICAgcGlwZV9zZXR0ZXIuY2FsbChuZXdfcGlwZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgb3JpZ2luYWxfcmVhZF9wcm9jID0gJHN0ZGluLnJlYWRfcHJvY1xuICAgICAgICAkc3RkaW4ucmVhZF9wcm9jID0gYGZ1bmN0aW9uKHMpIHsgdmFyIHAgPSBwcm9tcHQoI3tvdXRwdXR9KTsgaWYgKHAgIT09IG51bGwpIHJldHVybiBwICsgXCJcXG5cIjsgcmV0dXJuIG5pbDsgfWBcbiAgICAgIGVuZFxuXG4gICAgICB5aWVsZFxuICAgIGVuc3VyZVxuICAgICAgb3JpZ2luYWwuZWFjaCBkbyB8cGlwZSwgcGlwZV9zZXR0ZXJ8XG4gICAgICAgIHBpcGVfc2V0dGVyLmNhbGwocGlwZSlcbiAgICAgIGVuZFxuICAgICAgJHN0ZGluLnJlYWRfcHJvYyA9IG9yaWdpbmFsX3JlYWRfcHJvY1xuICAgICAgc2VsZi5vdXRwdXQgPSAnJ1xuICAgIGVuZFxuXG4gICAgZGVmIHNlbGYuYnJvd3Nlcj9cbiAgICAgIGB0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YocHJvbXB0KSAhPT0gJ3VuZGVmaW5lZCdgXG4gICAgZW5kXG5cbiAgICBMSU5FQlJFQUtTID0gW1xuICAgICAgJ3VuZXhwZWN0ZWQgdG9rZW4gJGVuZCcsXG4gICAgICAndW50ZXJtaW5hdGVkIHN0cmluZyBtZWV0cyBlbmQgb2YgZmlsZSdcbiAgICBdLmZyZWV6ZVxuXG4gICAgY2xhc3MgU2lsZW5jZXJcbiAgICAgIGRlZiBpbml0aWFsaXplXG4gICAgICAgIEBzdGRlcnIgPSAkc3RkZXJyXG4gICAgICBlbmRcblxuICAgICAgZGVmIHNpbGVuY2VcbiAgICAgICAgQGNvbGxlY3RvciA9IDo6U3RyaW5nSU8ubmV3XG4gICAgICAgICRzdGRlcnIgPSBAY29sbGVjdG9yXG4gICAgICAgIHlpZWxkXG4gICAgICBlbnN1cmVcbiAgICAgICAgJHN0ZGVyciA9IEBzdGRlcnJcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgd2FybmluZ3NcbiAgICAgICAgQGNvbGxlY3Rvci5zdHJpbmdcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OkJpbmRpbmdcbiAgZGVmIGlyYlxuICAgIDo6T3BhbDo6SVJCLmVuc3VyZV9sb2FkZWQoJ29wYWwtcmVwbHV0aWxzJylcblxuICAgIHNpbGVuY2VyID0gOjpPcGFsOjpJUkI6OlNpbGVuY2VyLm5ld1xuXG4gICAgOjpPcGFsOjpJUkIucHJlcGFyZV9jb25zb2xlIGRvXG4gICAgICBsb29wIGRvXG4gICAgICAgIHByaW50ICc+PiAnXG4gICAgICAgIGxpbmUgPSBnZXRzXG4gICAgICAgIGJyZWFrIHVubGVzcyBsaW5lXG4gICAgICAgIGNvZGUgPSAnJ1xuXG4gICAgICAgIHB1dHMgbGluZSBpZiA6Ok9wYWw6OklSQi5icm93c2VyP1xuXG4gICAgICAgIGlmIGxpbmUuc3RhcnRfd2l0aD8gJ2xzICdcbiAgICAgICAgICBjb2RlID0gbGluZVszLi4tMV1cbiAgICAgICAgICBtb2RlID0gOmxzXG4gICAgICAgIGVsc2lmIGxpbmUgPT0gXCJsc1xcblwiXG4gICAgICAgICAgY29kZSA9ICdzZWxmJ1xuICAgICAgICAgIG1vZGUgPSA6bHNcbiAgICAgICAgZWxzaWYgbGluZS5zdGFydF93aXRoPyAnc2hvdyAnXG4gICAgICAgICAgY29kZSA9IGxpbmVbNS4uLTFdXG4gICAgICAgICAgbW9kZSA9IDpzaG93XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb2RlID0gbGluZVxuICAgICAgICAgIG1vZGUgPSA6aW5zcGVjdFxuICAgICAgICBlbmRcblxuICAgICAgICBqc19jb2RlID0gbmlsXG5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBzaWxlbmNlci5zaWxlbmNlIGRvXG4gICAgICAgICAgICBqc19jb2RlID0gYE9wYWwuY29tcGlsZShjb2RlLCB7aXJiOiB0cnVlfSlgXG4gICAgICAgICAgZW5kXG4gICAgICAgIHJlc2N1ZSBTeW50YXhFcnJvciA9PiBlXG4gICAgICAgICAgaWYgOjpPcGFsOjpJUkI6OkxJTkVCUkVBS1MuaW5jbHVkZT8oZS5tZXNzYWdlKVxuICAgICAgICAgICAgcHJpbnQgJy4uICdcbiAgICAgICAgICAgIGxpbmUgPSBnZXRzXG4gICAgICAgICAgICByZXR1cm4gdW5sZXNzIGxpbmVcbiAgICAgICAgICAgIHB1dHMgbGluZSBpZiA6Ok9wYWw6OklSQi5icm93c2VyP1xuICAgICAgICAgICAgY29kZSArPSBsaW5lXG4gICAgICAgICAgICByZXRyeVxuICAgICAgICAgIGVsc2lmIHNpbGVuY2VyLndhcm5pbmdzLmVtcHR5P1xuICAgICAgICAgICAgd2FybiBlLmZ1bGxfbWVzc2FnZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICMgTW9zdCBsaWtlbHkgYSBwYXJzZXIgZXJyb3JcbiAgICAgICAgICAgIHdhcm4gc2lsZW5jZXIud2FybmluZ3NcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG5cbiAgICAgICAgaWYgbW9kZSA9PSA6c2hvd1xuICAgICAgICAgIHB1dHMganNfY29kZVxuICAgICAgICAgIHJldHVyblxuICAgICAgICBlbmRcblxuICAgICAgICBwdXRzIDo6UkVQTFV0aWxzLmV2YWxfYW5kX3ByaW50KGpzX2NvZGUsIG1vZGUsIGZhbHNlLCBzZWxmKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbiV4e1xuICAvLyBSdW4gaW4gV2ViVG9vbHMgY29uc29sZSB3aXRoOiBPcGFsLmlyYihjID0+IGV2YWwoYykpXG4gIE9wYWwuaXJiID0gZnVuY3Rpb24oZnVuKSB7XG4gICAgI3s6OkJpbmRpbmcubmV3KGBmdW5gKS5pcmJ9XG4gIH1cblxuICBPcGFsLmxvYWRfcGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgT3BhbC5PcGFsLklSQi4kZW5zdXJlX2xvYWRlZCgnb3BhbC1wYXJzZXInKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgT3BhbC5ldmFsID09PSAndW5kZWZpbmVkJykge1xuICAgIE9wYWwuZXZhbCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgT3BhbC5sb2FkX3BhcnNlcigpO1xuICAgICAgcmV0dXJuIE9wYWwuZXZhbChzdHIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgT3BhbC5jb21waWxlID09PSAndW5kZWZpbmVkJykge1xuICAgIE9wYWwuY29tcGlsZSA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICAgICAgT3BhbC5sb2FkX3BhcnNlcigpO1xuICAgICAgcmV0dXJuIE9wYWwuY29tcGlsZShzdHIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+IiwiPG1vZHVsZTpJUkI+IiwiZW5zdXJlX2xvYWRlZCIsInNlbGYiLCJsaWJyYXJ5IiwiaW5jbHVkZT8iLCJ2ZXJzaW9uIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsInVybCIsIktlcm5lbCIsInJhaXNlIiwic2luZ2xldG9uX2NsYXNzIiwiYXR0cl9hY2Nlc3NvciIsInByZXBhcmVfY29uc29sZSIsIm91dHB1dD0iLCJvcmlnaW5hbCIsIiRzdGRvdXQiLCJibG9jayBpbiBwcmVwYXJlX2NvbnNvbGUiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcmVwYXJlX2NvbnNvbGUiLCIkc3RkZXJyIiwiYnJvd3Nlcj8iLCJlYWNoIiwicGlwZSIsInBpcGVfc2V0dGVyIiwibmV3X3BpcGUiLCJkdXAiLCJ3cml0ZV9wcm9jPSIsInByb2MiLCJzdHIiLCJibG9jayAoMyBsZXZlbHMpIGluIHByZXBhcmVfY29uc29sZSIsIisiLCJvdXRwdXQiLCJzcGxpdCIsImxhc3QiLCIzMCIsImpvaW4iLCJlbmRfd2l0aD8iLCJ3cml0ZV9wcm9jIiwiY2FsbCIsInR0eT0iLCJvcmlnaW5hbF9yZWFkX3Byb2MiLCIkc3RkaW4iLCJyZWFkX3Byb2MiLCJyZWFkX3Byb2M9IiwiZnJlZXplIiwiPGNsYXNzOlNpbGVuY2VyPiIsImluaXRpYWxpemUiLCJAc3RkZXJyIiwic2lsZW5jZSIsIkBjb2xsZWN0b3IiLCJTdHJpbmdJTyIsIm5ldyIsIndhcm5pbmdzIiwic3RyaW5nIiwiPGNsYXNzOkJpbmRpbmc+IiwiaXJiIiwiT3BhbDo6SVJCIiwiT3BhbCIsInNpbGVuY2VyIiwiT3BhbDo6SVJCOjpTaWxlbmNlciIsImJsb2NrIGluIGlyYiIsImJsb2NrICgyIGxldmVscykgaW4gaXJiIiwibG9vcCIsImJsb2NrICgzIGxldmVscykgaW4gaXJiIiwicHJpbnQiLCJsaW5lIiwiZ2V0cyIsImNvZGUiLCJwdXRzIiwic3RhcnRfd2l0aD8iLCJbXSIsIjMiLCItMSIsIm1vZGUiLCI1IiwianNfY29kZSIsImJsb2NrICg0IGxldmVscykgaW4gaXJiIiwiU3ludGF4RXJyb3IiLCJlIiwiT3BhbDo6SVJCOjpMSU5FQlJFQUtTIiwibWVzc2FnZSIsImVtcHR5PyIsIndhcm4iLCJmdWxsX21lc3NhZ2UiLCJSRVBMVXRpbHMiLCJldmFsX2FuZF9wcmludCIsIkJpbmRpbmciXSwibWFw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QUEsQ0FBQUEsQ0FBdkIsQ0FBQTtrQkFDRS9FLElBQUFnRixNQUFBQSxDQUFLSixDQUFDSyxjQUFBQSxDQUFBQSxDQUFORDtnQkFERjtrQkFJRWhGLElBQUFnRixNQUFBQSxDQUFLeEIsUUFBUU4sVUFBQUEsQ0FBQUEsQ0FBYjhCO2dCQUpGO2NBUkY7WUFBQSxDQUhFO1VBQUEsQ0FBQTtVQW1CRixJQUFBLE1BQUdULElBQUgsRUFBVyxNQUFYLENBQUE7O1lBQ0V2RSxJQUFBa0UsTUFBQUEsQ0FBS08sT0FBTFA7WUFDQSxTQUFBLFFBQUE7VUFGRjtVQUtBTCxPQUFBN0QsSUFBQWtFLE1BQUFBLENBQUtnQixnQkFBV0MsZ0JBQUFBLENBQWdCVixPQUEzQixFQUFvQ0YsSUFBcEMsRUFBMEMsS0FBMUMsRUFBaUR2RSxJQUF0Q21GLENBQWhCakIsRUFqREZQLENBQUFBLEdBQUFBLHVDQUFBQSxDQUFBQyxDQUFBQTtVQUFBQTtVQUFBQTtRQUFBQSxDQUFBQSxJQURGRixDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBV2hELEVBTGIyQztRQUFBQTtRQUFBQTtNQUFBQTtJQUFBQSxDQUFBQSxHQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBOztBQStEQXhEO0FBQ0FBO0FBQ0FBLElBQU13RixjQUFTbkMsS0FBQUEsQ0FBTXJELEdBQU5xRCxDQUFXSSxLQUFBQSxDQUFBQTtBQUMxQnpEOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQTlMQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyMzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Vuc3VwcG9ydGVkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiV4e1xuICB2YXIgd2FybmluZ3MgPSB7fTtcblxuICBmdW5jdGlvbiBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShtZXNzYWdlKSB7XG4gICAgc3dpdGNoIChPcGFsLmNvbmZpZy51bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eSkge1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBgbWVzc2FnZWB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHdhcm4obWVzc2FnZSlcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIGlnbm9yZVxuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oc3RyaW5nKSB7XG4gICAgaWYgKHdhcm5pbmdzW3N0cmluZ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nc1tzdHJpbmddID0gdHJ1ZTtcbiAgICAje3dhcm4oYHN0cmluZ2ApfTtcbiAgfVxufVxuXG5jbGFzcyA6OlN0cmluZ1xuICBgdmFyIEVSUk9SID0gXCJTdHJpbmcjJXMgbm90IHN1cHBvcnRlZC4gTXV0YWJsZSBTdHJpbmcgbWV0aG9kcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBPcGFsLlwiYFxuXG4gICVpW1xuICAgIDw8IGNhcGl0YWxpemUhIGNob21wISBjaG9wISBkb3duY2FzZSEgZ3N1YiEgbHN0cmlwISBuZXh0ISByZXZlcnNlIVxuICAgIHNsaWNlISBzcXVlZXplISBzdHJpcCEgc3ViISBzdWNjISBzd2FwY2FzZSEgdHIhIHRyX3MhIHVwY2FzZSEgcHJlcGVuZFxuICAgIFtdPSBjbGVhciBlbmNvZGUhIHVuaWNvZGVfbm9ybWFsaXplIVxuICBdLmVhY2ggZG8gfG1ldGhvZF9uYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbWV0aG9kX25hbWUgZG8gfCp8XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSBtZXRob2RfbmFtZVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgOjpLZXJuZWxcbiAgYHZhciBFUlJPUiA9IFwiT2JqZWN0IHRhaW50aW5nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgT3BhbFwiYFxuXG4gIGRlZiB0YWludFxuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdW50YWludFxuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdGFpbnRlZD9cbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6TW9kdWxlXG4gIGRlZiBwdWJsaWMoKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtZXRob2RzLmxlbmd0aCA9PT0gMSkgPyBtZXRob2RzWzBdIDogbWV0aG9kcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZCgqbWV0aG9kcylcbiAgICBgcmV0dXJuIChtZXRob2RzLmxlbmd0aCA9PT0gMSkgPyBtZXRob2RzWzBdIDogbWV0aG9kc2BcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfbWV0aG9kX2RlZmluZWQ/KG9iailcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgcHJpdmF0ZV9jb25zdGFudCgqKVxuICBlbmRcblxuICBhbGlhcyBuZXN0aW5nIHB1YmxpY1xuICBhbGlhcyBwcml2YXRlIHB1YmxpY1xuICBhbGlhcyBwcm90ZWN0ZWQgcHVibGljXG4gIGFsaWFzIHByb3RlY3RlZF9tZXRob2RfZGVmaW5lZD8gcHJpdmF0ZV9tZXRob2RfZGVmaW5lZD9cbiAgYWxpYXMgcHVibGljX2NsYXNzX21ldGhvZCBwcml2YXRlX2NsYXNzX21ldGhvZFxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kIGluc3RhbmNlX21ldGhvZFxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kcyBpbnN0YW5jZV9tZXRob2RzXG4gIGFsaWFzIHB1YmxpY19tZXRob2RfZGVmaW5lZD8gbWV0aG9kX2RlZmluZWQ/XG5lbmRcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiBwcml2YXRlX21ldGhvZHMoKm1ldGhvZHMpXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgcHJvdGVjdGVkX21ldGhvZHMgcHJpdmF0ZV9tZXRob2RzXG4gIGFsaWFzIHByaXZhdGVfaW5zdGFuY2VfbWV0aG9kcyBwcml2YXRlX21ldGhvZHNcbiAgYWxpYXMgcHJvdGVjdGVkX2luc3RhbmNlX21ldGhvZHMgcHJpdmF0ZV9tZXRob2RzXG5lbmRcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiBldmFsKCopXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BhbC9vcGFsL2Jsb2IvI3tSVUJZX0VOR0lORV9WRVJTSU9OfS9kb2NzL29wYWxfcGFyc2VyLm1kIGZvciBkZXRhaWxzLlwiXG4gIGVuZFxuZW5kXG5cbmRlZiBzZWxmLnB1YmxpYygqbWV0aG9kcylcbiAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXG5lbmRcblxuZGVmIHNlbGYucHJpdmF0ZSgqbWV0aG9kcylcbiAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiS2VybmVsIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwic2VsZiIsIndhcm4iLCI8Y2xhc3M6U3RyaW5nPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6U3RyaW5nPiIsIm1ldGhvZF9uYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6U3RyaW5nPiIsImRlZmluZV9tZXRob2QiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpTdHJpbmc+IiwiJSIsIjxtb2R1bGU6S2VybmVsPiIsInRhaW50IiwidW50YWludCIsInRhaW50ZWQ/IiwiPGNsYXNzOk1vZHVsZT4iLCJwdWJsaWMiLCJwcml2YXRlX2NsYXNzX21ldGhvZCIsInByaXZhdGVfbWV0aG9kX2RlZmluZWQ/IiwicHJpdmF0ZV9jb25zdGFudCIsInByaXZhdGVfbWV0aG9kcyIsImV2YWwiLCJSVUJZX0VOR0lORV9WRVJTSU9OIiwicHJpdmF0ZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOzs7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLE1BQVFDLE9BQVFDLE9BQUFBLENBQU9DLDBCQUFmLEVBQXVDSCxPQUEvQkU7QUFDaEJGO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsSUFBTUksSUFBQUMsTUFBQUEsQ0FBTUwsTUFBTkssQ0FBZUw7QUFDckJBOztFQUdBTTtFQUFBQTs7OztJQUNHQTtJQUVEQSxPQUlDQyxNQUpELENBQ0UsSUFERixFQUNLLGFBREwsRUFDaUIsUUFEakIsRUFDd0IsT0FEeEIsRUFDOEIsV0FEOUIsRUFDd0MsT0FEeEMsRUFDOEMsU0FEOUMsRUFDc0QsT0FEdEQsRUFDNEQsVUFENUQsRUFFRSxRQUZGLEVBRVMsVUFGVCxFQUVrQixRQUZsQixFQUV5QixNQUZ6QixFQUU4QixPQUY5QixFQUVvQyxXQUZwQyxFQUU4QyxLQUY5QyxFQUVrRCxPQUZsRCxFQUV3RCxTQUZ4RCxF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QTBCLE1BQUl0QixJQUFKc0IsY0FBQUEsb0JBaEhBLEVBZ0hBQTtBQUFBQSxJQUFBQTs7O0lBaEhBO0lBZ0hpQjtJQUNkQSxvREFBREE7RUFERkEsQ0FBQUEsSUFBQUE7QUFoSEExQjsifX0seyJvZmZzZXQiOnsibGluZSI6MzQxMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYmluZGluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OkJpbmRpbmdcbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZShqc2V2YWwsIHNjb3BlX3ZhcmlhYmxlcyA9IFtdLCByZWNlaXZlciA9IHVuZGVmaW5lZCwgc291cmNlX2xvY2F0aW9uID0gbmlsKVxuICAgIEBqc2V2YWwsIEBzY29wZV92YXJpYWJsZXMsIEByZWNlaXZlciwgQHNvdXJjZV9sb2NhdGlvbiA9IFxcXG4gICAgICBqc2V2YWwsIHNjb3BlX3ZhcmlhYmxlcywgcmVjZWl2ZXIsIHNvdXJjZV9sb2NhdGlvblxuICAgIHJlY2VpdmVyID0ganNfZXZhbCgnc2VsZicpIHVubGVzcyBgdHlwZW9mIHJlY2VpdmVyICE9PSB1bmRlZmluZWRgXG4gIGVuZFxuXG4gIGRlZiBqc19ldmFsKCphcmdzKVxuICAgIGlmIEBqc2V2YWxcbiAgICAgIEBqc2V2YWwuY2FsbCgqYXJncylcbiAgICBlbHNlXG4gICAgICA6Oktlcm5lbC5yYWlzZSAnRXZhbHVhdGlvbiBvbiBhIFByb2MjYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbG9jYWxfdmFyaWFibGVfZ2V0KHN5bWJvbClcbiAgICBqc19ldmFsKHN5bWJvbClcbiAgcmVzY3VlIDo6RXhjZXB0aW9uXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwibG9jYWwgdmFyaWFibGUgYCN7c3ltYm9sfScgaXMgbm90IGRlZmluZWQgZm9yICN7aW5zcGVjdH1cIlxuICBlbmRcblxuICBkZWYgbG9jYWxfdmFyaWFibGVfc2V0KHN5bWJvbCwgdmFsdWUpXG4gICAgYE9wYWwuQmluZGluZy50bXBfdmFsdWUgPSB2YWx1ZWBcbiAgICBqc19ldmFsKFwiI3tzeW1ib2x9ID0gT3BhbC5CaW5kaW5nLnRtcF92YWx1ZVwiKVxuICAgIGBkZWxldGUgT3BhbC5CaW5kaW5nLnRtcF92YWx1ZWBcbiAgICB2YWx1ZVxuICBlbmRcblxuICBkZWYgbG9jYWxfdmFyaWFibGVzXG4gICAgQHNjb3BlX3ZhcmlhYmxlc1xuICBlbmRcblxuICBkZWYgbG9jYWxfdmFyaWFibGVfZGVmaW5lZD8odmFsdWUpXG4gICAgQHNjb3BlX3ZhcmlhYmxlcy5pbmNsdWRlPyh2YWx1ZSlcbiAgZW5kXG5cbiAgZGVmIGV2YWwoc3RyLCBmaWxlID0gbmlsLCBsaW5lID0gbmlsKVxuICAgIHJldHVybiByZWNlaXZlciBpZiBzdHIgPT0gJ3NlbGYnXG5cbiAgICA6Oktlcm5lbC5ldmFsKHN0ciwgc2VsZiwgZmlsZSwgbGluZSlcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOnJlY2VpdmVyLCA6c291cmNlX2xvY2F0aW9uXG5lbmRcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiBiaW5kaW5nXG4gICAgOjpLZXJuZWwucmFpc2UgXCJPcGFsIGRvZXNuJ3Qgc3VwcG9ydCBkeW5hbWljIGNhbGxzIHRvIGJpbmRpbmdcIlxuICBlbmRcbmVuZFxuXG5UT1BMRVZFTF9CSU5ESU5HID0gOjpCaW5kaW5nLm5ldyhcbiAgJXh7XG4gICAgZnVuY3Rpb24oanMpIHtcbiAgICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKFwic2VsZlwiLCBcInJldHVybiBcIiArIGpzKSkoc2VsZik7XG4gICAgfVxuICB9LFxuICBbXSwgc2VsZiwgWyc8bWFpbj4nLCAwXVxuKVxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6QmluZGluZz4iLCJpbml0aWFsaXplIiwianNldmFsIiwic2NvcGVfdmFyaWFibGVzIiwicmVjZWl2ZXIiLCJzb3VyY2VfbG9jYXRpb24iLCJAanNldmFsIiwiQHNjb3BlX3ZhcmlhYmxlcyIsIkByZWNlaXZlciIsIkBzb3VyY2VfbG9jYXRpb24iLCJzZWxmIiwianNfZXZhbCIsImNhbGwiLCJhcmdzIiwiS2VybmVsIiwicmFpc2UiLCJsb2NhbF92YXJpYWJsZV9nZXQiLCJzeW1ib2wiLCJFeGNlcHRpb24iLCJOYW1lRXJyb3IiLCJpbnNwZWN0IiwibG9jYWxfdmFyaWFibGVfc2V0IiwidmFsdWUiLCJsb2NhbF92YXJpYWJsZXMiLCJsb2NhbF92YXJpYWJsZV9kZWZpbmVkPyIsImluY2x1ZGU/IiwiZXZhbCIsInN0ciIsImZpbGUiLCJsaW5lIiwiYXR0cl9yZWFkZXIiLCI8bW9kdWxlOktlcm5lbD4iLCJiaW5kaW5nIiwiQmluZGluZyIsIm5ldyIsIjAiXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7O0FBRUVDLElBQUFBLDBCQUFBQSxzQkFBZUMsTUFBRCxFQUFTQyxlQUFULEVBQStCQyxRQUEvQixFQUFxREMsZUFBbkVKO0FBQUFBLE1BQUFBOzs7TUFBdUIsK0NBQWtCOztNQUEwQiwrQ0FBa0I7TUFDbkYsS0FDRSxDQUFBQyxNQUFBLEVBQVFDLGVBQVIsRUFBeUJDLFFBQXpCLEVBQW1DQyxlQUFuQyxDQURGLEVBQUFDLENBQUFBLGNBQUEsS0FBQUEsQ0FBQSxFQUFTQyxDQUFBQSx1QkFBVCxLQUFTQSxDQUFULEVBQTJCQyxDQUFBQSxnQkFBM0IsS0FBMkJBLENBQTNCLEVBQXNDQyxDQUFBQSx1QkFBdEMsS0FBc0NBLENBQXRDO01BRUEsSUFBQSxRQUFtQ1IsNkJBQW5DLENBQUE7UUFMSkEsT0FBQTtNQUtJO1FBQUFBLE9BQUFHLENBQUFBLFdBQVdNLElBQUFDLFNBQUFBLENBQVFWLE1BQVJVLENBQVhQO01BQUE7SUFIRkgsQ0FBQUEsSUFBQUE7O0FBTUFVLElBQUFBLHVCQUFBQSxtQkFSRixFQVFFQTtBQUFBQSxNQUFBQTs7O01BUkY7TUFRYztNQUNWLElBQUEsUUFBR0wsV0FBSCxDQUFBO1FBQ0VLLE9BQU9DLE1BQVBOLFdBQU9NLFFBQUFBLEVBQU0sTUFBQ0MsSUFBRCxDQUFORDtNQURUO1FBR0VELE9BQUFHLE9BQVFDLE9BQUFBLENBQU9KLCtDQUFQSTtNQUhWO0lBREZKLENBQUFBLElBQUFBOztBQVFBSyxJQUFBQSxrQ0FBQUEsOEJBQXVCQyxNQUF2QkQ7QUFBQUEsTUFBQUE7O01BQ0U7UUFBQUEsT0FBQU4sSUFBQUMsU0FBQUEsQ0FBUU0sTUFBUk47TUFBQTtRQUNGLHNCQUFPLENBQUFPLGdCQUFBLENBQVA7VUFBQTtZQUNFRixPQUFBRixPQUFRQyxPQUFBQSxDQUFPSSxnQkFBZixFQUE2Qkgsa0JBQUQsR0FBQSxDQUFtQkMsTUFBbkIsQ0FBQSxHQUEwQkQsdUJBQTFCLEdBQUEsQ0FBaUROLElBQUFVLFNBQUFBLENBQUFBLENBQWpELENBQXBCTDtVQURWO1FBQUEsQ0FERTtNQUFBO0lBREZDLENBQUFBLEdBQUFBOztBQU1BSyxJQUFBQSxrQ0FBQUEsOEJBQXVCSixNQUFELEVBQVNLLEtBQS9CRDtBQUFBQSxNQUFBQTs7O01BQ0dBO01BQ0RYLElBQUFDLFNBQUFBLENBQVEsRUFBQSxHQUFBLENBQUdNLE1BQUgsQ0FBQSxHQUFVSSwyQkFBbEJWO01BQ0NVO01BQ0RBLE9BQUFDO0lBSkZELENBQUFBLEdBQUFBOztBQU9BRSxJQUFBQSwrQkFBQUEsYUFDRSxpQkFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHVDQUFBQSxnREFBNEJGLEtBQTVCRTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWpCLG9CQUFnQmtCLGFBQUFBLENBQVVILEtBQVZHO0lBRGxCRCxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsb0JBQUFBLHlCQUFTQyxHQUFELEVBQU1DLElBQU4sRUFBa0JDLElBQTFCSCxHQUFBQSxNQUFBQSxJQUFBQSx3Q0FBQUE7QUFBQUEsTUFBQUE7OztNQUFjLHlCQUFPO01BQUsseUJBQU87TUFDL0IsSUFBQSxNQUFtQkMsR0FBbkIsRUFBMEJELE1BQTFCLENBQUE7UUFBQSxPQUFPaEIsSUFBQU4sVUFBQUEsQ0FBQUE7TUFBUDtNQUVBc0IsT0FBQVosT0FBUVksTUFBQUEsQ0FBTUMsR0FBZCxFQUFtQmpCLElBQW5CLEVBQXlCa0IsSUFBekIsRUFBK0JDLElBQXZCSCxFQUhWQTtRQUFBQTtRQUFBQTtNQUFBQTtJQUFBQSxDQUFBQSxJQUFBQTtJQU1BMUIsT0FBQVUsSUFBQW9CLGFBQUFBLENBQVksVUFBWixFQUF1QixpQkFBdkJBO0VBM0NGOUIsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQThDQStCO0VBQUFBOzs7SUFDRUEsT0FBQUMsdUJBQUFBLG1CQUFBQTtBQUFBQTtNQUNFQSxPQUFBbEIsT0FBUUMsT0FBQUEsQ0FBT2lCLCtDQUFQakI7SUFEVmlCLENBQUFBLEdBQUFBO0VBREZELEdBQU8sSUFBUEE7RUFNQWhDLE9BQUEsNENBQW1Ca0MsY0FBU0MsS0FBQUE7QUFFNUJuQztBQUNBQTtBQUNBQTtBQUNBQSxFQUxtQixFQU1qQixFQU5pQixFQU1iVyxJQU5hLEVBTVAsQ0FBQ1gsUUFBRCxFQUFXb0MsQ0FBWCxDQU5nQkQsQ0FBNUI7QUFwREFuQzsifX0seyJvZmZzZXQiOnsibGluZSI6MzUxOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvY2Vzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgOjpQcm9jZXNzXG4gIEBfX2Nsb2Nrc19fID0gW11cbiAgZGVmIHNlbGYuX19yZWdpc3Rlcl9jbG9ja19fKG5hbWUsIGZ1bmMpXG4gICAgY29uc3Rfc2V0IG5hbWUsIEBfX2Nsb2Nrc19fLnNpemVcbiAgICBAX19jbG9ja3NfXyA8PCBmdW5jXG4gIGVuZFxuXG4gIF9fcmVnaXN0ZXJfY2xvY2tfXyA6Q0xPQ0tfUkVBTFRJTUUsIGBmdW5jdGlvbigpIHsgcmV0dXJuIERhdGUubm93KCkgfWBcblxuICBtb25vdG9uaWMgPSBmYWxzZVxuXG4gICV4e1xuICAgIGlmIChPcGFsLmdsb2JhbC5wZXJmb3JtYW5jZSkge1xuICAgICAgbW9ub3RvbmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoT3BhbC5nbG9iYWwucHJvY2VzcyAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgICAgLy8gbGV0IG5vdyBiZSB0aGUgYmFzZSB0byBnZXQgc21hbGxlciBudW1iZXJzXG4gICAgICB2YXIgaHJ0aW1lX2Jhc2UgPSBwcm9jZXNzLmhydGltZSgpO1xuXG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lKGhydGltZV9iYXNlKTtcbiAgICAgICAgdmFyIHVzID0gKGhydGltZVsxXSAvIDEwMDApIHwgMDsgLy8gY3V0IGJlbG93IG1pY3Jvc2VjcztcbiAgICAgICAgcmV0dXJuICgoaHJ0aW1lWzBdICogMTAwMCkgKyAodXMgLyAxMDAwKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIF9fcmVnaXN0ZXJfY2xvY2tfXyg6Q0xPQ0tfTU9OT1RPTklDLCBtb25vdG9uaWMpIGlmIG1vbm90b25pY1xuXG4gIGRlZiBzZWxmLnBpZFxuICAgIDBcbiAgZW5kXG5cbiAgZGVmIHNlbGYudGltZXNcbiAgICB0ID0gOjpUaW1lLm5vdy50b19mXG4gICAgOjpCZW5jaG1hcms6OlRtcy5uZXcodCwgdCwgdCwgdCwgdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xvY2tfZ2V0dGltZShjbG9ja19pZCwgdW5pdCA9IDpmbG9hdF9zZWNvbmQpXG4gICAgKGNsb2NrID0gQF9fY2xvY2tzX19bY2xvY2tfaWRdKSB8fCA6Oktlcm5lbC5yYWlzZSg6OkVycm5vOjpFSU5WQUwsIFwiY2xvY2tfZ2V0dGltZSgje2Nsb2NrX2lkfSkgI3tAX19jbG9ja3NfX1tjbG9ja19pZF19XCIpXG4gICAgJXh7XG4gICAgICB2YXIgbXMgPSBjbG9jaygpO1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ2Zsb2F0X3NlY29uZCc6ICAgICAgcmV0dXJuICAobXMgLyAxMDAwKTsgICAgICAgICAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhIGZsb2F0IChkZWZhdWx0KVxuICAgICAgICBjYXNlICdmbG9hdF9taWxsaXNlY29uZCc6IHJldHVybiAgKG1zIC8gMSk7ICAgICAgICAgICAgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhcyBhIGZsb2F0XG4gICAgICAgIGNhc2UgJ2Zsb2F0X21pY3Jvc2Vjb25kJzogcmV0dXJuICAobXMgKiAxMDAwKTsgICAgICAgICAvLyBudW1iZXIgb2YgbWljcm9zZWNvbmRzIGFzIGEgZmxvYXRcbiAgICAgICAgY2FzZSAnc2Vjb25kJzogICAgICAgICAgICByZXR1cm4gKChtcyAvIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBzZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAvIDEpICAgICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICdtaWNyb3NlY29uZCc6ICAgICAgIHJldHVybiAoKG1zICogMTAwMCkgICAgfCAwKTsgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ25hbm9zZWNvbmQnOiAgICAgICAgcmV0dXJuICgobXMgKiAxMDAwMDAwKSB8IDApOyAvLyBudW1iZXIgb2YgbmFub3NlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBkZWZhdWx0OiAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHVuaXQ6ICN7dW5pdH1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6UHJvY2Vzcz4iLCJAX19jbG9ja3NfXyIsIl9fcmVnaXN0ZXJfY2xvY2tfXyIsInNlbGYiLCJuYW1lIiwiZnVuYyIsImNvbnN0X3NldCIsInNpemUiLCI8PCIsIm1vbm90b25pYyIsInBpZCIsIjAiLCJ0aW1lcyIsInQiLCJUaW1lIiwibm93IiwidG9fZiIsIkJlbmNobWFyazo6VG1zIiwiQmVuY2htYXJrIiwibmV3IiwiY2xvY2tfZ2V0dGltZSIsImNsb2NrX2lkIiwidW5pdCIsIiRyZXRfb3JfMSIsImNsb2NrIiwiW10iLCJLZXJuZWwiLCJyYWlzZSIsIkVycm5vOjpFSU5WQUwiLCJFcnJubyIsIkFyZ3VtZW50RXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxrQkFBYztJQUNkQyxNQUFJQyxJQUFKRCx5QkFBQUEsOEJBQTRCRSxJQUFELEVBQU9DLElBQWxDSDtBQUFBQSxNQUFBQTtBQUFBQTs7O01BQ0VDLElBQUFHLFdBQUFBLENBQVVGLElBQVYsRUFBZ0JILGVBQVdNLE1BQUFBLENBQUFBLENBQTNCRDtNQUNBSixPQUFBRCxlQUFZTyxPQUFBQSxDQUFHSCxJQUFIRztJQUZkTixDQUFBQSxHQUFBQTtJQUtBQyxJQUFBRCxvQkFBQUEsQ0FBbUIsZ0JBQW5CLEVBQXFDRixnQ0FBckNFO0lBRUFPLFlBQVk7O0FBR2RUO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUVFLElBQUEsUUFBbURTLFNBQW5ELENBQUE7TUFBQU4sSUFBQUQsb0JBQUFBLENBQW1CLGlCQUFuQixFQUFxQ08sU0FBckNQO0lBQUE7SUFFQVEsTUFBSVAsSUFBSk8sVUFBQUEsWUFDRUMsQ0FERkQsQ0FBQUEsR0FBQUE7SUFJQUUsTUFBSVQsSUFBSlMsWUFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsSUFBSUMsV0FBTUMsS0FBQUEsQ0FBQUEsQ0FBSUMsTUFBQUEsQ0FBQUE7TUFDZEosT0FBQUssSUFBQUMsZ0JBQUFELFFBQWdCRSxLQUFBQSxDQUFLTixDQUFyQixFQUF3QkEsQ0FBeEIsRUFBMkJBLENBQTNCLEVBQThCQSxDQUE5QixFQUFpQ0EsQ0FBakJNO0lBRmxCUCxDQUFBQSxHQUFBQTtJQUtBWixPQUFBb0IsTUFBSWpCLElBQUppQixvQkFBQUEseUJBQXVCQyxRQUFELEVBQVdDLElBQWpDRjtBQUFBQSxNQUFBQTtBQUFBQTs7O01BQWlDLHlCQUFPO01BQ3RDLElBQUEsUUFBQUcsQ0FBQUEsWUFBQ0MsQ0FBQUEsUUFBUXZCLGVBQVd3QixPQUFBQSxDQUFDSixRQUFESSxDQUFuQkQsQ0FBREQsQ0FBQSxDQUFBO1FBQUE7TUFBQTtRQUFtQ0csT0FBUUMsT0FBQUEsQ0FBT0MsSUFBQUMsWUFBQUQsV0FBZixFQUFpQ1IsZ0JBQUQsR0FBQSxDQUFpQkMsUUFBakIsQ0FBQSxHQUEwQkQsSUFBMUIsR0FBQSxDQUE4Qm5CLGVBQVd3QixPQUFBQSxDQUFDSixRQUFESSxDQUF6QyxDQUF4QkU7TUFBM0M7O0FBRUpQO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQk0sT0FBUUMsT0FBQUEsQ0FBT0csb0JBQWYsRUFBaUNWLG1CQUFELEdBQUEsQ0FBb0JFLElBQXBCLENBQXhCSztBQUMzQlA7QUFDQUE7SUFkRUEsQ0FBQUEsSUFBQUE7RUF4Q0ZwQixHQUFPLElBQVBBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNTk1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5cbmNsYXNzIDo6RW5jb2RpbmdcbiAgZGVmIHNlbGYucmVnaXN0ZXIobmFtZSwgb3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgbmFtZXMgPSBbbmFtZV0gKyAob3B0aW9uc1s6YWxpYXNlc10gfHwgW10pXG4gICAgYXNjaWkgPSBvcHRpb25zWzphc2NpaV0gfHwgZmFsc2VcbiAgICBkdW1teSA9IG9wdGlvbnNbOmR1bW15XSB8fCBmYWxzZVxuXG4gICAgaWYgb3B0aW9uc1s6aW5oZXJpdHNdXG4gICAgICBlbmNvZGluZyA9IG9wdGlvbnNbOmluaGVyaXRzXS5jbG9uZVxuICAgICAgZW5jb2RpbmcuaW5pdGlhbGl6ZShuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIGVsc2VcbiAgICAgIGVuY29kaW5nID0gbmV3KG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgZW5kXG4gICAgZW5jb2RpbmcuaW5zdGFuY2VfZXZhbCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgcmVnaXN0ZXIgPSBgT3BhbC5lbmNvZGluZ3NgXG4gICAgbmFtZXMuZWFjaCBkbyB8ZW5jb2RpbmdfbmFtZXxcbiAgICAgIGNvbnN0X3NldCBlbmNvZGluZ19uYW1lLnRyKCctJywgJ18nKSwgZW5jb2RpbmdcbiAgICAgIHJlZ2lzdGVyLkpTW2VuY29kaW5nX25hbWVdID0gZW5jb2RpbmdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmluZChuYW1lKVxuICAgIHJldHVybiBkZWZhdWx0X2V4dGVybmFsIGlmIG5hbWUgPT0gOmRlZmF1bHRfZXh0ZXJuYWxcbiAgICBgcmV0dXJuIE9wYWwuZmluZF9lbmNvZGluZyhuYW1lKWBcbiAgZW5kXG5cbiAgc2luZ2xldG9uX2NsYXNzLmF0dHJfYWNjZXNzb3IgOmRlZmF1bHRfZXh0ZXJuYWxcblxuICBhdHRyX3JlYWRlciA6bmFtZSwgOm5hbWVzXG5cbiAgZGVmIGluaXRpYWxpemUobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBAbmFtZSAgPSBuYW1lXG4gICAgQG5hbWVzID0gbmFtZXNcbiAgICBAYXNjaWkgPSBhc2NpaVxuICAgIEBkdW1teSA9IGR1bW15XG4gIGVuZFxuXG4gIGRlZiBhc2NpaV9jb21wYXRpYmxlP1xuICAgIEBhc2NpaVxuICBlbmRcblxuICBkZWYgZHVtbXk/XG4gICAgQGR1bW15XG4gIGVuZFxuXG4gIGRlZiBiaW5hcnk/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBAbmFtZVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxFbmNvZGluZzoje0BuYW1lfSN7JyAoZHVtbXkpJyBpZiBAZHVtbXl9PlwiXG4gIGVuZFxuXG4gICMgbWV0aG9kcyB0byBpbXBsZW1lbnQgcGVyIGVuY29kaW5nXG4gIGRlZiBjaGFyc2l6ZShzdHJpbmcpXG4gICAgJXh7XG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICghKGNoYXJjb2RlID49IDB4RDgwMCAmJiBjaGFyY29kZSA8PSAweERCRkYpKSB7XG4gICAgICAgICAgbGVuKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9jaGFyKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGxvd19zdXJyb2dhdGUgPSBcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGNociA9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaGFyY29kZSA+PSAweERDMDAgJiYgY2hhcmNvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgbG93X3N1cnJvZ2F0ZSA9IGNocjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA+PSAweEQ4MDAgJiYgY2hhcmNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgY2hyID0gbG93X3N1cnJvZ2F0ZSArIGNocjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nLmVuY29kaW5nLm5hbWUgIT0gXCJVVEYtOFwiKSB7XG4gICAgICAgICAgY2hyID0gbmV3IFN0cmluZyhjaHIpO1xuICAgICAgICAgIGNoci5lbmNvZGluZyA9IHN0cmluZy5lbmNvZGluZztcbiAgICAgICAgfVxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgY2hyKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoKilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKCopXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIDo6RW5jb2RpbmdFcnJvciA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG4gIGNsYXNzIDo6Q29tcGF0aWJpbGl0eUVycm9yIDwgOjpFbmNvZGluZ0Vycm9yOyBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtOCcsIGFsaWFzZXM6IFsnQ1A2NTAwMSddLCBhc2NpaTogdHJ1ZSBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9mNTJkZmZkOWRmMDQ0NWI5M2MwYzkwNjVjMmY4ZjBmNDZiMmM3MjlhL2luZGV4LmpzI0wxOTU0LUwyMDMyXG4gICAgICB2YXIgdW5pdHMgPSBJbmZpbml0eTtcbiAgICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkRgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgICAgIC8vIGVuY29kZSB1dGY4XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgfCAweEMwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweEMgfCAweEUwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVhaztcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEludmFsaWQgY29kZSBwb2ludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2TEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoICogMmBcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2QkUnLCBpbmhlcml0czogOjpFbmNvZGluZzo6VVRGXzE2TEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aCAqIDRgXG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkJFJywgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OlVURl8zMkxFIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdBU0NJSS04QklUJywgYWxpYXNlczogWydCSU5BUlknXSwgYXNjaWk6IHRydWUgZG9cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNociA9IG5ldyBTdHJpbmcoc3RyaW5nLmNoYXJBdChpKSk7XG4gICAgICAgIGNoci5lbmNvZGluZyA9IHN0cmluZy5lbmNvZGluZztcbiAgICAgICAgI3t5aWVsZCBgY2hyYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGJpbmFyeT9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ0lTTy04ODU5LTEnLCBhbGlhc2VzOiBbJ0lTTzg4NTktMSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OkFTQ0lJXzhCSVRcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VTLUFTQ0lJJywgYWxpYXNlczogWydBU0NJSSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OkFTQ0lJXzhCSVRcblxuY2xhc3MgOjpTdHJpbmdcbiAgYXR0cl9yZWFkZXIgOmVuY29kaW5nXG4gIGF0dHJfcmVhZGVyIDppbnRlcm5hbF9lbmNvZGluZ1xuICBgT3BhbC5wcm9wKFN0cmluZy5wcm90b3R5cGUsICdieXRlcycsIG5pbClgXG4gIGBPcGFsLnByb3AoU3RyaW5nLnByb3RvdHlwZSwgJ2VuY29kaW5nJywgI3s6OkVuY29kaW5nOjpVVEZfOH0pYFxuICBgT3BhbC5wcm9wKFN0cmluZy5wcm90b3R5cGUsICdpbnRlcm5hbF9lbmNvZGluZycsICN7OjpFbmNvZGluZzo6VVRGXzh9KWBcblxuICBkZWYgYlxuICAgIGR1cC5mb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplXG4gICAgQGludGVybmFsX2VuY29kaW5nLmJ5dGVzaXplKHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9ieXRlKSB7IGJ5dGVzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGludGVybmFsX2VuY29kaW5nLmVhY2hfYnl0ZShzZWxmLCAmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBieXRlc1xuICAgICMgUkVNSU5EOiByZXF1aXJlZCB3aGVuIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIG90aGVyd2lzZSB0aGUgZm9sbG93aW5nIGVycm9yIHdpbGwgYmUgdGhyb3duOlxuICAgICMgQ2Fubm90IGNyZWF0ZSBwcm9wZXJ0eSAnYnl0ZXMnIG9uIHN0cmluZyAnYWJjJ1xuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gI3tgbmV3IFN0cmluZyhzZWxmKWAuZWFjaF9ieXRlLnRvX2F9O1xuICAgICAgfVxuICAgIH1cblxuICAgIEBieXRlcyB8fD0gZWFjaF9ieXRlLnRvX2FcbiAgICBAYnl0ZXMuZHVwXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jaGFyKSB7IGxlbmd0aCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIEBlbmNvZGluZy5lYWNoX2NoYXIoc2VsZiwgJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2hhcnMoJmJsb2NrKVxuICAgIHJldHVybiBlYWNoX2NoYXIudG9fYSB1bmxlc3MgYmxvY2tcblxuICAgIGVhY2hfY2hhcigmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvZGVwb2ludCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2NvZGVwb2ludCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAje3lpZWxkIGBzZWxmLmNvZGVQb2ludEF0KGkpYH07XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvZGVwb2ludHMoJmJsb2NrKVxuICAgICMgSWYgYSBibG9jayBpcyBnaXZlbiwgd2hpY2ggaXMgYSBkZXByZWNhdGVkIGZvcm0sIHdvcmtzIHRoZSBzYW1lIGFzIGVhY2hfY29kZXBvaW50LlxuICAgIHJldHVybiBlYWNoX2NvZGVwb2ludCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuICAgIGVhY2hfY29kZXBvaW50LnRvX2FcbiAgZW5kXG5cbiAgZGVmIGVuY29kZShlbmNvZGluZylcbiAgICBgT3BhbC5lbmMoc2VsZiwgZW5jb2RpbmcpYFxuICBlbmRcblxuICBkZWYgZm9yY2VfZW5jb2RpbmcoZW5jb2RpbmcpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZjtcblxuICAgICAgaWYgKGVuY29kaW5nID09PSBzdHIuZW5jb2RpbmcpIHsgcmV0dXJuIHN0cjsgfVxuXG4gICAgICBlbmNvZGluZyA9ICN7OjpPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIDo6U3RyaW5nLCA6dG9fcyl9O1xuICAgICAgZW5jb2RpbmcgPSAjezo6RW5jb2RpbmcuZmluZChlbmNvZGluZyl9O1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHN0ci5lbmNvZGluZykgeyByZXR1cm4gc3RyOyB9XG5cbiAgICAgIHN0ciA9IE9wYWwuc2V0X2VuY29kaW5nKHN0ciwgZW5jb2RpbmcpO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldGJ5dGUoaWR4KVxuICAgIHN0cmluZ19ieXRlcyA9IGJ5dGVzXG4gICAgaWR4ID0gOjpPcGFsLmNvZXJjZV90byEoaWR4LCA6OkludGVnZXIsIDp0b19pbnQpXG4gICAgcmV0dXJuIGlmIHN0cmluZ19ieXRlcy5sZW5ndGggPCBpZHhcblxuICAgIHN0cmluZ19ieXRlc1tpZHhdXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgJXtcbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBvdGhlci5lbmNvZGluZztcbiAgICAgIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcgPSBvdGhlci5pbnRlcm5hbF9lbmNvZGluZztcbiAgICB9XG4gIGVuZFxuXG4gICMgc3R1YlxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLmRlZmF1bHRfZXh0ZXJuYWwgPSBfX0VOQ09ESU5HX19cbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RW5jb2Rpbmc+IiwicmVnaXN0ZXIiLCJuYW1lIiwib3B0aW9ucyIsIm5hbWVzIiwiKyIsIiRyZXRfb3JfMSIsIltdIiwiYXNjaWkiLCJkdW1teSIsImVuY29kaW5nIiwiY2xvbmUiLCJpbml0aWFsaXplIiwibmV3IiwiYmxvY2tfZ2l2ZW4/IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImVhY2giLCJibG9jayBpbiByZWdpc3RlciIsImVuY29kaW5nX25hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlZ2lzdGVyIiwiY29uc3Rfc2V0IiwidHIiLCJmaW5kIiwiZGVmYXVsdF9leHRlcm5hbCIsInNpbmdsZXRvbl9jbGFzcyIsImF0dHJfYWNjZXNzb3IiLCJhdHRyX3JlYWRlciIsIkBuYW1lIiwiQG5hbWVzIiwiQGFzY2lpIiwiQGR1bW15IiwiYXNjaWlfY29tcGF0aWJsZT8iLCJkdW1teT8iLCJiaW5hcnk/IiwidG9fcyIsImluc3BlY3QiLCJjaGFyc2l6ZSIsInN0cmluZyIsImVhY2hfY2hhciIsImVhY2hfYnl0ZSIsIktlcm5lbCIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsImJ5dGVzaXplIiwiPGNsYXNzOkVuY29kaW5nRXJyb3I+IiwiU3RhbmRhcmRFcnJvciIsIjxjbGFzczpDb21wYXRpYmlsaXR5RXJyb3I+IiwiRW5jb2RpbmdFcnJvciIsIkVuY29kaW5nIiwiYmxvY2sgaW4gPHRvcCAocmVxdWlyZWQpPiIsImJsb2NrICgyIGxldmVscykgaW4gPHRvcCAocmVxdWlyZWQpPiIsImJ5dGVzIiwibGVuZ3RoIiwiRW5jb2Rpbmc6OlVURl8xNkxFIiwiMCIsIkVuY29kaW5nOjpVVEZfMzJMRSIsIkVuY29kaW5nOjpBU0NJSV84QklUIiwiPGNsYXNzOlN0cmluZz4iLCJFbmNvZGluZzo6VVRGXzgiLCJiIiwiZHVwIiwiZm9yY2VfZW5jb2RpbmciLCJAaW50ZXJuYWxfZW5jb2RpbmciLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2hfYnl0ZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9ieXRlIiwidG9fYSIsIkBieXRlcyIsImJsb2NrIGluIGVhY2hfY2hhciIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9jaGFyIiwiQGVuY29kaW5nIiwiY2hhcnMiLCJlYWNoX2NvZGVwb2ludCIsImNvZGVwb2ludHMiLCJlbmNvZGUiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsImdldGJ5dGUiLCJpZHgiLCJzdHJpbmdfYnl0ZXMiLCJJbnRlZ2VyIiwiPCIsImluaXRpYWxpemVfY29weSIsIm90aGVyIiwidmFsaWRfZW5jb2Rpbmc/IiwiZGVmYXVsdF9leHRlcm5hbD0iXSwibWFwcGluZ3MiOiJBQUFBQSwwQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBRUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlILElBQUpHLGVBQUFBLG9CQUFrQkMsSUFBRCxFQUFPQyxPQUF4QkY7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBd0IsK0JBQVUsWUFBQTtNQUNoQ0csUUFBZUMsU0FBUCxDQUFDSCxJQUFELENBQU9HLEVBQUcsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBSCxPQUFPSSxPQUFBQSxDQUFDLFNBQURBLENBQVBELENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQXFCLEVBQXJCLENBQUEsQ0FBSEQ7TUFDZkcsUUFBUSxDQUFBLFFBQUFGLENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7TUFD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LG1CQUFZQyxHQUFaRDtBQUFBQSxNQUFBQTs7O01BQ0VFLGVBQWVwRixJQUFBdUQsT0FBQUEsQ0FBQUE7TUFDZjRCLE1BQU1KLEtBQU1DLGVBQUFBLENBQVlHLEdBQWxCLEVBQXVCRSxjQUF2QixFQUFrQyxRQUE1Qkw7TUFDWixJQUFBLFFBQThCTSxPQUFwQkYsWUFBWTVCLFFBQUFBLENBQUFBLENBQVE4QixFQUFFSCxHQUFGRyxDQUE5QixDQUFBO1FBQUEsT0FBQTtNQUFBO01BRUFKLE9BQUFFLFlBQVkzRSxPQUFBQSxDQUFDMEUsR0FBRDFFO0lBTGR5RSxDQUFBQSxHQUFBQTs7QUFRQUssSUFBQUEsK0JBQUFBLDJCQUFvQkMsS0FBcEJEO0FBQUFBO01BQ0VBLE9BQUVBLElBQUYsR0FDSkEseUNBREksR0FFSkEsMkRBRkksR0FHSkE7SUFKRUEsQ0FBQUEsR0FBQUE7SUFRQTFCLE9BQUE0QiwrQkFBQUEsWUFDRSxJQURGQSxDQUFBQSxHQUFBQTtFQXZHRjVCLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUE0R0E5RCxPQUFVMkYsTUFBQUEsQ0FBb0I1QixJQTNaOUJWLGNBMlo4QlUsVUFBcEI0QixDQUFBQSxFQUFBQSxNQUFWdEMsZUFBVXNDLHFCQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtBQTNaVjNGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MTE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9taW5pLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvYmFzZSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9uaWwnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2Jvb2xlYW4nXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3N0cmluZydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYXRvcidcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYXJyYXknXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2hhc2gnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL251bWJlcidcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcmFuZ2UnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3Byb2MnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL21ldGhvZCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi92YXJpYWJsZXMnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2lvJ1xuOjpPYmplY3QucmVxdWlyZSAnb3BhbC9yZWdleHBfYW5jaG9ycydcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiT2JqZWN0IiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDRCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixXQUFURTtFQUVSRCxPQUFRQyxTQUFBQSxDQUFTRixhQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLG9CQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixvQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysb0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLG1CQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixZQUFURTtFQUNSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixxQkFBVEU7QUFqQlJGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MTQzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9maWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XG5cbmNsYXNzIDo6RmlsZSA8IDo6SU9cbiAgU2VwYXJhdG9yID0gU0VQQVJBVE9SID0gJy8nXG4gIEFMVF9TRVBBUkFUT1IgPSBuaWxcbiAgUEFUSF9TRVBBUkFUT1IgPSAnOidcbiAgIyBBc3N1bWluZyBjYXNlIGluc2Vuc3RpdmUgZmlsZXN5c3RlbVxuICBGTk1fU1lTQ0FTRSA9IDBcbiAgd2luZG93c19yb290X3J4ID0gJXJ7XlthLXpBLVpdOig/OlxcXFx8XFwvKX1cblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFic29sdXRlX3BhdGgocGF0aCwgYmFzZWRpciA9IG5pbClcbiAgICAgIHNlcCA9IFNFUEFSQVRPUlxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIG5ld19wYXJ0cyA9IFtdXG5cbiAgICAgIHBhdGggPSBwYXRoLnJlc3BvbmRfdG8/KDp0b19wYXRoKSA/IHBhdGgudG9fcGF0aCA6IHBhdGhcbiAgICAgIHBhdGggPSA6Ok9wYWwuY29lcmNlX3RvIShgcGF0aGAsIDo6U3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgICBiYXNlZGlyIHx8PSA6OkRpci5wd2RcbiAgICAgIHBhdGhfYWJzICAgID0gYHBhdGguc3Vic3RyKDAsIHNlcC5sZW5ndGgpID09PSBzZXAgfHwgd2luZG93c19yb290X3J4LnRlc3QocGF0aClgXG4gICAgICBiYXNlZGlyX2FicyA9IGBiYXNlZGlyLnN1YnN0cigwLCBzZXAubGVuZ3RoKSA9PT0gc2VwIHx8IHdpbmRvd3Nfcm9vdF9yeC50ZXN0KGJhc2VkaXIpYFxuXG4gICAgICBpZiBwYXRoX2Fic1xuICAgICAgICBwYXJ0cyAgICAgICA9IHBhdGguc3BsaXQoL1sje3NlcF9jaGFyc31dLylcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QocGF0aCkgPyAnJyA6ICN7cGF0aC5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIGFicyAgICAgICAgID0gdHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBwYXJ0cyAgICAgICA9IGJhc2VkaXIuc3BsaXQoL1sje3NlcF9jaGFyc31dLykgKyBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KGJhc2VkaXIpID8gJycgOiAje2Jhc2VkaXIuc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICBhYnMgICAgICAgICA9IGJhc2VkaXJfYWJzXG4gICAgICBlbmRcblxuICAgICAgJXh7XG4gICAgICAgIHZhciBwYXJ0O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHBhcnQgPT09IG5pbCkgfHxcbiAgICAgICAgICAgIChwYXJ0ID09PSAnJyAgJiYgKChuZXdfcGFydHMubGVuZ3RoID09PSAwKSB8fCBhYnMpKSB8fFxuICAgICAgICAgICAgKHBhcnQgPT09ICcuJyAmJiAoKG5ld19wYXJ0cy5sZW5ndGggPT09IDApIHx8IGFicykpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3X3BhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhYnMgJiYgcGFydHNbMF0gIT09ICcuJykge1xuICAgICAgICAgICN7bmV3X3BhcnRzLnVuc2hpZnQgJy4nfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld19wYXRoID0gbmV3X3BhcnRzLmpvaW4oc2VwKVxuICAgICAgbmV3X3BhdGggPSBsZWFkaW5nX3NlcCArIG5ld19wYXRoIGlmIGFic1xuICAgICAgbmV3X3BhdGhcbiAgICBlbmRcblxuICAgIGRlZiBleHBhbmRfcGF0aChwYXRoLCBiYXNlZGlyID0gbmlsKVxuICAgICAgc2VwID0gU0VQQVJBVE9SXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgaWYgYHBhdGhbMF0gPT09ICd+JyB8fCAoYmFzZWRpciAmJiBiYXNlZGlyWzBdID09PSAnficpYFxuICAgICAgICBob21lID0gRGlyLmhvbWVcbiAgICAgICAgOjpLZXJuZWwucmFpc2UoOjpBcmd1bWVudEVycm9yLCBcImNvdWxkbid0IGZpbmQgSE9NRSBlbnZpcm9ubWVudCAtLSBleHBhbmRpbmcgYH4nXCIpIHVubGVzcyBob21lXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KGhvbWUpID8gJycgOiAje2hvbWUuc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsICdub24tYWJzb2x1dGUgaG9tZScpIHVubGVzcyBob21lLnN0YXJ0X3dpdGg/KGxlYWRpbmdfc2VwKVxuXG4gICAgICAgIGhvbWUgICAgICAgICAgICArPSBzZXBcbiAgICAgICAgaG9tZV9wYXRoX3JlZ2V4cCA9IC9eXFx+KD86I3tzZXB9fCQpL1xuICAgICAgICBwYXRoICAgICAgICAgICAgID0gcGF0aC5zdWIoaG9tZV9wYXRoX3JlZ2V4cCwgaG9tZSlcbiAgICAgICAgYmFzZWRpciAgICAgICAgICA9IGJhc2VkaXIuc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpIGlmIGJhc2VkaXJcbiAgICAgIGVuZFxuICAgICAgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyKVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICAvLyBDb2VyY2UgYSBnaXZlbiBwYXRoIHRvIGEgcGF0aCBzdHJpbmcgdXNpbmcgI3RvX3BhdGggYW5kICN0b19zdHJcbiAgICAgIGZ1bmN0aW9uICRjb2VyY2VfdG9fcGF0aChwYXRoKSB7XG4gICAgICAgIGlmICgkdHJ1dGh5KCN7YHBhdGhgLnJlc3BvbmRfdG8/KDp0b19wYXRoKX0pKSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGguJHRvX3BhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBwYXRoYCwgOjpTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGEgUmVnRXhwIGNvbXBhdGlibGUgY2hhciBjbGFzc1xuICAgICAgZnVuY3Rpb24gJHNlcF9jaGFycygpIHtcbiAgICAgICAgaWYgKCN7QUxUX1NFUEFSQVRPUn0gPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiBPcGFsLmVzY2FwZV9yZWdleHAoI3tTRVBBUkFUT1J9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3BhbC5lc2NhcGVfcmVnZXhwKCN7U0VQQVJBVE9SICsgQUxUX1NFUEFSQVRPUn0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmIGRpcm5hbWUocGF0aCwgbGV2ZWwgPSAxKVxuICAgICAgcmV0dXJuIHBhdGggaWYgbGV2ZWwgPT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImxldmVsIGNhbid0IGJlIG5lZ2F0aXZlXCIgaWYgbGV2ZWwgPCAwXG5cbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBwYXRoID0gYCRjb2VyY2VfdG9fcGF0aChwYXRoKWBcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWJzb2x1dGUgPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoI3tcIl5bI3tzZXBfY2hhcnN9XVwifSkpLCBvdXQ7XG5cbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgc2VwYXJhdG9yc1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlteI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgYmFzZW5hbWVcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgZmluYWwgdHJhaWxpbmcgc2VwYXJhdG9yc1xuXG4gICAgICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICAgIG91dCA9IGFic29sdXRlID8gJy8nIDogJy4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG91dCA9IHBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGV2ZWwgPT0gMSkge1xuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7ZGlybmFtZShgb3V0YCwgbGV2ZWwgLSAxKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGJhc2VuYW1lKG5hbWUsIHN1ZmZpeCA9IG5pbClcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuYW1lID0gYCRjb2VyY2VfdG9fcGF0aChuYW1lKWBcbiAgICAgICV4e1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1ZmZpeCAhPT0gbmlsKSB7XG4gICAgICAgICAgc3VmZml4ID0gI3s6Ok9wYWwuY29lcmNlX3RvIShzdWZmaXgsIDo6U3RyaW5nLCA6dG9fc3RyKX1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWZmaXggPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIoLilbI3tzZXBfY2hhcnN9XSokXCJ9KSwgJyQxJyk7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiXig/Oi4qWyN7c2VwX2NoYXJzfV0pPyhbXiN7c2VwX2NoYXJzfV0rKSRcIn0pLCAnJDEnKTtcblxuICAgICAgICBpZiAoc3VmZml4ID09PSBcIi4qXCIpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9cXC5bXlxcLl0rJC8sICcnKTtcbiAgICAgICAgfSBlbHNlIGlmKHN1ZmZpeCAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1ZmZpeCA9IE9wYWwuZXNjYXBlX3JlZ2V4cChzdWZmaXgpO1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiI3tzdWZmaXh9JFwifSksICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGV4dG5hbWUocGF0aClcbiAgICAgIGBwYXRoID0gJGNvZXJjZV90b19wYXRoKHBhdGgpYFxuICAgICAgZmlsZW5hbWUgPSBiYXNlbmFtZShwYXRoKVxuICAgICAgcmV0dXJuICcnIGlmIGZpbGVuYW1lLmVtcHR5P1xuICAgICAgbGFzdF9kb3RfaWR4ID0gZmlsZW5hbWVbMS4uLTFdLnJpbmRleCgnLicpXG4gICAgICAjIGV4dGVuc2lvbiBuYW1lIG11c3QgY29udGFpbnMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciAuKHNvbWV0aGluZylcbiAgICAgIGxhc3RfZG90X2lkeC5uaWw/IHx8IGxhc3RfZG90X2lkeCArIDEgPT0gZmlsZW5hbWUubGVuZ3RoIC0gMSA/ICcnIDogZmlsZW5hbWVbKGxhc3RfZG90X2lkeCArIDEpLi4tMV1cbiAgICBlbmRcblxuICAgIGRlZiBleGlzdD8ocGF0aClcbiAgICAgIGBPcGFsLm1vZHVsZXNbI3twYXRofV0gIT0gbnVsbGBcbiAgICBlbmRcblxuICAgIGRlZiBkaXJlY3Rvcnk/KHBhdGgpXG4gICAgICBmaWxlcyA9IFtdXG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9wYWwubW9kdWxlcykge1xuICAgICAgICAgICN7ZmlsZXN9LnB1c2goa2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRoID0gcGF0aC5nc3ViKC8oXi4je1NFUEFSQVRPUn0rfCN7U0VQQVJBVE9SfSskKS8pXG4gICAgICBmaWxlID0gZmlsZXMuZmluZCB7IHxmfCBmID1+IC9eI3twYXRofS8gfVxuICAgICAgZmlsZVxuICAgIGVuZFxuXG4gICAgZGVmIGpvaW4oKnBhdGhzKVxuICAgICAgaWYgcGF0aHMuZW1wdHk/XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgZW5kXG4gICAgICByZXN1bHQgPSAnJ1xuICAgICAgcGF0aHMgPSBwYXRocy5mbGF0dGVuLmVhY2hfd2l0aF9pbmRleC5tYXAgZG8gfGl0ZW0sIGluZGV4fFxuICAgICAgICBpZiBpbmRleCA9PSAwICYmIGl0ZW0uZW1wdHk/XG4gICAgICAgICAgU0VQQVJBVE9SXG4gICAgICAgIGVsc2lmIHBhdGhzLmxlbmd0aCA9PSBpbmRleCArIDEgJiYgaXRlbS5lbXB0eT9cbiAgICAgICAgICBTRVBBUkFUT1JcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGl0ZW1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHBhdGhzID0gcGF0aHMucmVqZWN0KCY6ZW1wdHk/KVxuICAgICAgcGF0aHMuZWFjaF93aXRoX2luZGV4IGRvIHxpdGVtLCBpbmRleHxcbiAgICAgICAgbmV4dF9pdGVtID0gcGF0aHNbaW5kZXggKyAxXVxuICAgICAgICBpZiBuZXh0X2l0ZW0ubmlsP1xuICAgICAgICAgIHJlc3VsdCA9IFwiI3tyZXN1bHR9I3tpdGVtfVwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpZiBpdGVtLmVuZF93aXRoPyhTRVBBUkFUT1IpICYmIG5leHRfaXRlbS5zdGFydF93aXRoPyhTRVBBUkFUT1IpXG4gICAgICAgICAgICBpdGVtID0gaXRlbS5zdWIoLyN7U0VQQVJBVE9SfSskLywgJycpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgcmVzdWx0ID0gaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSB8fCBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19XCJcbiAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICBcIiN7cmVzdWx0fSN7aXRlbX0je1NFUEFSQVRPUn1cIlxuICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmVzdWx0XG4gICAgZW5kXG5cbiAgICBkZWYgc3BsaXQocGF0aClcbiAgICAgIHBhdGguc3BsaXQoU0VQQVJBVE9SKVxuICAgIGVuZFxuXG4gICAgYWxpYXMgcmVhbHBhdGggZXhwYW5kX3BhdGhcbiAgICBhbGlhcyBleGlzdHM/IGV4aXN0P1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RmlsZT4iLCIwIiwid2luZG93c19yb290X3J4IiwiYWJzb2x1dGVfcGF0aCIsInBhdGgiLCJiYXNlZGlyIiwic2VwIiwiU0VQQVJBVE9SIiwic2VwX2NoYXJzIiwibmV3X3BhcnRzIiwicmVzcG9uZF90bz8iLCJ0b19wYXRoIiwiT3BhbCIsImNvZXJjZV90byEiLCJTdHJpbmciLCIkcmV0X29yXzEiLCJEaXIiLCJwd2QiLCJwYXRoX2FicyIsImJhc2VkaXJfYWJzIiwicGFydHMiLCJzcGxpdCIsImxlYWRpbmdfc2VwIiwic3ViIiwiYWJzIiwiKyIsInVuc2hpZnQiLCJuZXdfcGF0aCIsImpvaW4iLCJleHBhbmRfcGF0aCIsImhvbWUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJzdGFydF93aXRoPyIsImhvbWVfcGF0aF9yZWdleHAiLCJzZWxmIiwiQUxUX1NFUEFSQVRPUiIsImRpcm5hbWUiLCJsZXZlbCIsIjEiLCI8IiwiLSIsImJhc2VuYW1lIiwibmFtZSIsInN1ZmZpeCIsImV4dG5hbWUiLCJmaWxlbmFtZSIsImVtcHR5PyIsImxhc3RfZG90X2lkeCIsIltdIiwiLTEiLCJyaW5kZXgiLCJuaWw/IiwibGVuZ3RoIiwiZXhpc3Q/IiwiZGlyZWN0b3J5PyIsImZpbGVzIiwiZ3N1YiIsImZpbGUiLCJmaW5kIiwiYmxvY2sgaW4gZGlyZWN0b3J5PyIsImYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRpcmVjdG9yeT8iLCI9fiIsInBhdGhzIiwicmVzdWx0IiwibWFwIiwiZmxhdHRlbiIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIGpvaW4iLCJpdGVtIiwiaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGpvaW4iLCJyZWplY3QiLCJ0b19wcm9jIiwibmV4dF9pdGVtIiwiZW5kX3dpdGg/IiwiSU8iXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLHFDQUFZLHFDQUFZQSxHQUFaLENBQVo7SUFDQSx5Q0FBZ0IsR0FBaEI7SUFDQSwwQ0FBaUJBLEdBQWpCO0lBRUEsdUNBQWNDLENBQWQ7SUFDQUMsa0JBQWtCO0lBRWxCRixPQUFBO01BQUE7Ozs7QUFDRUcsTUFBQUEsNkJBQUFBLHlCQUFr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QVMxQyxnQkFBQUEsQ0FBYTNCLGVBQWIyQixDQUF0QyxDQUFBLENBQUEsQ0FBSDtjQUNFcUMsT0FBT0EsSUFBSWhELEtBQUFBLENBQUssU0FBR2hCLGVBQUgsRUFBYWtFLElBQWIsQ0FBQSxDQUFULEVBQTJCQSxFQUF2QmxEO1lBRGI7WUFHQWtELE9BQUFQLENBQUFBLFNBQVMsQ0FBRyxDQUFBLFFBQUFLLElBQUlNLGNBQUFBLENBQVd0RSxlQUFYc0UsQ0FBSixDQUFBLElBQUEsQ0FBQSxRQUE2QkQsU0FBUzFDLGdCQUFBQSxDQUFhM0IsZUFBYjJCLENBQXRDLENBQUEsQ0FBQSxDQUFILEdBQUEsQ0FDRSxFQUFBLEdBQUEsQ0FBR2dDLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVosQ0FERixJQUFBLENBR0UsRUFBQSxHQUFBLENBQUdMLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVosQ0FBQSxHQUFBLENBQW1CaEUsZUFBbkIsQ0FIRixDQUFBLENBQVQyRDtVQU5GLEVBRkZJLENBQUFBLEdBQUtEO1FBZUx6QyxPQUFBc0M7TUE5QkZ0QyxDQUFBQSxJQUFBQTs7QUFpQ0FQLE1BQUFBLHFCQUFBQSxpQkFBVWpCLElBQVZpQjtBQUFBQTtRQUNFQSxPQUFBakIsSUFBSWlCLE9BQUFBLENBQU9kLGVBQVBjO01BRE5BLENBQUFBLEdBQUFBO01BSUEsYUFBTSxVQUFOLEVBQWUsYUFBZjtNQUNBLE9BQUEsYUFBTSxTQUFOLEVBQWMsUUFBZDtJQW5ORiw0QkFBU2UsSUFBVDtFQVJGcEMsR0FBTSxJQUFOQSxFQUFlOEUsU0FBZjlFO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0NDIzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi90aW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogc2xpY2UsIGRlbnlfZnJvemVuX2FjY2Vzc1xuXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIDo6VGltZSA8IGBEYXRlYFxuICBpbmNsdWRlIDo6Q29tcGFyYWJsZVxuXG4gICV4e1xuICAgIHZhciBkYXlzX29mX3dlZWsgPSAjeyV3W1N1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5IFN1bmRheV19LFxuICAgICAgICBzaG9ydF9kYXlzICAgPSAjeyV3W1N1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdF19LFxuICAgICAgICBzaG9ydF9tb250aHMgPSAjeyV3W0phbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXX0sXG4gICAgICAgIGxvbmdfbW9udGhzICA9ICN7JXdbSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlcl19O1xuICB9XG5cbiAgZGVmIHNlbGYuYXQoc2Vjb25kcywgZnJhYyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgjezo6VGltZSA9PT0gc2Vjb25kc30pIHtcbiAgICAgICAgaWYgKGZyYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBUaW1lIGludG8gYW4gZXhhY3QgbnVtYmVyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoc2Vjb25kcy5nZXRUaW1lKCkpO1xuICAgICAgICByZXN1bHQudGltZXpvbmUgPSBzZWNvbmRzLnRpbWV6b25lO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgc2Vjb25kcyA9ICN7OjpPcGFsLmNvZXJjZV90byEoc2Vjb25kcywgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFjLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGZyYWMgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGZyYWMsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDAgKyAoZnJhYyAvIDEwMDApKTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XG4gICAgICBpZiAoeWVhci4kJGlzX3N0cmluZykge1xuICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHllYXJgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoID09PSBuaWwpIHtcbiAgICAgICAgbW9udGggPSAxO1xuICAgICAgfSBlbHNlIGlmICghbW9udGguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7YG1vbnRoYC5yZXNwb25kX3RvPyg6dG9fc3RyKX0pIHtcbiAgICAgICAgICBtb250aCA9ICN7YG1vbnRoYC50b19zdHJ9O1xuICAgICAgICAgIHN3aXRjaCAobW9udGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ2phbic6IG1vbnRoID0gIDE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZlYic6IG1vbnRoID0gIDI7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hcic6IG1vbnRoID0gIDM7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Fwcic6IG1vbnRoID0gIDQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21heSc6IG1vbnRoID0gIDU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bic6IG1vbnRoID0gIDY7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bCc6IG1vbnRoID0gIDc7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2F1Zyc6IG1vbnRoID0gIDg7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlcCc6IG1vbnRoID0gIDk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29jdCc6IG1vbnRoID0gMTA7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ25vdic6IG1vbnRoID0gMTE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RlYyc6IG1vbnRoID0gMTI7IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IG1vbnRoID0gI3tgbW9udGhgLnRvX2l9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb250aCA9ICN7OjpPcGFsLmNvZXJjZV90byEoYG1vbnRoYCwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm1vbnRoIG91dCBvZiByYW5nZTogI3tgbW9udGhgfVwifVxuICAgICAgfVxuICAgICAgbW9udGggPSBtb250aCAtIDE7XG5cbiAgICAgIGlmIChkYXkgPT09IG5pbCkge1xuICAgICAgICBkYXkgPSAxO1xuICAgICAgfSBlbHNlIGlmIChkYXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgZGF5ID0gcGFyc2VJbnQoZGF5LCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXkgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBkYXlgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRheSA8IDEgfHwgZGF5ID4gMzEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiZGF5IG91dCBvZiByYW5nZTogI3tgZGF5YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPT09IG5pbCkge1xuICAgICAgICBob3VyID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoaG91ci4kJGlzX3N0cmluZykge1xuICAgICAgICBob3VyID0gcGFyc2VJbnQoaG91ciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG91ciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGhvdXJgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPCAwIHx8IGhvdXIgPiAyNCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJob3VyIG91dCBvZiByYW5nZTogI3tgaG91cmB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPT09IG5pbCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChtaW4uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgbWluID0gcGFyc2VJbnQobWluLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBtaW5gLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA8IDAgfHwgbWluID4gNTkpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibWluIG91dCBvZiByYW5nZTogI3tgbWluYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA9PT0gbmlsKSB7XG4gICAgICAgIHNlYyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFzZWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlYy4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHNlYyA9IHBhcnNlSW50KHNlYywgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYyA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHNlY2AsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWMgPCAwIHx8IHNlYyA+IDYwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInNlYyBvdXQgb2YgcmFuZ2U6ICN7YHNlY2B9XCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWNdO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBzZWxmLm5ldyh5ZWFyID0gdW5kZWZpbmVkLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgdXRjX29mZnNldCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQsIHRpbWV6b25lLCB1dGNfZGF0ZTtcblxuICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIGlmICh1dGNfb2Zmc2V0ID09PSBuaWwpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdGltZXpvbmUgPSAje19wYXJzZV9vZmZzZXQodXRjX29mZnNldCl9O1xuICAgICAgdXRjX2RhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHV0Y19kYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh1dGNfZGF0ZS5nZXRUaW1lKCkgLSB0aW1lem9uZSAqIDM2MDAwMDApO1xuICAgICAgcmVzdWx0LnRpbWV6b25lID0gdGltZXpvbmU7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBzZWxmLl9wYXJzZV9vZmZzZXQodXRjX29mZnNldClcbiAgICAleHtcbiAgICAgIHZhciB0aW1lem9uZTtcbiAgICAgIGlmICh1dGNfb2Zmc2V0LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGlmICh1dGNfb2Zmc2V0ID09ICdVVEMnKSB7XG4gICAgICAgICAgdGltZXpvbmUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoL15bKy1dXFxkXFxkOlswLTVdXFxkJC8udGVzdCh1dGNfb2Zmc2V0KSkge1xuICAgICAgICAgIHZhciBzaWduLCBob3VycywgbWludXRlcztcbiAgICAgICAgICBzaWduID0gdXRjX29mZnNldFswXTtcbiAgICAgICAgICBob3VycyA9ICsodXRjX29mZnNldFsxXSArIHV0Y19vZmZzZXRbMl0pO1xuICAgICAgICAgIG1pbnV0ZXMgPSArKHV0Y19vZmZzZXRbNF0gKyB1dGNfb2Zmc2V0WzVdKTtcblxuICAgICAgICAgIHRpbWV6b25lID0gKHNpZ24gPT0gJy0nID8gLTEgOiAxKSAqIChob3VycyArIG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gVW5zdXBwb3J0ZWQ6IFwiQVwiLi5cIklcIixcIktcIi4uXCJaXCJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJSdcIitISDpNTVwiLCBcIi1ISDpNTVwiLCBcIlVUQ1wiIGV4cGVjdGVkIGZvciB1dGNfb2Zmc2V0OiAje3V0Y19vZmZzZXR9J31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodXRjX29mZnNldC4kJGlzX251bWJlcikge1xuICAgICAgICB0aW1lem9uZSA9IHV0Y19vZmZzZXQgLyAzNjAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIk9wYWwgZG9lc24ndCBzdXBwb3J0IG90aGVyIHR5cGVzIGZvciBhIHRpbWV6b25lIGFyZ3VtZW50IHRoYW4gSW50ZWdlciBhbmQgU3RyaW5nXCJ9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXpvbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2NhbCh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdtKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgeWVhciAgPSBhcmdzWzVdO1xuICAgICAgICBtb250aCA9IGFyZ3NbNF07XG4gICAgICAgIGRheSAgID0gYXJnc1szXTtcbiAgICAgICAgaG91ciAgPSBhcmdzWzJdO1xuICAgICAgICBtaW4gICA9IGFyZ3NbMV07XG4gICAgICAgIHNlYyAgID0gYXJnc1swXTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCkpO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnRpbWV6b25lID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5ub3dcbiAgICBuZXdcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgOjpUaW1lID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICd0aW1lICsgdGltZT8nXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAjezo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIChvdGhlciAqIDEwMDApKTtcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IHNlbGYudGltZXpvbmU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgOjpUaW1lID09PSBvdGhlclxuICAgICAgcmV0dXJuIGAoc2VsZi5nZXRUaW1lKCkgLSBvdGhlci5nZXRUaW1lKCkpIC8gMTAwMGBcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBvdGhlciA9ICN7OjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpIC0gKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LnRpbWV6b25lID0gc2VsZi50aW1lem9uZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIDo6VGltZSA9PT0gb3RoZXJcbiAgICAgIHRvX2YgPD0+IG90aGVyLnRvX2ZcbiAgICBlbHNlXG4gICAgICByID0gb3RoZXIgPD0+IHNlbGZcbiAgICAgIGlmIHIubmlsP1xuICAgICAgICBuaWxcbiAgICAgIGVsc2lmIHIgPiAwXG4gICAgICAgIC0xXG4gICAgICBlbHNpZiByIDwgMFxuICAgICAgICAxXG4gICAgICBlbHNlXG4gICAgICAgIDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgOjpUaW1lID09PSBvdGhlciAmJiBgI3t0b19mfSA9PT0gI3tvdGhlci50b19mfWBcbiAgZW5kXG5cbiAgZGVmIGFzY3RpbWVcbiAgICBzdHJmdGltZSAnJWEgJWIgJWUgJUg6JU06JVMgJVknXG4gIGVuZFxuXG4gIFtcbiAgICBbOnllYXIsICdnZXRGdWxsWWVhcicsICdnZXRVVENGdWxsWWVhciddLFxuICAgIFs6bW9uLCAnZ2V0TW9udGgnLCAnZ2V0VVRDTW9udGgnLCAxXSxcbiAgICBbOndkYXksICdnZXREYXknLCAnZ2V0VVRDRGF5J10sXG4gICAgWzpkYXksICdnZXREYXRlJywgJ2dldFVUQ0RhdGUnXSxcbiAgICBbOmhvdXIsICdnZXRIb3VycycsICdnZXRVVENIb3VycyddLFxuICAgIFs6bWluLCAnZ2V0TWludXRlcycsICdnZXRVVENNaW51dGVzJ10sXG4gICAgWzpzZWMsICdnZXRTZWNvbmRzJywgJ2dldFVUQ1NlY29uZHMnXSxcbiAgXS5lYWNoIGRvIHxtZXRob2QsIGdldHRlciwgdXRjZ2V0dGVyLCBkaWZmZXJlbmNlID0gMHxcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZCBkb1xuICAgICAgJXh7XG4gICAgICAgIHJldHVybiBkaWZmZXJlbmNlICsgKChzZWxmLnRpbWV6b25lICE9IG51bGwpID9cbiAgICAgICAgICAobmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyBzZWxmLnRpbWV6b25lICogMzYwMDAwMCkpW3V0Y2dldHRlcl0oKSA6XG4gICAgICAgICAgc2VsZltnZXR0ZXJdKCkpXG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB5ZGF5XG4gICAgIyBodHRwOi8vamF2YXNjcmlwdC5hYm91dC5jb20vbGlicmFyeS9ibGRheXllYXIuaHRtXG4gICAgIyBhbHNvIHNlZSBtb21lbnQuanMgaW1wbGVtZW50YXRpb246IGh0dHA6Ly9naXQuaW8vdkNLTkVcblxuICAgIHN0YXJ0X29mX3llYXIgPSBUaW1lLm5ldyh5ZWFyKS50b19pXG4gICAgc3RhcnRfb2ZfZGF5ICA9IFRpbWUubmV3KHllYXIsIG1vbnRoLCBkYXkpLnRvX2lcbiAgICBvbmVfZGF5ICAgICAgID0gODZfNDAwXG5cbiAgICAoKHN0YXJ0X29mX2RheSAtIHN0YXJ0X29mX3llYXIpIC8gb25lX2RheSkucm91bmQgKyAxXG4gIGVuZFxuXG4gIGRlZiBpc2RzdFxuICAgICV4e1xuICAgICAgdmFyIGphbiA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgMCwgMSksXG4gICAgICAgICAganVsID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgICAgIHJldHVybiBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkpYFxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgb3RoZXIuaXNfYT8oOjpUaW1lKSAmJiAoc2VsZiA8PT4gb3RoZXIpLnplcm8/XG4gIGVuZFxuXG4gIFtcbiAgICBbOnN1bmRheT8sIDBdLFxuICAgIFs6bW9uZGF5PywgMV0sXG4gICAgWzp0dWVzZGF5PywgMl0sXG4gICAgWzp3ZWRuZXNkYXk/LCAzXSxcbiAgICBbOnRodXJzZGF5PywgNF0sXG4gICAgWzpmcmlkYXk/LCA1XSxcbiAgICBbOnNhdHVyZGF5PywgNl1cbiAgXS5lYWNoIGRvIHxtZXRob2QsIHdlZWtkYXl8XG4gICAgZGVmaW5lX21ldGhvZCBtZXRob2QgZG9cbiAgICAgIGAje3dkYXl9ID09PSB3ZWVrZGF5YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGAnVGltZTonICsgc2VsZi5nZXRUaW1lKClgXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgaWYgdXRjP1xuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTIFVUQydcbiAgICBlbHNlXG4gICAgICBzdHJmdGltZSAnJVktJW0tJWQgJUg6JU06JVMgJXonXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzdWNjXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IHNlbGYudGltZXpvbmU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVzZWNcbiAgICBgc2VsZi5nZXRNaWxsaXNlY29uZHMoKSAqIDEwMDBgXG4gIGVuZFxuXG4gIGRlZiB6b25lXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi50aW1lem9uZSA9PT0gMCkgcmV0dXJuIFwiVVRDXCI7XG4gICAgICBlbHNlIGlmIChzZWxmLnRpbWV6b25lICE9IG51bGwpIHJldHVybiBuaWw7XG5cbiAgICAgIHZhciBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJygnKSA9PSAtMSkge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1tBLVpdezMsNH0vKVswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1xcKCguKylcXCkoPzpcXHN8JCkvKVsxXVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09IFwiR01UXCIgJiYgLyhHTVRcXFcqXFxkezR9KS8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBSZWdFeHAuJDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRnbVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKTtcbiAgICAgIHJlc3VsdC50aW1lem9uZSA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdtdGltZVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudGltZXpvbmUgIT09IDApIHtcbiAgICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcbiAgICAgICAgc2VsZi50aW1lem9uZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnbXQ/XG4gICAgYHNlbGYudGltZXpvbmUgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBnbXRfb2Zmc2V0XG4gICAgYChzZWxmLnRpbWV6b25lICE9IG51bGwpID8gc2VsZi50aW1lem9uZSAqIDYwIDogLXNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwYFxuICBlbmRcblxuICBkZWYgc3RyZnRpbWUoZm9ybWF0KVxuICAgICV4e1xuICAgICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lKFtcXC1fI14wXSo6ezAsMn0pKFxcZCspPyhbRU9dKikoLikvZywgZnVuY3Rpb24oZnVsbCwgZmxhZ3MsIHdpZHRoLCBfLCBjb252KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiLCBqZCwgYywgcyxcbiAgICAgICAgICAgIHplcm8gICA9IGZsYWdzLmluZGV4T2YoJzAnKSAhPT0gLTEsXG4gICAgICAgICAgICBwYWQgICAgPSBmbGFncy5pbmRleE9mKCctJykgPT09IC0xLFxuICAgICAgICAgICAgYmxhbmsgID0gZmxhZ3MuaW5kZXhPZignXycpICE9PSAtMSxcbiAgICAgICAgICAgIHVwY2FzZSA9IGZsYWdzLmluZGV4T2YoJ14nKSAhPT0gLTEsXG4gICAgICAgICAgICBpbnZlcnQgPSBmbGFncy5pbmRleE9mKCcjJykgIT09IC0xLFxuICAgICAgICAgICAgY29sb25zID0gKGZsYWdzLm1hdGNoKCc6JykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG5cbiAgICAgICAgaWYgKHplcm8gJiYgYmxhbmspIHtcbiAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZignMCcpIDwgZmxhZ3MuaW5kZXhPZignXycpKSB7XG4gICAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNvbnYpIHtcbiAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3llYXJ9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5yb3VuZCgje3llYXJ9IC8gMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3llYXJ9ICUgMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7bW9ufTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICByZXN1bHQgKz0gbG9uZ19tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X21vbnRoc1sje21vbn0gLSAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVyb1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDMgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3lkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tob3VyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tob3VyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ICUgMTIgfHwgMTIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcInBtXCIgOiBcImFtXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21pbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3NlY31cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDMgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyA5IDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tgc2VsZi5nZXRNaWxsaXNlY29uZHMoKS50b1N0cmluZygpYC5yanVzdCgzLCAnMCcpfTtcbiAgICAgICAgICAgIHJlc3VsdCAgPSAje2ByZXN1bHRgLmxqdXN0KGB3aWR0aGAsICcwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHZhciBvZmZzZXQgID0gKHNlbGYudGltZXpvbmUgPT0gbnVsbCkgPyBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgOiAoLXNlbGYudGltZXpvbmUgKiA2MCksXG4gICAgICAgICAgICAgICAgaG91cnMgICA9IE1hdGguZmxvb3IoTWF0aC5hYnMob2Zmc2V0KSAvIDYwKSxcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5hYnMob2Zmc2V0KSAlIDYwO1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gb2Zmc2V0IDwgMCA/IFwiK1wiIDogXCItXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gaG91cnMgPCAxMCA/IFwiMFwiIDogXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycztcblxuICAgICAgICAgICAgaWYgKGNvbG9ucyA+IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcyA8IDEwID8gXCIwXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IG1pbnV0ZXM7XG5cbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAxKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIjowMFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7em9uZX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGRheXNfb2Zfd2Vla1sje3dkYXl9XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gc2hvcnRfZGF5c1sje3dkYXl9XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7d2RheX0gKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t3ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclswXS50b19zLnJqdXN0KDIsICcwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzFdfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclsxXVstMi4uLTFdfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t0b19pfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCIlXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVhICViICVlICVUICVZJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclbS8lZC8leScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJVktJW0tJWQnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVlLSVeYi0lNFknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVJOiVNOiVTICVwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdSJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSDolTScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUg6JU06JVMnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIE5vbi1zdGFuZGFyZDogSklTIFggMDMwMSBkYXRlIGZvcm1hdFxuICAgICAgICAgIGNhc2UgJ0onOlxuICAgICAgICAgICAgamQgPSAje3RvX2RhdGUuamR9O1xuICAgICAgICAgICAgaWYgKGpkIDwgMjQwNTE2MCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJVktJW0tJWQnKX07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoamQgPCAyNDE5NjE0KVxuICAgICAgICAgICAgICBjID0gJ00nLCBzID0gMTg2NztcbiAgICAgICAgICAgIGVsc2UgaWYgKGpkIDwgMjQyNDg3NSlcbiAgICAgICAgICAgICAgYyA9ICdUJywgcyA9IDE5MTE7XG4gICAgICAgICAgICBlbHNlIGlmIChqZCA8IDI0NDc1MzUpXG4gICAgICAgICAgICAgIGMgPSAnUycsIHMgPSAxOTI1O1xuICAgICAgICAgICAgZWxzZSBpZiAoamQgPCAyNDU4NjA1KVxuICAgICAgICAgICAgICBjID0gJ0gnLCBzID0gMTk4ODtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYyA9ICdSJywgcyA9IDIwMTg7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSAje2Zvcm1hdCAnJWMlMDJkJywgYGNgLCB5ZWFyIC0gYHNgfTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCctJW0tJWQnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGNhc2UpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW0EtWl0vLCBmdW5jdGlvbihjKSB7IGMudG9Mb3dlckNhc2UoKSB9KS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZSgvW2Etel0vLCBmdW5jdGlvbihjKSB7IGMudG9VcHBlckNhc2UoKSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWQgJiYgKHplcm8gfHwgYmxhbmspKSB7XG4gICAgICAgICAgcmVzdWx0ID0gI3tgcmVzdWx0YC5yanVzdChgaXNOYU4od2lkdGgpID8gMiA6IHdpZHRoYCwgYGJsYW5rID8gXCIgXCIgOiBcIjBcImApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgW3NlYywgbWluLCBob3VyLCBkYXksIG1vbnRoLCB5ZWFyLCB3ZGF5LCB5ZGF5LCBpc2RzdCwgem9uZV1cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBgc2VsZi5nZXRUaW1lKCkgLyAxMDAwYFxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBwYXJzZUludChzZWxmLmdldFRpbWUoKSAvIDEwMDAsIDEwKWBcbiAgZW5kXG5cbiAgZGVmIGN3ZWVrX2N5ZWFyXG4gICAgamFuMDEgPSA6OlRpbWUubmV3KHllYXIsIDEsIDEpXG4gICAgamFuMDFfd2RheSA9IGphbjAxLndkYXlcbiAgICBmaXJzdF9tb25kYXkgPSAwXG4gICAgeWVhciA9IHNlbGYueWVhclxuICAgIGlmIGphbjAxX3dkYXkgPD0gNCAmJiBqYW4wMV93ZGF5ICE9IDBcbiAgICAgICMgSmFuIDAxIGlzIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyXG4gICAgICBvZmZzZXQgPSBqYW4wMV93ZGF5IC0gMVxuICAgIGVsc2VcbiAgICAgICMgSmFuIDAxIGlzIGluIHRoZSBsYXN0IHdlZWsgb2YgdGhlIHByZXZpb3VzIHllYXJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSA3IC0gMVxuICAgICAgb2Zmc2V0ID0gLTEgaWYgb2Zmc2V0ID09IC04ICMgQWRqdXN0IGlmIEphbiAwMSBpcyBhIFN1bmRheVxuICAgIGVuZFxuXG4gICAgd2VlayA9ICgoeWRheSArIG9mZnNldCkgLyA3LjAwKS5jZWlsXG5cbiAgICBpZiB3ZWVrIDw9IDBcbiAgICAgICMgR2V0IHRoZSBsYXN0IHdlZWsgb2YgdGhlIHByZXZpb3VzIHllYXJcbiAgICAgIHJldHVybiA6OlRpbWUubmV3KHNlbGYueWVhciAtIDEsIDEyLCAzMSkuY3dlZWtfY3llYXJcbiAgICBlbHNpZiB3ZWVrID09IDUzXG4gICAgICAjIEZpbmQgb3V0IHdoZXRoZXIgdGhpcyBpcyBhY3R1YWxseSB3ZWVrIDUzIG9yIGFscmVhZHkgd2VlayAwMSBvZiB0aGUgZm9sbG93aW5nIHllYXJcbiAgICAgIGRlYzMxID0gOjpUaW1lLm5ldyhzZWxmLnllYXIsIDEyLCAzMSlcbiAgICAgIGRlYzMxX3dkYXkgPSBkZWMzMS53ZGF5XG4gICAgICBpZiBkZWMzMV93ZGF5IDw9IDMgJiYgZGVjMzFfd2RheSAhPSAwXG4gICAgICAgIHdlZWsgPSAxXG4gICAgICAgIHllYXIgKz0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBbd2VlaywgeWVhcl1cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIG1rdGltZSBsb2NhbFxuICAgIGFsaWFzIHV0YyBnbVxuICBlbmRcblxuICBhbGlhcyBjdGltZSBhc2N0aW1lXG4gIGFsaWFzIGRzdD8gaXNkc3RcbiAgYWxpYXMgZ2V0dXRjIGdldGdtXG4gIGFsaWFzIGdtdG9mZiBnbXRfb2Zmc2V0XG4gIGFsaWFzIG1kYXkgZGF5XG4gIGFsaWFzIG1vbnRoIG1vblxuICBhbGlhcyB0b19zIGluc3BlY3RcbiAgYWxpYXMgdHZfc2VjIHRvX2lcbiAgYWxpYXMgdHZfdXNlYyB1c2VjXG4gIGFsaWFzIHV0YyBnbXRpbWVcbiAgYWxpYXMgdXRjPyBnbXQ/XG4gIGFsaWFzIHV0Y19vZmZzZXQgZ210X29mZnNldFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlRpbWU+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJhdCIsInNlY29uZHMiLCJmcmFjIiwiVGltZSIsIj09PSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19pIiwiQXJndW1lbnRFcnJvciIsIm5ldyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW4iLCJzZWMiLCJ1dGNfb2Zmc2V0IiwiX3BhcnNlX29mZnNldCIsImxvY2FsIiwibWlsbGlzZWNvbmQiLCJfZHVtbXkxIiwiX2R1bW15MiIsIl9kdW1teTMiLCJnbSIsIm5vdyIsIisiLCJvdGhlciIsIi0iLCI8PT4iLCJ0b19mIiwiciIsIm5pbD8iLCI+IiwiMCIsIi0xIiwiPCIsIjEiLCI9PSIsIiRyZXRfb3JfMSIsImFzY3RpbWUiLCJzdHJmdGltZSIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6VGltZT4iLCJtZXRob2QiLCJnZXR0ZXIiLCJ1dGNnZXR0ZXIiLCJkaWZmZXJlbmNlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6VGltZT4iLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6VGltZT4iLCJ5ZGF5Iiwic3RhcnRfb2ZfeWVhciIsInN0YXJ0X29mX2RheSIsIm9uZV9kYXkiLCI4NjQwMCIsIi8iLCJyb3VuZCIsImlzZHN0IiwiZHVwIiwiY29weSIsImNvcHlfaW5zdGFuY2VfdmFyaWFibGVzIiwiaW5pdGlhbGl6ZV9kdXAiLCJlcWw/IiwiaXNfYT8iLCJ6ZXJvPyIsIjIiLCIzIiwiNCIsIjUiLCI2Iiwid2Vla2RheSIsIndkYXkiLCJoYXNoIiwiaW5zcGVjdCIsInV0Yz8iLCJzdWNjIiwidXNlYyIsInpvbmUiLCJnZXRnbSIsImdtdGltZSIsImdtdD8iLCJnbXRfb2Zmc2V0IiwiZm9ybWF0IiwibW9uIiwicmp1c3QiLCJsanVzdCIsImN3ZWVrX2N5ZWFyIiwiW10iLCJ0b19zIiwiLTIiLCJ0b19kYXRlIiwiamQiLCJ0b19hIiwiamFuMDEiLCJqYW4wMV93ZGF5IiwiZmlyc3RfbW9uZGF5IiwiPD0iLCJvZmZzZXQiLCI3IiwiLTgiLCJ3ZWVrIiwiY2VpbCIsIjEyIiwiMzEiLCI1MyIsImRlYzMxIiwiZGVjMzFfd2RheSJdLCJtYXBwaW5ncyI6IkFBQUFBLCtCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEOztBQUdGRCx1QkFBeUIsQ0FBR0EsUUFBSCxFQUFVQSxRQUFWLEVBQWlCQSxTQUFqQixFQUF5QkEsV0FBekIsRUFBbUNBLFVBQW5DLEVBQTRDQSxRQUE1QyxFQUFtREEsVUFBbkQsRUFBNERBLFFBQTVELENBQW9FQTtBQUM3RkEsdUJBQXlCLENBQUdBLEtBQUgsRUFBT0EsS0FBUCxFQUFXQSxLQUFYLEVBQWVBLEtBQWYsRUFBbUJBLEtBQW5CLEVBQXVCQSxLQUF2QixFQUEyQkEsS0FBM0IsQ0FBZ0NBO0FBQ3pEQSx1QkFBeUIsQ0FBR0EsS0FBSCxFQUFPQSxLQUFQLEVBQVdBLEtBQVgsRUFBZUEsS0FBZixFQUFtQkEsS0FBbkIsRUFBdUJBLEtBQXZCLEVBQTJCQSxLQUEzQixFQUErQkEsS0FBL0IsRUFBbUNBLEtBQW5DLEVBQXVDQSxLQUF2QyxFQUEyQ0EsS0FBM0MsRUFBK0NBLEtBQS9DLENBQW9EQTtBQUM3RUEsdUJBQXlCLENBQUdBLFNBQUgsRUFBV0EsVUFBWCxFQUFvQkEsT0FBcEIsRUFBMEJBLE9BQTFCLEVBQWdDQSxLQUFoQyxFQUFvQ0EsTUFBcEMsRUFBeUNBLE1BQXpDLEVB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T0FBS2UsU0FBTGYsSUFBS2UsRUFBR1csQ0FBSFg7UUFGUDtNQUpGO01BVUE2RCxPQUFBLENBQUNjLElBQUQsRUFBTzFGLElBQVA7SUE3QkY0RSxDQUFBQSxHQUFBQTtJQWdDQTs7O01BQ0UsYUFBTSxRQUFOLEVBQWEsT0FBYjtNQUNBLE9BQUEsYUFBTSxLQUFOLEVBQVUsSUFBVjtJQUZGLDRCQUFTakcsSUFBVDtJQUtBLGFBQU0sT0FBTixFQUFZLFNBQVo7SUFDQSxhQUFNLE1BQU4sRUFBVyxPQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsT0FBYjtJQUNBLGFBQU0sUUFBTixFQUFhLFlBQWI7SUFDQSxhQUFNLE1BQU4sRUFBVyxLQUFYO0lBQ0EsYUFBTSxPQUFOLEVBQVksS0FBWjtJQUNBLGFBQU0sTUFBTixFQUFXLFNBQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxNQUFiO0lBQ0EsYUFBTSxTQUFOLEVBQWMsTUFBZDtJQUNBLGFBQU0sS0FBTixFQUFVLFFBQVY7SUFDQSxhQUFNLE1BQU4sRUFBVyxNQUFYO0lBQ0FFLE9BQUEsYUFBTSxZQUFOLEVBQWlCLFlBQWpCO0VBN3dCRkEsR0FBTSxJQUFOQSxFQUFnQkgsSUFBaEJHO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1Mjg2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcblxucmVxdWlyZSAnY29yZWxpYi9yYW5kb20vZm9ybWF0dGVyJ1xuXG5jbGFzcyA6OlJhbmRvbVxuICBhdHRyX3JlYWRlciA6c2VlZCwgOnN0YXRlXG5cbiAgZGVmIHNlbGYuX3ZlcmlmeV9jb3VudChjb3VudClcbiAgICAleHtcbiAgICAgIGlmICghJHRydXRoeShjb3VudCkpIGNvdW50ID0gMTY7XG4gICAgICBpZiAodHlwZW9mIGNvdW50ICE9PSBcIm51bWJlclwiKSBjb3VudCA9ICN7YGNvdW50YC50b19pbnR9O1xuICAgICAgaWYgKGNvdW50IDwgMCkgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBzdHJpbmcgc2l6ZSAob3Igc2l6ZSB0b28gYmlnKSd9O1xuICAgICAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHNlZWQgPSA6OlJhbmRvbS5uZXdfc2VlZClcbiAgICBzZWVkID0gOjpPcGFsLmNvZXJjZV90byEoc2VlZCwgOjpJbnRlZ2VyLCA6dG9faW50KVxuICAgIEBzdGF0ZSA9IHNlZWRcbiAgICByZXNlZWQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIHJlc2VlZChzZWVkKVxuICAgIEBzZWVkID0gc2VlZFxuICAgIGBzZWxmLiRybmcgPSBPcGFsLiQkcmFuZC5yZXNlZWQoc2VlZClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ld19zZWVkXG4gICAgYE9wYWwuJCRyYW5kLm5ld19zZWVkKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgc2VsZjo6REVGQVVMVC5yYW5kKGxpbWl0KVxuICBlbmRcblxuICBkZWYgc2VsZi5zcmFuZChuID0gOjpSYW5kb20ubmV3X3NlZWQpXG4gICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcblxuICAgIHByZXZpb3VzX3NlZWQgPSBzZWxmOjpERUZBVUxULnNlZWRcbiAgICBzZWxmOjpERUZBVUxULnJlc2VlZChuKVxuICAgIHByZXZpb3VzX3NlZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJhbmRvbShzaXplKVxuICAgIDo6U2VjdXJlUmFuZG9tLmJ5dGVzKHNpemUpXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIDo6UmFuZG9tID09PSBvdGhlclxuXG4gICAgc2VlZCA9PSBvdGhlci5zZWVkICYmIHN0YXRlID09IG90aGVyLnN0YXRlXG4gIGVuZFxuXG4gIGRlZiBieXRlcyhsZW5ndGgpXG4gICAgbGVuZ3RoID0gOjpSYW5kb20uX3ZlcmlmeV9jb3VudChsZW5ndGgpXG5cbiAgICA6OkFycmF5Lm5ldyhsZW5ndGgpIHsgcmFuZCgyNTUpLmNociB9LmpvaW4uZW5jb2RlKCdBU0NJSS04QklUJylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuYnl0ZXMobGVuZ3RoKVxuICAgIHNlbGY6OkRFRkFVTFQuYnl0ZXMobGVuZ3RoKVxuICBlbmRcblxuICBkZWYgcmFuZChsaW1pdCA9IHVuZGVmaW5lZClcbiAgICByYW5kb21fbnVtYmVyKGxpbWl0KVxuICBlbmRcblxuICAjIE5vdCBwYXJ0IG9mIHRoZSBSdWJ5IGludGVyZmFjZSAodXNlICNyYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eSksIGJ1dFxuICAjIHVzZWQgYnkgUmFuZG9tOjpGb3JtYXR0ZXIgYXMgYSBzaG9ydGN1dCwgYXMgZm9yIFJhbmRvbSBpbnRlcmZhY2UgdGhlIGZsb2F0XG4gICMgUk5HIGlzIHByaW1hcnkuXG4gIGRlZiByYW5kb21fZmxvYXRcbiAgICAleHtcbiAgICAgIHNlbGYuc3RhdGUrKztcbiAgICAgIHJldHVybiBPcGFsLiQkcmFuZC5yYW5kKHNlbGYuJHJuZyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kb21fZmxvYXRcbiAgICBzZWxmOjpERUZBVUxULnJhbmRvbV9mbG9hdFxuICBlbmRcblxuICBkZWYgc2VsZi5nZW5lcmF0b3I9KGdlbmVyYXRvcilcbiAgICBgT3BhbC4kJHJhbmQgPSAje2dlbmVyYXRvcn1gXG5cbiAgICBpZiBjb25zdF9kZWZpbmVkPyA6REVGQVVMVFxuICAgICAgc2VsZjo6REVGQVVMVC5yZXNlZWRcbiAgICBlbHNlXG4gICAgICBjb25zdF9zZXQgOkRFRkFVTFQsIG5ldyhuZXdfc2VlZClcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxucmVxdWlyZSAnY29yZWxpYi9yYW5kb20vbWVyc2VubmVfdHdpc3RlcidcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UmFuZG9tPiIsImF0dHJfcmVhZGVyIiwiX3ZlcmlmeV9jb3VudCIsImNvdW50IiwidG9faW50IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiaW5pdGlhbGl6ZSIsInNlZWQiLCJSYW5kb20iLCJuZXdfc2VlZCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsIkBzdGF0ZSIsInJlc2VlZCIsIkBzZWVkIiwicmFuZCIsImxpbWl0Iiwic2VsZjo6REVGQVVMVCIsInNyYW5kIiwibiIsInByZXZpb3VzX3NlZWQiLCJ1cmFuZG9tIiwic2l6ZSIsIlNlY3VyZVJhbmRvbSIsImJ5dGVzIiwiPT0iLCJvdGhlciIsIiRyZXRfb3JfMSIsInN0YXRlIiwibGVuZ3RoIiwibmV3IiwiQXJyYXkiLCJibG9jayBpbiBieXRlcyIsImJsb2NrICgyIGxldmVscykgaW4gYnl0ZXMiLCIyNTUiLCJjaHIiLCJqb2luIiwiZW5jb2RlIiwicmFuZG9tX251bWJlciIsInJhbmRvbV9mbG9hdCIsImdlbmVyYXRvcj0iLCJnZW5lcmF0b3IiLCJjb25zdF9kZWZpbmVkPyIsImNvbnN0X3NldCJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRiwwQkFBUkU7RUFFQUM7RUFBQUE7Ozs7SUFDRUYsSUFBQUcsYUFBQUEsQ0FBWSxNQUFaLEVBQW1CLE9BQW5CQTtJQUVBQyxNQUFJSixJQUFKSSxvQkFBQUEseUJBQXVCQyxLQUF2QkQ7QUFBQUE7O0FBRUZBO0FBQ0FBLDZDQUErQ0EsQ0FBQ0EsS0FBREEsQ0FBT0UsUUFBQUEsQ0FBQUEsQ0FBUUY7QUFDOURBLHFCQUF1QkcsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NMLHdDQUF4QkksQ0FBaUVKO0FBQ2hHQTtBQUNBQTtBQUNBQTtJQVBFQSxDQUFBQSxHQUFBQTs7QUFVQU0s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QUFBLEdBQUFBO0lBT0FBLE1BQUk1QyxJQUFKNEMsbUJBQUFBLHdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXRCLElBQUF0QixJQUFBc0IsWUFBYXNCLGNBQUFBLENBQUFBO0lBRGZBLENBQUFBLEdBQUFBO0lBSUExQyxPQUFBMkMsTUFBSTdDLElBQUo2QyxpQkFBQUEsZ0NBQW9CQyxTQUFwQkQ7QUFBQUEsTUFBQUE7OztNQUNHQSxjQUFnQkM7TUFFakIsSUFBQSxRQUFHOUMsSUFBQStDLG1CQUFBQSxDQUFlLFNBQWZBLENBQUgsQ0FBQTtRQUNFRixPQUFBdkIsSUFBQXRCLElBQUFzQixZQUFhSixRQUFBQSxDQUFBQTtNQURmO1FBR0UyQixPQUFBN0MsSUFBQWdELFdBQUFBLENBQVUsU0FBVixFQUFvQmhELElBQUFtQyxLQUFBQSxDQUFJbkMsSUFBQWEsVUFBQUEsQ0FBQUEsQ0FBSnNCLENBQXBCYTtNQUhGO0lBSEZILENBQUFBLEdBQUFBO0VBOUVGM0MsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQXlGQUgsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUNBQVJFO0FBN0ZBRjsifX0seyJvZmZzZXQiOnsibGluZSI6NTQxNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZGlyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6RGlyXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgY2hkaXIoZGlyKVxuICAgICAgcHJldl9jd2QgPSBgT3BhbC5jdXJyZW50X2RpcmBcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3tkaXJ9YFxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3twcmV2X2N3ZH1gXG4gICAgZW5kXG5cbiAgICBkZWYgcHdkXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciB8fCAnLidgXG4gICAgZW5kXG5cbiAgICBkZWYgaG9tZVxuICAgICAgOjpFTlZbJ0hPTUUnXSB8fCAnLidcbiAgICBlbmRcblxuICAgIGFsaWFzIGdldHdkIHB3ZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RGlyPiIsImNoZGlyIiwiZGlyIiwicHJldl9jd2QiLCJwd2QiLCJob21lIiwiJHJldF9vcl8xIiwiRU5WIiwiW10iLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBOzs7O0FBQ0VDLE1BQUFBLHFCQUFBQSxpQkFBVUMsR0FBVkQ7QUFBQUEsUUFBQUE7O1FBQUFBO1FBQ0VBLE9BQUEsY0FBQTs7UUFBQUUsV0FBWUY7UUFDWEEsbUJBQXFCQztRQUN0QixPQUFBLHFCQUFBLEVBQUE7UUFGQTtVQUlDRCxtQkFBcUJFO1FBSnRCLENBQUE7TUFERkYsQ0FBQUEsR0FBQUE7O0FBUUFHLE1BQUFBLG1CQUFBQSxlQUFBQTtBQUFBQTtRQUNFQSxPQUFDQSx1QkFBREE7TUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLE1BQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0UsSUFBQSxRQUFBQyxDQUFBQSxZQUFBQyxVQUFLQyxPQUFBQSxDQUFDSCxNQUFERyxDQUFMRixDQUFBLENBQUE7VUFBQUQsT0FBQTtRQUFBO1VBQWlCQSxPQUFBQTtRQUFqQjtNQURGQSxDQUFBQSxHQUFBQTtNQUlBLE9BQUEsYUFBTSxPQUFOLEVBQVksS0FBWjtJQWpCRiw0QkFBU0ksSUFBVDtFQURGVCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1NDYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jZXNzL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpTaWduYWxcbiAgZGVmIHNlbGYudHJhcCgqKVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OkdDXG4gIGRlZiBzZWxmLnN0YXJ0XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpTaWduYWw+IiwidHJhcCIsInNlbGYiLCI8Y2xhc3M6R0M+Iiwic3RhcnQiXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBOzs7RUFBQUM7RUFBQUE7OztJQUNFQSxPQUFBQyxNQUFJQyxJQUFKRCxXQUFBQSxnQkFERixFQUNFQTtBQUFBQSxNQUFBQTs7O01BREY7TUFDZ0I7TUFEaEJBLE9BQUE7SUFDRUEsQ0FBQUEsSUFBQUE7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQUtBRCxPQUFBSTtFQUFBQTs7O0lBQ0VBLE9BQUFDLE1BQUlGLElBQUpFLFlBQUFBLFlBTkYsR0FNRUEsQ0FBQUEsR0FBQUE7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUxBSjsifX0seyJvZmZzZXQiOnsibGluZSI6NTQ4OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgOjpLZXJuZWxcbiAgZGVmIFJhdGlvbmFsKG51bWVyYXRvciwgZGVub21pbmF0b3IgPSAxKVxuICAgIDo6UmF0aW9uYWwuY29udmVydChudW1lcmF0b3IsIGRlbm9taW5hdG9yKVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlN0cmluZ1xuICBkZWYgdG9fclxuICAgIDo6UmF0aW9uYWwuZnJvbV9zdHJpbmcoc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiUmF0aW9uYWwiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsIjEiLCJjb252ZXJ0IiwiPGNsYXNzOlN0cmluZz4iLCJ0b19yIiwiZnJvbV9zdHJpbmciLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUMsd0JBQUFBLG9CQUFhQyxTQUFELEVBQVlDLFdBQXhCRjtBQUFBQTs7TUFBd0IsdUNBQWNHO01BQ3BDSCxPQUFBQSxlQUFVSSxTQUFBQSxDQUFTSCxTQUFuQixFQUE4QkMsV0FBcEJFO0lBRFpKLENBQUFBLElBQUFBO0VBREZELEdBQU8sSUFBUEE7RUFNQUQsT0FBQU87RUFBQUE7OztJQUNFQSxPQUFBQyxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBTixlQUFVTyxhQUFBQSxDQUFhQyxJQUFiRDtJQURaRCxDQUFBQSxHQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBTkFQOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1NTE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yZWdleHAucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHByb3AsIGZyZWV6ZVxuXG5jbGFzcyA6OlJlZ2V4cEVycm9yIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcblxuY2xhc3MgOjpSZWdleHAgPCBgUmVnRXhwYFxuICBzZWxmOjpJR05PUkVDQVNFID0gMVxuICBzZWxmOjpFWFRFTkRFRCA9IDJcbiAgc2VsZjo6TVVMVElMSU5FID0gNFxuXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfcmVnZXhwJywgdHJ1ZSlgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgYWxsb2NhdGVkID0gc3VwZXJcbiAgICAgIGAje2FsbG9jYXRlZH0udW5pbml0aWFsaXplZCA9IHRydWVgXG4gICAgICBhbGxvY2F0ZWRcbiAgICBlbmRcblxuICAgIGRlZiBlc2NhcGUoc3RyaW5nKVxuICAgICAgYE9wYWwuZXNjYXBlX3JlZ2V4cChzdHJpbmcpYFxuICAgIGVuZFxuXG4gICAgZGVmIGxhc3RfbWF0Y2gobiA9IG5pbClcbiAgICAgIGlmIG4ubmlsP1xuICAgICAgICAkflxuICAgICAgZWxzaWYgJH5cbiAgICAgICAgJH5bbl1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHVuaW9uKCpwYXJ0cylcbiAgICAgICV4e1xuICAgICAgICB2YXIgaXNfZmlyc3RfcGFydF9hcnJheSwgcXVvdGVkX3ZhbGlkYXRlZCwgcGFydCwgb3B0aW9ucywgZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAvKD8hKS87XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGZhc3QgaWYgdGhlcmUncyBvbmx5IG9uZSBlbGVtZW50XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3ZlciB0aGUgMiBhcnJheXMgcGFzc2VkIGFzIGFyZ3VtZW50cyBjYXNlXG4gICAgICAgIGlzX2ZpcnN0X3BhcnRfYXJyYXkgPSBwYXJ0c1swXS4kJGlzX2FycmF5O1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBpc19maXJzdF9wYXJ0X2FycmF5KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgQXJyYXkgaW50byBTdHJpbmcnfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBzcGxhdCBpc3N1ZXMgKHJlbGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvODU4KVxuICAgICAgICBpZiAoaXNfZmlyc3RfcGFydF9hcnJheSkge1xuICAgICAgICAgIHBhcnRzID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocGFydC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgICAgZWFjaF9wYXJ0X29wdGlvbnMgPSAje2BwYXJ0YC5vcHRpb25zfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zICE9IGVhY2hfcGFydF9vcHRpb25zKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdBbGwgZXhwcmVzc2lvbnMgbXVzdCB1c2UgdGhlIHNhbWUgb3B0aW9ucyd9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goJygnK3BhcnQuc291cmNlKycpJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YC50b19zdHIpfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAjIFRha2UgYWR2YW50YWdlIG9mIGxvZ2ljIHRoYXQgY2FuIHBhcnNlIG9wdGlvbnMgZnJvbSBKUyBSZWdleFxuICAgICAgbmV3KGBxdW90ZWRfdmFsaWRhdGVkYC5qb2luKCd8JyksIGBvcHRpb25zYClcbiAgICBlbmRcblxuICAgIGRlZiBuZXcocmVnZXhwLCBvcHRpb25zID0gdW5kZWZpbmVkKVxuICAgICAgJXh7XG4gICAgICAgIGlmIChyZWdleHAuJCRpc19yZWdleHApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXhwID0gI3s6Ok9wYWwuY29lcmNlX3RvIShyZWdleHAsIDo6U3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgaWYgKHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDEpID09PSAnXFxcXCcgJiYgcmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMikgIT09ICdcXFxcJykge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSZWdleHBFcnJvciwgXCJ0b28gc2hvcnQgZXNjYXBlIHNlcXVlbmNlOiAvI3tyZWdleHB9L1wifVxuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXhwID0gcmVnZXhwLnJlcGxhY2UoJ1xcXFxBJywgJ14nKS5yZXBsYWNlKCdcXFxceicsICckJylcblxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICN7IW9wdGlvbnN9KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSAnJztcbiAgICAgICAgICBpZiAoI3tJR05PUkVDQVNFfSAmIG9wdGlvbnMpIHsgdGVtcCArPSAnaSc7IH1cbiAgICAgICAgICBpZiAoI3tNVUxUSUxJTkV9ICAmIG9wdGlvbnMpIHsgdGVtcCArPSAnbSc7IH1cbiAgICAgICAgICBvcHRpb25zID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gJ2knO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGFsaWFzIGNvbXBpbGUgbmV3XG4gICAgYWxpYXMgcXVvdGUgZXNjYXBlXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgaW5zdGFuY2VvZiBSZWdFeHAgJiYgc2VsZi50b1N0cmluZygpID09PSBvdGhlci50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgPT09KHN0cmluZylcbiAgICBgI3ttYXRjaCg6Ok9wYWwuY29lcmNlX3RvPyhzdHJpbmcsIDo6U3RyaW5nLCA6dG9fc3RyKSl9ICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9fihzdHJpbmcpXG4gICAgbWF0Y2goc3RyaW5nKSAmJiAkfi5iZWdpbigwKVxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgIyBTcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGZyZWV6ZSwgYmVjYXVzZSB0aGUgJCRnbSBhbmQgJCRnIHByb3BlcnRpZXMgbmVlZCB0byBiZSBzZXRcbiAgICAjIGVzcGVjaWFsbHkgZm9yIFJlZ0V4cC5cblxuICAgIHJldHVybiBzZWxmIGlmIGZyb3plbj9cblxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLmhhc093blByb3BlcnR5KCckJGcnKSkgeyAkcHJvcChzZWxmLCAnJCRnJywgbnVsbCk7IH1cbiAgICAgIGlmICghc2VsZi5oYXNPd25Qcm9wZXJ0eSgnJCRnbScpKSB7ICRwcm9wKHNlbGYsICckJGdtJywgbnVsbCk7IH1cblxuICAgICAgcmV0dXJuICRmcmVlemUoc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICMgVXNlIGEgcmVnZXhwIHRvIGV4dHJhY3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgdGhlIG9wdGlvbmFsIG1vZGUgbW9kaWZpZXJzIGZyb20gdGhlIHN0cmluZy5cbiAgICAjIEluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24sIGVzY2FwZSBhbnkgZnJvbnQgc2xhc2ggKG5vdCBhbHJlYWR5IGVzY2FwZWQpIHdpdGggYSBiYWNrc2xhc2guXG4gICAgJXh7XG4gICAgICB2YXIgcmVnZXhwX2Zvcm1hdCA9IC9eXFwvKC4qKVxcLyhbXlxcL10qKSQvO1xuICAgICAgdmFyIHZhbHVlID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgdmFyIG1hdGNoZXMgPSByZWdleHBfZm9ybWF0LmV4ZWModmFsdWUpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgdmFyIHJlZ2V4cF9wYXR0ZXJuID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgdmFyIHJlZ2V4cF9mbGFncyA9IG1hdGNoZXNbMl07XG4gICAgICAgIHZhciBjaGFycyA9IHJlZ2V4cF9wYXR0ZXJuLnNwbGl0KCcnKTtcbiAgICAgICAgdmFyIGNoYXJzX2xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRfY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICAgIGlmICghY2hhcl9lc2NhcGVkICYmIGN1cnJlbnRfY2hhciA9PSAnLycpIHtcbiAgICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdCgnXFxcXCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gcmVnZXhwX3BhdHRlcm5fZXNjYXBlZC5jb25jYXQoY3VycmVudF9jaGFyKTtcbiAgICAgICAgICBpZiAoY3VycmVudF9jaGFyID09ICdcXFxcJykge1xuICAgICAgICAgICAgaWYgKGNoYXJfZXNjYXBlZCkge1xuICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBvdmVyIGVzY2FwZVxuICAgICAgICAgICAgICBjaGFyX2VzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy8nICsgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCArICcvJyArIHJlZ2V4cF9mbGFncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaChzdHJpbmcsIHBvcyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIHZhciBtID0gc2VsZi5leGVjKCRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGBzZWxmYCwgYG1gKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb3MgPSAkY29lcmNlX3RvKHBvcywgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgICBpZiAobWQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1kLmluZGV4ID49IHBvcykge1xuICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHJlYCwgYG1kYCl9O1xuICAgICAgICAgIHJldHVybiBibG9jayA9PT0gbmlsID8gI3skfn0gOiAje3lpZWxkICR+fTtcbiAgICAgICAgfVxuICAgICAgICByZS5sYXN0SW5kZXggPSBtZC5pbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2g/KHN0cmluZywgcG9zID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbmlsID8gZmFsc2UgOiBzZWxmLnRlc3QoJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJykpO1xuICAgICAgfVxuXG4gICAgICBwb3MgPSAkY29lcmNlX3RvKHBvcywgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG1kID09PSBudWxsIHx8IG1kLmluZGV4IDwgcG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVzXG4gICAgc291cmNlLnNjYW4oL1xcKD88KFxcdyspPi8sIG5vX21hdGNoZGF0YTogdHJ1ZSkubWFwKCY6Zmlyc3QpLnVuaXFcbiAgZW5kXG5cbiAgZGVmIG5hbWVkX2NhcHR1cmVzXG4gICAgc291cmNlLnNjYW4oL1xcKD88KFxcdyspPi8sIG5vX21hdGNoZGF0YTogdHJ1ZSkgIyBTY2FuIGZvciBjYXB0dXJlIGdyb3Vwc1xuICAgICAgICAgIC5tYXAoJjpmaXJzdCkgICAgICAgICAgICAgICAgICAgICAgICAgICAjIEdldCB0aGUgZmlyc3QgcmVnZXhwIG1hdGNoIChcXHcrKVxuICAgICAgICAgIC5lYWNoX3dpdGhfaW5kZXggICAgICAgICAgICAgICAgICAgICAgICAjIEFkZCBpbmRleCB0byBhbiBpdGVyYXRvclxuICAgICAgICAgIC5ncm91cF9ieSgmOmZpcnN0KSAgICAgICAgICAgICAgICAgICAgICAjIEdyb3VwIGJ5IHRoZSBjYXB0dXJlIGdyb3VwIG5hbWVzXG4gICAgICAgICAgLnRyYW5zZm9ybV92YWx1ZXMgZG8gfGl8ICAgICAgICAgICAgICAgICMgQ29udmVydCBoYXNoIHZhbHVlc1xuICAgICAgICAgICAgaS5tYXAgeyB8anwgai5sYXN0ICsgMSB9ICAgICAgICAgICAgICAjIERyb3AgdGhlIGNhcHR1cmUgZ3JvdXAgbmFtZXM7IGluY3JlYXNlIGluZGV4ZXMgYnkgMVxuICAgICAgICAgIGVuZFxuICBlbmRcblxuICBkZWYgflxuICAgIHNlbGYgPX4gJF9cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZVxuICAgIGBzZWxmLnNvdXJjZWBcbiAgZW5kXG5cbiAgZGVmIG9wdGlvbnNcbiAgICAjIEZsYWdzIHdvdWxkIGJlIG5pY2UgdG8gdXNlIHdpdGggdGhpcywgYnV0IHN0aWxsIGV4cGVyaW1lbnRhbCAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cC9mbGFnc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAvLyBzaG91bGQgYmUgc3VwcG9ydGVkIGluIElFNiBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS83ZjV6MjZ3NCh2PXZzLjk0KS5hc3B4XG4gICAgICBpZiAoc2VsZi5tdWx0aWxpbmUpIHtcbiAgICAgICAgcmVzdWx0IHw9ICN7TVVMVElMSU5FfTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmVzdWx0IHw9ICN7SUdOT1JFQ0FTRX07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhc2Vmb2xkP1xuICAgIGBzZWxmLmlnbm9yZUNhc2VgXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgdG9fcyBzb3VyY2VcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWdleHAsIG1hdGNoX2dyb3Vwcywgbm9fbWF0Y2hkYXRhOiBmYWxzZSlcbiAgICAkfiAgICAgICAgICA9IHNlbGYgdW5sZXNzIG5vX21hdGNoZGF0YVxuICAgIEByZWdleHAgICAgID0gcmVnZXhwXG4gICAgQGJlZ2luICAgICAgPSBgbWF0Y2hfZ3JvdXBzLmluZGV4YFxuICAgIEBzdHJpbmcgICAgID0gYG1hdGNoX2dyb3Vwcy5pbnB1dGBcbiAgICBAcHJlX21hdGNoICA9IGBtYXRjaF9ncm91cHMuaW5wdXQuc2xpY2UoMCwgbWF0Y2hfZ3JvdXBzLmluZGV4KWBcbiAgICBAcG9zdF9tYXRjaCA9IGBtYXRjaF9ncm91cHMuaW5wdXQuc2xpY2UobWF0Y2hfZ3JvdXBzLmluZGV4ICsgbWF0Y2hfZ3JvdXBzWzBdLmxlbmd0aClgXG4gICAgQG1hdGNoZXMgICAgPSBbXVxuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWF0Y2hfZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IG1hdGNoX2dyb3Vwc1tpXTtcblxuICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgICAgICAgICN7QG1hdGNoZXN9LnB1c2gobmlsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKGlkeClcbiAgICBpZiAobWF0Y2ggPSBzZWxmW2lkeF0pXG4gICAgICBtYXRjaFxuICAgIGVsc2lmIGlkeC5pc19hPyhJbnRlZ2VyKSAmJiBpZHggPj0gbGVuZ3RoXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tpZHh9IG91dCBvZiBtYXRjaGVzXCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG1hdGNoX2xlbmd0aChpZHgpXG4gICAgbWF0Y2goaWR4KSYubGVuZ3RoXG4gIGVuZFxuXG4gIGRlZiBbXSgqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzWzBdLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGlmICgjeyFyZWdleHAubmFtZXMuaW5jbHVkZT8oYXJnc1swXSl9KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwidW5kZWZpbmVkIGdyb3VwIG5hbWUgcmVmZXJlbmNlOiAje2FyZ3NbMF19XCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7bmFtZWRfY2FwdHVyZXNbYXJnc1swXV19XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7QG1hdGNoZXNbKmFyZ3NdfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjb2Zmc2V0IG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtzZWxmLmJlZ2luLCBzZWxmLmJlZ2luICsgc2VsZi5tYXRjaGVzW25dLmxlbmd0aF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyA6Ok1hdGNoRGF0YSA9PT0gb3RoZXJcblxuICAgIGBzZWxmLnN0cmluZyA9PSBvdGhlci5zdHJpbmdgICYmXG4gICAgICBgc2VsZi5yZWdleHAudG9TdHJpbmcoKSA9PSBvdGhlci5yZWdleHAudG9TdHJpbmcoKWAgJiZcbiAgICAgIGBzZWxmLnByZV9tYXRjaCA9PSBvdGhlci5wcmVfbWF0Y2hgICYmXG4gICAgICBgc2VsZi5wb3N0X21hdGNoID09IG90aGVyLnBvc3RfbWF0Y2hgICYmXG4gICAgICBgc2VsZi5iZWdpbiA9PSBvdGhlci5iZWdpbmBcbiAgZW5kXG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNiZWdpbiBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmJlZ2luO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVuZChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjZW5kIG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuYmVnaW4gKyBzZWxmLm1hdGNoZXNbbl0ubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhcHR1cmVzXG4gICAgYCN7QG1hdGNoZXN9LnNsaWNlKDEpYFxuICBlbmRcblxuICBkZWYgbmFtZWRfY2FwdHVyZXNcbiAgICBtYXRjaGVzID0gY2FwdHVyZXNcbiAgICByZWdleHAubmFtZWRfY2FwdHVyZXMudHJhbnNmb3JtX3ZhbHVlcyBkbyB8aXxcbiAgICAgIG1hdGNoZXNbaS5sYXN0IC0gMV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG5hbWVzXG4gICAgcmVnZXhwLm5hbWVzXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcblxuICAgICAgaWYgKCN7cmVnZXhwLm5hbWVzLmVtcHR5P30pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RyICs9IFwiIFwiICsgaSArIFwiOlwiICsgI3tgI3tAbWF0Y2hlc31baV1gLmluc3BlY3R9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3sgbmFtZWRfY2FwdHVyZXMuZWFjaCBkbyB8aywgdnxcbiAgICAgICAgICAgICAleHtcbiAgICAgICAgICAgICAgIHN0ciArPSBcIiBcIiArICN7a30gKyBcIjpcIiArICN7di5pbnNwZWN0fVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgZW5kIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BtYXRjaGVzfS5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgI3tAbWF0Y2hlc31bMF1gXG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgYSwgaW5kZXgsIHZhbHVlcyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIGlmIChhcmdzW2ldLiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgICBhID0gI3tgYXJnc1tpXWAudG9fYX07XG4gICAgICAgICAgYS51bnNoaWZ0KGksIDEpO1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoYXJncywgYSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGFyZ3NbaV1gLCA6OkludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggKz0gI3tAbWF0Y2hlc30ubGVuZ3RoO1xuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG5pbCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMucHVzaCgje0BtYXRjaGVzfVtpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBzaXplIGxlbmd0aFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSZWdleHBFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOlJlZ2V4cD4iLCJzZWxmIiwiMSIsIjIiLCI0IiwiYWxsb2NhdGUiLCJhbGxvY2F0ZWQiLCJlc2NhcGUiLCJzdHJpbmciLCJsYXN0X21hdGNoIiwibiIsIm5pbD8iLCIkfiIsIltdIiwidW5pb24iLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm9wdGlvbnMiLCJ0b19zdHIiLCJuZXciLCJqb2luIiwicmVnZXhwIiwiT3BhbCIsImNvZXJjZV90byEiLCJTdHJpbmciLCJSZWdleHBFcnJvciIsIiEiLCJJR05PUkVDQVNFIiwiTVVMVElMSU5FIiwiPT0iLCJvdGhlciIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsIj1+IiwiJHJldF9vcl8xIiwiYmVnaW4iLCIwIiwiZnJlZXplIiwiZnJvemVuPyIsImluc3BlY3QiLCJwb3MiLCJNYXRjaERhdGEiLCJJbnRlZ2VyIiwibWF0Y2g/IiwibmFtZXMiLCJtYXAiLCJzb3VyY2UiLCJzY2FuIiwidG9fcHJvYyIsInVuaXEiLCJuYW1lZF9jYXB0dXJlcyIsInRyYW5zZm9ybV92YWx1ZXMiLCJncm91cF9ieSIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIG5hbWVkX2NhcHR1cmVzIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gbmFtZWRfY2FwdHVyZXMiLCJqIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuYW1lZF9jYXB0dXJlcyIsIisiLCJsYXN0IiwifiIsIiRfIiwiY2FzZWZvbGQ/IiwiPGNsYXNzOk1hdGNoRGF0YT4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJtYXRjaF9ncm91cHMiLCIka3dhcmdzIiwibm9fbWF0Y2hkYXRhIiwiQHJlZ2V4cCIsIkBiZWdpbiIsIkBzdHJpbmciLCJAcHJlX21hdGNoIiwiQHBvc3RfbWF0Y2giLCJAbWF0Y2hlcyIsImlkeCIsImlzX2E/IiwiPj0iLCJsZW5ndGgiLCJJbmRleEVycm9yIiwibWF0Y2hfbGVuZ3RoIiwiaW5jbHVkZT8iLCJhcmdzIiwib2Zmc2V0IiwiQXJndW1lbnRFcnJvciIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImVuZCIsImNhcHR1cmVzIiwibWF0Y2hlcyIsIi0iLCJlbXB0eT8iLCJlYWNoIiwiYmxvY2sgaW4gaW5zcGVjdCIsImsiLCJ2IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0IiwidG9fYSIsInRvX3MiLCJ2YWx1ZXNfYXQiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsT0FBTSxJQUFOQSxFQUFzQkMsb0JBQXRCRDtFQUVBRTtFQUFBQTs7SUFBQUE7OztJQUNFLFdBQUFDLElBQUEsZ0JBQW1CQyxDQUFuQjtJQUNBLFdBQUFELElBQUEsY0FBaUJFLENBQWpCO0lBQ0EsV0FBQUYsSUFBQSxlQUFrQkcsQ0FBbEI7SUFFQ0o7SUFFRDtNQUFBOzs7O0FBQ0VLLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOztRQUNFQyxZQUFZLE9BQUFMLElBQUEsRUFBQSxzREFBQSxZQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7UUFDVEssU0FBVUQ7UUFDYkEsT0FBQUM7TUFIRkQsQ0FBQUEsR0FBQUE7O0FBTUFFLE1BQUFBLHNCQUFBQSxrQkFBV0MsTUFBWEQ7QUFBQUE7UUFDRUEsT0FBQ0EsMEJBQURBO01BREZBLENBQUFBLEdBQUFBOztBQUlBRSxNQUFBQSwwQkFBQUEsc0JBQWVDLENBQWZEO0FBQUFBLFFBQUFBOzs7UUFBZSxtQkFBSTtRQUNqQixJQUFBLFFBQUdDLENBQUNDLFNBQUFBLENBQUFBLENBQUosQ0FBQTtVQUNFRixPQUFBRztRQURGLE9BRUEsSUFBQSxRQUFNQSxXQUFOLENBQUE7VUFDRUgsT0FBQUcsV0FBRUMsT0FBQUEsQ0FBQ0gsQ0FBREc7UUFESjtVQXpCTkosT0FBQTtRQXlCTTtNQUhGQSxDQUFBQSxJQUFBQTs7QUFRQUssTUFBQUEscUJBQUFBLGlCQTlCSixFQThCSUE7QUFBQUEsUUFBQUE7OztRQTlCSjtRQThCYzs7QUFFZEE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsVUFBWUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNEJILDZDQUFwQkU7QUFDcEJGO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGtDQUFvQ2IsSUFBQU0sUUFBQUEsQ0FBUU8sSUFBUlAsQ0FBZU87QUFDbkRBO0FBQ0FBO0FBQ0FBLGdDQUFrQ0EsQ0FBQ0EsSUFBREEsQ0FBTUksU0FBQUEsQ0FBQUEsQ0FBU0o7QUFDakRBO0FBQ0FBLGNBQWdCQyxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QkgsMkNBQXBCRTtBQUN4QkY7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0NBQW9DYixJQUFBTSxRQUFBQSxDQUFPTyxDQUFDQSxJQUFEQSxDQUFNSyxRQUFBQSxDQUFBQSxDQUFiWixDQUFzQk87QUFDMURBO0FBQ0FBO0FBQ0FBO1FBRU1BLE9BQUFiLElBQUFtQixLQUFBQSxDQUFJTixDQUFDQSxnQkFBREEsQ0FBa0JPLE1BQUFBLENBQU1QLEdBQU5PLENBQXRCLEVBQW1DUCxPQUFuQ007TUF4Q0ZOLENBQUFBLElBQUFBOztBQTJDQU0sTUFBQUEsbUJBQUFBLGdCQUFRRSxNQUFELEVBQVNKLE9BQWhCRTtBQUFBQTs7OztBQUVKQTtBQUNBQTtBQUNBQTs7QUFFQUEsaUJBQW1CRyxLQUFNQyxlQUFBQSxDQUFZRixNQUFsQixFQUEwQkcsYUFBMUIsRUFBb0MsUUFBOUJELENBQXVDSjs7QUFFaEVBO0FBQ0FBLFVBQVlMLE9BQVFDLE9BQUFBLENBQU9VLGtCQUFmLEVBQStCTiw4QkFBRCxHQUFBLENBQStCRSxNQUEvQixDQUFBLEdBQXNDRixHQUE1REo7QUFDcEJJOztBQUVBQTs7QUFFQUEscUNBQXdDRixPQUFEUyxNQUFBQSxDQUFBQSxDQUFTUDtBQUNoREE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLGNBQWdCUSxnQkFBV1I7QUFDM0JBLGNBQWdCUyxlQUFVVDtBQUMxQkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO01BN0JJQSxDQUFBQSxJQUFBQTtNQWdDQSxhQUFNLFNBQU4sRUFBYyxLQUFkO01BQ0EsT0FBQSxhQUFNLE9BQU4sRUFBWSxRQUFaO0lBL0ZGLDRCQUFTbkIsSUFBVDs7QUFrR0E2QixJQUFBQSxrQkFBQUEsMEJBQU9DLEtBQVBEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSwrREFBREE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFFLElBQUFBLG1CQUFBQSw2QkFBUXhCLE1BQVJ3QjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBRy9CLElBQUFnQyxPQUFBQSxDQUFNVixLQUFNVyxlQUFBQSxDQUFZMUIsTUFBbEIsRUFBMEJpQixhQUExQixFQUFvQyxRQUE5QlMsQ0FBWkQsQ0FBb0REO0lBRHpEQSxDQUFBQSxHQUFBQTs7QUFJQUcsSUFBQUEsa0JBQUFBLDZCQUFPM0IsTUFBUDJCO0FBQUFBLE1BQUFBO0FBQUFBOztNQUNFLElBQUEsUUFBQUMsQ0FBQUEsWUFBQW5DLElBQUFnQyxPQUFBQSxDQUFNekIsTUFBTnlCLENBQUFHLENBQUEsQ0FBQTtRQUFpQkQsT0FBQXZCLFdBQUV5QixPQUFBQSxDQUFPQyxDQUFQRDtNQUFuQjtRQUFBRixPQUFBO01BQUE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFJLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7OztNQUlFLElBQUEsUUFBZXRDLElBQUF1QyxZQUFBQSxDQUFBQSxDQUFmLENBQUE7UUFBQSxPQUFPdkM7TUFBUDs7QUFHSnNDO0FBQ0FBOztBQUVBQTtBQUNBQTtJQVhFQSxDQUFBQSxHQUFBQTs7QUFjQUUsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7O0FBSUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBbkNFQSxDQUFBQSxHQUFBQTs7QUFzQ0FSLElBQUFBLHFCQUFBQSxpQkFBVXpCLE1BQUQsRUFBU2tDLEdBQWxCVDtBQUFBQSxNQUFBQTtBQUFBQTs7TUFBQUE7Ozs7O0FBRUZBO0FBQ0FBLFFBQVVsQixPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QmdCLHNCQUFwQmpCO0FBQ2xCaUI7O0FBRUFBO0FBQ0FBLG1DQUFxQ3JCLENBQUFBLGNBQUssR0FBTEEsQ0FBU3FCO0FBQzlDQSw2Q0FBK0NSLGFBQVNRO0FBQ3hEQTtBQUNBQSxVQUFZckIsQ0FBQUEsY0FBSytCLGdCQUFXdkIsS0FBQUEsQ0FBTWEsSUFBakIsRUFBeUJBLENBQWRiLENBQWhCUixDQUFrQ3FCO0FBQzlDQSxpQ0FBbUNyQixXQUFHcUIsR0FBSyxtQkFBTXJCLFdBQU4sQ0FBU3FCO0FBQ3BEQTtBQUNBQSxpQkFBbUJyQixDQUFBQSxjQUFLLEdBQUxBLENBQVNxQjtBQUM1QkE7QUFDQUE7O0FBRUFBLDRCQUE4QlcsY0FBVVg7O0FBRXhDQTtBQUNBQSxlQUFpQnJCLENBQUFBLGNBQUssR0FBTEEsQ0FBU3FCO0FBQzFCQTs7QUFFQUEsa0NBQW9DUixhQUFTUTs7QUFFN0NBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQnJCLENBQUFBLGNBQUssR0FBTEEsQ0FBU3FCO0FBQzVCQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQnJCLENBQUFBLGNBQUssR0FBTEEsQ0FBU3FCO0FBQzVCQTtBQUNBQTtBQUNBQSxVQUFZckIsQ0FBQUEsY0FBSytCLGdCQUFXdkIsS0FBQUEsQ0FBTWEsRUFBakIsRUFBdUJBLEVBQVpiLENBQWhCUixDQUFpQ3FCO0FBQzdDQSxpQ0FBbUNyQixXQUFHcUIsR0FBSyxtQkFBTXJCLFdBQU4sQ0FBU3FCO0FBQ3BEQTtBQUNBQTtBQUNBQTtBQUNBQTtJQTlDRUEsQ0FBQUEsSUFBQUE7O0FBaURBWSxJQUFBQSxzQkFBQUEsOEJBQVdyQyxNQUFELEVBQVNrQyxHQUFuQkc7QUFBQUEsTUFBQUE7Ozs7O0FBRUZBO0FBQ0FBLFFBQVU5QixPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QjRCLHNCQUFwQjdCO0FBQ2xCNkI7O0FBRUFBO0FBQ0FBLHFFQUF1RXBCLGFBQVNvQjtBQUNoRkE7O0FBRUFBLDRCQUE4QkQsY0FBVUM7O0FBRXhDQTtBQUNBQTtBQUNBQTs7QUFFQUEsa0NBQW9DcEIsYUFBU29COztBQUU3Q0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQWxDRUEsQ0FBQUEsSUFBQUE7O0FBcUNBQyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUE2Q0MsTUFBN0M5QyxJQUFBK0MsUUFBQUEsQ0FBQUEsQ0FBTUMsTUFBQUEsQ0FBTSxZQUFaLEVBQTBCLDBCQUFBLGdCQUFjLElBQWQsRUFBcEJBLENBQXVDRixPQUFBQSxFQUFBQSxFQUFBQSxFQUFNLE9BQURHLFNBQUFBLENBQUFBLENBQUxILENBQWFJLE1BQUFBLENBQUFBO0lBRDVETCxDQUFBQSxHQUFBQTs7QUFJQU0sSUFBQUEsOEJBQUFBLDBCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FJTUMsTUFEQUMsTUFGQVAsTUFETjlDLElBQUErQyxRQUFBQSxDQUFBQSxDQUFNQyxNQUFBQSxDQUFNLFlBQVosRUFBMEIsMEJBQUEsZ0JBQWMsSUFBZCxFQUFwQkEsQ0FDQUYsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTSxPQUFERyxTQUFBQSxDQUFBQSxDQUFMSCxDQUNBUSxpQkFBQUEsQ0FBQUEsQ0FDQUQsWUFBQUEsRUFBQUEsRUFBQUEsRUFBVyxPQUFESixTQUFBQSxDQUFBQSxDQUFWSSxDQUNBRCxvQkFBQUEsRUFBQUEsRUFBQUEsRUFKTkcsYUFJNEJDLENBSjVCRDs7UUFJNEI7UUFDcEJFLE9BQUNYLE1BQURVLENBQUNWLE9BQUFBLEVBQUFBLEVBQUFBLEVBQURXLGFBQVNDLENBQVREOztVQUFTO1VBQUdFLE9BQU9DLFNBQVBGLENBQUNHLE1BQUFBLENBQUFBLENBQU1ELEVBQUUzRCxDQUFGMkQsRUFBbkJILENBQUFBLEdBQUNYLEVBTFRTLENBQUFBLEdBSU1IO0lBTFJELENBQUFBLEdBQUFBOztBQVVBVyxJQUFBQSxpQkFBQUEscUJBQUFBO0FBQUFBLE1BQUFBO0FBQUFBOztNQUNFQSxPQUFBOUQsSUFBS2tDLE9BQUFBLENBQUc2QixRQUFIN0I7SUFEUDRCLENBQUFBLEdBQUFBOztBQUlBZixJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxXQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQTlCLElBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7OztBQUdGQTtBQUNBQSxRQUFVSCxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QkMsc0JBQXBCRjtBQUNsQkU7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0JBQW9CVyxlQUFVWDtBQUM5QkE7QUFDQUE7QUFDQUEsa0JBQW9CVSxnQkFBV1Y7QUFDL0JBO0FBQ0FBO0FBQ0FBO0lBZkVBLENBQUFBLEdBQUFBOztBQWtCQStDLElBQUFBLHlCQUFBQSxpQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLGVBQURBO0lBREZBLENBQUFBLEdBQUFBO0lBSUEsYUFBTSxNQUFOLEVBQVcsSUFBWDtJQUNBakUsT0FBQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0VBNVNGQSxHQUFNLElBQU5BLEVBQWtCSCxNQUFsQkc7RUErU0FILE9BQUFxRTtFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFakUsSUFBQWtFLGFBQUFBLENBQVksWUFBWixFQUF5QixXQUF6QixFQUFxQyxRQUFyQyxFQUE4QyxRQUE5Q0E7O0FBRUFDLElBQUFBLDBCQUFBQSxzQkFBZTlDLE1BQUQsRUFBUytDLFlBQVQsRUF0VGhCQyxPQXNURUY7QUFBQUEsTUFBQUE7OztNQXRURjs7TUFzVHVDLDhDQUFBLHlDQUFjO01BQ2pELEtBQUEsUUFBMEJHLFlBQTFCLENBQUE7UUFBQTNELGNBQWNYO01BQWQ7TUFDQXVFLGNBQWNsRDtNQUNkbUQsYUFBZUw7TUFDZk0sY0FBZU47TUFDZk8saUJBQWVQO01BQ2ZRLGtCQUFlUjtNQUNmUyxlQUFjOztBQUdsQlQ7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlTLFlBQVNUO0FBQ3JCQTtBQUNBQTtBQUNBQSxVQUFZUyxZQUFTVDtBQUNyQkE7QUFDQUE7QUFDQUE7SUFwQkVBLENBQUFBLElBQUFBOztBQXVCQW5DLElBQUFBLHFCQUFBQSxpQkFBVTZDLEdBQVY3QztBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUlBLENBQUFBLFFBQVFoQyxJQUFJWSxPQUFBQSxDQUFDaUUsR0FBRGpFLENBQVpvQixDQUFKLENBQUE7UUFDRUEsT0FBQUE7TUFERixPQUVBLElBQU0sQ0FBQSxRQUFBNkMsR0FBR0MsVUFBQUEsQ0FBT25DLGFBQVBtQyxDQUFILENBQUEsSUFBQSxDQUFBLFFBQTBCQyxPQUFKRixHQUFJRSxFQUFHL0UsSUFBQWdGLFFBQUFBLENBQUFBLENBQUhELENBQTFCLENBQUEsQ0FBQSxDQUFOO1FBQ0UvQyxPQUFBbEIsT0FBUUMsT0FBQUEsQ0FBT2tFLGlCQUFmLEVBQThCakQsUUFBRCxHQUFBLENBQVM2QyxHQUFULENBQUEsR0FBYTdDLGlCQUFsQ2pCO01BRFY7UUFoVkppQixPQUFBO01BZ1ZJO0lBSEZBLENBQUFBLEdBQUFBOztBQVFBa0QsSUFBQUEsNEJBQUFBLHdCQUFpQkwsR0FBakJLO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLENBQUEsS0FBQWxGLElBQUFnQyxPQUFBQSxDQUFNNkMsR0FBTjdDLENBQUEscUNBQUEsRUFBQSxRQUFBLENBQUEsQ0FBQTtJQURGa0QsQ0FBQUEsR0FBQUE7O0FBSUF0RSxJQUFBQSxrQkFBQUEsMEJBelZGLEVBeVZFQTtBQUFBQSxNQUFBQTs7O01BelZGO01BeVZTOztBQUVUQTtBQUNBQSxZQUFlWixJQUFBcUIsUUFBQUEsQ0FBQUEsQ0FBTXdCLE9BQUFBLENBQUFBLENBQU1zQyxhQUFBQSxDQUFVQyxJQUFJeEUsT0FBQUEsQ0FBQ3lCLENBQUR6QixDQUFkdUUsQ0FBYnpELE1BQUFBLENBQUFBLENBQWdDZDtBQUM5Q0EsVUFBWUUsT0FBUUMsT0FBQUEsQ0FBT2tFLGlCQUFmLEVBQThCckUsa0NBQUQsR0FBQSxDQUFtQ3dFLElBQUl4RSxPQUFBQSxDQUFDeUIsQ0FBRHpCLENBQXZDLENBQXJCRztBQUNwQkg7QUFDQUEsZUFBaUJaLElBQUFtRCxnQkFBQUEsQ0FBQUEsQ0FBY3ZDLE9BQUFBLENBQUN3RSxJQUFJeEUsT0FBQUEsQ0FBQ3lCLENBQUR6QixDQUFMQTtBQUMvQkE7QUFDQUE7QUFDQUEsZUFBeUJBLE1BQVJnRSxZQUFRaEUsTUFBQUEsRUFBQyxNQUFDd0UsSUFBRCxDQUFEeEU7QUFDekJBO0FBQ0FBO0lBWEVBLENBQUFBLElBQUFBOztBQWNBeUUsSUFBQUEsc0JBQUFBLGtCQUFXNUUsQ0FBWDRFO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUEsUUFBVXZFLE9BQVFDLE9BQUFBLENBQU91RSxvQkFBZixFQUFnQ0QsNENBQXhCdEU7QUFDbEJzRTtBQUNBQTtBQUNBQTtJQU5FQSxDQUFBQSxHQUFBQTs7QUFTQXhELElBQUFBLGtCQUFBQSw4QkFBT0MsS0FBUEQ7QUFBQUEsTUFBQUE7OztNQUNFLEtBQUEsUUFBb0JhLGdCQUFwQixFQUFvQ1osS0FBcEMsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUVBLElBQUEsUUFBQUssQ0FBQUEsWUFBQSxDQUFBLFFBQUFvRCxDQUFBQSxZQUFBLENBQUEsUUFBQUMsQ0FBQUEsWUFBQSxDQUFBLFFBQUFDLENBQUFBLFlBQUM1RCwyQkFBRDRELENBQUEsQ0FBQSxHQUFBLENBQ0c1RCxpREFESCxJQUFBLENBQUEsU0FBQSxDQUFBLENBQUEyRCxDQUFBLENBQUEsR0FBQSxDQUVHM0QsaUNBRkgsSUFBQSxDQUFBLFNBQUEsQ0FBQSxDQUFBMEQsQ0FBQSxDQUFBLEdBQUEsQ0FHRzFELG1DQUhILElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBQU0sQ0FBQSxDQUFBO1FBSUVOLE9BQUNBLHlCQUFEQTtNQUpGO1FBQUFBLE9BQUE7TUFBQTtJQUhGQSxDQUFBQSxHQUFBQTs7QUFVQU8sSUFBQUEscUJBQUFBLGlCQUFVM0IsQ0FBVjJCO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUEsUUFBVXRCLE9BQVFDLE9BQUFBLENBQU91RSxvQkFBZixFQUFnQ2xELDJDQUF4QnJCO0FBQ2xCcUI7QUFDQUE7QUFDQUE7SUFORUEsQ0FBQUEsR0FBQUE7O0FBU0FzRCxJQUFBQSxtQkFBQUEsZUFBUWpGLENBQVJpRjtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBLFFBQVU1RSxPQUFRQyxPQUFBQSxDQUFPdUUsb0JBQWYsRUFBZ0NJLHlDQUF4QjNFO0FBQ2xCMkU7QUFDQUE7QUFDQUE7SUFORUEsQ0FBQUEsR0FBQUE7O0FBU0FDLElBQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUdmLFlBQVNlO0lBRGRBLENBQUFBLEdBQUFBOztBQUlBeEMsSUFBQUEsOEJBQUFBLDBCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0V5QyxVQUFVNUYsSUFBQTJGLFVBQUFBLENBQUFBO01BQ1Z4QyxPQUFxQkMsTUFBckJwRCxJQUFBcUIsUUFBQUEsQ0FBQUEsQ0FBTThCLGdCQUFBQSxDQUFBQSxDQUFlQyxvQkFBQUEsRUFBQUEsRUFBQUEsRUFBckJHLGNBQTJDQyxDQUEzQ0Q7O1FBQTJDO1FBQ3pDRSxPQUFBbUMsT0FBT2hGLE9BQUFBLENBQVFpRixVQUFQckMsQ0FBQ0ssTUFBQUEsQ0FBQUEsQ0FBTWdDLEVBQUU1RixDQUFGNEYsQ0FBUmpGLEVBRFQyQyxDQUFBQSxHQUFxQkg7SUFGdkJELENBQUFBLEdBQUFBOztBQU9BTixJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBN0MsSUFBQXFCLFFBQUFBLENBQUFBLENBQU13QixPQUFBQSxDQUFBQTtJQURSQSxDQUFBQSxHQUFBQTs7QUFJQUwsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBLGlDQUFtQ0EsQ0FBR29DLFlBQVNwQyxHQUFaQSxDQUFnQkEsU0FBQUEsQ0FBQUEsQ0FBU0E7O0FBRTVEQSxVQUFZeEMsSUFBQXFCLFFBQUFBLENBQUFBLENBQU13QixPQUFBQSxDQUFBQSxDQUFNaUQsV0FBQUEsQ0FBQUEsQ0FBUXREO0FBQ2hDQSxpQ0FBbUNvQyxZQUFTcEM7QUFDNUNBLGlDQUFtQ0EsQ0FBR29DLFlBQVNwQyxHQUFaQSxDQUFnQkEsU0FBQUEsQ0FBQUEsQ0FBU0E7QUFDNURBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFFBQXlCdUQsTUFBZC9GLElBQUFtRCxnQkFBQUEsQ0FBQUEsQ0FBYzRDLFFBQUFBLEVBQUFBLEVBQUFBLEVBQWRDLGNBQXdCQyxDQUFELEVBQUlDLENBQTNCRjs7UUFBd0I7UUFBRztRQUN6QkcsT0FDYkEsNEJBQThCRixDQUFFRSxTQUFXRCxDQUFDMUQsU0FBQUEsQ0FBQUEsRUFGakN3RCxDQUFBQSxHQUFjRDtBQUt6QnZEOztBQUVBQTtBQUNBQTtJQWxCRUEsQ0FBQUEsR0FBQUE7O0FBcUJBd0MsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR0osWUFBU0k7SUFEZEEsQ0FBQUEsR0FBQUE7O0FBSUFvQixJQUFBQSxvQkFBQUEsYUFDRSxTQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR3pCLFlBQVN5QjtJQURkQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEseUJBQUFBLHFCQTViRixFQTRiRUE7QUFBQUEsTUFBQUE7OztNQTViRjtNQTRiZ0I7O0FBRWhCQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLGNBQWdCQSxDQUFDQSxPQUFEQSxDQUFTRixNQUFBQSxDQUFBQSxDQUFNRTtBQUMvQkE7QUFDQUE7QUFDQUE7O0FBRUFBLGdCQUFrQmhGLEtBQU1DLGVBQUFBLENBQWErRSxPQUFuQixFQUE2QjNELGNBQTdCLEVBQXdDLFFBQWxDcEIsQ0FBMkMrRTs7QUFFbkVBO0FBQ0FBLG1CQUFxQjFCLFlBQVMwQjtBQUM5QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBLG9CQUFzQjFCLFlBQVMwQjtBQUMvQkE7O0FBRUFBO0FBQ0FBO0lBMUJFQSxDQUFBQSxJQUFBQTtJQTZCQSxhQUFNLE1BQU4sRUFBVyxJQUFYO0lBQ0FyQyxPQUFBLGFBQU0sTUFBTixFQUFXLFFBQVg7RUF2S0ZBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBblRBckU7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYxMDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIDo6U3RydWN0XG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgZGVmIHNlbGYubmV3KGNvbnN0X25hbWUsICphcmdzLCBrZXl3b3JkX2luaXQ6IGZhbHNlLCAmYmxvY2spXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgaWYgY29uc3RfbmFtZS5jbGFzcyA9PSA6OlN0cmluZyAmJiBjb25zdF9uYW1lWzBdLnVwY2FzZSAhPSBjb25zdF9uYW1lWzBdXG4gICAgICAgICMgRmFzdCB0cmFjayBzbyB0aGF0IHdlIHNraXAgbmVlZGxlc3NseSBnb2luZyB0aHJ1IGV4Y2VwdGlvbnNcbiAgICAgICAgIyBpbiBtb3N0IGNhc2VzLlxuICAgICAgICBhcmdzLnVuc2hpZnQoY29uc3RfbmFtZSlcbiAgICAgICAgY29uc3RfbmFtZSA9IG5pbFxuICAgICAgZWxzZVxuICAgICAgICBiZWdpblxuICAgICAgICAgIGNvbnN0X25hbWUgPSA6Ok9wYWwuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICAgICAgcmVzY3VlIDo6VHlwZUVycm9yLCA6Ok5hbWVFcnJvclxuICAgICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxuICAgICAgICAgIGNvbnN0X25hbWUgPSBuaWxcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFyZ3MubWFwIGRvIHxhcmd8XG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShhcmcsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGVuZFxuXG4gICAga2xhc3MgPSA6OkNsYXNzLm5ldyhzZWxmKSBkb1xuICAgICAgYXJncy5lYWNoIHsgfGFyZ3wgZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUoYXJnKSB9XG5cbiAgICAgIGNsYXNzIDw8IHNlbGZcbiAgICAgICAgZGVmIG5ldygqYXJncylcbiAgICAgICAgICBpbnN0YW5jZSA9IGFsbG9jYXRlXG4gICAgICAgICAgYCN7aW5zdGFuY2V9LiQkZGF0YSA9IHt9YFxuICAgICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUoKmFyZ3MpXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYWxpYXNfbWV0aG9kIDpbXSwgOm5ld1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBrbGFzcy5tb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrXG4gICAgYGtsYXNzLiQka2V5d29yZF9pbml0ID0ga2V5d29yZF9pbml0YFxuXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgOjpTdHJ1Y3QuY29uc3Rfc2V0KGNvbnN0X25hbWUsIGtsYXNzKVxuICAgIGVuZFxuXG4gICAga2xhc3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUobmFtZSlcbiAgICBpZiBzZWxmID09IDo6U3RydWN0XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd5b3UgY2Fubm90IGRlZmluZSBhdHRyaWJ1dGVzIHRvIHRoZSBTdHJ1Y3QgY2xhc3MnXG4gICAgZW5kXG5cbiAgICBtZW1iZXJzIDw8IG5hbWVcblxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICAgIGVuZFxuXG4gICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm1lbWJlcnNcbiAgICBpZiBzZWxmID09IDo6U3RydWN0XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0aGUgU3RydWN0IGNsYXNzIGhhcyBubyBtZW1iZXJzJ1xuICAgIGVuZFxuXG4gICAgQG1lbWJlcnMgfHw9IFtdXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcbiAgICBtZW1iZXJzID0gQG1lbWJlcnNcblxuICAgIGtsYXNzLmluc3RhbmNlX2V2YWwgZG9cbiAgICAgIEBtZW1iZXJzID0gbWVtYmVyc1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICBpZiBgI3tzZWxmLmNsYXNzfS4kJGtleXdvcmRfaW5pdGBcbiAgICAgIGt3YXJncyA9IGFyZ3MubGFzdCB8fCB7fVxuXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IDEgfHwgYChhcmdzLmxlbmd0aCA9PT0gMSAmJiAha3dhcmdzLiQkaXNfaGFzaClgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAje2FyZ3MubGVuZ3RofSwgZXhwZWN0ZWQgMClcIlxuICAgICAgZW5kXG5cbiAgICAgIGV4dHJhID0ga3dhcmdzLmtleXMgLSBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgICAgIGlmIGV4dHJhLmFueT9cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVua25vd24ga2V5d29yZHM6ICN7ZXh0cmEuam9pbignLCAnKX1cIlxuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBzZWxmW25hbWVdID0ga3dhcmdzW25hbWVdXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnc3RydWN0IHNpemUgZGlmZmVycydcbiAgICAgIGVuZFxuXG4gICAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX2luZGV4IGRvIHxuYW1lLCBpbmRleHxcbiAgICAgICAgc2VsZltuYW1lXSA9IGFyZ3NbaW5kZXhdXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShmcm9tKVxuICAgICV4e1xuICAgICAgc2VsZi4kJGRhdGEgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tLiQkZGF0YSksIGksIG1heCwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIG1heCA9IGtleXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGtleXNbaV07XG4gICAgICAgIHNlbGYuJCRkYXRhW25hbWVdID0gZnJvbS4kJGRhdGFbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5rZXl3b3JkX2luaXQ/XG4gICAgYHNlbGYuJCRrZXl3b3JkX2luaXRgXG4gIGVuZFxuXG4gIGRlZiBtZW1iZXJzXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgSGFzaC5uZXcoYHNlbGYuJCRkYXRhYCkuaGFzaFxuICBlbmRcblxuICBkZWYgW10obmFtZSlcbiAgICBpZiA6OkludGVnZXIgPT09IG5hbWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIDo6U3RyaW5nID09PSBuYW1lXG4gICAgICAleHtcbiAgICAgICAgaWYoIXNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBpZiA6OkludGVnZXIgPT09IG5hbWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIDo6U3RyaW5nID09PSBuYW1lXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKSB1bmxlc3Mgc2VsZi5jbGFzcy5tZW1iZXJzLmluY2x1ZGU/KG5hbWUudG9fc3ltKVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7OjpTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7OjpTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgLmVxbD8oYGJgKX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIHNlbGZbbmFtZV0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfcGFpclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9wYWlyKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCB7IHxuYW1lfCB5aWVsZCBbbmFtZSwgc2VsZltuYW1lXV0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubWFwIHsgfG5hbWV8IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9ICcjPHN0cnVjdCAnXG5cbiAgICBpZiBgaW5zcGVjdF9zdGFja2AuaW5jbHVkZT8gX19pZF9fXG4gICAgICByZXN1bHQgKyAnOi4uLj4nXG4gICAgZWxzZVxuICAgICAgYGluc3BlY3Rfc3RhY2tgIDw8IF9faWRfX1xuICAgICAgcHVzaGVkID0gdHJ1ZVxuXG4gICAgICBpZiA6OlN0cnVjdCA9PT0gc2VsZiAmJiBzZWxmLmNsYXNzLm5hbWVcbiAgICAgICAgcmVzdWx0ICs9IFwiI3tzZWxmLmNsYXNzfSBcIlxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdCArPSBlYWNoX3BhaXIubWFwIGRvIHxuYW1lLCB2YWx1ZXxcbiAgICAgICAgXCIje25hbWV9PSN7T3BhbC5pbnNwZWN0KHZhbHVlKX1cIlxuICAgICAgZW5kLmpvaW4gJywgJ1xuXG4gICAgICByZXN1bHQgKz0gJz4nXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbnN1cmVcbiAgICBgaW5zcGVjdF9zdGFjay5wb3AoKWAgaWYgcHVzaGVkXG4gIGVuZFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje2BhcmdzW2ldYC5jbGFzc30gaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goI3tzZWxmW2BhcmdzW2ldYF19KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGlnKGtleSwgKmtleXMpXG4gICAgaXRlbSA9IGlmIGBrZXkuJCRpc19zdHJpbmcgJiYgc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KWBcbiAgICAgICAgICAgICBgc2VsZi4kJGRhdGFba2V5XSB8fCBuaWxgXG4gICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmtleXMpXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuICBhbGlhcyB2YWx1ZXMgdG9fYVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlN0cnVjdD4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIm5ldyIsImNvbnN0X25hbWUiLCJjbGFzcyIsIlN0cmluZyIsIltdIiwiMCIsInVwY2FzZSIsImFyZ3MiLCJ1bnNoaWZ0IiwiT3BhbCIsImNvbnN0X25hbWUhIiwiVHlwZUVycm9yIiwiTmFtZUVycm9yIiwibWFwIiwiYmxvY2sgaW4gbmV3IiwiYXJnIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuZXciLCJjb2VyY2VfdG8hIiwia2xhc3MiLCJDbGFzcyIsImVhY2giLCJibG9jayAoMyBsZXZlbHMpIGluIG5ldyIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwidG9fcHJvYyIsIlN0cnVjdCIsImNvbnN0X3NldCIsIm5hbWUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJtZW1iZXJzIiwiPDwiLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgaW4gZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwidmFsdWUiLCJAbWVtYmVycyIsIiRyZXRfb3JfMSIsImluaGVyaXRlZCIsImluc3RhbmNlX2V2YWwiLCJibG9jayBpbiBpbmhlcml0ZWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaGVyaXRlZCIsImt3YXJncyIsImxhc3QiLCI+IiwibGVuZ3RoIiwiMSIsImV4dHJhIiwiLSIsImtleXMiLCJhbnk/Iiwiam9pbiIsImJsb2NrIGluIGluaXRpYWxpemUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJbXT0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpbmRleCIsImluaXRpYWxpemVfY29weSIsImZyb20iLCJrZXl3b3JkX2luaXQ/IiwiaGFzaCIsIkhhc2giLCJJbnRlZ2VyIiwiPCIsInNpemUiLCItQCIsIkluZGV4RXJyb3IiLCI+PSIsImluY2x1ZGU/IiwidG9fc3ltIiwiPT0iLCJvdGhlciIsImluc3RhbmNlX29mPyIsIl9faWRfXyIsIj09PSIsImVxbD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJlYWNoX3BhaXIiLCJibG9jayBpbiBlYWNoX3BhaXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfcGFpciIsInRvX2EiLCJibG9jayBpbiB0b19hIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19hIiwiaW5zcGVjdCIsInJlc3VsdCIsIisiLCJwdXNoZWQiLCJibG9jayBpbiBpbnNwZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0IiwidG9faCIsImVhY2hfd2l0aF9vYmplY3QiLCJibG9jayBpbiB0b19oIiwiaCIsImJsb2NrICgyIGxldmVscykgaW4gdG9faCIsInZhbHVlc19hdCIsImJsb2NrIGluIHZhbHVlc19hdCIsImJsb2NrICgyIGxldmVscykgaW4gdmFsdWVzX2F0IiwiZmxhdHRlbiIsImRpZyIsImtleSIsIml0ZW0iLCJyZXNwb25kX3RvPyJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7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ZSI6NjU2MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xucmVxdWlyZSAnY29yZWxpYi9yYXRpb25hbC9iYXNlJ1xuXG5jbGFzcyA6OlJhdGlvbmFsIDwgOjpOdW1lcmljXG4gIGRlZiBzZWxmLnJlZHVjZShudW0sIGRlbilcbiAgICBudW0gPSBudW0udG9faVxuICAgIGRlbiA9IGRlbi50b19pXG5cbiAgICBpZiBkZW4gPT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICBlbHNpZiBkZW4gPCAwXG4gICAgICBudW0gPSAtbnVtXG4gICAgICBkZW4gPSAtZGVuXG4gICAgZWxzaWYgZGVuID09IDFcbiAgICAgIHJldHVybiBuZXcobnVtLCBkZW4pXG4gICAgZW5kXG5cbiAgICBnY2QgPSBudW0uZ2NkKGRlbilcblxuICAgIG5ldyhudW0gLyBnY2QsIGRlbiAvIGdjZClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29udmVydChudW0sIGRlbilcbiAgICBpZiBudW0ubmlsPyB8fCBkZW4ubmlsP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdjYW5ub3QgY29udmVydCBuaWwgaW50byBSYXRpb25hbCdcbiAgICBlbmRcblxuICAgIGlmIDo6SW50ZWdlciA9PT0gbnVtICYmIDo6SW50ZWdlciA9PT0gZGVuXG4gICAgICByZXR1cm4gcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgaWYgOjpGbG9hdCA9PT0gbnVtIHx8IDo6U3RyaW5nID09PSBudW0gfHwgOjpDb21wbGV4ID09PSBudW1cbiAgICAgIG51bSA9IG51bS50b19yXG4gICAgZW5kXG5cbiAgICBpZiA6OkZsb2F0ID09PSBkZW4gfHwgOjpTdHJpbmcgPT09IGRlbiB8fCA6OkNvbXBsZXggPT09IGRlblxuICAgICAgZGVuID0gZGVuLnRvX3JcbiAgICBlbmRcblxuICAgIGlmIGRlbi5lcXVhbD8oMSkgJiYgISg6OkludGVnZXIgPT09IG51bSlcbiAgICAgIDo6T3BhbC5jb2VyY2VfdG8hKG51bSwgOjpSYXRpb25hbCwgOnRvX3IpXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBudW0gJiYgOjpOdW1lcmljID09PSBkZW5cbiAgICAgIG51bSAvIGRlblxuICAgIGVsc2VcbiAgICAgIHJlZHVjZShudW0sIGRlbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUobnVtLCBkZW4pXG4gICAgQG51bSA9IG51bVxuICAgIEBkZW4gPSBkZW5cbiAgICBmcmVlemVcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIEBudW1cbiAgZW5kXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgQGRlblxuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIFtvdGhlciwgc2VsZl1cblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICBbb3RoZXIudG9fciwgc2VsZl1cblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgW290aGVyLCB0b19mXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgQG51bSA9PSBvdGhlci5udW1lcmF0b3IgJiYgQGRlbiA9PSBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIEBudW0gPT0gb3RoZXIgJiYgQGRlbiA9PSAxXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YgPT0gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yIDw9PiAwXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgQG51bSAtIEBkZW4gKiBvdGhlciA8PT4gMFxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mIDw9PiBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOjw9Piwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yICsgQGRlbiAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0gKyBvdGhlciAqIEBkZW4sIEBkZW4pXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YgKyBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciAtIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtIC0gb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mIC0gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSAqIG90aGVyLCBAZGVuKVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mICogb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5udW1lcmF0b3JcblxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgaWYgb3RoZXIgPT0gMFxuICAgICAgICB0b19mIC8gMC4wXG4gICAgICBlbHNlXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0sIEBkZW4gKiBvdGhlcilcbiAgICAgIGVuZFxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mIC8gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICBpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIDo6RmxvYXQ6OklORklOSVRZXG4gICAgICBlbHNpZiBvdGhlciA+IDBcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSoqb3RoZXIsIEBkZW4qKm90aGVyKVxuICAgICAgZWxzaWYgb3RoZXIgPCAwXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBkZW4qKi1vdGhlciwgQG51bSoqLW90aGVyKVxuICAgICAgZWxzZVxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbCgxLCAxKVxuICAgICAgZW5kXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIHRvX2YqKm90aGVyXG5cbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVsc2lmIG90aGVyLmRlbm9taW5hdG9yID09IDFcbiAgICAgICAgaWYgb3RoZXIgPCAwXG4gICAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQGRlbioqb3RoZXIubnVtZXJhdG9yLmFicywgQG51bSoqb3RoZXIubnVtZXJhdG9yLmFicylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0qKm90aGVyLm51bWVyYXRvciwgQGRlbioqb3RoZXIubnVtZXJhdG9yKVxuICAgICAgICBlbmRcbiAgICAgIGVsc2lmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICAgIGVsc2VcbiAgICAgICAgdG9fZioqb3RoZXJcbiAgICAgIGVuZFxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bS5hYnMsIEBkZW4uYWJzKVxuICBlbmRcblxuICBkZWYgY2VpbChwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICAoLSgtQG51bSAvIEBkZW4pKS5jZWlsXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmNlaWwsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGZsb29yKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgICgtKC1AbnVtIC8gQGRlbikpLmZsb29yXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmZsb29yLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgXCJSYXRpb25hbDoje0BudW19OiN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiKCN7c2VsZn0pXCJcbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXBzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0gI3tlcHMuYWJzfSxcbiAgICAgICAgICBhID0gI3tzZWxmIC0gYGVgfSxcbiAgICAgICAgICBiID0gI3tzZWxmICsgYGVgfTtcblxuICAgICAgdmFyIHAwID0gMCxcbiAgICAgICAgICBwMSA9IDEsXG4gICAgICAgICAgcTAgPSAxLFxuICAgICAgICAgIHExID0gMCxcbiAgICAgICAgICBwMiwgcTI7XG5cbiAgICAgIHZhciBjLCBrLCB0O1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjID0gI3tgYWAuY2VpbH07XG5cbiAgICAgICAgaWYgKCN7YGNgIDw9IGBiYH0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGsgID0gYyAtIDE7XG4gICAgICAgIHAyID0gayAqIHAxICsgcDA7XG4gICAgICAgIHEyID0gayAqIHExICsgcTA7XG4gICAgICAgIHQgID0gI3sxIC8gKGBiYCAtIGBrYCl9O1xuICAgICAgICBiICA9ICN7MSAvIChgYWAgLSBga2ApfTtcbiAgICAgICAgYSAgPSB0O1xuXG4gICAgICAgIHAwID0gcDE7XG4gICAgICAgIHEwID0gcTE7XG4gICAgICAgIHAxID0gcDI7XG4gICAgICAgIHExID0gcTI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBjICogcDEgKyBwMGAsIGBjICogcTEgKyBxMGApfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3VuZChwcmVjaXNpb24gPSAwKVxuICAgIHJldHVybiB3aXRoX3ByZWNpc2lvbig6cm91bmQsIHByZWNpc2lvbikgdW5sZXNzIHByZWNpc2lvbiA9PSAwXG4gICAgcmV0dXJuIDAgaWYgQG51bSA9PSAwXG4gICAgcmV0dXJuIEBudW0gaWYgQGRlbiA9PSAxXG5cbiAgICBudW0gPSBAbnVtLmFicyAqIDIgKyBAZGVuXG4gICAgZGVuID0gQGRlbiAqIDJcblxuICAgIGFwcHJveCA9IChudW0gLyBkZW4pLnRydW5jYXRlXG5cbiAgICBpZiBAbnVtIDwgMFxuICAgICAgLWFwcHJveFxuICAgIGVsc2VcbiAgICAgIGFwcHJveFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIEBudW0gLyBAZGVuXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgdHJ1bmNhdGVcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIje0BudW19LyN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgQG51bSA8IDAgPyBjZWlsIDogZmxvb3JcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6dHJ1bmNhdGUsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHdpdGhfcHJlY2lzaW9uKG1ldGhvZCwgcHJlY2lzaW9uKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGFuIEludGVnZXInIHVubGVzcyA6OkludGVnZXIgPT09IHByZWNpc2lvblxuXG4gICAgcCA9IDEwKipwcmVjaXNpb25cbiAgICBzID0gc2VsZiAqIHBcblxuICAgIGlmIHByZWNpc2lvbiA8IDFcbiAgICAgIChzLnNlbmQobWV0aG9kKSAvIHApLnRvX2lcbiAgICBlbHNlXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChzLnNlbmQobWV0aG9kKSwgcClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZnJvbV9zdHJpbmcoc3RyaW5nKVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHN0cmluZy50cmltTGVmdCgpLFxuICAgICAgICAgIHJlID0gL15bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/LyxcbiAgICAgICAgICBtYXRjaCA9IHN0ci5tYXRjaChyZSksXG4gICAgICAgICAgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gcmF0aW9uYWwgcmVhbCBwYXJ0XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoMCwgMSl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZGl2aWRlIC9cbiAgYWxpYXMgcXVvIC9cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpSYXRpb25hbD4iLCJyZWR1Y2UiLCJudW0iLCJkZW4iLCJ0b19pIiwiMCIsIktlcm5lbCIsInJhaXNlIiwiWmVyb0RpdmlzaW9uRXJyb3IiLCI8IiwiLUAiLCIxIiwibmV3IiwiZ2NkIiwiLyIsImNvbnZlcnQiLCJuaWw/IiwiVHlwZUVycm9yIiwiSW50ZWdlciIsIkZsb2F0IiwiU3RyaW5nIiwiQ29tcGxleCIsInRvX3IiLCJlcXVhbD8iLCI9PT0iLCJPcGFsIiwiY29lcmNlX3RvISIsIlJhdGlvbmFsIiwiTnVtZXJpYyIsImluaXRpYWxpemUiLCJAbnVtIiwiQGRlbiIsImZyZWV6ZSIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiY29lcmNlIiwib3RoZXIiLCIkcmV0X29yXzEiLCJ0b19mIiwiPT0iLCIkcmV0X29yXzIiLCI8PT4iLCItIiwiKiIsIl9fY29lcmNlZF9fIiwiKyIsIioqIiwiRmxvYXQ6OklORklOSVRZIiwiPiIsImFicyIsImNlaWwiLCJwcmVjaXNpb24iLCJ3aXRoX3ByZWNpc2lvbiIsImZsb29yIiwiaGFzaCIsImluc3BlY3QiLCJyYXRpb25hbGl6ZSIsImVwcyIsIkFyZ3VtZW50RXJyb3IiLCI8PSIsInJvdW5kIiwiMiIsImFwcHJveCIsInRydW5jYXRlIiwidG9fcyIsIm1ldGhvZCIsInAiLCIxMCIsInMiLCJzZW5kIiwiZnJvbV9zdHJpbmciLCJzdHJpbmciXSwibWFwcGluZ3MiOiJBQUFBQSxtQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHVCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFQyxNQUFJSCxJQUFKRyxhQUFBQSxrQkFBZ0JDLEdBQUQsRUFBTUMsR0FBckJGO0FBQUFBLE1BQUFBOzs7TUFDRUMsTUFBTUEsR0FBR0UsTUFBQUEsQ0FBQUE7TUFDVEQsTUFBTUEsR0FBR0MsTUFBQUEsQ0FBQUE7TUFFVCxJQUFBLE1BQUdELEdBQUgsRUFBVUUsQ0FBVixDQUFBO1FBQ0VDLE9BQVFDLE9BQUFBLENBQU9DLHdCQUFmLEVBQW9DUCxjQUE1Qk07TUFEVixPQUVBLElBQUEsUUFBVUUsT0FBSk4sR0FBSU0sRUFBRUosQ0FBRkksQ0FBVixDQUFBOztRQUNFUCxNQUFPQSxHQUFEUSxPQUFBQSxDQUFBQTtRQUNOUCxNQUFPQSxHQUFETyxPQUFBQSxDQUFBQTtNQUZSLE9BR0EsSUFBQSxNQUFNUCxHQUFOLEVBQWFRLENBQWIsQ0FBQTtRQUNFLE9BQU9iLElBQUFjLEtBQUFBLENBQUlWLEdBQUosRUFBU0MsR0FBVFM7TUFEVDtNQUlBQyxNQUFNWCxHQUFHVyxLQUFBQSxDQUFLVixHQUFMVTtNQUVUWixPQUFBSCxJQUFBYyxLQUFBQSxDQUFRRSxXQUFKWixHQUFJWSxFQUFFRCxHQUFGQyxDQUFSLEVBQW1CQSxXQUFKWCxHQUFJVyxFQUFFRCxHQUFGQyxDQUFuQkY7SUFmRlgsQ0FBQUEsR0FBQUE7SUFrQkFjLE1BQUlqQixJQUFKaUIsY0FBQUEsbUJBQWlCYixHQUFELEVBQU1DLEdBQXRCWTtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBRyxDQUFBLFFBQUFiLEdBQUdjLFNBQUFBLENBQUFBLENBQUgsQ0FBQSxJQUFBLENBQUEsUUFBWWIsR0FBR2EsU0FBQUEsQ0FBQUEsQ0FBZixDQUFBLENBQUEsQ0FBSDtRQUNFVixPQUFRQyxPQUFBQSxDQUFPVSxnQkFBZixFQUE0QkYsa0NBQXBCUjtNQURWO01BSUEsSUFBRyxDQUFBLFFBQUFXLGNBQUEsRUFBY2hCLEdBQWQsQ0FBQSxJQUFBLENBQUEsUUFBcUJnQixjQUFyQixFQUFtQ2YsR0FBbkMsQ0FBQSxDQUFBLENBQUg7UUFDRSxPQUFPTCxJQUFBRyxRQUFBQSxDQUFPQyxHQUFQLEVBQVlDLEdBQVpGO01BRFQ7TUFJQSxJQUFHLENBQUEsQ0FBQSxRQUFBa0IsWUFBQSxFQUFZakIsR0FBWixDQUFBLElBQUEsQ0FBQSxRQUFtQmtCLGFBQW5CLEVBQWdDbEIsR0FBaEMsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLFFBQXVDbUIsY0FBdkMsRUFBcURuQixHQUFyRCxDQUFBLENBQUEsQ0FBSDtRQUNFQSxNQUFNQSxHQUFHb0IsTUFBQUEsQ0FBQUE7TUFEWDtNQUlBLElBQUcsQ0FBQSxDQUFBLFFBQUFILFlBQUEsRUFBWWhCLEdBQVosQ0FBQSxJQUFBLENBQUEsUUFBbUJpQixhQUFuQixFQUFnQ2pCLEdBQWhDLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxRQUF1Q2tCLGNBQXZDLEVBQXFEbEIsR0FBckQsQ0FBQSxDQUFBLENBQUg7UUFDRUEsTUFBTUEsR0FBR21CLE1BQUFBLENBQUFBO01BRFg7TUFJQSxJQUFHLENBQUEsUUFBQW5CLEdBQUdvQixXQUFBQSxDQUFRWixDQUFSWSxDQUFILENBQUEsSUFBQSxDQUFBLEtBQW1CTCxjQUFVTSxRQUFBQSxDQUFJdEIsR0FBSnNCLENBQTdCLENBQUEsQ0FBQSxDQUFIO1FBQ0VULE9BQUFVLEtBQU1DLGVBQUFBLENBQVl4QixHQUFsQixFQUF1QnlCLGVBQXZCLEVBQW1DLE1BQTdCRDtNQURSLE9BRUEsSUFBTSxDQUFBLFFBQUFFLGNBQUEsRUFBYzFCLEdBQWQsQ0FBQSxJQUFBLENBQUEsUUFBcUIwQixjQUFyQixFQUFtQ3pCLEdBQW5DLENBQUEsQ0FBQSxDQUFOO1FBQ0VZLE9BQUlELFdBQUpaLEdBQUlZLEVBQUVYLEdBQUZXO01BRE47UUFHRUMsT0FBQWpCLElBQUFHLFFBQUFBLENBQU9DLEdBQVAsRUFBWUMsR0FBWkY7TUFIRjtJQW5CRmMsQ0FBQUEsR0FBQUE7O0FBMEJBYyxJQUFBQSwwQkFBQUEsc0JBQWUzQixHQUFELEVBQU1DLEdBQXBCMEI7QUFBQUEsTUFBQUE7OztNQUNFQyxXQUFPNUI7TUFDUDZCLFdBQU81QjtNQUNQMEIsT0FBQS9CLElBQUFrQyxRQUFBQSxDQUFBQTtJQUhGSCxDQUFBQSxHQUFBQTs7QUFNQUksSUFBQUEseUJBQUFBLGFBQ0UsS0FERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLDJCQUFBQSxhQUNFLEtBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxzQkFBQUEsa0JBQVdDLEtBQVhEO0FBQUFBLE1BQUFBOztNQUVFLElBQUEsUUFBS1IsZUFBTCxFQURBVSxDQUFBQSxZQUFLRCxLQUFMQyxDQUNBLENBQUE7UUFDRUYsT0FBQSxDQUFDQyxLQUFELEVBQVF0QyxJQUFSO01BREYsT0FHQSxJQUFBLFFBQUtvQixjQUFMLEVBbkVKLFNBbUVJLENBQUE7UUFDRWlCLE9BQUEsQ0FBQ0MsS0FBS2QsTUFBQUEsQ0FBQUEsQ0FBTixFQUFheEIsSUFBYjtNQURGLE9BR0EsSUFBQSxRQUFLcUIsWUFBTCxFQXRFSixTQXNFSSxDQUFBO1FBQ0VnQixPQUFBLENBQUNDLEtBQUQsRUFBUXRDLElBQUF3QyxNQUFBQSxDQUFBQSxDQUFSO01BREY7UUFQQUgsT0FBQTtNQU9BO0lBUkZBLENBQUFBLEdBQUFBOztBQWFBSSxJQUFBQSxrQkFBQUEsNEJBQU9ILEtBQVBHO0FBQUFBLE1BQUFBOztNQUVFLElBQUEsUUFBS1osZUFBTCxFQURBVSxDQUFBQSxZQUFLRCxLQUFMQyxDQUNBLENBQUE7UUFDRSxJQUFBLFFBQUFHLENBQUFBLFlBQUFWLFFBQUtTLE9BQUFBLENBQUdILEtBQUtILFdBQUFBLENBQUFBLENBQVJNLENBQUxDLENBQUEsQ0FBQTtVQUEyQkQsT0FBQVIsUUFBS1EsT0FBQUEsQ0FBR0gsS0FBS0YsYUFBQUEsQ0FBQUEsQ0FBUks7UUFBaEM7VUFBQUEsT0FBQTtRQUFBO01BREYsT0FHQSxJQUFBLFFBQUtyQixjQUFMLEVBaEZKLFNBZ0ZJLENBQUE7UUFDRSxJQUFBLFFBQUFzQixDQUFBQSxZQUFBVixRQUFLUyxPQUFBQSxDQUFHSCxLQUFIRyxDQUFMQyxDQUFBLENBQUE7VUFBaUJELE9BQUFSLFFBQUtRLE9BQUFBLENBQUc1QixDQUFINEI7UUFBdEI7VUFBQUEsT0FBQTtRQUFBO01BREYsT0FHQSxJQUFBLFFBQUtwQixZQUFMLEVBbkZKLFNBbUZJLENBQUE7UUFDRW9CLE9BQUF6QyxJQUFBd0MsTUFBQUEsQ0FBQUEsQ0FBS0MsT0FBQUEsQ0FBR0gsS0FBSEc7TUFEUDtRQUlFQSxPQUFBSCxLQUFNRyxPQUFBQSxDQUFHekMsSUFBSHlDO01BSlI7SUFSRkEsQ0FBQUEsR0FBQUE7O0FBZ0JBRSxJQUFBQSxtQkFBQUEsK0JBQVFMLEtBQVJLO0FBQUFBLE1BQUFBOztNQUVFLElBQUEsUUFBS2QsZUFBTCxFQURBVSxDQUFBQSxZQUFLRCxLQUFMQyxDQUNBLENBQUE7UUFDRUksT0FBeUJDLFVBQXBCQyxVQUFMYixRQUFLYSxFQUFFUCxLQUFLRixhQUFBQSxDQUFBQSxDQUFQUyxDQUFvQkQsRUFBT0MsVUFBTFosUUFBS1ksRUFBRVAsS0FBS0gsV0FBQUEsQ0FBQUEsQ0FBUFUsQ0FBUEQsQ0FBeUJELFFBQUFBLENBQUlwQyxDQUFKb0M7TUFEcEQsT0FHQSxJQUFBLFFBQUt2QixjQUFMLEVBaEdKLFNBZ0dJLENBQUE7UUFDRXVCLE9BQUtDLFVBQUxaLFFBQUtZLEVBQU9DLFVBQUxaLFFBQUtZLEVBQUVQLEtBQUZPLENBQVBELENBQWVELFFBQUFBLENBQUlwQyxDQUFKb0M7TUFEdEIsT0FHQSxJQUFBLFFBQUt0QixZQUFMLEVBbkdKLFNBbUdJLENBQUE7UUFDRXNCLE9BQUEzQyxJQUFBd0MsTUFBQUEsQ0FBQUEsQ0FBS0csUUFBQUEsQ0FBSUwsS0FBSks7TUFEUDtRQUlFQSxPQUFBM0MsSUFBQThDLGFBQUFBLENBQVksS0FBWixFQUFrQlIsS0FBbEJRO01BSkY7SUFSRkgsQ0FBQUEsR0FBQUE7O0FBZ0JBSSxJQUFBQSxpQkFBQUEsMkJBQU1ULEtBQU5TO0FBQUFBLE1BQUFBOztNQUVFLElBQUEsUUFBS2xCLGVBQUwsRUFEQVUsQ0FBQUEsWUFBS0QsS0FBTEMsQ0FDQSxDQUFBOztRQUNFbkMsTUFBK0IyQyxTQUFwQkYsVUFBTGIsUUFBS2EsRUFBRVAsS0FBS0YsYUFBQUEsQ0FBQUEsQ0FBUFMsQ0FBb0JFLEVBQU9GLFVBQUxaLFFBQUtZLEVBQUVQLEtBQUtILFdBQUFBLENBQUFBLENBQVBVLENBQVBFO1FBQy9CMUMsTUFBV3dDLFVBQUxaLFFBQUtZLEVBQUVQLEtBQUtGLGFBQUFBLENBQUFBLENBQVBTO1FBRVhFLE9BQUF2QyxPQUFRcUIsVUFBQUEsQ0FBVXpCLEdBQWxCLEVBQXVCQyxHQUFmd0I7TUFKVixPQU1BLElBQUEsUUFBS1QsY0FBTCxFQW5ISixTQW1ISSxDQUFBO1FBQ0UyQixPQUFBdkMsT0FBUXFCLFVBQUFBLENBQWVrQixTQUFMZixRQUFLZSxFQUFRRixVQUFOUCxLQUFNTyxFQUFFWixRQUFGWSxDQUFSRSxDQUF2QixFQUF1Q2QsUUFBL0JKO01BRFYsT0FHQSxJQUFBLFFBQUtSLFlBQUwsRUF0SEosU0FzSEksQ0FBQTtRQUNFMEIsT0FBS0EsU0FBTC9DLElBQUF3QyxNQUFBQSxDQUFBQSxDQUFLTyxFQUFFVCxLQUFGUztNQURQO1FBSUVBLE9BQUEvQyxJQUFBOEMsYUFBQUEsQ0FBWSxHQUFaLEVBQWdCUixLQUFoQlE7TUFKRjtJQVhGQyxDQUFBQSxHQUFBQTs7QUFtQkFILElBQUFBLGlCQUFBQSw0QkFBTU4sS0FBTk07QUFBQUEsTUFBQUE7O01BRUUsSUFBQSxRQUFLZixlQUFMLEVBREFVLENBQUFBLFlBQUtELEtBQUxDLENBQ0EsQ0FBQTs7UUFDRW5DLE1BQStCd0MsVUFBcEJDLFVBQUxiLFFBQUthLEVBQUVQLEtBQUtGLGFBQUFBLENBQUFBLENBQVBTLENBQW9CRCxFQUFPQyxVQUFMWixRQUFLWSxFQUFFUCxLQUFLSCxXQUFBQSxDQUFBQSxDQUFQVSxDQUFQRDtRQUMvQnZDLE1BQVd3QyxVQUFMWixRQUFLWSxFQUFFUCxLQUFLRixhQUFBQSxDQUFBQSxDQUFQUztRQUVYRCxPQUFBcEMsT0FBUXFCLFVBQUFBLENBQVV6QixHQUFsQixFQUF1QkMsR0FBZndCO01BSlYsT0FNQSxJQUFBLFFBQUtULGNBQUwsRUF0SUosU0FzSUksQ0FBQTtRQUNFd0IsT0FBQXBDLE9BQVFxQixVQUFBQSxDQUFlZSxVQUFMWixRQUFLWSxFQUFRQyxVQUFOUCxLQUFNTyxFQUFFWixRQUFGWSxDQUFSRCxDQUF2QixFQUF1Q1gsUUFBL0JKO01BRFYsT0FHQSxJQUFBLFFBQUtSLFlBQUwsRUF6SUosU0F5SUksQ0FBQTtRQUNFdUIsT0FBS0EsVUFBTDVDLElBQUF3QyxNQUFBQSxDQUFBQSxDQUFLSSxFQUFFTixLQUFGTTtNQURQO1FBSUVBLE9BQUE1QyxJQUFBOEMsYUFBQUEsQ0FBWSxHQUFaLEVBQWdCUixLQUFoQlE7TUFKRjtJQVhGRixDQUFBQSxHQUFBQTs7QUFtQkFDLElBQUFBLGlCQUFBQSx1QkFBTVAsS0FBTk87QUFBQUEsTUFBQUE7O01BRUUsSUFBQSxRQUFLaEIsZUFBTCxFQURBVSxDQUFBQSxZQUFLRCxLQUFMQyxDQUNBLENBQUE7O1FBQ0VuQyxNQUFXeUMsVUFBTGIsUUFBS2EsRUFBRVAsS0FBS0gsV0FBQUEsQ0FBQUEsQ0FBUFU7UUFDWHhDLE1BQVd3QyxVQUFMWixRQUFLWSxFQUFFUCxLQUFLRixhQUFBQSxDQUFBQSxDQUFQUztRQUVYQSxPQUFBckMsT0FBUXFCLFVBQUFBLENBQVV6QixHQUFsQixFQUF1QkMsR0FBZndCO01BSlYsT0FNQSxJQUFBLFFBQUtULGNBQUwsRUF6SkosU0F5SkksQ0FBQTtRQUNFeUIsT0FBQXJDLE9BQVFxQixVQUFBQSxDQUFlZ0IsVUFBTGIsUUFBS2EsRUFBRVAsS0FBRk8sQ0FBdkIsRUFBZ0NaLFFBQXhCSjtNQURWLE9BR0EsSUFBQSxRQUFLUixZQUFMLEVBNUpKLFNBNEpJLENBQUE7UUFDRXdCLE9BQUtBLFVBQUw3QyxJQUFBd0MsTUFBQUEsQ0FBQUEsQ0FBS0ssRUFBRVAsS0FBRk87TUFEUDtRQUlFQSxPQUFBN0MsSUFBQThDLGFBQUFBLENBQVksR0FBWixFQUFnQlIsS0FBaEJRO01BSkY7SUFYRkQsQ0FBQUEsR0FBQUE7O0FBbUJBN0IsSUFBQUEsaUJBQUFBLDRCQUFNc0IsS0FBTnRCO0FBQUFBLE1BQUFBOztNQUVFLElBQUEsUUFBS2EsZUFBTCxFQURBVSxDQUFBQSxZQUFLRCxLQUFMQyxDQUNBLENBQUE7O1FBQ0VuQyxNQUFXeUMsVUFBTGIsUUFBS2EsRUFBRVAsS0FBS0YsYUFBQUEsQ0FBQUEsQ0FBUFM7UUFDWHhDLE1BQVd3QyxVQUFMWixRQUFLWSxFQUFFUCxLQUFLSCxXQUFBQSxDQUFBQSxDQUFQVTtRQUVYN0IsT0FBQVIsT0FBUXFCLFVBQUFBLENBQVV6QixHQUFsQixFQUF1QkMsR0FBZndCO01BSlYsT0FNQSxJQUFBLFFBQUtULGNBQUwsRUE1S0osU0E0S0ksQ0FBQTtRQUNFLElBQUEsTUFBR2tCLEtBQUgsRUFBWS9CLENBQVosQ0FBQTtVQUNFUyxPQUFLQSxXQUFMaEIsSUFBQXdDLE1BQUFBLENBQUFBLENBQUt4QixFQUFFLEdBQUZBO1FBRFA7VUFHRUEsT0FBQVIsT0FBUXFCLFVBQUFBLENBQVVHLFFBQWxCLEVBQTZCYSxVQUFMWixRQUFLWSxFQUFFUCxLQUFGTyxDQUFyQmhCO1FBSFY7TUFERixPQU9BLElBQUEsUUFBS1IsWUFBTCxFQW5MSixTQW1MSSxDQUFBO1FBQ0VMLE9BQUtBLFdBQUxoQixJQUFBd0MsTUFBQUEsQ0FBQUEsQ0FBS3hCLEVBQUVzQixLQUFGdEI7TUFEUDtRQUlFQSxPQUFBaEIsSUFBQThDLGFBQUFBLENBQVksR0FBWixFQUFnQlIsS0FBaEJRO01BSkY7SUFmRjlCLENBQUFBLEdBQUFBOztBQXVCQWdDLElBQUFBLGtCQUFBQSx3QkFBT1YsS0FBUFU7QUFBQUEsTUFBQUE7O01BRUUsSUFBQSxRQUFLNUIsY0FBTCxFQURBbUIsQ0FBQUEsWUFBS0QsS0FBTEMsQ0FDQSxDQUFBO1FBQ0UsSUFBRyxDQUFBLE1BQUF2QyxJQUFBLEVBQVFPLENBQVIsQ0FBQSxJQUFBLENBQUEsUUFBbUJJLE9BQU4yQixLQUFNM0IsRUFBRUosQ0FBRkksQ0FBbkIsQ0FBQSxDQUFBLENBQUg7VUFDRXFDLE9BQUFDLElBQUE1QixZQUFBNEI7UUFERixPQUVBLElBQUEsUUFBWUMsT0FBTlosS0FBTVksRUFBRTNDLENBQUYyQyxDQUFaLENBQUE7VUFDRUYsT0FBQXhDLE9BQVFxQixVQUFBQSxDQUFVRyxRQUFJZ0IsT0FBQUEsQ0FBRVYsS0FBRlUsQ0FBdEIsRUFBK0JmLFFBQUllLE9BQUFBLENBQUVWLEtBQUZVLENBQTNCbkI7UUFEVixPQUVBLElBQUEsUUFBWWxCLE9BQU4yQixLQUFNM0IsRUFBRUosQ0FBRkksQ0FBWixDQUFBO1VBQ0VxQyxPQUFBeEMsT0FBUXFCLFVBQUFBLENBQVVJLFFBQUllLE9BQUFBLENBQUdWLEtBQUQxQixPQUFBQSxDQUFBQSxDQUFGb0MsQ0FBdEIsRUFBZ0NoQixRQUFJZ0IsT0FBQUEsQ0FBR1YsS0FBRDFCLE9BQUFBLENBQUFBLENBQUZvQyxDQUE1Qm5CO1FBRFY7VUFHRW1CLE9BQUF4QyxPQUFRcUIsVUFBQUEsQ0FBVWhCLENBQWxCLEVBQXFCQSxDQUFiZ0I7UUFIVjtNQUxGLE9BV0EsSUFBQSxRQUFLUixZQUFMLEVBeE1KLFNBd01JLENBQUE7UUFDRTJCLE9BQUFoRCxJQUFBd0MsTUFBQUEsQ0FBQUEsQ0FBSVEsT0FBQUEsQ0FBRVYsS0FBRlU7TUFETixPQUdBLElBQUEsUUFBS25CLGVBQUwsRUEzTUosU0EyTUksQ0FBQTtRQUNFLElBQUEsTUFBR1MsS0FBSCxFQUFZL0IsQ0FBWixDQUFBO1VBQ0V5QyxPQUFBeEMsT0FBUXFCLFVBQUFBLENBQVVoQixDQUFsQixFQUFxQkEsQ0FBYmdCO1FBRFYsT0FFQSxJQUFBLE1BQU1TLEtBQUtGLGFBQUFBLENBQUFBLENBQVgsRUFBMkJ2QixDQUEzQixDQUFBO1VBQ0UsSUFBQSxRQUFTRixPQUFOMkIsS0FBTTNCLEVBQUVKLENBQUZJLENBQVQsQ0FBQTtZQUNFcUMsT0FBQXhDLE9BQVFxQixVQUFBQSxDQUFVSSxRQUFJZSxPQUFBQSxDQUFFVixLQUFLSCxXQUFBQSxDQUFBQSxDQUFVZ0IsS0FBQUEsQ0FBQUEsQ0FBakJILENBQXRCLEVBQTZDaEIsUUFBSWdCLE9BQUFBLENBQUVWLEtBQUtILFdBQUFBLENBQUFBLENBQVVnQixLQUFBQSxDQUFBQSxDQUFqQkgsQ0FBekNuQjtVQURWO1lBR0VtQixPQUFBeEMsT0FBUXFCLFVBQUFBLENBQVVHLFFBQUlnQixPQUFBQSxDQUFFVixLQUFLSCxXQUFBQSxDQUFBQSxDQUFQYSxDQUF0QixFQUF5Q2YsUUFBSWUsT0FBQUEsQ0FBRVYsS0FBS0gsV0FBQUEsQ0FBQUEsQ0FBUGEsQ0FBckNuQjtVQUhWO1FBREYsT0FNQSxJQUFNLENBQUEsTUFBQTdCLElBQUEsRUFBUU8sQ0FBUixDQUFBLElBQUEsQ0FBQSxRQUFtQkksT0FBTjJCLEtBQU0zQixFQUFFSixDQUFGSSxDQUFuQixDQUFBLENBQUEsQ0FBTjtVQUNFcUMsT0FBQXhDLE9BQVFDLE9BQUFBLENBQU9DLHdCQUFmLEVBQW9Dc0MsY0FBNUJ2QztRQURWO1VBR0V1QyxPQUFBaEQsSUFBQXdDLE1BQUFBLENBQUFBLENBQUlRLE9BQUFBLENBQUVWLEtBQUZVO1FBSE47TUFURjtRQWdCRUEsT0FBQWhELElBQUE4QyxhQUFBQSxDQUFZLElBQVosRUFBaUJSLEtBQWpCUTtNQWhCRjtJQWhCRkUsQ0FBQUEsR0FBQUE7O0FBb0NBRyxJQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEzQyxPQUFRcUIsVUFBQUEsQ0FBVUcsUUFBSW1CLEtBQUFBLENBQUFBLENBQXRCLEVBQTRCbEIsUUFBSWtCLEtBQUFBLENBQUFBLENBQXhCdEI7SUFEVnNCLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsZ0JBQVNDLFNBQVREO0FBQUFBLE1BQUFBOzs7TUFBUyxtQ0FBWTdDO01BQ25CLElBQUEsTUFBRzhDLFNBQUgsRUFBZ0I5QyxDQUFoQixDQUFBO1FBQ0U2QyxPQUFTcEMsV0FBTGdCLFFBQURwQixPQUFBQSxDQUFBQSxDQUFNSSxFQUFFaUIsUUFBRmpCLENBQVJKLE9BQUFBLENBQUFBLENBQWdCd0MsTUFBQUEsQ0FBQUE7TUFEbkI7UUFHRUEsT0FBQXBELElBQUFzRCxnQkFBQUEsQ0FBZSxNQUFmLEVBQXNCRCxTQUF0QkM7TUFIRjtJQURGRixDQUFBQSxJQUFBQTs7QUFRQUcsSUFBQUEscUJBQUFBLGlCQUFVRixTQUFWRTtBQUFBQSxNQUFBQTs7O01BQVUsbUNBQVloRDtNQUNwQixJQUFBLE1BQUc4QyxTQUFILEVBQWdCOUMsQ0FBaEIsQ0FBQTtRQUNFZ0QsT0FBU3ZDLFdBQUxnQixRQUFEcEIsT0FBQUEsQ0FBQUEsQ0FBTUksRUFBRWlCLFFBQUZqQixDQUFSSixPQUFBQSxDQUFBQSxDQUFnQjJDLE9BQUFBLENBQUFBO01BRG5CO1FBR0VBLE9BQUF2RCxJQUFBc0QsZ0JBQUFBLENBQWUsT0FBZixFQUF1QkQsU0FBdkJDO01BSEY7SUFERkMsQ0FBQUEsSUFBQUE7O0FBUUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLFdBQUQsR0FBQSxDQUFZeEIsUUFBWixDQUFBLEdBQWlCd0IsR0FBakIsR0FBQSxDQUFvQnZCLFFBQXBCO0lBREZ1QixDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsR0FBRCxHQUFBLENBQUl6RCxJQUFKLENBQUEsR0FBU3lEO0lBRFhBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSwyQkFBQUEsdUJBQWdCQyxHQUFoQkQ7QUFBQUEsTUFBQUE7Ozs7O0FBRUZBO0FBQ0FBLFFBQVVsRCxPQUFRQyxPQUFBQSxDQUFPbUQsb0JBQWYsRUFBaUNGLDZCQUFELEdBQUEsQ0FBK0JBLGdCQUEvQixDQUFBLEdBQWlEQSxZQUF6RWpELENBQXFGaUQ7QUFDdkdBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUEsY0FBZ0JDLEdBQUdSLEtBQUFBLENBQUFBLENBQUtPO0FBQ3hCQSxjQUFxQmQsVUFBTDVDLElBQUs0QyxFQUFHYyxDQUFIZCxDQUFNYztBQUMzQkEsY0FBcUJYLFNBQUwvQyxJQUFLK0MsRUFBR1csQ0FBSFgsQ0FBTVc7O0FBRTNCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFlBQWNBLENBQUNBLENBQURBLENBQUdOLE1BQUFBLENBQUFBLENBQU1NOztBQUV2QkEsWUFBa0JHLE9BQUhILENBQUdHLEVBQUlILENBQUpHLENBQU9IO0FBQ3pCQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUEsYUFBaUIxQyxXQUFGSCxDQUFFRyxFQUFPNEIsVUFBSGMsQ0FBR2QsRUFBR2MsQ0FBSGQsQ0FBUDVCLENBQWMwQztBQUMvQkEsYUFBaUIxQyxXQUFGSCxDQUFFRyxFQUFPNEIsVUFBSGMsQ0FBR2QsRUFBR2MsQ0FBSGQsQ0FBUDVCLENBQWMwQztBQUMvQkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQSxhQUFlbEQsT0FBUXFCLFVBQUFBLENBQVc2QixXQUFuQixFQUFrQ0EsV0FBMUI3QixDQUF3QzZCO0FBQy9EQTtJQTNDRUEsQ0FBQUEsSUFBQUE7O0FBOENBSSxJQUFBQSxxQkFBQUEsaUJBQVVULFNBQVZTO0FBQUFBLE1BQUFBOzs7TUFBVSxtQ0FBWXZEO01BQ3BCLEtBQUEsTUFBZ0Q4QyxTQUFoRCxFQUE2RDlDLENBQTdELENBQUE7UUFBQSxPQUFPUCxJQUFBc0QsZ0JBQUFBLENBQWUsT0FBZixFQUF1QkQsU0FBdkJDO01BQVA7TUFDQSxJQUFBLE1BQVl0QixRQUFaLEVBQW9CekIsQ0FBcEIsQ0FBQTtRQUFBLE9BQU9BO01BQVA7TUFDQSxJQUFBLE1BQWUwQixRQUFmLEVBQXVCcEIsQ0FBdkIsQ0FBQTtRQUFBLE9BQU9tQjtNQUFQO01BRUE1QixNQUFtQjJDLFNBQUpGLFVBQVRiLFFBQUltQixLQUFBQSxDQUFBQSxDQUFLTixFQUFFa0IsQ0FBRmxCLENBQUlFLEVBQUVkLFFBQUZjO01BQ25CMUMsTUFBV3dDLFVBQUxaLFFBQUtZLEVBQUVrQixDQUFGbEI7TUFFWG1CLFNBQWNoRCxXQUFKWixHQUFJWSxFQUFFWCxHQUFGVyxDQUFNaUQsVUFBQUEsQ0FBQUE7TUFFcEIsSUFBQSxRQUFRdEQsT0FBTHFCLFFBQUtyQixFQUFFSixDQUFGSSxDQUFSLENBQUE7UUFDRW1ELE9BQUNFLE1BQURwRCxPQUFBQSxDQUFBQTtNQURGO1FBR0VrRCxPQUFBRTtNQUhGO0lBVkZGLENBQUFBLElBQUFBOztBQWlCQXRCLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUt4QixXQUFMZ0IsUUFBS2hCLEVBQUVpQixRQUFGakI7SUFEUHdCLENBQUFBLEdBQUFBOztBQUlBbEMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQU4sSUFBQWlFLFVBQUFBLENBQUFBO0lBREYzRCxDQUFBQSxHQUFBQTs7QUFJQWtCLElBQUFBLG9CQUFBQSxZQUFBQSxHQUFBQTs7QUFJQTBDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsRUFBQSxHQUFBLENBQUdsQyxRQUFILENBQUEsR0FBUWtDLEdBQVIsR0FBQSxDQUFXakMsUUFBWDtJQURGaUMsQ0FBQUEsR0FBQUE7O0FBSUFELElBQUFBLHdCQUFBQSxvQkFBYVosU0FBYlk7QUFBQUEsTUFBQUE7OztNQUFhLG1DQUFZMUQ7TUFDdkIsSUFBQSxNQUFHOEMsU0FBSCxFQUFnQjlDLENBQWhCLENBQUE7UUFDRSxJQUFBLFFBQUtJLE9BQUxxQixRQUFLckIsRUFBRUosQ0FBRkksQ0FBTCxDQUFBO1VBQVdzRCxPQUFBakUsSUFBQW9ELE1BQUFBLENBQUFBO1FBQVg7VUFBa0JhLE9BQUFqRSxJQUFBdUQsT0FBQUEsQ0FBQUE7UUFBbEI7TUFERjtRQUdFVSxPQUFBakUsSUFBQXNELGdCQUFBQSxDQUFlLFVBQWYsRUFBMEJELFNBQTFCQztNQUhGO0lBREZXLENBQUFBLElBQUFBOztBQVFBWCxJQUFBQSw4QkFBQUEsMEJBQW1CYSxNQUFELEVBQVNkLFNBQTNCQztBQUFBQSxNQUFBQTs7O01BQ0UsS0FBQSxRQUFvRGxDLGNBQXBELEVBQWtFaUMsU0FBbEUsQ0FBQTtRQUFBN0MsT0FBUUMsT0FBQUEsQ0FBT1UsZ0JBQWYsRUFBNEJtQyxnQkFBcEI3QztNQUFSO01BRUEyRCxJQUFJQyxDQUFBQSxFQUFBQSxDQUFFckIsT0FBQUEsQ0FBRUssU0FBRkw7TUFDTnNCLElBQVN6QixVQUFMN0MsSUFBSzZDLEVBQUV1QixDQUFGdkI7TUFFVCxJQUFBLFFBQWFsQyxPQUFWMEMsU0FBVTFDLEVBQUVFLENBQUZGLENBQWIsQ0FBQTtRQUNFMkMsT0FBZ0J0QyxXQUFmc0QsQ0FBQ0MsTUFBQUEsQ0FBTUosTUFBTkksQ0FBY3ZELEVBQUVvRCxDQUFGcEQsQ0FBSVYsTUFBQUEsQ0FBQUE7TUFEdEI7UUFHRWdELE9BQUE5QyxPQUFRcUIsVUFBQUEsQ0FBVXlDLENBQUNDLE1BQUFBLENBQU1KLE1BQU5JLENBQW5CLEVBQWtDSCxDQUExQnZDO01BSFY7SUFORnlCLENBQUFBLEdBQUFBO0lBYUFrQixNQUFJeEUsSUFBSndFLGtCQUFBQSx1QkFBcUJDLE1BQXJCRDtBQUFBQTs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxtQkFBcUJoRSxPQUFRcUIsVUFBQUEsQ0FBVzJDLFNBQW5CLEVBQWdDQSxXQUF4QjNDLENBQXNDMkM7QUFDbkVBO0FBQ0FBLG1CQUFxQmhFLE9BQVFxQixVQUFBQSxDQUFXMkMsU0FBbkIsRUFBK0IzRCxDQUF2QmdCLENBQTBCMkM7QUFDdkRBO0FBQ0FBO0FBQ0FBLGlCQUFtQmhFLE9BQVFxQixVQUFBQSxDQUFXMkMsU0FBbkIsRUFBK0IzRCxDQUF2QmdCLENBQTBCMkM7QUFDckRBO0FBQ0FBO0FBQ0FBLGVBQWlCaEUsT0FBUXFCLFVBQUFBLENBQVV0QixDQUFsQixFQUFxQk0sQ0FBYmdCLENBQWdCMkM7QUFDekNBO0FBQ0FBO0lBckNFQSxDQUFBQSxHQUFBQTtJQXdDQSxhQUFNLFFBQU4sRUFBYSxHQUFiO0lBQ0F0RSxPQUFBLGFBQU0sS0FBTixFQUFVLEdBQVY7RUFyWUZBLEdBQU0sSUFBTkEsRUFBbUI0QixjQUFuQjVCO0FBSEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo3MDAwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvclxuXG5tb2R1bGUgOjpNYXRoXG4gIHNlbGY6OkUgID0gYE1hdGguRWBcbiAgc2VsZjo6UEkgPSBgTWF0aC5QSWBcblxuICBzZWxmOjpEb21haW5FcnJvciA9IDo6Q2xhc3MubmV3KDo6U3RhbmRhcmRFcnJvcilcblxuICBkZWYgc2VsZi5jaGVja2VkKG1ldGhvZCwgKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNOYU4oYXJnc1sxXSkpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBNYXRoW21ldGhvZF0uYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgRG9tYWluRXJyb3IsIFwiTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcXFwiI3ttZXRob2R9XFxcIlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZsb2F0ISh2YWx1ZSlcbiAgICA6Oktlcm5lbC5GbG9hdCh2YWx1ZSlcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxuICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3s6OkZsb2F0fSlgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmludGVnZXIhKHZhbHVlKVxuICAgIDo6S2VybmVsLkludGVnZXIodmFsdWUpXG4gIHJlc2N1ZSA6OkFyZ3VtZW50RXJyb3JcbiAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7OjpJbnRlZ2VyfSlgXG4gIGVuZFxuXG4gIG1vZHVsZV9mdW5jdGlvblxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZgKVxuICAgICV4e1xuICAgICAgT3BhbC5wcm9wKE1hdGgsICdlcmYnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBBMSA9ICAwLjI1NDgyOTU5MixcbiAgICAgICAgICAgIEEyID0gLTAuMjg0NDk2NzM2LFxuICAgICAgICAgICAgQTMgPSAgMS40MjE0MTM3NDEsXG4gICAgICAgICAgICBBNCA9IC0xLjQ1MzE1MjAyNyxcbiAgICAgICAgICAgIEE1ID0gIDEuMDYxNDA1NDI5LFxuICAgICAgICAgICAgUCAgPSAgMC4zMjc1OTExO1xuXG4gICAgICAgIHZhciBzaWduID0gMTtcblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBNYXRoLmFicyh4KTtcblxuICAgICAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBQICogeCk7XG4gICAgICAgIHZhciB5ID0gMS4wIC0gKCgoKChBNSAqIHQgKyBBNCkgKiB0KSArIEEzKSAqIHQgKyBBMikgKiB0ICsgQTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB5O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguZXJmY2ApXG4gICAgJXh7XG4gICAgICBPcGFsLnByb3AoTWF0aCwgJ2VyZmMnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoeCksXG4gICAgICAgICAgICB0ID0gMS4wIC8gKDAuNSAqIHogKyAxLjApO1xuXG4gICAgICAgIHZhciBBMSA9IHQgKiAwLjE3MDg3Mjc3ICsgLTAuODIyMTUyMjMsXG4gICAgICAgICAgICBBMiA9IHQgKiBBMSArIDEuNDg4NTE1ODcsXG4gICAgICAgICAgICBBMyA9IHQgKiBBMiArIC0xLjEzNTIwMzk4LFxuICAgICAgICAgICAgQTQgPSB0ICogQTMgKyAwLjI3ODg2ODA3LFxuICAgICAgICAgICAgQTUgPSB0ICogQTQgKyAtMC4xODYyODgwNixcbiAgICAgICAgICAgIEE2ID0gdCAqIEE1ICsgMC4wOTY3ODQxOCxcbiAgICAgICAgICAgIEE3ID0gdCAqIEE2ICsgMC4zNzQwOTE5NixcbiAgICAgICAgICAgIEE4ID0gdCAqIEE3ICsgMS4wMDAwMjM2OCxcbiAgICAgICAgICAgIEE5ID0gdCAqIEE4LFxuICAgICAgICAgICAgQTEwID0gLXogKiB6IC0gMS4yNjU1MTIyMyArIEE5O1xuXG4gICAgICAgIHZhciBhID0gdCAqIE1hdGguZXhwKEExMCk7XG5cbiAgICAgICAgaWYgKHggPCAwLjApIHtcbiAgICAgICAgICByZXR1cm4gMi4wIC0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICAjIFNpbmdsZSBhcmd1bWVudCBlcXVpdmFsZW50IGZ1bmN0aW9uc1xuICAlaVtcbiAgICBhY29zIGFjb3NoIGFzaW4gYXNpbmggYXRhbiBhdGFuaCBjYnJ0XG4gICAgY29zIGNvc2ggZXJmIGVyZmMgZXhwIHNpbiBzaW5oIHNxcnQgdGFuaFxuICBdLmVhY2ggZG8gfG1ldGhvZHxcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZCBkbyB8eHxcbiAgICAgIDo6TWF0aC5jaGVja2VkIG1ldGhvZCwgOjpNYXRoLmZsb2F0ISh4KVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYXRhbjIoeSwgeClcbiAgICA6Ok1hdGguY2hlY2tlZCA6YXRhbjIsIDo6TWF0aC5mbG9hdCEoeSksIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGh5cG90KHgsIHkpXG4gICAgOjpNYXRoLmNoZWNrZWQgOmh5cG90LCA6Ok1hdGguZmxvYXQhKHgpLCA6Ok1hdGguZmxvYXQhKHkpXG4gIGVuZFxuXG4gIGRlZiBmcmV4cCh4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgcmV0dXJuIFtOYU4sIDBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggICA9IE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoeCkpIC8gTWF0aC5sb2coMikpICsgMSxcbiAgICAgICAgICBmcmFjID0geCAvIE1hdGgucG93KDIsIGV4KTtcblxuICAgICAgcmV0dXJuIFtmcmFjLCBleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2FtbWEobilcbiAgICBuID0gTWF0aC5mbG9hdCEobilcblxuICAgICV4e1xuICAgICAgdmFyIGksIHQsIHgsIHZhbHVlLCByZXN1bHQsIHR3b04sIHRocmVlTiwgZm91ck4sIGZpdmVOO1xuXG4gICAgICB2YXIgRyA9IDQuNzQyMTg3NTtcblxuICAgICAgdmFyIFAgPSBbXG4gICAgICAgICAwLjk5OTk5OTk5OTk5OTk5NzA5MTgyLFxuICAgICAgICAgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LFxuICAgICAgICAtNTkuNTk3OTYwMzU1NDc1NDkxMjQ4LFxuICAgICAgICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LFxuICAgICAgICAtMC40OTE5MTM4MTYwOTc2MjAxOTk3OCxcbiAgICAgICAgIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgICAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LFxuICAgICAgICAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAgICAgIDAuMTU4MDg4NzAzMjI0OTEyNDg4ODRlLTMsXG4gICAgICAgIC0wLjIxMDI2NDQ0MTcyNDEwNDg4MzE5ZS0zLFxuICAgICAgICAgMC4yMTc0Mzk2MTgxMTUyMTI2NDMyMGUtMyxcbiAgICAgICAgLTAuMTY0MzE4MTA2NTM2NzYzODkwMjJlLTMsXG4gICAgICAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LFxuICAgICAgICAtMC4yNjE5MDgzODQwMTU4MTQwODY3MGUtNCxcbiAgICAgICAgIDAuMzY4OTkxODI2NTk1MzE2MjI3MDRlLTVcbiAgICAgIF07XG5cblxuICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gLTEgfHwgbiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgRG9tYWluRXJyb3IsICdOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFwiZ2FtbWFcIid9O1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tJbnRlZ2VyID09PSBufSkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmluaXRlKG4pID8gSW5maW5pdHkgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiA+IDE3MSkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICA9IG4gLSAyO1xuICAgICAgICByZXN1bHQgPSBuIC0gMTtcblxuICAgICAgICB3aGlsZSAodmFsdWUgPiAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09IDApIHtcbiAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIG4pICogI3s6Ok1hdGguZ2FtbWEoMSAtIG4pfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID49IDE3MS4zNSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID4gODUuMCkge1xuICAgICAgICB0d29OICAgPSBuICogbjtcbiAgICAgICAgdGhyZWVOID0gdHdvTiAqIG47XG4gICAgICAgIGZvdXJOICA9IHRocmVlTiAqIG47XG4gICAgICAgIGZpdmVOICA9IGZvdXJOICogbjtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJIC8gbikgKiBNYXRoLnBvdygobiAvIE1hdGguRSksIG4pICpcbiAgICAgICAgICAoMSArIDEgLyAoMTIgKiBuKSArIDEgLyAoMjg4ICogdHdvTikgLSAxMzkgLyAoNTE4NDAgKiB0aHJlZU4pIC1cbiAgICAgICAgICA1NzEgLyAoMjQ4ODMyMCAqIGZvdXJOKSArIDE2Mzg3OSAvICgyMDkwMTg4ODAgKiBmaXZlTikgK1xuICAgICAgICAgIDUyNDY4MTkgLyAoNzUyNDY3OTY4MDAgKiBmaXZlTiAqIG4pKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSAxO1xuICAgICAgeCAgPSBQWzBdO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgUC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4ICs9IFBbaV0gLyAobiArIGkpO1xuICAgICAgfVxuXG4gICAgICB0ID0gbiArIEcgKyAwLjU7XG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkpICogTWF0aC5wb3codCwgbiArIDAuNSkgKiBNYXRoLmV4cCgtdCkgKiB4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudClcbiAgICBtYW50aXNzYSA9IE1hdGguZmxvYXQhKG1hbnRpc3NhKVxuICAgIGV4cG9uZW50ID0gTWF0aC5pbnRlZ2VyIShleHBvbmVudClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKGV4cG9uZW50KSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Zsb2F0IE5hTiBvdXQgb2YgcmFuZ2Ugb2YgaW50ZWdlcid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGdhbW1hKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiA9PSAtMSkge1xuICAgICAgICByZXR1cm4gW0luZmluaXR5LCAxXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW01hdGgubG9nKE1hdGguYWJzKCN7OjpNYXRoLmdhbW1hKG4pfSkpLCAjezo6TWF0aC5nYW1tYShuKX0gPCAwID8gLTEgOiAxXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2coeCwgYmFzZSA9IHVuZGVmaW5lZClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgaWYgYGJhc2UgPT0gbnVsbGBcbiAgICAgIDo6TWF0aC5jaGVja2VkIDpsb2csIDo6TWF0aC5mbG9hdCEoeClcbiAgICBlbHNlXG4gICAgICBpZiA6OlN0cmluZyA9PT0gYmFzZVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IoYmFzZSwgI3s6OkZsb2F0fSlgXG4gICAgICBlbmRcblxuICAgICAgOjpNYXRoLmNoZWNrZWQoOmxvZywgOjpNYXRoLmZsb2F0ISh4KSkgLyA6Ok1hdGguY2hlY2tlZCg6bG9nLCA6Ok1hdGguZmxvYXQhKGJhc2UpKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbG9nMTAoeClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgOjpNYXRoLmNoZWNrZWQgOmxvZzEwLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBsb2cyKHgpXG4gICAgaWYgOjpTdHJpbmcgPT09IHhcbiAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih4LCAjezo6RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIDo6TWF0aC5jaGVja2VkIDpsb2cyLCA6Ok1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiB0YW4oeClcbiAgICB4ID0gOjpNYXRoLmZsb2F0ISh4KVxuXG4gICAgaWYgeC5pbmZpbml0ZT9cbiAgICAgIHJldHVybiA6OkZsb2F0OjpOQU5cbiAgICBlbmRcblxuICAgIDo6TWF0aC5jaGVja2VkIDp0YW4sIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpNYXRoPiIsInNlbGYiLCJDbGFzcyIsIm5ldyIsIlN0YW5kYXJkRXJyb3IiLCJjaGVja2VkIiwibWV0aG9kIiwiS2VybmVsIiwicmFpc2UiLCJEb21haW5FcnJvciIsImZsb2F0ISIsInZhbHVlIiwiRmxvYXQiLCJBcmd1bWVudEVycm9yIiwiaW50ZWdlciEiLCJJbnRlZ2VyIiwibW9kdWxlX2Z1bmN0aW9uIiwiZWFjaCIsImJsb2NrIGluIDxtb2R1bGU6TWF0aD4iLCJibG9jayAoMiBsZXZlbHMpIGluIDxtb2R1bGU6TWF0aD4iLCJkZWZpbmVfbWV0aG9kIiwieCIsImJsb2NrICgzIGxldmVscykgaW4gPG1vZHVsZTpNYXRoPiIsIk1hdGgiLCJhdGFuMiIsInkiLCJoeXBvdCIsImZyZXhwIiwiZ2FtbWEiLCJuIiwiPT09IiwiLSIsIjEiLCJsZGV4cCIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJSYW5nZUVycm9yIiwibGdhbW1hIiwibG9nIiwiYmFzZSIsIlN0cmluZyIsIi8iLCJsb2cxMCIsImxvZzIiLCJ0YW4iLCJpbmZpbml0ZT8iLCJGbG9hdDo6TkFOIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRSxXQUFBQyxJQUFBLE9BQVlELE1BQVo7SUFDQSxXQUFBQyxJQUFBLFFBQVlELE9BQVo7SUFFQSxXQUFBQyxJQUFBLGlCQUFvQkMsTUFBT0MsS0FBQUEsQ0FBS0Msb0JBQUxELENBQTNCO0lBRUFFLE1BQUlKLElBQUpJLGNBQUFBLG1CQUFpQkMsTUFBRCxFQVJsQixFQVFFRDtBQUFBQSxNQUFBQTs7O01BUkY7TUFRMkI7O0FBRTNCQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFFBQVVFLE9BQVFDLE9BQUFBLENBQU9DLGlCQUFmLEVBQTZCSiwwQ0FBRCxHQUFBLENBQTJDQyxNQUEzQyxDQUFBLEdBQWtERCxJQUF0RUcsQ0FBMEVIO0FBQzVGQTs7QUFFQUE7QUFDQUE7SUFiRUEsQ0FBQUEsSUFBQUE7SUFnQkFLLE1BQUlULElBQUpTLGFBQUFBLDRCQUFnQkMsS0FBaEJEO0FBQUFBO01BQ0U7UUFBQUEsT0FBQUgsT0FBUUssT0FBQUEsQ0FBT0QsS0FBUEM7TUFBUjtRQUNGLHNCQUFPLENB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UUFDRWQsT0FBUUMsT0FBQUEsQ0FBUW1DLGVBQWlCL0IsWUFBUStCLENBQWpDbkM7TUFEVjtNQUlBbUMsT0FBQXBCLFdBQU1sQixTQUFBQSxDQUFTLE1BQWYsRUFBc0JrQixXQUFNYixXQUFBQSxDQUFRVyxDQUFSWCxDQUF0Qkw7SUFMUnNDLENBQUFBLEdBQUFBO0lBUUEzQyxPQUFBNEMsbUJBQUFBLGVBQVF2QixDQUFSdUI7QUFBQUE7O01BQ0V2QixJQUFJRSxXQUFNYixXQUFBQSxDQUFRVyxDQUFSWDtNQUVWLElBQUEsUUFBR1csQ0FBQ3dCLGNBQUFBLENBQUFBLENBQUosQ0FBQTtRQUNFLE9BQU9DLElBQUFsQyxZQUFBa0M7TUFEVDtNQUlBRixPQUFBckIsV0FBTWxCLFNBQUFBLENBQVMsS0FBZixFQUFxQmtCLFdBQU1iLFdBQUFBLENBQVFXLENBQVJYLENBQXJCTDtJQVBSdUMsQ0FBQUEsR0FBQUE7RUFwUkY1QyxHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo3MzE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHJlc3BvbmRfdG8sIGdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwLCBwcm9wXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xuXG5jbGFzcyA6OlN0cmluZyA8IGBTdHJpbmdgXG4gIGluY2x1ZGUgOjpDb21wYXJhYmxlXG5cbiAgJXh7XG4gICAgT3BhbC5wcm9wKCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGlzX3N0cmluZycsIHRydWUpO1xuICB9XG5cbiAgZGVmIF9faWRfX1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KHdoYXQpXG4gICAgOjpPcGFsLmNvZXJjZV90bz8od2hhdCwgOjpTdHJpbmcsIDp0b19zdHIpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ldygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBhcmdzWzBdIHx8IFwiXCI7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3NbYXJncy5sZW5ndGgtMV07XG4gICAgICBzdHIgPSAkY29lcmNlX3RvKHN0ciwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMuJCRpc19oYXNoKSB7XG4gICAgICAgIGlmIChvcHRzLiQkc21hcC5lbmNvZGluZykgc3RyID0gc3RyLiRmb3JjZV9lbmNvZGluZyhvcHRzLiQkc21hcC5lbmNvZGluZyk7XG4gICAgICB9XG4gICAgICBzdHIgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKHN0cik7XG4gICAgICBpZiAoIXN0ci4kaW5pdGlhbGl6ZS4kJHByaXN0aW5lKSAje2BzdHJgLmluaXRpYWxpemUoKmFyZ3MpfTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICBlbmRcblxuICAjIE91ciBpbml0aWFsaXplIG1ldGhvZCBkb2VzIG5vdGhpbmcsIHRoZSBzdHJpbmcgdmFsdWUgc2V0dXAgaXMgYmVpbmdcbiAgIyBkb25lIGJ5IFN0cmluZy5uZXcuIFRoZXJlZm9yZSBub3QgYWxsIGtpbmRzIG9mIHN1YmNsYXNzaW5nIHdpbGwgd29yay5cbiAgIyBBcyBhIHJ1bGUgb2YgdGh1bWIsIHdoZW4gc3ViY2xhc3NpbmcgU3RyaW5nLCBlaXRoZXIgbWFrZSBzdXJlIHRvIG92ZXJyaWRlXG4gICMgLm5ldyBvciBtYWtlIHN1cmUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgZ2l2ZW4gdG8gYSBjb25zdHJ1Y3RvciBpc1xuICAjIGEgc3RyaW5nIHdlIHdhbnQgb3VyIHN1YmNsYXNzLXN0cmluZyB0byBob2xkLlxuICBkZWYgaW5pdGlhbGl6ZShzdHIgPSB1bmRlZmluZWQsIGVuY29kaW5nOiBuaWwsIGNhcGFjaXR5OiBuaWwpXG4gIGVuZFxuXG4gIGRlZiAlKGRhdGEpXG4gICAgaWYgOjpBcnJheSA9PT0gZGF0YVxuICAgICAgZm9ybWF0KHNlbGYsICpkYXRhKVxuICAgIGVsc2VcbiAgICAgIGZvcm1hdChzZWxmLCBkYXRhKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihjb3VudClcbiAgICAleHtcbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcmd1bWVudCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCk7XG5cbiAgICAgIC8vIEFsbCBjcmVkaXQgZm9yIHRoZSBiaXQtdHdpZGRsaW5nIG1hZ2ljIGNvZGUgYmVsb3cgZ29lcyB0byBNb3ppbGxhXG4gICAgICAvLyBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvbiBvZiBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCgpIHBvc3RlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCAqIGNvdW50ID49IDEgPDwgMjgpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdtdWx0aXBseSBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJ31cbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID4+Pj0gMTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8oI3tvdGhlcn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgXG5cbiAgICAleHtcbiAgICAgIGlmIChvdGhlciA9PSBcIlwiICYmIHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5TdHJpbmcpIHJldHVybiAje3NlbGZ9O1xuICAgICAgaWYgKHNlbGYgPT0gXCJcIiAmJiBvdGhlci4kJGNsYXNzID09PSBPcGFsLlN0cmluZykgcmV0dXJuICN7b3RoZXJ9O1xuICAgICAgdmFyIG91dCA9IHNlbGYgKyBvdGhlcjtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nID09PSBvdXQuZW5jb2RpbmcgJiYgb3RoZXIuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZykgcmV0dXJuIG91dDtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nLm5hbWUgPT09IFwiVVRGLThcIiB8fCBvdGhlci5lbmNvZGluZy5uYW1lID09PSBcIlVURi04XCIpIHJldHVybiBvdXQ7XG4gICAgICByZXR1cm4gT3BhbC5lbmMob3V0LCBzZWxmLmVuY29kaW5nKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX3N0clxuICAgICAgb3RoZXIgPSBvdGhlci50b19zdHIudG9fc1xuXG4gICAgICBgc2VsZiA+IG90aGVyID8gMSA6IChzZWxmIDwgb3RoZXIgPyAtMSA6IDApYFxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICB2YXIgY21wID0gI3tvdGhlciA8PT4gc2VsZn07XG5cbiAgICAgICAgaWYgKGNtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY21wID4gMCA/IC0xIDogKGNtcCA8IDAgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoJHJlc3BvbmRfdG8ob3RoZXIsICckdG9fc3RyJykpIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPX4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ3R5cGUgbWlzbWF0Y2g6IFN0cmluZyBnaXZlbid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tvdGhlciA9fiBzZWxmfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHNpemUgPSBzZWxmLmxlbmd0aCwgZXhjbHVkZSwgcmFuZ2U7XG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3JhbmdlKSB7XG4gICAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xuICAgICAgICByYW5nZSAgID0gaW5kZXg7XG4gICAgICAgIGxlbmd0aCAgPSBpbmRleC5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhpbmRleC5lbmQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpbmRleCAgID0gaW5kZXguYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMoaW5kZXgpID4gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggKz0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUgfHwgcmFuZ2UuZW5kID09PSBuaWwpIHtcbiAgICAgICAgICBsZW5ndGggKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9IGxlbmd0aCAtIGluZGV4O1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLnN1YnN0cihpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvcn1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKGluZGV4KSAhPT0gLTEgPyBpbmRleCA6IG5pbDtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19yZWdleHApIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc2VsZi5tYXRjaChpbmRleCk7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgaW5kZXhgLCBgbWF0Y2hgKX1cblxuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgJiYgLWxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFtsZW5ndGggKz0gbWF0Y2gubGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiBsZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbbGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5zdWJzdHIoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnN1YnN0cihpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBiXG4gICAgYG5ldyBTdHJpbmcoI3tzZWxmfSlgLmZvcmNlX2VuY29kaW5nKCdiaW5hcnknKVxuICBlbmRcblxuICBkZWYgY2FwaXRhbGl6ZVxuICAgIGBzZWxmLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2VsZi5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKWBcbiAgZW5kXG5cbiAgZGVmIGNhc2VjbXAob3RoZXIpXG4gICAgcmV0dXJuIG5pbCB1bmxlc3Mgb3RoZXIucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG4gICAgJXh7XG4gICAgICB2YXIgYXNjaWlfb25seSA9IC9eW1xceDAwLVxceDdGXSokLztcbiAgICAgIGlmIChhc2NpaV9vbmx5LnRlc3Qoc2VsZikgJiYgYXNjaWlfb25seS50ZXN0KG90aGVyKSkge1xuICAgICAgICBzZWxmID0gc2VsZi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvdGhlciA9IG90aGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYgPD0+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjYXNlY21wPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBjbXAgPSAje2Nhc2VjbXAob3RoZXIpfTtcbiAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNtcCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZW50ZXIod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgcGFkc3RyID0gYCRjb2VyY2VfdG8oI3twYWRzdHJ9LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG5cbiAgICBpZiBwYWRzdHIuZW1wdHk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gcmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNob21wKHNlcGFyYXRvciA9ICQvKVxuICAgIHJldHVybiBzZWxmIGlmIGBzZXBhcmF0b3IgPT09IG5pbCB8fCBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIHNlcGFyYXRvciA9IDo6T3BhbC5jb2VyY2VfdG8hKHNlcGFyYXRvciwgOjpTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gXCJcXG5cIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoL1xccj9cXG4/JC8sICcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlcGFyYXRvciA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoLyhcXHI/XFxuKSskLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZi5sZW5ndGggPj0gc2VwYXJhdG9yLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGFpbCA9IHNlbGYuc3Vic3RyKHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCwgc2VwYXJhdG9yLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRhaWwgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2hvcFxuICAgICV4e1xuICAgICAgdmFyIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCByZXN1bHQ7XG5cbiAgICAgIGlmIChsZW5ndGggPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gXCJcXG5cIiAmJiBzZWxmLmNoYXJBdChsZW5ndGggLSAyKSA9PT0gXCJcXHJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBsZW5ndGggLSAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNoclxuICAgIGBzZWxmLmNoYXJBdCgwKWBcbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogbmlsKVxuICAgIHVubGVzcyBmcmVlemUubmlsPyB8fCBmcmVlemUgPT0gdHJ1ZSB8fCBmcmVlemUgPT0gZmFsc2VcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5leHBlY3RlZCB2YWx1ZSBmb3IgZnJlZXplOiAje2ZyZWV6ZS5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgY29weSA9IGBuZXcgU3RyaW5nKHNlbGYpYFxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmLCBmcmVlemU6IGZyZWV6ZSlcblxuICAgIGlmIGZyZWV6ZSA9PSB0cnVlXG4gICAgICBgaWYgKCFjb3B5LiQkZnJvemVuKSB7IGNvcHkuJCRmcm96ZW4gPSB0cnVlOyB9YFxuICAgIGVsc2lmIGZyZWV6ZS5uaWw/XG4gICAgICBgaWYgKHNlbGYuJCRmcm96ZW4pIHsgY29weS4kJGZyb3plbiA9IHRydWU7IH1gXG4gICAgZW5kXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gYG5ldyBTdHJpbmcoc2VsZilgXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGNvdW50KCpzZXRzKVxuICAgICV4e1xuICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnQXJndW1lbnRFcnJvcjogd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSspJ31cbiAgICAgIH1cbiAgICAgIHZhciBjaGFyX2NsYXNzID0gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKTtcbiAgICAgIGlmIChjaGFyX2NsYXNzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoIC0gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpLmxlbmd0aDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGUoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9wcmVmaXgocHJlZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFwcmVmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXgsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfc3VmZml4KHN1ZmZpeClcbiAgICAleHtcbiAgICAgIGlmICghc3VmZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpID09PSBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRvd25jYXNlXG4gICAgYHNlbGYudG9Mb3dlckNhc2UoKWBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfbGluZShzZXBhcmF0b3IgPSAkLywgY2hvbXA6IGZhbHNlLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2xpbmUsIHNlcGFyYXRvciwgY2hvbXA6IGNob21wIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gbmlsKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmKTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgc2VwYXJhdG9yID0gJGNvZXJjZV90byhzZXBhcmF0b3IsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIHZhciBhLCBpLCBuLCBsZW5ndGgsIGNob21wZWQsIHRyYWlsaW5nLCBzcGxpdHRlZCwgdmFsdWU7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZvciAoYSA9IHNlbGYuc3BsaXQoLygoPzpcXHI/XFxuKXsyfSkoPzooPzpcXHI/XFxuKSopLyksIGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoYVtpXSB8fCBhW2kgKyAxXSkge1xuICAgICAgICAgICAgdmFsdWUgPSAoYVtpXSB8fCBcIlwiKSArIChhW2kgKyAxXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChjaG9tcCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9ICN7YHZhbHVlYC5jaG9tcChcIlxcblwiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBjaG9tcGVkICA9ICN7Y2hvbXAoc2VwYXJhdG9yKX07XG4gICAgICB0cmFpbGluZyA9IHNlbGYubGVuZ3RoICE9IGNob21wZWQubGVuZ3RoO1xuICAgICAgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNwbGl0dGVkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXR0ZWRbaV07XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSB8fCB0cmFpbGluZykge1xuICAgICAgICAgIHZhbHVlICs9IHNlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvbXApIHtcbiAgICAgICAgICB2YWx1ZSA9ICN7YHZhbHVlYC5jaG9tcChzZXBhcmF0b3IpfTtcbiAgICAgICAgfVxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVuZF93aXRoPygqc3VmZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3VmZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4ZXNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBnc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpnc3ViLCBwYXR0ZXJufTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9ICcnLCBtYXRjaF9kYXRhID0gbmlsLCBpbmRleCA9IDAsIG1hdGNoLCBfcmVwbGFjZW1lbnQ7XG5cbiAgICAgIGlmIChwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEluZGV4O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXN1bHQgKz0gc2VsZi5zbGljZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaF9kYXRhID0gI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhc3RJbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IGJsb2NrKG1hdGNoWzBdKTtcbiAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IGxhc3RJbmRleDsgLy8gc2F2ZSBhbmQgcmVzdG9yZSBsYXN0SW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKCFyZXBsYWNlbWVudC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQgKyAoc2VsZlttYXRjaC5pbmRleF0gfHwgXCJcIikpO1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQpXG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBoZXhcbiAgICB0b19pIDE2XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgb3RoZXIgPSAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihvdGhlcikgIT09IC0xO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KHNlYXJjaCwgb2Zmc2V0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGluZGV4LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHJlZ2V4O1xuXG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcbiAgICAgICAgcmVnZXggPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID49IG9mZnNldCkge1xuICAgICAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgcmVnZXhgLCBgbWF0Y2hgKX1cbiAgICAgICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2ggPSAkY29lcmNlX3RvKHNlYXJjaCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDAgJiYgb2Zmc2V0ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbmlsIDogaW5kZXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3MgKi9cbiAgICAgIHZhciBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHUwMDdGLVxcdTAwOUZcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICAgIG1ldGEgPSB7XG4gICAgICAgICAgICAnXFx1MDAwNyc6ICdcXFxcYScsXG4gICAgICAgICAgICAnXFx1MDAxYic6ICdcXFxcZScsXG4gICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgJ1xcdic6ICdcXFxcdicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVzY2FwZWQgPSBzZWxmLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoY2hyKSB7XG4gICAgICAgICAgICBpZiAobWV0YVtjaHJdKSByZXR1cm4gbWV0YVtjaHJdO1xuICAgICAgICAgICAgY2hyID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY2hyIDw9IDB4ZmYgJiYgKHNlbGYuZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpIHx8IHNlbGYuaW50ZXJuYWxfZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgY2hyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBjaHIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiAnXCInICsgZXNjYXBlZC5yZXBsYWNlKC9cXCNbXFwkXFxAXFx7XS9nLCAnXFxcXCQmJykgKyAnXCInO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludGVyblxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIGxpbmVzKHNlcGFyYXRvciA9ICQvLCBjaG9tcDogZmFsc2UsICZibG9jaylcbiAgICBlID0gZWFjaF9saW5lKHNlcGFyYXRvciwgY2hvbXA6IGNob21wLCAmYmxvY2spXG4gICAgYmxvY2sgPyBzZWxmIDogZS50b19hXG4gIGVuZFxuXG4gIGRlZiBsanVzdCh3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGluZGV4ICA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFwiXCI7XG5cbiAgICAgIHdpZHRoIC09IHNlbGYubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHdpZHRoKSB7XG4gICAgICAgIHJlc3VsdCArPSBwYWRzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmICsgcmVzdWx0LnNsaWNlKDAsIHdpZHRoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsc3RyaXBcbiAgICBgc2VsZi5yZXBsYWNlKC9eW1xcdTAwMDBcXHNdKi8sICcnKWBcbiAgZW5kXG5cbiAgZGVmIGFzY2lpX29ubHk/XG4gICAgIyBub24tQVNDSUktY29tcGF0aWJsZSBlbmNvZGluZyBtdXN0IHJldHVybiBmYWxzZVxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLmVuY29kaW5nLmFzY2lpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2gocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgU3RyaW5nID09PSBwYXR0ZXJuIHx8IHBhdHRlcm4ucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICAgIHBhdHRlcm4gPSA6OlJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgOjpSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3twYXR0ZXJuLmNsYXNzfSAoZXhwZWN0ZWQgUmVnZXhwKVwiXG4gICAgZW5kXG5cbiAgICBwYXR0ZXJuLm1hdGNoKHNlbGYsIHBvcywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWF0Y2g/KHBhdHRlcm4sIHBvcyA9IHVuZGVmaW5lZClcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IDo6UmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyA6OlJlZ2V4cCA9PT0gcGF0dGVyblxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2g/KHNlbGYsIHBvcylcbiAgZW5kXG5cbiAgZGVmIG5leHRcbiAgICAleHtcbiAgICAgIHZhciBpID0gc2VsZi5sZW5ndGg7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZjtcbiAgICAgIHZhciBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID0gc2VsZi5zZWFyY2goL1thLXpBLVowLTldLyk7XG4gICAgICB2YXIgY2FycnkgPSBmYWxzZTtcbiAgICAgIHZhciBjb2RlO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb2RlID0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDY1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gOTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpICsgMSk7XG4gICAgICAgIGlmIChjYXJyeSAmJiAoaSA9PT0gMCB8fCBpID09PSBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4KSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXJyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9jdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLFxuICAgICAgICAgIHJhZGl4ID0gODtcblxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykoLispJC9pLCBmdW5jdGlvbiAob3JpZ2luYWwsIGhlYWQsIGZsYWcsIHRhaWwpIHtcbiAgICAgICAgc3dpdGNoICh0YWlsLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICBpZiAodGFpbC5jaGFyQXQoMSkgPT09ICd4JyAmJiBmbGFnID09PSAnMHgnKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgcmFkaXggPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIHJhZGl4ID0gODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIHJhZGl4ID0gMTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9yZFxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvZGVQb2ludEF0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY29kZVBvaW50QXQoMCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhckNvZGVBdCgwKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oc2VwKVxuICAgICV4e1xuICAgICAgdmFyIGksIG07XG5cbiAgICAgIGlmIChzZXAuJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IHNlcC5leGVjKHNlbGYpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAjezo6TWF0Y2hEYXRhLm5ldyBgc2VwYCwgYG1gfTtcbiAgICAgICAgICBzZXAgPSBtWzBdO1xuICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAkY29lcmNlX3RvKHNlcCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYuaW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtzZWxmLCAnJywgJyddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJylgXG4gIGVuZFxuXG4gIGRlZiByaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IG51bGw7XG4gICAgICAgIHIgPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwgfHwgX20uaW5kZXggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7OjpNYXRjaERhdGEubmV3IGByYCwgYG1gfTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIGkgPSBzZWxmLmxhc3RJbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGkgPT09IC0xID8gbmlsIDogaTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByanVzdCh3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGNoYXJzICAgICA9IE1hdGguZmxvb3Iod2lkdGggLSBzZWxmLmxlbmd0aCksXG4gICAgICAgICAgcGF0dGVybnMgID0gTWF0aC5mbG9vcihjaGFycyAvIHBhZHN0ci5sZW5ndGgpLFxuICAgICAgICAgIHJlc3VsdCAgICA9IEFycmF5KHBhdHRlcm5zICsgMSkuam9pbihwYWRzdHIpLFxuICAgICAgICAgIHJlbWFpbmluZyA9IGNoYXJzIC0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHJlc3VsdCArIHBhZHN0ci5zbGljZSgwLCByZW1haW5pbmcpICsgc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBycGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKHNlcC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZXApO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKF9tID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IF9tO1xuICAgICAgICAgIHIubGFzdEluZGV4ID0gbS5pbmRleCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAjezo6TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgc2VwID0gbVswXTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAkY29lcmNlX3RvKHNlcCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbJycsICcnLCBzZWxmXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZi5zbGljZSgwLCBpKSxcbiAgICAgICAgc2VsZi5zbGljZShpLCBpICsgc2VwLmxlbmd0aCksXG4gICAgICAgIHNlbGYuc2xpY2UoaSArIHNlcC5sZW5ndGgpXG4gICAgICBdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc2NhbihwYXR0ZXJuLCBub19tYXRjaGRhdGE6IGZhbHNlLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgbWF0Y2hfZGF0YSA9IG5pbCxcbiAgICAgICAgICBtYXRjaDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZikpICE9IG51bGwpIHtcbiAgICAgICAgbWF0Y2hfZGF0YSA9ICN7OjpNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYCwgbm9fbWF0Y2hkYXRhOiBub19tYXRjaGRhdGF9O1xuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgIG1hdGNoLmxlbmd0aCA9PSAxID8gcmVzdWx0LnB1c2gobWF0Y2hbMF0pIDogcmVzdWx0LnB1c2goI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IE9wYWwueWllbGQxKGJsb2NrLCBtYXRjaFswXSkgOiBPcGFsLnlpZWxkMShibG9jaywgI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXN9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW5vX21hdGNoZGF0YSkgI3skfiA9IGBtYXRjaF9kYXRhYH07XG5cbiAgICAgIHJldHVybiAoYmxvY2sgIT09IG5pbCA/IHNlbGYgOiByZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBXZSByZWRlZmluZSB0aGlzIG1ldGhvZCBvbiBTdHJpbmcsIGFzIGtlcm5lbC5yYiBpcyBpbiBzdHJpY3QgbW9kZVxuICAjIHNvIHRoYXQgdGhpbmdzIGxpa2UgQm9vbGVhbiBkb24ndCBnZXQgYm94ZWQuIEZvciBTdHJpbmcgdGhvdWdoIC1cbiAgIyB3ZSBlaXRoZXIgbmVlZCB0byBib3ggaXQgdG8gZGVmaW5lIHByb3BlcnRpZXMgb24gaXQsIG9yIHJ1biBpdCBpblxuICAjIG5vbi1zdHJpY3QgbW9kZS4gVGhpcyBpcyBhIG1lc3MgYW5kIHdlIG5lZWQgdG8gY29tZSBiYWNrIHRvIGl0XG4gICMgYXQgYSBsYXRlciB0aW1lLlxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIHNwbGl0KHBhdHRlcm4gPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXQgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKGxpbWl0ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkIHx8IHBhdHRlcm4gPT09IG5pbCkge1xuICAgICAgICBwYXR0ZXJuID0gI3skOyB8fCAnICd9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b1N0cmluZygpLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBpLCBpaTtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcgJykge1xuICAgICAgICAgIHBhdHRlcm4gPSAvXFxzKy9nbTtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ20nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzdHJpbmcuc3BsaXQocGF0dGVybik7XG5cbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxICYmIHJlc3VsdFswXSA9PT0gc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbcmVzdWx0WzBdXTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKChpID0gcmVzdWx0LmluZGV4T2YodW5kZWZpbmVkKSkgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PT0gMCkge1xuICAgICAgICB3aGlsZSAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgICByZXN1bHQubGVuZ3RoIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcblxuICAgICAgaWYgKGxpbWl0IDwgMCkge1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnICYmIHBhdHRlcm4uc291cmNlLmluZGV4T2YoJyg/PScpID09PSAtMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gbWF0Y2gubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgcmVzdWx0LnNsaWNlKGxpbWl0IC0gMSkuam9pbignJykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPj0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgIGlmIChpICsgMSA9PT0gbGltaXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnNwbGljZShsaW1pdCAtIDEsIHJlc3VsdC5sZW5ndGggLSAxLCBzdHJpbmcuc2xpY2UoaW5kZXgpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3F1ZWV6ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKC8oLilcXDErL2csICckMScpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgY2hhcl9jbGFzcyArICcpXFxcXDErJywgJ2cnKSwgJyQxJyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RhcnRfd2l0aD8oKnByZWZpeGVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVmaXhlc1tpXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHZhciByZWdleHAgPSBwcmVmaXhlc1tpXTtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSByZWdleHAuZXhlYyhzZWxmKTtcblxuICAgICAgICAgIGlmIChtYXRjaCAhPSBudWxsICYmIG1hdGNoLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGByZWdleHBgLCBgbWF0Y2hgKX07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9ICRjb2VyY2VfdG8ocHJlZml4ZXNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICAgIGlmIChzZWxmLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15bXFxzXFx1MDAwMF0qfFtcXHNcXHUwMDAwXSokL2csICcnKWBcbiAgZW5kXG5cbiAgZGVmIHN1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsIG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpO1xuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgcmVzdWx0ID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfVxuXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgxIGZvciAyKSd9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgYmxvY2sobWF0Y2hbMF0pICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9ICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gJGNvZXJjZV90byhyZXBsYWNlbWVudCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvKFtcXFxcXSspKFswLTkrJmAnXSkvZywgZnVuY3Rpb24gKG9yaWdpbmFsLCBzbGFzaGVzLCBjb21tYW5kKSB7XG4gICAgICAgICAgICBpZiAoc2xhc2hlcy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgY2FzZSBcIiZcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFswXTtcbiAgICAgICAgICAgIGNhc2UgXCJgXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgZGVmYXVsdDogIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgKG1hdGNoW2NvbW1hbmRdIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudCArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VtKG4gPSAxNilcbiAgICAleHtcbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgJiAoTWF0aC5wb3coMiwgbikgLSAxKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzd2FwY2FzZVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGYucmVwbGFjZSgvKFthLXpdKyl8KFtBLVpdKykvZywgZnVuY3Rpb24oJDAsJDEsJDIpIHtcbiAgICAgICAgcmV0dXJuICQxID8gJDAudG9VcHBlckNhc2UoKSA6ICQwLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRmxvYXQoc2VsZi5yZXBsYWNlKC9fL2csICcnKSk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpIHx8IHJlc3VsdCA9PSBJbmZpbml0eSB8fCByZXN1bHQgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faShiYXNlID0gMTApXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICByYWRpeCA9ICRjb2VyY2VfdG8oYmFzZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChyYWRpeCA9PT0gMSB8fCByYWRpeCA8IDAgfHwgcmFkaXggPiAzNikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YHJhZGl4YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykoLispJC8sIGZ1bmN0aW9uIChvcmlnaW5hbCwgaGVhZCwgZmxhZywgdGFpbCkge1xuICAgICAgICBzd2l0Y2ggKHRhaWwuY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgxKSA9PT0gJ3gnICYmIGZsYWcgPT09ICcweCcgJiYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDIpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSA4KSB7XG4gICAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxMCkge1xuICAgICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSB7XG4gICAgICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBtZXRob2RfbmFtZSA9IGBzZWxmLnZhbHVlT2YoKWBcblxuICAgIHByb2MgPSA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgZ2l2ZW4nfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3YgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChyZWN2ID09IG51bGwpIHJlY3YgPSBuaWw7XG5cbiAgICAgICAgdmFyIGJvZHkgPSByZWN2WyckJyArICN7bWV0aG9kX25hbWV9XTtcblxuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICAgICAgYXJnc1swXSA9ICN7bWV0aG9kX25hbWV9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYm9keS5jYWxsKHJlY3YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBib2R5LmFwcGx5KHJlY3YsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBgcHJvYy4kJHNvdXJjZV9sb2NhdGlvbiA9IG5pbGBcblxuICAgIHByb2NcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgdHIoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDAgfHwgZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X3RvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGFzdF90byA9IGNoO1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSB0b19sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0X3RvLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiA9PSBudWxsID8gZ2xvYmFsX3N1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdfc3RyICs9IChzdWIgIT0gbnVsbCA/IHN1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld19zdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJfcyhmcm9tLCB0bylcbiAgICAleHtcbiAgICAgIGZyb20gPSAkY29lcmNlX3RvKGZyb20sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgIHRvID0gJGNvZXJjZV90byh0bywgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyb21fY2hhcnMgPSBmcm9tX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcblxuICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0b19sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICAgICAgdmFyIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHRvX2NoYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSB0b19sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvX2NoYXJzID0gdG9fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICAgICAgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aF9kaWZmID0gZnJvbV9sZW5ndGggLSB0b19sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGhfZGlmZiA+IDApIHtcbiAgICAgICAgICB2YXIgcGFkX2NoYXIgPSAodG9fbGVuZ3RoID4gMCA/IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdIDogJycpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGhfZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICB0b19jaGFycy5wdXNoKHBhZF9jaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0b19jaGFyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5ld19zdHIgPSAnJ1xuICAgICAgdmFyIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGxcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdXG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgaWYgKHN1YiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGFzdF9zdWJzdGl0dXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbmV3X3N0ciArPSBnbG9iYWxfc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld19zdHIgKz0gY2g7XG4gICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoc3ViICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCB8fCBsYXN0X3N1YnN0aXR1dGUgIT09IHN1Yikge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IHN1YjtcbiAgICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gc3ViO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld19zdHIgKz0gY2g7XG4gICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld19zdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXBjYXNlXG4gICAgYHNlbGYudG9VcHBlckNhc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHVwdG8oc3RvcCwgZXhjbCA9IGZhbHNlLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp1cHRvLCBzdG9wLCBleGNsIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIHZhciBhLCBiLCBzID0gc2VsZi50b1N0cmluZygpO1xuXG4gICAgICBzdG9wID0gJGNvZXJjZV90byhzdG9wLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocy5sZW5ndGggPT09IDEgJiYgc3RvcC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICBhID0gcy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBiID0gc3RvcC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHMsIDEwKS50b1N0cmluZygpID09PSBzICYmIHBhcnNlSW50KHN0b3AsIDEwKS50b1N0cmluZygpID09PSBzdG9wKSB7XG5cbiAgICAgICAgYSA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHN0b3AsIDEwKTtcblxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgYSA9PT0gYikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2soYS50b1N0cmluZygpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHdoaWxlIChzLmxlbmd0aCA8PSBzdG9wLmxlbmd0aCAmJiBzIDw9IHN0b3ApIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBzID09PSBzdG9wKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhzKTtcblxuICAgICAgICAgIHMgPSAje2BzYC5zdWNjfTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cykge1xuICAgICAgZnVuY3Rpb24gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChzZXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgaSwgbGVuID0gc2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJfY2hhcixcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoLFxuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20sXG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byxcbiAgICAgICAgICAgIGNoYXJfY29kZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY3Vycl9jaGFyID0gc2V0LmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoY3Vycl9jaGFyID09PSAnLScgJiYgaSA+IDAgJiYgaSA8IChsZW4gLSAxKSAmJiAhc2tpcF9uZXh0X2Rhc2gpIHtcbiAgICAgICAgICAgIGNoYXJfY29kZV9mcm9tID0gc2V0LmNoYXJDb2RlQXQoaSAtIDEpO1xuICAgICAgICAgICAgY2hhcl9jb2RlX3VwdG8gPSBzZXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhcl9jb2RlX2Zyb20gPiBjaGFyX2NvZGVfdXB0bykge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BjaGFyX2NvZGVfZnJvbWB9LSN7YGNoYXJfY29kZV91cHRvYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY2hhcl9jb2RlID0gY2hhcl9jb2RlX2Zyb20gKyAxOyBjaGFyX2NvZGUgPCBjaGFyX2NvZGVfdXB0byArIDE7IGNoYXJfY29kZSsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJfY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoID0gKGN1cnJfY2hhciA9PT0gJ1xcXFwnKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyX2NoYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXRBLCBzZXRCKSB7XG4gICAgICAgIGlmIChzZXRBLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzZXRCO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGksIGxlbiA9IHNldEEubGVuZ3RoLFxuICAgICAgICAgICAgY2hyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaHIgPSBzZXRBLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoc2V0Qi5pbmRleE9mKGNocikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgbGVuLCBzZXQsIG5lZywgY2hyLCB0bXAsXG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9ICcnLFxuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzZXQgPSAkY29lcmNlX3RvKHNldHNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIG5lZyA9IChzZXQuY2hhckF0KDApID09PSAnXicgJiYgc2V0Lmxlbmd0aCA+IDEpO1xuICAgICAgICBzZXQgPSBleHBsb2RlX3NlcXVlbmNlc19pbl9jaGFyYWN0ZXJfc2V0KG5lZyA/IHNldC5zbGljZSgxKSA6IHNldCk7XG4gICAgICAgIGlmIChuZWcpIHtcbiAgICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uKG5lZ19pbnRlcnNlY3Rpb24sIHNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihwb3NfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgJiYgbmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRtcCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hyID0gcG9zX2ludGVyc2VjdGlvbi5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24uaW5kZXhPZihjaHIpID09PSAtMSkge1xuICAgICAgICAgICAgdG1wICs9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9IHRtcDtcbiAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnWycgKyAjezo6UmVnZXhwLmVzY2FwZShgcG9zX2ludGVyc2VjdGlvbmApfSArICddJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1teJyArICN7OjpSZWdleHAuZXNjYXBlKGBuZWdfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IDpuZmMpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIkludmFsaWQgbm9ybWFsaXphdGlvbiBmb3JtICN7Zm9ybX1cIiB1bmxlc3MgJWlbbmZjIG5mZCBuZmtjIG5ma2RdLmluY2x1ZGU/KGZvcm0pXG4gICAgYHNlbGYubm9ybWFsaXplKCN7Zm9ybS51cGNhc2V9KWBcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplZD8oZm9ybSA9IDpuZmMpXG4gICAgdW5pY29kZV9ub3JtYWxpemUoZm9ybSkgPT0gc2VsZlxuICBlbmRcblxuICBkZWYgdW5wYWNrKGZvcm1hdClcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL3N0cmluZy91bnBhY2snLlwiXG4gIGVuZFxuXG4gIGRlZiB1bnBhY2sxKGZvcm1hdClcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrMSwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSB7IHJldHVybiBzZWxmOyB9XG4gICAgICAkcHJvcChzZWxmLCBcIiQkZnJvemVuXCIsIHRydWUpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgLUBcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuJCRmcm96ZW4pIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PSAnVVRGLTgnICYmIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcubmFtZSA9PSAnVVRGLTgnKSByZXR1cm4gc2VsZi50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHNlbGYuJGR1cCgpLiRmcmVlemUoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJyB8fCBzZWxmLiQkZnJvemVuID09PSB0cnVlYFxuICBlbmRcblxuICBhbGlhcyArQCBkdXBcbiAgYWxpYXMgPT09ID09XG4gIGFsaWFzIGJ5dGVzbGljZSBbXVxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIGVxdWFsPyA9PT1cbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuICBhbGlhcyBzbGljZSBbXVxuICBhbGlhcyBzdWNjIG5leHRcbiAgYWxpYXMgdG9fc3RyIHRvX3NcbiAgYWxpYXMgdG9fc3ltIGludGVyblxuXG4gIDo6T3BhbC5wcmlzdGluZSBzZWxmLCA6aW5pdGlhbGl6ZVxuZW5kXG5cblN5bWJvbCA9IFN0cmluZ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpTdHJpbmc+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJfX2lkX18iLCJ0cnlfY29udmVydCIsIndoYXQiLCJPcGFsIiwiY29lcmNlX3RvPyIsIlN0cmluZyIsIm5ldyIsImluaXRpYWxpemUiLCJhcmdzIiwiJSIsImRhdGEiLCJBcnJheSIsImZvcm1hdCIsIioiLCJjb3VudCIsIkludGVnZXIiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJSYW5nZUVycm9yIiwiKyIsIm90aGVyIiwiPD0+IiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19zIiwiPT0iLCI9fiIsIlR5cGVFcnJvciIsIltdIiwiaW5kZXgiLCJsZW5ndGgiLCIkfiIsIk1hdGNoRGF0YSIsImIiLCJmb3JjZV9lbmNvZGluZyIsImNhcGl0YWxpemUiLCJjYXNlY21wIiwiY2FzZWNtcD8iLCJjZW50ZXIiLCJ3aWR0aCIsInBhZHN0ciIsImVtcHR5PyIsImxqdXN0IiwiLyIsIjIiLCJjZWlsIiwicmp1c3QiLCJmbG9vciIsImNob21wIiwic2VwYXJhdG9yIiwiJC8iLCJjb2VyY2VfdG8hIiwiY2hvcCIsImNociIsImNsb25lIiwiJGt3YXJncyIsImZyZWV6ZSIsIm5pbD8iLCJjbGFzcyIsImNvcHkiLCJjb3B5X3NpbmdsZXRvbl9tZXRob2RzIiwiaW5pdGlhbGl6ZV9jbG9uZSIsImR1cCIsImluaXRpYWxpemVfZHVwIiwiZGVsZXRlIiwiZGVsZXRlX3ByZWZpeCIsInByZWZpeCIsImRlbGV0ZV9zdWZmaXgiLCJzdWZmaXgiLCJkb3duY2FzZSIsImVhY2hfbGluZSIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiZW5kX3dpdGg/IiwiZ3N1YiIsInBhdHRlcm4iLCJyZXBsYWNlbWVudCIsImhhc2giLCJoZXgiLCJ0b19pIiwiMTYiLCJpbmNsdWRlPyIsInNlYXJjaCIsIm9mZnNldCIsImluc3BlY3QiLCJpbnRlcm4iLCJsaW5lcyIsImUiLCJibG9jayIsInRvX3Byb2MiLCJ0b19hIiwibHN0cmlwIiwiYXNjaWlfb25seT8iLCJtYXRjaCIsInBvcyIsIlJlZ2V4cCIsIm1hdGNoPyIsIm5leHQiLCJvY3QiLCJvcmQiLCJwYXJ0aXRpb24iLCJzZXAiLCJyZXZlcnNlIiwicmluZGV4IiwicnBhcnRpdGlvbiIsInJzdHJpcCIsInNjYW4iLCJub19tYXRjaGRhdGEiLCJjYXB0dXJlcyIsInNpbmdsZXRvbl9jbGFzcyIsInNwbGl0IiwibGltaXQiLCIkcmV0X29yXzEiLCIkOyIsInNxdWVlemUiLCJzdGFydF93aXRoPyIsInN0cmlwIiwic3ViIiwic3VtIiwibiIsInN3YXBjYXNlIiwidG9fZiIsImJhc2UiLCIxMCIsIm1ldGhvZF9uYW1lIiwicHJvYyIsImJsb2NrIGluIHRvX3Byb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3Byb2MiLCJ0ciIsImZyb20iLCJ0byIsInRyX3MiLCJ1cGNhc2UiLCJ1cHRvIiwic3RvcCIsImV4Y2wiLCJzdWNjIiwiZXNjYXBlIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiX2xvYWQiLCJ1bmljb2RlX25vcm1hbGl6ZSIsImZvcm0iLCJ1bmljb2RlX25vcm1hbGl6ZWQ/IiwidW5wYWNrIiwidW5wYWNrMSIsIi1AIiwiZnJvemVuPyIsInByaXN0aW5lIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEOztBQUdGRCxjQUFnQkYsSUFBS0U7QUFDckJBOztBQUVFRyxJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxlQUFEQTtJQURGQSxDQUFBQSxHQUFBQTtJQUlBQyxNQUFJTixJQUFKTSxrQkFBQUEsdUJBQXFCQyxJQUFyQkQ7QUFBQUE7TUFDRUEsT0FBQUUsS0FBTUMsZUFBQUEsQ0FBWUYsSUFBbEIsRUFBd0JHLGFBQXhCLEVBQWtDLFFBQTVCRDtJQURSSCxDQUFBQSxHQUFBQTtJQUlBSyxNQUFJWCxJQUFKVyxVQUFBQSx1QkFwQkYsRUFvQkVBO0FBQUFBLE1BQUFBOzs7TUFwQkY7TUFvQmU7O0FBRWZBO0FBQ0FBO0FBQ0FBLDRCQUE4QkQsYUFBU0M7QUFDdkNBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLHVDQUE4Q0MsTUFBTEQsQ0FBQ0EsR0FBREEsQ0FBS0MsY0FBQUEsRUFBWSxNQUFDQyxJQUFELENBQVpELENBQW1CRDtBQUNqRUE7QUFDQUE7SUFYRUEsQ0FBQUEsSUFBQUE7O0FBbUJBQyxJQUFBQSwwQkFB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K0gsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHVCQUFBQSxtQkFBWXJJLE1BQVpxSTtBQUFBQTtNQUNFQSxPQUFBakksT0FBUUMsT0FBQUEsQ0FBT2dJLHdFQUFQaEk7SUFEVmdJLENBQUFBLEdBQUFBOztBQUlBeEYsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTEVBLENBQUFBLEdBQUFBOztBQVFBeUYsSUFBQUEsa0JBQUFBLDRCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTkVBLENBQUFBLEdBQUFBOztBQVNBQyxJQUFBQSx1QkFBQUEsZ0NBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxrREFBREE7SUFERkEsQ0FBQUEsR0FBQUE7SUFJQSxhQUFNLElBQU4sRUFBUyxLQUFUO0lBQ0EsYUFBTSxLQUFOLEVBQVUsSUFBVjtJQUNBLGFBQU0sV0FBTixFQUFnQixJQUFoQjtJQUNBLGFBQU0sTUFBTixFQUFXLElBQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxLQUFiO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLFFBQWhCO0lBQ0EsYUFBTSxPQUFOLEVBQVksSUFBWjtJQUNBLGFBQU0sTUFBTixFQUFXLE1BQVg7SUFDQSxhQUFNLFFBQU4sRUFBYSxNQUFiO0lBQ0EsYUFBTSxRQUFOLEVBQWEsUUFBYjtJQUVBdEosT0FBQU0sS0FBTWlKLFVBQUFBLENBQVV6SixJQUFoQixFQUFzQixZQUFoQnlKO0VBeDFEUnZKLEdBQU0sSUFBTkEsRUFBa0JILE1BQWxCRztFQTIxREFILE9BQUEsa0NBQVNXLFlBQVQ7QUFoMkRBWDsifX0seyJvZmZzZXQiOnsibGluZSI6OTQ1OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIva2VybmVsL2Zvcm1hdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5tb2R1bGUgOjpLZXJuZWxcbiAgZGVmIGZvcm1hdChmb3JtYXRfc3RyaW5nLCAqYXJncylcbiAgICBpZiBhcmdzLmxlbmd0aCA9PSAxICYmIGFyZ3NbMF0ucmVzcG9uZF90bz8oOnRvX2FyeSlcbiAgICAgIGFyeSA9IDo6T3BhbC5jb2VyY2VfdG8/KGFyZ3NbMF0sIDo6QXJyYXksIDp0b19hcnkpXG4gICAgICBhcmdzID0gYXJ5LnRvX2EgdW5sZXNzIGFyeS5uaWw/XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAvL3VzZWQgZm9yIHNsaWNpbmc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSAwLFxuICAgICAgICAgIGVuZF9zbGljZSxcbiAgICAgICAgICAvL3VzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBmb3JtYXQgc3RyaW5nOlxuICAgICAgICAgIGksXG4gICAgICAgICAgbGVuID0gZm9ybWF0X3N0cmluZy5sZW5ndGgsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nIGZpZWxkIHZhbHVlczpcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgc3RyLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAlZyBhbmQgJUcgZmllbGRzOlxuICAgICAgICAgIGV4cG9uZW50LFxuICAgICAgICAgIC8vdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiB3aWR0aCBhbmQgcHJlY2lzaW9uOlxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAvL3VzZWQgZm9yIGhvbGRpbmcgdGVtcG9yYXJ5IHZhbHVlczpcbiAgICAgICAgICB0bXBfbnVtLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAle30gYW5kICU8PiBmaWxlZHM6XG4gICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5LFxuICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhcixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWIsICVCLCAlbywgJXgsIGFuZCAlWCBmaWVsZHM6XG4gICAgICAgICAgYmFzZV9udW1iZXIsXG4gICAgICAgICAgYmFzZV9wcmVmaXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCxcbiAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0LFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgbmV4dF9hcmcsXG4gICAgICAgICAgc2VxX2FyZ19udW0gPSAxLFxuICAgICAgICAgIHBvc19hcmdfbnVtID0gMCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgZmxhZ3M6XG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgRk5PTkUgID0gMCxcbiAgICAgICAgICBGU0hBUlAgPSAxLFxuICAgICAgICAgIEZNSU5VUyA9IDIsXG4gICAgICAgICAgRlBMVVMgID0gNCxcbiAgICAgICAgICBGWkVSTyAgPSA4LFxuICAgICAgICAgIEZTUEFDRSA9IDE2LFxuICAgICAgICAgIEZXSURUSCA9IDMyLFxuICAgICAgICAgIEZQUkVDICA9IDY0LFxuICAgICAgICAgIEZQUkVDMCA9IDEyODtcblxuICAgICAgZnVuY3Rpb24gQ0hFQ0tfRk9SX0ZMQUdTKCkge1xuICAgICAgICBpZiAoZmxhZ3MmRldJRFRIKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnZmxhZyBhZnRlciB3aWR0aCd9IH1cbiAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfV0lEVEgoKSB7XG4gICAgICAgIGlmIChmbGFncyZGV0lEVEgpIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3aWR0aCBnaXZlbiB0d2ljZSd9IH1cbiAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dpZHRoIGFmdGVyIHByZWNpc2lvbid9IH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX05USF9BUkcobnVtKSB7XG4gICAgICAgIGlmIChudW0gPj0gYXJncy5sZW5ndGgpIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0b28gZmV3IGFyZ3VtZW50cyd9IH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbbnVtXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX05FWFRfQVJHKCkge1xuICAgICAgICBzd2l0Y2ggKHBvc19hcmdfbnVtKSB7XG4gICAgICAgIGNhc2UgLTE6ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBudW1iZXJlZFwifSAvLyByYWlzZVxuICAgICAgICBjYXNlIC0yOiAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ1bm51bWJlcmVkKCN7YHNlcV9hcmdfbnVtYH0pIG1peGVkIHdpdGggbmFtZWRcIn0gLy8gcmFpc2VcbiAgICAgICAgfVxuICAgICAgICBwb3NfYXJnX251bSA9IHNlcV9hcmdfbnVtKys7XG4gICAgICAgIHJldHVybiBHRVRfTlRIX0FSRyhwb3NfYXJnX251bSAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfUE9TX0FSRyhudW0pIHtcbiAgICAgICAgaWYgKHBvc19hcmdfbnVtID4gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW0gPCAxKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBpbmRleCAtICN7YG51bWB9JFwifVxuICAgICAgICB9XG4gICAgICAgIHBvc19hcmdfbnVtID0gLTE7XG4gICAgICAgIHJldHVybiBHRVRfTlRIX0FSRyhudW0gLSAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX0FSRygpIHtcbiAgICAgICAgcmV0dXJuIChuZXh0X2FyZyA9PT0gdW5kZWZpbmVkID8gR0VUX05FWFRfQVJHKCkgOiBuZXh0X2FyZyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJFQURfTlVNKGxhYmVsKSB7XG4gICAgICAgIHZhciBudW0sIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgIGlmIChpID09PSBsZW4pIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlKlswLTldJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA8IDQ4IHx8IGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA+IDU3KSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBudW0gPSBwYXJzZUludChzdHIsIDEwKSB8fCAwO1xuICAgICAgICAgICAgaWYgKG51bSA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiI3tgbGFiZWxgfSB0b28gYmlnXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU1fQUZURVJfQVNURVIobGFiZWwpIHtcbiAgICAgICAgdmFyIGFyZywgbnVtID0gUkVBRF9OVU0obGFiZWwpO1xuICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgYXJnID0gR0VUX1BPU19BUkcobnVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmcgPSBHRVRfTkVYVF9BUkcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tgYXJnYC50b19pbnR9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnKTsgaSAhPT0gLTE7IGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnLCBpKSkge1xuICAgICAgICBzdHIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZmxhZ3MgPSBGTk9ORTtcbiAgICAgICAgd2lkdGggPSAtMTtcbiAgICAgICAgcHJlY2lzaW9uID0gLTE7XG4gICAgICAgIG5leHRfYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGVuZF9zbGljZSA9IGk7XG5cbiAgICAgICAgaSsrO1xuXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSBpO1xuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xcMCc6XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0X3NlcXVlbmNlOiBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuXG4gICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTUEFDRTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGU0hBUlA7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlBMVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRk1JTlVTO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZaRVJPO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgY2FzZSAnNic6XG4gICAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICB0bXBfbnVtID0gUkVBRF9OVU0oJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgaWYgKGkgKyAyID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnJSc7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmV4dF9hcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInZhbHVlIGdpdmVuIHR3aWNlIC0gJSN7YHRtcF9udW1gfSRcIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXh0X2FyZyA9IEdFVF9QT1NfQVJHKHRtcF9udW0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgICB3aWR0aCA9IHRtcF9udW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXNlICdcXHsnOlxuICAgICAgICAgICAgY2xvc2luZ19icmFjZV9jaGFyID0gKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSAnPCcgPyAnPicgOiAnXFx9Jyk7XG4gICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgPSAnJztcblxuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgbmFtZSAtIHVubWF0Y2hlZCBwYXJlbnRoZXNpcyd9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBjbG9zaW5nX2JyYWNlX2NoYXIpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgbnVtYmVyZWRcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zX2FyZ19udW0gPSAtMjtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSB1bmRlZmluZWQgfHwgIWFyZ3NbMF0uJCRpc19oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ29uZSBoYXNoIHJlcXVpcmVkJ31cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXh0X2FyZyA9ICN7YGFyZ3NbMF1gLmZldGNoKGBoYXNoX3BhcmFtZXRlcl9rZXlgKX07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xvc2luZ19icmFjZV9jaGFyID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gbmV4dF9hcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByYWlzZVxuXG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgIHdpZHRoID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGlmIChmbGFncyZGUFJFQzApIHtcbiAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdwcmVjaXNpb24gZ2l2ZW4gdHdpY2UnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MgfD0gRlBSRUN8RlBSRUMwO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIGZsYWdzICY9IH5GUFJFQztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBSRUFEX05VTSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIGFyZyA9ICN7OjpLZXJuZWwuSW50ZWdlcihgR0VUX0FSRygpYCl9O1xuICAgICAgICAgICAgaWYgKGFyZyA+PSAwKSB7XG4gICAgICAgICAgICAgIHN0ciA9IGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDI7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzBiJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMSsvO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0ID0gJzEnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDg7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzAnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL14zPzcrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICc3JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDE2O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcweCc7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXmYrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICdmJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSAtICgoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgPyBiYXNlX3ByZWZpeC5sZW5ndGggOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxIC0gKGZsYWdzJkZTSEFSUCA/IDIgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKGFyZyA+Pj4gMCkudG9TdHJpbmcoYmFzZV9udW1iZXIpLnJlcGxhY2UoYmFzZV9uZWdfemVyb19yZWdleCwgYmFzZV9uZWdfemVyb19kaWdpdCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24gLSAyKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDIgLSAoZmxhZ3MmRlNIQVJQID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gYmFzZV9uZWdfemVyb19kaWdpdCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIGFyZyA9ICN7OjpLZXJuZWwuRmxvYXQoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCB8fCBpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSBJbmZpbml0eSAmJiAhaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnSW5mJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9GaXhlZChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQoc3RyLnNwbGl0KCdlJylbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKGV4cG9uZW50IDwgLTQgfHwgZXhwb25lbnQgPj0gKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvUHJlY2lzaW9uKHByZWNpc2lvbiA9PT0gLTEgPyAoZmxhZ3MmRlNIQVJQID8gNiA6IHVuZGVmaW5lZCkgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgYXJnICE9PSAtSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFtlRV1bLStdPykoWzAtOV0pJC8sICckMTAkMicpO1xuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBOb3QgaW1wbGVtZW50ZWQgYmVjYXVzZSB0aGVyZSBhcmUgbm8gc3BlY3MgZm9yIHRoaXMgZmllbGQgdHlwZS5cbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCAnYEFgIGFuZCBgYWAgZm9ybWF0IGZpZWxkIHR5cGVzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gT3BhbCB5ZXQnfVxuICAgICAgICAgICAgLy8gcmFpc2VcblxuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgYXJnID0gR0VUX0FSRygpO1xuICAgICAgICAgICAgaWYgKCN7YGFyZ2AucmVzcG9uZF90bz8oOnRvX2FyeSl9KSB7IGFyZyA9ICN7YGFyZ2AudG9fYXJ5fVswXTsgfVxuICAgICAgICAgICAgaWYgKCN7YGFyZ2AucmVzcG9uZF90bz8oOnRvX3N0cil9KSB7XG4gICAgICAgICAgICAgIHN0ciA9ICN7YGFyZ2AudG9fc3RyfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJGNvZXJjZV90byhhcmcsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnJWMgcmVxdWlyZXMgYSBjaGFyYWN0ZXInfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC5pbnNwZWN0fTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLnRvX3N9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlI3tgZm9ybWF0X3N0cmluZy5jaGFyQXQoaSlgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBmb3JtYXRfc3RyaW5nLnNsaWNlKGJlZ2luX3NsaWNlLCBlbmRfc2xpY2UpICsgc3RyO1xuICAgICAgICBiZWdpbl9zbGljZSA9IGkgKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3skREVCVUd9ICYmIHBvc19hcmdfbnVtID49IDAgJiYgc2VxX2FyZ19udW0gPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RvbyBtYW55IGFyZ3VtZW50cyBmb3IgZm9ybWF0IHN0cmluZyd9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgKyBmb3JtYXRfc3RyaW5nLnNsaWNlKGJlZ2luX3NsaWNlKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNwcmludGYgZm9ybWF0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiZm9ybWF0IiwiZm9ybWF0X3N0cmluZyIsImFyZ3MiLCJsZW5ndGgiLCIxIiwiW10iLCIwIiwicmVzcG9uZF90bz8iLCJhcnkiLCJPcGFsIiwiY29lcmNlX3RvPyIsIkFycmF5IiwibmlsPyIsInRvX2EiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0b19pbnQiLCJmZXRjaCIsIkludGVnZXIiLCJGbG9hdCIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ0b19hcnkiLCJ0b19zdHIiLCJpbnNwZWN0IiwidG9fcyIsIiRERUJVRyJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7OztBQUNFQyxJQUFBQSxzQkFBQUEsa0JBQVdDLGFBQUQsRUFIWixFQUdFRDtBQUFBQSxNQUFBQTtBQUFBQTs7O01BSEY7TUFHNEI7TUFDeEIsSUFBRyxDQUFBLE1BQUFFLElBQUlDLFFBQUFBLENBQUFBLENBQUosRUFBZUMsQ0FBZixDQUFBLElBQUEsQ0FBQSxRQUFvQkYsSUFBSUcsT0FBQUEsQ0FB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QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGtCQUFvQmMsT0FBUU0sT0FBQUEsQ0FBUXBCLFNBQVJvQixDQUFvQnBCO0FBQ2hEQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUEsWUFBY2MsT0FBUUMsT0FBQUEsQ0FBT00sMEJBQWYsRUFBc0NyQixnRUFBOUJlO0FBQ3RCZjs7QUFFQUE7QUFDQUE7QUFDQUEsZ0JBQWtCQSxDQUFDQSxHQUFEQSxDQUFLTyxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFzQlAsVUFBWUEsQ0FBQ0EsR0FBREEsQ0FBS3NCLFFBQUFBLENBQUFBLENBQVF0QjtBQUN0RUEsZ0JBQWtCQSxDQUFDQSxHQUFEQSxDQUFLTyxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFzQlA7QUFDN0NBLG9CQUFzQkEsQ0FBQ0EsR0FBREEsQ0FBS3VCLFFBQUFBLENBQUFBLENBQVF2QjtBQUNuQ0E7QUFDQUEsd0RBQTBEbUIsY0FBVW5CO0FBQ3BFQTtBQUNBQTtBQUNBQSxjQUFnQmMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NoQix5QkFBeEJlO0FBQ3hCZjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0JBQW9CQSxDQUFDQSxTQUFEQSxDQUFXd0IsU0FBQUEsQ0FBQUEsQ0FBU3hCO0FBQ3hDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0JBQW9CQSxDQUFDQSxTQUFEQSxDQUFXeUIsTUFBQUEsQ0FBQUEsQ0FBTXpCO0FBQ3JDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsWUFBY2MsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUNoQiw2QkFBRCxHQUFBLENBQStCQSx1QkFBL0IsQ0FBeEJlO0FBQ3RCZjtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWWMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NoQiw2QkFBeEJlO0FBQ3BCZjs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBLFVBQVkwQixZQUFPMUI7QUFDbkJBLFFBQVVjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIsc0NBQXhCZTtBQUNsQmY7O0FBRUFBO0FBQ0FBO0lBN2hCRUEsQ0FBQUEsSUFBQUE7SUFnaUJBRCxPQUFBLGFBQU0sU0FBTixFQUFjLFFBQWQ7RUFqaUJGQSxHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMDAyNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29tcGxleC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5yZXF1aXJlICdjb3JlbGliL2NvbXBsZXgvYmFzZSdcblxuY2xhc3MgOjpDb21wbGV4IDwgOjpOdW1lcmljXG4gIGRlZiBzZWxmLnJlY3QocmVhbCwgaW1hZyA9IDApXG4gICAgdW5sZXNzIDo6TnVtZXJpYyA9PT0gcmVhbCAmJiByZWFsLnJlYWw/ICYmIDo6TnVtZXJpYyA9PT0gaW1hZyAmJiBpbWFnLnJlYWw/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vdCBhIHJlYWwnXG4gICAgZW5kXG5cbiAgICBuZXcocmVhbCwgaW1hZylcbiAgZW5kXG5cbiAgZGVmIHNlbGYucG9sYXIociwgdGhldGEgPSAwKVxuICAgIHVubGVzcyA6Ok51bWVyaWMgPT09IHIgJiYgci5yZWFsPyAmJiA6Ok51bWVyaWMgPT09IHRoZXRhICYmIHRoZXRhLnJlYWw/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vdCBhIHJlYWwnXG4gICAgZW5kXG5cbiAgICBuZXcociAqIDo6TWF0aC5jb3ModGhldGEpLCByICogOjpNYXRoLnNpbih0aGV0YSkpXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpyZWFsLCA6aW1hZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlYWwsIGltYWcgPSAwKVxuICAgIEByZWFsID0gcmVhbFxuICAgIEBpbWFnID0gaW1hZ1xuICAgIGZyZWV6ZVxuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIFtvdGhlciwgc2VsZl1cbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBbOjpDb21wbGV4Lm5ldyhvdGhlciwgMCksIHNlbGZdXG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIENvbXBsZXhcIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgQHJlYWwgPT0gb3RoZXIucmVhbCAmJiBAaW1hZyA9PSBvdGhlci5pbWFnXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQHJlYWwgPT0gb3RoZXIgJiYgQGltYWcgPT0gMFxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgOjpLZXJuZWwuQ29tcGxleCgtQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCArIG90aGVyLnJlYWwsIEBpbWFnICsgb3RoZXIuaW1hZylcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsICsgb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDorLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsIC0gb3RoZXIucmVhbCwgQGltYWcgLSBvdGhlci5pbWFnKVxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgLSBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKiBvdGhlci5yZWFsIC0gQGltYWcgKiBvdGhlci5pbWFnLFxuICAgICAgICBAcmVhbCAqIG90aGVyLmltYWcgKyBAaW1hZyAqIG90aGVyLnJlYWwsXG4gICAgICApXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCAqIG90aGVyLCBAaW1hZyAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICBpZiAoOjpOdW1iZXIgPT09IEByZWFsICYmIEByZWFsLm5hbj8pIHx8ICg6Ok51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHxcbiAgICAgICAgICg6Ok51bWJlciA9PT0gb3RoZXIucmVhbCAmJiBvdGhlci5yZWFsLm5hbj8pIHx8ICg6Ok51bWJlciA9PT0gb3RoZXIuaW1hZyAmJiBvdGhlci5pbWFnLm5hbj8pXG4gICAgICAgIDo6Q29tcGxleC5uZXcoOjpGbG9hdDo6TkFOLCA6OkZsb2F0OjpOQU4pXG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYgKiBvdGhlci5jb25qIC8gb3RoZXIuYWJzMlxuICAgICAgZW5kXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbC5xdW8ob3RoZXIpLCBAaW1hZy5xdW8ob3RoZXIpKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgb3RoZXIgPT0gMFxuICAgICAgcmV0dXJuIDo6Q29tcGxleC5uZXcoMSwgMClcbiAgICBlbmRcblxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIHIsIHRoZXRhID0gcG9sYXJcbiAgICAgIG9yZSAgICAgID0gb3RoZXIucmVhbFxuICAgICAgb2ltICAgICAgPSBvdGhlci5pbWFnXG4gICAgICBuciAgICAgICA9IDo6TWF0aC5leHAob3JlICogOjpNYXRoLmxvZyhyKSAtIG9pbSAqIHRoZXRhKVxuICAgICAgbnRoZXRhICAgPSB0aGV0YSAqIG9yZSArIG9pbSAqIDo6TWF0aC5sb2cocilcblxuICAgICAgOjpDb21wbGV4LnBvbGFyKG5yLCBudGhldGEpXG4gICAgZWxzaWYgOjpJbnRlZ2VyID09PSBvdGhlclxuICAgICAgaWYgb3RoZXIgPiAwXG4gICAgICAgIHggPSBzZWxmXG4gICAgICAgIHogPSB4XG4gICAgICAgIG4gPSBvdGhlciAtIDFcblxuICAgICAgICB3aGlsZSBuICE9IDBcbiAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgd2hpbGUgbW9kID09IDBcbiAgICAgICAgICAgIHggPSA6Oktlcm5lbC5Db21wbGV4KHgucmVhbCAqIHgucmVhbCAtIHguaW1hZyAqIHguaW1hZywgMiAqIHgucmVhbCAqIHguaW1hZylcbiAgICAgICAgICAgIG4gPSBkaXZcbiAgICAgICAgICAgIGRpdiwgbW9kID0gbi5kaXZtb2QoMilcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHogKj0geFxuICAgICAgICAgIG4gLT0gMVxuICAgICAgICBlbmRcblxuICAgICAgICB6XG4gICAgICBlbHNlXG4gICAgICAgICg6OlJhdGlvbmFsLm5ldygxLCAxKSAvIHNlbGYpKiotb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIDo6RmxvYXQgPT09IG90aGVyIHx8IDo6UmF0aW9uYWwgPT09IG90aGVyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXG5cbiAgICAgIDo6Q29tcGxleC5wb2xhcihyKipvdGhlciwgdGhldGEgKiBvdGhlcilcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICA6Ok1hdGguaHlwb3QoQHJlYWwsIEBpbWFnKVxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIEByZWFsICogQHJlYWwgKyBAaW1hZyAqIEBpbWFnXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIDo6TWF0aC5hdGFuMihAaW1hZywgQHJlYWwpXG4gIGVuZFxuXG4gIGRlZiBjb25qXG4gICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCwgLUBpbWFnKVxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAcmVhbC5kZW5vbWluYXRvci5sY20oQGltYWcuZGVub21pbmF0b3IpXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIENvbXBsZXggPT09IG90aGVyICYmIEByZWFsLmNsYXNzID09IEBpbWFnLmNsYXNzICYmIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZkaXYob3RoZXIpXG4gICAgdW5sZXNzIDo6TnVtZXJpYyA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcblxuICAgIHNlbGYgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIEByZWFsLmZpbml0ZT8gJiYgQGltYWcuZmluaXRlP1xuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFwiQ29tcGxleDoje0ByZWFsfToje0BpbWFnfVwiXG4gIGVuZFxuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICBAcmVhbC5pbmZpbml0ZT8gfHwgQGltYWcuaW5maW5pdGU/XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgZCA9IGRlbm9taW5hdG9yXG5cbiAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsLm51bWVyYXRvciAqIChkIC8gQHJlYWwuZGVub21pbmF0b3IpLFxuICAgICAgQGltYWcubnVtZXJhdG9yICogKGQgLyBAaW1hZy5kZW5vbWluYXRvciksXG4gICAgKVxuICBlbmRcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBAaW1hZyAhPSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgcmVhbC5yYXRpb25hbGl6ZShlcHMpXG4gIGVuZFxuXG4gIGRlZiByZWFsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW0ByZWFsLCBAaW1hZ11cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEZsb2F0XCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2ZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgQHJlYWwudG9faVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgQHJlYWwudG9fclxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIHJlc3VsdCA9IEByZWFsLmluc3BlY3RcblxuICAgIHJlc3VsdCArPVxuICAgICAgaWYgKDo6TnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fCBAaW1hZy5wb3NpdGl2ZT8gfHwgQGltYWcuemVybz9cbiAgICAgICAgJysnXG4gICAgICBlbHNlXG4gICAgICAgICctJ1xuICAgICAgZW5kXG5cbiAgICByZXN1bHQgKz0gQGltYWcuYWJzLmluc3BlY3RcblxuICAgIGlmIDo6TnVtYmVyID09PSBAaW1hZyAmJiAoQGltYWcubmFuPyB8fCBAaW1hZy5pbmZpbml0ZT8pXG4gICAgICByZXN1bHQgKz0gJyonXG4gICAgZW5kXG5cbiAgICByZXN1bHQgKyAnaSdcbiAgZW5kXG5cbiAgSSA9IG5ldygwLCAxKVxuXG4gIGRlZiBzZWxmLmZyb21fc3RyaW5nKHN0cilcbiAgICAleHtcbiAgICAgIHZhciByZSA9IC9bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/KGVcXGQrKT8vLFxuICAgICAgICAgIG1hdGNoID0gc3RyLm1hdGNoKHJlKSxcbiAgICAgICAgICByZWFsLCBpbWFnLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGVzIGJvdGggZmxvYXRzIGFuZCByYXRpb25hbHNcbiAgICAgIGZ1bmN0aW9uIGN1dE51bWJlcigpIHtcbiAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuXG4gICAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgbnVtZXJhdG9yYCwgYGRlbm9taW5hdG9yYCl9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmV2ZXJ0aW5nICcvJ1xuICAgICAgICAgICAgICBzdHIgPSAnLycgKyBzdHI7XG4gICAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IHJlYWwgcGFydCwgbm8gZGVub21pbmF0b3JcbiAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlYWwgPSBjdXROdW1iZXIoKTtcblxuICAgICAgaWYgKCFyZWFsKSB7XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICdpJykge1xuICAgICAgICAgIC8vIGkgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICctJyAmJiBzdHJbMV0gPT09ICdpJykge1xuICAgICAgICAgIC8vIC1pID0+IENvbXBsZXgoMCwgLTEpXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCAtMSl9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcrJyAmJiBzdHJbMV0gPT09ICdpJykge1xuICAgICAgICAgIC8vICtpID0+IENvbXBsZXgoMCwgMSlcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KDAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbnl0aGluZyA9PiBDb21wbGV4KDAsIDApXG4gICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgMCl9O1xuICAgICAgfVxuXG4gICAgICBpbWFnID0gY3V0TnVtYmVyKCk7XG4gICAgICBpZiAoIWltYWcpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gM2kgPT4gQ29tcGxleCgwLCAzKVxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgYHJlYWxgKX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gMyA9PiBDb21wbGV4KDMsIDApXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleChgcmVhbGAsIDApfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMysyaSA9PiBDb21wbGV4KDMsIDIpXG4gICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoYHJlYWxgLCBgaW1hZ2ApfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBjb25qdWdhdGUgY29ualxuICBhbGlhcyBkaXZpZGUgL1xuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG4gIGFsaWFzIHBoYXNlIGFyZ1xuICBhbGlhcyBxdW8gL1xuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgdW5kZWYgbmVnYXRpdmU/XG4gIHVuZGVmIHBvc2l0aXZlP1xuICB1bmRlZiBzdGVwXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6Q29tcGxleD4iLCJyZWN0IiwicmVhbCIsImltYWciLCIwIiwiTnVtZXJpYyIsInJlYWw/IiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuZXciLCJwb2xhciIsInIiLCJ0aGV0YSIsIioiLCJNYXRoIiwiY29zIiwic2luIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlYWwiLCJAaW1hZyIsImZyZWV6ZSIsImNvZXJjZSIsIm90aGVyIiwiQ29tcGxleCIsImNsYXNzIiwiPT0iLCIkcmV0X29yXzEiLCItQCIsIisiLCJfX2NvZXJjZWRfXyIsIi0iLCIvIiwiTnVtYmVyIiwibmFuPyIsIkZsb2F0OjpOQU4iLCJGbG9hdCIsImNvbmoiLCJhYnMyIiwicXVvIiwiKioiLCIxIiwib3JlIiwib2ltIiwibnIiLCJleHAiLCJsb2ciLCJudGhldGEiLCJJbnRlZ2VyIiwiPiIsIngiLCJ6IiwibiIsImRpdm1vZCIsIjIiLCJkaXYiLCJtb2QiLCJSYXRpb25hbCIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsIiRyZXRfb3JfMiIsIj09PSIsImZkaXYiLCJmaW5pdGU/IiwiaGFzaCIsImluZmluaXRlPyIsImluc3BlY3QiLCJudW1lcmF0b3IiLCJkIiwiYXJnIiwicmF0aW9uYWxpemUiLCJlcHMiLCJBcmd1bWVudEVycm9yIiwiUmFuZ2VFcnJvciIsInRvX2YiLCJ0b19pIiwidG9fciIsInRv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YUFBTSxLQUFOLEVBQVUsR0FBVjtJQUNBLGFBQU0sYUFBTixFQUFrQixNQUFsQjs7SUFFQSxzQkFBTSxXQUFOOztJQUNBLHNCQUFNLFdBQU47OztJQUNBLHNCQUFNLE1BQU47SUEzV0ZFLE9BQUE7RUFHQUEsR0FBTSxJQUFOQSxFQUFrQkssY0FBbEJMO0FBSEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMDQ3MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdmFyaWFibGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgcmVnZXhwIG1hdGNoZXNcbiV4eyRndmFyc1snJiddID0gJGd2YXJzWyd+J10gPSAkZ3ZhcnNbJ2AnXSA9ICRndmFyc1tcIidcIl0gPSBuaWx9XG5cbiMgcmVxdWlyZXNcbiRMT0FERURfRkVBVFVSRVMgPSAkXCIgPSBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgXG4kTE9BRF9QQVRIICAgICAgID0gJDogPSBbXVxuXG4jIHNwbGl0IGxpbmVzXG4kLyA9IFwiXFxuXCJcbiQsID0gbmlsXG5cbjo6QVJHViA9IFtdXG46OkFSR0YgPSA6Ok9iamVjdC5uZXdcbjo6RU5WICA9IHt9XG5cbiRWRVJCT1NFID0gZmFsc2VcbiRERUJVRyAgID0gZmFsc2VcbiRTQUZFICAgID0gMFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIkTE9BREVEX0ZFQVRVUkVTIiwiJFwiIiwiJExPQURfUEFUSCIsIiQ6IiwiJC8iLCIkLCIsIk9iamVjdCIsIm5ldyIsIiRWRVJCT1NFIiwiJERFQlVHIiwiJFNBRkUiLCIwIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQ0dBO0VBR0hDLHlCQUFtQkMsQ0FBQUEsZUFBTUYsb0JBQU5FO0VBQ25CQyxtQkFBbUJDLENBQUFBLGNBQUssRUFBTEE7RUFHbkJDLGNBQUtMO0VBQ0xNLGNBQUs7RUFFTCxXQUFBLElBQUEsVUFBUyxFQUFUO0VBQ0EsV0FBQSxJQUFBLFVBQVNDLE9BQVFDLEtBQUFBLENBQUFBLENBQWpCO0VBQ0EsV0FBQSxJQUFBLFNBQVMsWUFBQSxFQUFUO0VBRUFDLGlCQUFXO0VBQ1hDLGVBQVc7RUFDWFYsT0FBQVcsQ0FBQUEsY0FBV0MsQ0FBWEQ7QUFqQkFYOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMDQ4OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbnVtYmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgOjpOdW1iZXIgPCA6Ok51bWVyaWNcbiAgOjpPcGFsLmJyaWRnZShgTnVtYmVyYCwgc2VsZilcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19udW1iZXInLCB0cnVlKWBcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyID09PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICByZXR1cm4gWyN7OjpLZXJuZWwuRmxvYXQob3RoZXIpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/KDp0b19mKX0pIHtcbiAgICAgICAgcmV0dXJuIFsjezo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6OkZsb2F0LCA6dG9fZil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBbb3RoZXIsIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje290aGVyLmNsYXNzfSBpbnRvIEZsb2F0XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF9faWRfX1xuICAgIGAoc2VsZiAqIDIpICsgMWBcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6LSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Lywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICUob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA9PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPCAwIHx8IHNlbGYgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIChzZWxmICUgb3RoZXIgKyBvdGhlcikgJSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZiAlIG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiUsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICYgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiYsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIHwgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOnwsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIF4gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOl4sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIDwgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjwsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA8PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmID4gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOj4sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA+PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Pj0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gICMgQ29tcHV0ZSB0aGUgcmVzdWx0IG9mIHRoZSBzcGFjZXNoaXAgb3BlcmF0b3IgaW5zaWRlIGl0cyBvd24gZnVuY3Rpb24gc28gaXRcbiAgIyBjYW4gYmUgb3B0aW1pemVkIGRlc3BpdGUgYSB0cnkvZmluYWxseSBjb25zdHJ1Y3QuXG4gICV4e1xuICAgIHZhciBzcGFjZXNoaXBfb3BlcmF0b3IgPSBmdW5jdGlvbihzZWxmLCBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChpc05hTihzZWxmKSB8fCBpc05hTihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYgPiBvdGhlcikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYgPCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8PT4sIGBvdGhlcmB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgYHNwYWNlc2hpcF9vcGVyYXRvcihzZWxmLCBvdGhlcilgXG4gIHJlc2N1ZSA6OkFyZ3VtZW50RXJyb3JcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIDw8KGNvdW50KVxuICAgIGNvdW50ID0gOjpPcGFsLmNvZXJjZV90byEgY291bnQsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPDwgI3tjb3VudH0gOiBzZWxmID4+IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmID4+KGNvdW50KVxuICAgIGNvdW50ID0gOjpPcGFsLmNvZXJjZV90byEgY291bnQsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPj4gI3tjb3VudH0gOiBzZWxmIDw8IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmIFtdKGJpdClcbiAgICBiaXQgPSA6Ok9wYWwuY29lcmNlX3RvISBiaXQsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgJXh7XG4gICAgICBpZiAoI3tiaXR9IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmICgje2JpdH0gPj0gMzIpIHtcbiAgICAgICAgcmV0dXJuICN7IHNlbGYgfSA8IDAgPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc2VsZiA+PiAje2JpdH0pICYgMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIGArc2VsZmBcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgYC1zZWxmYFxuICBlbmRcblxuICBkZWYgflxuICAgIGB+c2VsZmBcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmICEoOjpJbnRlZ2VyID09PSBzZWxmKSB8fCBvdGhlciA+IDBcbiAgICAgICAgYE1hdGgucG93KHNlbGYsIG90aGVyKWBcbiAgICAgIGVsc2VcbiAgICAgICAgOjpSYXRpb25hbC5uZXcoc2VsZiwgMSkqKm90aGVyXG4gICAgICBlbmRcbiAgICBlbHNpZiBzZWxmIDwgMCAmJiAoOjpGbG9hdCA9PT0gb3RoZXIgfHwgOjpSYXRpb25hbCA9PT0gb3RoZXIpXG4gICAgICA6OkNvbXBsZXgubmV3KHNlbGYsIDApKipvdGhlci50b19mXG4gICAgZWxzaWYgYG90aGVyLiQkaXNfbnVtYmVyICE9IG51bGxgXG4gICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyA6PT19KSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzID09PSA9PVxuXG4gIGRlZiBhYnNcbiAgICBgTWF0aC5hYnMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgYE1hdGguYWJzKHNlbGYgKiBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFsbGJpdHM/KG1hc2spXG4gICAgbWFzayA9IDo6T3BhbC5jb2VyY2VfdG8hIG1hc2ssIDo6SW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IG1hc2tgXG4gIGVuZFxuXG4gIGRlZiBhbnliaXRzPyhtYXNrKVxuICAgIG1hc2sgPSA6Ok9wYWwuY29lcmNlX3RvISBtYXNrLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSAhPT0gMGBcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgcmV0dXJuIHNlbGYgaWYgbmFuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgIGlmICgxIC8gc2VsZiA+IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZiA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYml0X2xlbmd0aFxuICAgIHVubGVzcyA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBiaXRfbGVuZ3RoYCBmb3IgI3tzZWxmfTpGbG9hdFwiLCAnYml0X2xlbmd0aCcpXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSAwIHx8IHNlbGYgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICB2YWx1ZSAgPSBzZWxmIDwgMCA/IH5zZWxmIDogc2VsZjtcblxuICAgICAgd2hpbGUgKHZhbHVlICE9IDApIHtcbiAgICAgICAgcmVzdWx0ICAgKz0gMTtcbiAgICAgICAgdmFsdWUgID4+Pj0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZWlsKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguY2VpbChmICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaHIoZW5jb2RpbmcgPSB1bmRlZmluZWQpXG4gICAgYE9wYWwuZW5jKFN0cmluZy5mcm9tQ2hhckNvZGUoc2VsZiksIGVuY29kaW5nIHx8IFwiQklOQVJZXCIpYFxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgMVxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkb3dudG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZG93bnRvLCBzdG9wKSBkb1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgOjpOdW1lcmljID09PSBzdG9wXG4gICAgICAgIHN0b3AgPiBzZWxmID8gMCA6IHNlbGYgLSBzdG9wICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghc3RvcC4kJGlzX251bWJlcikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHNlbGY7IGkgPj0gc3RvcDsgaS0tKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyIHx8IGBpc05hTihzZWxmKSAmJiBpc05hTihvdGhlcilgXG4gIGVuZFxuXG4gIGRlZiBldmVuP1xuICAgIGBzZWxmICUgMiA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkKG90aGVyKVxuICAgIHVubGVzcyA6OkludGVnZXIgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gTWF0aC5hYnMoc2VsZiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMob3RoZXIpO1xuXG4gICAgICB3aGlsZSAobWluID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gbWluO1xuXG4gICAgICAgIG1pbiA9IG1heCAlIG1pbjtcbiAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZGxjbShvdGhlcilcbiAgICBbZ2NkKG90aGVyKSwgbGNtKG90aGVyKV1cbiAgZW5kXG5cbiAgZGVmIGludGVnZXI/XG4gICAgYHNlbGYgJSAxID09PSAwYFxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6SW50ZWdlciAmJiA6OkludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkZsb2F0ICYmIDo6RmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6SW50ZWdlciAmJiA6OkludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkZsb2F0ICYmIDo6RmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBsY20ob3RoZXIpXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDAgfHwgb3RoZXIgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2VsZiAqIG90aGVyIC8gI3tnY2Qob3RoZXIpfSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgIGBzZWxmICsgMWBcbiAgZW5kXG5cbiAgZGVmIG5vYml0cz8obWFzaylcbiAgICBtYXNrID0gOjpPcGFsLmNvZXJjZV90byEgbWFzaywgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgPT0gMGBcbiAgZW5kXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgYHNlbGYgPT0gMCA/IG5pbCA6IHNlbGZgXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBvZGQ/XG4gICAgYHNlbGYgJSAyICE9PSAwYFxuICBlbmRcblxuICBkZWYgb3JkXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG93KGIsIG0gPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICN7c2VsZioqYn07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISgjezo6SW50ZWdlciA9PT0gYn0pKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMm5kIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhIDFzdCBhcmd1bWVudCBpcyBpbnRlZ2VyJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDFzdCBhcmd1bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUgd2hlbiAybmQgYXJndW1lbnQgc3BlY2lmaWVkJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKCN7OjpJbnRlZ2VyID09PSBtfSkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGFsbCBhcmd1bWVudHMgYXJlIGludGVnZXJzJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAjeyhzZWxmKipiKSAlIG19XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJlZFxuICAgIGBzZWxmIC0gMWBcbiAgZW5kXG5cbiAgZGVmIHF1byhvdGhlcilcbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2VsZiAvIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIDo6UmF0aW9uYWwubmV3KHNlbGYsIDEpXG4gICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICBlbHNpZiBuYW4/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgZWxzaWYgYGVwcyA9PSBudWxsYFxuICAgICAgZiwgbiAgPSA6Ok1hdGguZnJleHAgc2VsZlxuICAgICAgZiAgICAgPSA6Ok1hdGgubGRleHAoZiwgOjpGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIG4gICAgLT0gOjpGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgOjpSYXRpb25hbC5uZXcoMiAqIGYsIDEgPDwgKDEgLSBuKSkucmF0aW9uYWxpemUoOjpSYXRpb25hbC5uZXcoMSwgMSA8PCAoMSAtIG4pKSlcbiAgICBlbHNlXG4gICAgICB0b19yLnJhdGlvbmFsaXplKGVwcylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlbWFpbmRlcih5KVxuICAgIHNlbGYgLSB5ICogKHNlbGYgLyB5KS50cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgcm91bmQobmRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICBpZiA6OkludGVnZXIgPT09IHNlbGZcbiAgICAgIGlmIGBuZGlnaXRzID09IG51bGxgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgOjpGbG9hdCA9PT0gbmRpZ2l0cyAmJiBuZGlnaXRzLmluZmluaXRlP1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdJbmZpbml0eSdcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gOjpPcGFsLmNvZXJjZV90byEobmRpZ2l0cywgOjpJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDwgOjpJbnRlZ2VyOjpNSU5cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnb3V0IG9mIGJvdW5kcydcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbmRpZ2l0cyA+PSAwYFxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSAtbmRpZ2l0c1xuXG4gICAgICAleHtcbiAgICAgICAgaWYgKDAuNDE1MjQxICogbmRpZ2l0cyAtIDAuMTI1ID4gI3tzaXplfSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoTWF0aC5hYnMoc2VsZikgKyBmIC8gMikgLyBmKSAqIGY7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYgPCAwID8gLXggOiB4O1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGlmIG5hbj8gJiYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSA6Ok9wYWwuY29lcmNlX3RvIShgbmRpZ2l0cyB8fCAwYCwgOjpJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDw9IDBcbiAgICAgICAgaWYgbmFuP1xuICAgICAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ05hTidcbiAgICAgICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgbmRpZ2l0cyA9PSAwXG4gICAgICAgIHJldHVybiBgTWF0aC5yb3VuZChzZWxmKWBcbiAgICAgIGVsc2lmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgXywgZXhwID0gOjpNYXRoLmZyZXhwKHNlbGYpXG5cbiAgICAgIGlmIG5kaWdpdHMgPj0gKDo6RmxvYXQ6OkRJRyArIDIpIC0gKGV4cCA+IDAgPyBleHAgLyA0IDogZXhwIC8gMyAtIDEpXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgbmRpZ2l0cyA8IC0oZXhwID4gMCA/IGV4cCAvIDMgKyAxIDogZXhwIC8gNClcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIGVuZFxuXG4gICAgICBgTWF0aC5yb3VuZChzZWxmICogTWF0aC5wb3coMTAsIG5kaWdpdHMpKSAvIE1hdGgucG93KDEwLCBuZGlnaXRzKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRpbWVzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRpbWVzKSB7IHNlbGYgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBgc2VsZiA8IDAgPyBNYXRoLmNlaWwoc2VsZikgOiBNYXRoLmZsb29yKHNlbGYpYFxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgOjpSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNlXG4gICAgICBmLCBlICA9IDo6TWF0aC5mcmV4cChzZWxmKVxuICAgICAgZiAgICAgPSA6Ok1hdGgubGRleHAoZiwgOjpGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIGUgICAgLT0gOjpGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgKGYgKiAoOjpGbG9hdDo6UkFESVgqKmUpKS50b19yXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19zKGJhc2UgPSAxMClcbiAgICBiYXNlID0gOjpPcGFsLmNvZXJjZV90byEgYmFzZSwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBiYXNlIDwgMiB8fCBiYXNlID4gMzZcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIlxuICAgIGVuZFxuXG4gICAgIyBEb24ndCBsb3NlIHRoZSBuZWdhdGl2ZSB6ZXJvXG4gICAgaWYgc2VsZiA9PSAwICYmIGAxL3NlbGYgPT09IC1JbmZpbml0eWBcbiAgICAgIHJldHVybiAnLTAuMCdcbiAgICBlbmRcblxuICAgIGBzZWxmLnRvU3RyaW5nKGJhc2UpYFxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoZiAqIGZhY3RvciwgMTApIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZ2l0cyhiYXNlID0gMTApXG4gICAgaWYgc2VsZiA8IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TWF0aDo6RG9tYWluRXJyb3IsICdvdXQgb2YgZG9tYWluJ1xuICAgIGVuZFxuXG4gICAgYmFzZSA9IDo6T3BhbC5jb2VyY2VfdG8hIGJhc2UsIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiAhPSBwYXJzZUludChzZWxmKSkgI3s6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IsIFwidW5kZWZpbmVkIG1ldGhvZCBgZGlnaXRzJyBmb3IgI3tpbnNwZWN0fVwifVxuXG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLCByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKHNlbGYgPT0gMCkge1xuICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSAlIGJhc2UpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlIC8gYmFzZSwgMTApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpdm1vZChvdGhlcilcbiAgICBpZiBuYW4/IHx8IG90aGVyLm5hbj9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnVwdG8sIHN0b3ApIGRvXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyA6Ok51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA8IHNlbGYgPyAwIDogc3RvcCAtIHNlbGYgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBgc2VsZiA9PSAwYFxuICBlbmRcblxuICAjIFNpbmNlIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgMzIgYml0LCBkZWNsYXJlIGl0IHRvIGJlIHNvLlxuICBkZWYgc2l6ZVxuICAgIDRcbiAgZW5kXG5cbiAgZGVmIG5hbj9cbiAgICBgaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgYHNlbGYgIT0gSW5maW5pdHkgJiYgc2VsZiAhPSAtSW5maW5pdHkgJiYgIWlzTmFOKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gKzE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBgc2VsZiAhPSAwICYmIChzZWxmID09IEluZmluaXR5IHx8IDEgLyBzZWxmID4gMClgXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBgc2VsZiA9PSAtSW5maW5pdHkgfHwgMSAvIHNlbGYgPCAwYFxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBudW1iZXJUb1VpbnQ4QXJyYXkobnVtKSB7XG4gICAgICB2YXIgdWludDhhcnJheSA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgbmV3IERhdGFWaWV3KHVpbnQ4YXJyYXkuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIG51bSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdWludDhhcnJheTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1aW50OEFycmF5VG9OdW1iZXIoYXJyKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIpLmdldEZsb2F0NjQoMCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5jcmVtZW50TnVtYmVyQml0KG51bSkge1xuICAgICAgdmFyIGFyciA9IG51bWJlclRvVWludDhBcnJheShudW0pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gMHhmZikge1xuICAgICAgICAgIGFycltpXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyW2ldKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1aW50OEFycmF5VG9OdW1iZXIoYXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNyZW1lbnROdW1iZXJCaXQobnVtKSB7XG4gICAgICB2YXIgYXJyID0gbnVtYmVyVG9VaW50OEFycmF5KG51bSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSAwKSB7XG4gICAgICAgICAgYXJyW2ldID0gMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJbaV0tLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb051bWJlcihhcnIpO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBuZXh0X2Zsb2F0XG4gICAgcmV0dXJuIDo6RmxvYXQ6OklORklOSVRZIGlmIHNlbGYgPT0gOjpGbG9hdDo6SU5GSU5JVFlcbiAgICByZXR1cm4gOjpGbG9hdDo6TkFOIGlmIG5hbj9cblxuICAgIGlmIHNlbGYgPj0gMFxuICAgICAgIyBNYXRoLmFicygpIGlzIG5lZWRlZCB0byBoYW5kbGUgLTAuMFxuICAgICAgYGluY3JlbWVudE51bWJlckJpdChNYXRoLmFicyhzZWxmKSlgXG4gICAgZWxzZVxuICAgICAgYGRlY3JlbWVudE51bWJlckJpdChzZWxmKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHByZXZfZmxvYXRcbiAgICByZXR1cm4gLTo6RmxvYXQ6OklORklOSVRZIGlmIHNlbGYgPT0gLTo6RmxvYXQ6OklORklOSVRZXG4gICAgcmV0dXJuIDo6RmxvYXQ6Ok5BTiBpZiBuYW4/XG5cbiAgICBpZiBzZWxmID4gMFxuICAgICAgYGRlY3JlbWVudE51bWJlckJpdChzZWxmKWBcbiAgICBlbHNlXG4gICAgICBgLWluY3JlbWVudE51bWJlckJpdChNYXRoLmFicyhzZWxmKSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIGZkaXYgL1xuICBhbGlhcyBpbnNwZWN0IHRvX3NcbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuICBhbGlhcyBtb2R1bG8gJVxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG4gIGFsaWFzIHBoYXNlIGFuZ2xlXG4gIGFsaWFzIHN1Y2MgbmV4dFxuICBhbGlhcyB0b19pbnQgdG9faVxuZW5kXG5cbjo6Rml4bnVtID0gOjpOdW1iZXJcblxuY2xhc3MgOjpJbnRlZ2VyIDwgOjpOdW1lcmljXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcbiAgYHNlbGYuJCRpc19pbnRlZ2VyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiBzcXJ0KG4pXG4gICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgJXh7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpNYXRoOjpEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJpc3FydFwiJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChNYXRoLnNxcnQobiksIDEwKTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiB0cnlfY29udmVydChvYmplY3QpXG4gICAgICBPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCBzZWxmLCA6dG9faW50KVxuICAgIGVuZFxuICBlbmRcblxuICBzZWxmOjpNQVggPSBgTWF0aC5wb3coMiwgMzApIC0gMWBcbiAgc2VsZjo6TUlOID0gYC1NYXRoLnBvdygyLCAzMClgXG5lbmRcblxuY2xhc3MgOjpGbG9hdCA8IDo6TnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG5cbiAgICBkZWYgPT09KG90aGVyKVxuICAgICAgYCEhb3RoZXIuJCRpc19udW1iZXJgXG4gICAgZW5kXG4gIGVuZFxuXG4gIHNlbGY6OklORklOSVRZID0gYEluZmluaXR5YFxuICBzZWxmOjpNQVggICAgICA9IGBOdW1iZXIuTUFYX1ZBTFVFYFxuICBzZWxmOjpNSU4gICAgICA9IGBOdW1iZXIuTUlOX1ZBTFVFYFxuICBzZWxmOjpOQU4gICAgICA9IGBOYU5gXG5cbiAgc2VsZjo6RElHICAgICAgPSAxNVxuICBzZWxmOjpNQU5UX0RJRyA9IDUzXG4gIHNlbGY6OlJBRElYICAgID0gMlxuXG4gIHNlbGY6OkVQU0lMT04gPSBgTnVtYmVyLkVQU0lMT04gfHwgMi4yMjA0NDYwNDkyNTAzMTMwODA4NDcyNjMzMzYxODE2RS0xNmBcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpOdW1iZXI+IiwiT3BhbCIsImJyaWRnZSIsImFsbG9jYXRlIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuYW1lIiwiY29lcmNlIiwib3RoZXIiLCJjbGFzcyIsIkZsb2F0IiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiX19pZF9fIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIlplcm9EaXZpc2lvbkVycm9yIiwiJiIsInwiLCJeIiwiPCIsIjw9IiwiPiIsIj49IiwiPD0+IiwiQXJndW1lbnRFcnJvciIsIjw8IiwiY291bnQiLCJJbnRlZ2VyIiwiPj4iLCJbXSIsImJpdCIsIitAIiwiLUAiLCJ+IiwiKioiLCI9PT0iLCIwIiwiUmF0aW9uYWwiLCJuZXciLCIxIiwiQ29tcGxleCIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJOb01ldGhvZEVycm9yIiwiY2VpbCIsIm5kaWdpdHMiLCJjaHIiLCJlbmNvZGluZyIsImRlbm9taW5hdG9yIiwiaW5maW5pdGU/IiwiZG93bnRvIiwic3RvcCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZG93bnRvIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkb3dudG8iLCJOdW1lcmljIiwiZXF1YWw/IiwiJHJldF9vcl8xIiwiZXZlbj8iLCJmbG9vciIsImdjZCIsImdjZGxjbSIsImxjbSIsImludGVnZXI/IiwiaXNfYT8iLCJrbGFzcyIsImluc3RhbmNlX29mPyIsIm5leHQiLCJub2JpdHM/Iiwibm9uemVybz8iLCJudW1lcmF0b3IiLCJvZGQ/Iiwib3JkIiwicG93IiwiYiIsIm0iLCJwcmVkIiwicXVvIiwicmF0aW9uYWxpemUiLCJlcHMiLCJGbG9hdERvbWFpbkVycm9yIiwiTWF0aCIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsIkZsb2F0OjpNQU5UX0RJRyIsInRvX2kiLCIyIiwidG9fciIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiUmFuZ2VFcnJvciIsIkludGVnZXI6Ok1JTiIsInNpemUiLCJfIiwiZXhwIiwiRmxvYXQ6OkRJRyIsIjQiLCIzIiwidGltZXMiLCJibG9jayIsImJsb2NrIGluIHRpbWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0aW1lcyIsImUiLCJGbG9hdDo6UkFESVgiLCJ0b19zIiwiYmFzZSIsIjEwIiwiMzYiLCJkaWdpdHMiLCJNYXRoOjpEb21haW5FcnJvciIsImluc3BlY3QiLCJkaXZtb2QiLCJ1cHRvIiwiYmxvY2sgaW4gdXB0byIsImJsb2NrICgyIGxldmVscykgaW4gdXB0byIsInplcm8/IiwiZmluaXRlPyIsInBvc2l0aXZlPyIsIm5lZ2F0aXZlPyIsIm5leHRfZmxvYXQiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdDo6TkFOIiwicHJldl9mbG9hdCIsIk51bWJlciIsIjxjbGFzczpJbnRlZ2VyPiIsInNxcnQiLCJ0cnlfY29udmVydCIs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QUFqQjtJQUVBNkMsT0FBQSxXQUFBdEosSUFBQSxhQUFpQnNKLHVEQUFqQjtFQXhCRkEsR0FBTSxJQUFOQSxFQUFnQjlFLGNBQWhCOEU7QUFsNUJBdko7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExNjQ2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wbGV4L2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIDo6S2VybmVsXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXG4gICAgaWYgaW1hZ1xuICAgICAgQ29tcGxleC5uZXcocmVhbCwgaW1hZylcbiAgICBlbHNlXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCAwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlN0cmluZ1xuICBkZWYgdG9fY1xuICAgIENvbXBsZXguZnJvbV9zdHJpbmcoc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiQ29tcGxleCIsInJlYWwiLCJpbWFnIiwibmV3IiwiMCIsIjxjbGFzczpTdHJpbmc+IiwidG9fYyIsImZyb21fc3RyaW5nIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBWUMsSUFBRCxFQUFPQyxJQUFsQkY7QUFBQUE7O01BQWtCLHlCQUFPO01BQ3ZCLElBQUEsUUFBR0UsSUFBSCxDQUFBO1FBQ0VGLE9BQUFBLGFBQU9HLEtBQUFBLENBQUtGLElBQVosRUFBa0JDLElBQVhDO01BRFQ7UUFHRUgsT0FBQUEsYUFBT0csS0FBQUEsQ0FBS0YsSUFBWixFQUFrQkcsQ0FBWEQ7TUFIVDtJQURGSCxDQUFBQSxJQUFBQTtFQURGRCxHQUFPLElBQVBBO0VBVUFELE9BQUFPO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQU4sYUFBT08sYUFBQUEsQ0FBYUMsSUFBYkQ7SUFEVEQsQ0FBQUEsR0FBQUE7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQVZBUDsifX0seyJvZmZzZXQiOnsibGluZSI6MTE2ODAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL3JlZ2V4cF9hbmNob3JzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBPcGFsXG4gIHNlbGY6OlJFR0VYUF9TVEFSVCA9IFJVQllfRU5HSU5FID09ICdvcGFsJyA/ICdeJyA6ICdcXEEnXG4gIHNlbGY6OlJFR0VYUF9FTkQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnJCcgOiAnXFx6J1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDJGIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSArICFcIiMkJSYnKCkqKywtLi8gY2hhcnMpXG4gICMgXFx1MDAzQSAtIFxcdTAwNDAgKDo7PD0+P0AgY2hhcnMpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgYmVnZ2luaW5nIG9yIG1pZGRsZSBvZiBpdHMgbmFtZVxuICBzZWxmOjpGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMkZcXHUwMDNBLVxcdTAwNDBcXHUwMDVCLVxcdTAwNUVcXHUwMDYwXFx1MDA3Qi1cXHUwMDdGJ1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDIwIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSlcbiAgIyBcXHUwMDIyIC0gXFx1MDAyRiAoXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDNFICg6Ozw9PiBjaGFycylcbiAgIyBcXHUwMDQwICAgICAgICAgIChAIGNoYXIpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgZW5kIG9mIGl0cyBuYW1lXG4gICMgSW4gZmFjdCwgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSBGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgKyBcXHUwMDIxICgnPycpICsgXFx1MDAzRiAoJyEnKVxuICBzZWxmOjpGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgICA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIyLVxcdTAwMkZcXHUwMDNBLVxcdTAwM0VcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgc2VsZjo6SU5MSU5FX0lERU5USUZJRVJfUkVHRVhQID0gUmVnZXhwLm5ldyhcIlteI3tzZWxmOjpGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSU31dKlteI3tzZWxmOjpGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlN9XVwiKVxuXG4gICMgRm9yIGNvbnN0YW50cyBydWxlcyBhcmUgcHJldHR5IG11Y2ggdGhlIHNhbWUsIGJ1dCAnOicgaXMgYWxsb3dlZCBhbmQgJz8hJyBhcmUgbm90LlxuICAjIFBsdXMgaXQgbWF5IHN0YXJ0IHdpdGggYSAnOjonIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBjb25zdGFudCBjb21lcyBmcm9tIHRvcGxldmVsLlxuICBzZWxmOjpGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIxLVxcdTAwMkZcXHUwMDNCLVxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgc2VsZjo6Q09OU1RfTkFNRV9SRUdFWFAgPSBSZWdleHAubmV3KFwiI3tzZWxmOjpSRUdFWFBfU1RBUlR9KDo6KT9bQS1aXVteI3tzZWxmOjpGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSU31dKiN7c2VsZjo6UkVHRVhQX0VORH1cIilcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+Iiwic2VsZiIsIlJlZ2V4cCIsIm5ldyIsInNlbGY6OkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTIiwic2VsZjo6Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTIiwic2VsZjo6UkVHRVhQX1NUQVJUIiwic2VsZjo6Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMiLCJzZWxmOjpSRUdFWFBfRU5EIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRSxXQUFBQyxJQUFBLGtCQUE2Q0QsR0FBN0M7SUFDQSxXQUFBQyxJQUFBLGdCQUEyQ0QsR0FBM0M7SUFTQSxXQUFBQyxJQUFBLHlDQUE0Q0QscUVBQTVDO0lBWUEsV0FBQUMsSUFBQSx1Q0FBNENELDJGQUE1QztJQUNBLFdBQUFDLElBQUEsOEJBQWlDQyxZQUFNQyxLQUFBQSxDQUFNSCxJQUFELEdBQUEsQ0FBS0ksSUFBQUgsSUFBQUcsd0NBQUwsQ0FBQSxHQUErQ0osTUFBL0MsR0FBQSxDQUFxREssSUFBQUosSUFBQUksc0NBQXJELENBQUEsR0FBNkZMLEdBQWxHRyxDQUF2QztJQUlBLFdBQUFGLElBQUEsZ0NBQW1DRCwyRkFBbkM7SUFDQUEsT0FBQSxXQUFBQyxJQUFBLHVCQUEwQkMsWUFBTUMsS0FBQUEsQ0FBSyxFQUFBLEdBQUEsQ0FBR0csSUFBQUwsSUFBQUssaUJBQUgsQ0FBQSxHQUFzQk4sY0FBdEIsR0FBQSxDQUFvQ08sSUFBQU4sSUFBQU0sK0JBQXBDLENBQUEsR0FBcUVQLElBQXJFLEdBQUEsQ0FBeUVRLElBQUFQLElBQUFPLGVBQXpFLENBQUxMLENBQWhDO0VBN0JGSCxHQUFBQSxXQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTE3MDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL251bWVyaWMucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xuXG5jbGFzcyA6Ok51bWVyaWNcbiAgaW5jbHVkZSA6OkNvbXBhcmFibGVcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIG90aGVyLmluc3RhbmNlX29mPyBzZWxmLmNsYXNzXG4gICAgICByZXR1cm4gW290aGVyLCBzZWxmXVxuICAgIGVuZFxuXG4gICAgWzo6S2VybmVsLkZsb2F0KG90aGVyKSwgOjpLZXJuZWwuRmxvYXQoc2VsZildXG4gIGVuZFxuXG4gIGRlZiBfX2NvZXJjZWRfXyhtZXRob2QsIG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/KDpjb2VyY2UpXG4gICAgICBhLCBiID0gb3RoZXIuY29lcmNlKHNlbGYpXG4gICAgICBhLl9fc2VuZF9fIG1ldGhvZCwgYlxuICAgIGVsc2VcbiAgICAgIGNhc2UgbWV0aG9kXG4gICAgICB3aGVuIDorLCA6LSwgOiosIDovLCA6JSwgOiYsIDp8LCA6XiwgOioqXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBOdW1lcmljXCJcbiAgICAgIHdoZW4gOj4sIDo+PSwgOjwsIDo8PSwgOjw9PlxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tvdGhlci5jbGFzc30gZmFpbGVkXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIGVxdWFsPyBvdGhlclxuICAgICAgcmV0dXJuIDBcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgK0BcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIDAgLSBzZWxmXG4gIGVuZFxuXG4gIGRlZiAlKG90aGVyKVxuICAgIHNlbGYgLSBvdGhlciAqIGRpdihvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIHNlbGYgPCAwID8gLXNlbGYgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgc2VsZiAqIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgc2VsZiA8IDAgPyA6Ok1hdGg6OlBJIDogMFxuICBlbmRcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICB0b19mLmNlaWwobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGNvbmpcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIHRvX3IuZGVub21pbmF0b3JcbiAgZW5kXG5cbiAgZGVmIGRpdihvdGhlcilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSBvJyBpZiBvdGhlciA9PSAwXG5cbiAgICAoc2VsZiAvIG90aGVyKS5mbG9vclxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIFtkaXYob3RoZXIpLCBzZWxmICUgb3RoZXJdXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHRvX2YgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5mbG9vcihuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgaVxuICAgIDo6S2VybmVsLkNvbXBsZXgoMCwgc2VsZilcbiAgZW5kXG5cbiAgZGVmIGltYWdcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiBpbnRlZ2VyP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBub256ZXJvP1xuICAgIHplcm8/ID8gbmlsIDogc2VsZlxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgdG9fci5udW1lcmF0b3JcbiAgZW5kXG5cbiAgZGVmIHBvbGFyXG4gICAgW2FicywgYXJnXVxuICBlbmRcblxuICBkZWYgcXVvKG90aGVyKVxuICAgIDo6T3BhbC5jb2VyY2VfdG8hKHNlbGYsIDo6UmF0aW9uYWwsIDp0b19yKSAvIG90aGVyXG4gIGVuZFxuXG4gIGRlZiByZWFsXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVhbD9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW3NlbGYsIDBdXG4gIGVuZFxuXG4gIGRlZiByb3VuZChkaWdpdHMgPSB1bmRlZmluZWQpXG4gICAgdG9fZi5yb3VuZChkaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiBzdGVwKGxpbWl0ID0gdW5kZWZpbmVkLCBzdGVwID0gdW5kZWZpbmVkLCB0bzogdW5kZWZpbmVkLCBieTogdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiB0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndG8gaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcCAhPT0gdW5kZWZpbmVkICYmIGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdzdGVwIGlzIGdpdmVuIHR3aWNlJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSB0bztcbiAgICAgIH1cblxuICAgICAgaWYgKGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RlcCA9IGJ5O1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IG5pbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbWV0ZXJzKCkge1xuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ3N0ZXAgbXVzdCBiZSBudW1lcmljJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwICE9IG51bGwgJiYgI3tzdGVwID09IDB9KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsIHx8IHN0ZXAgPT0gbnVsbCkge1xuICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpZ24gPSAje3N0ZXAgPD0+IDB9O1xuXG4gICAgICAgIGlmIChzaWduID09PSBuaWwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCIwIGNhbid0IGJlIGNvZXJjZWQgaW50byAje3N0ZXAuY2xhc3N9XCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGltaXQgPT09IG5pbCB8fCBsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgbGltaXQgPSBzaWduID4gMCA/ICN7OjpGbG9hdDo6SU5GSU5JVFl9IDogI3stOjpGbG9hdDo6SU5GSU5JVFl9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3s6Ok9wYWwuY29tcGFyZShzZWxmLCBsaW1pdCl9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXBGbG9hdFNpemUoKSB7XG4gICAgICAgIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IEluZmluaXR5IHx8IHN0ZXAgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKHNlbGYpICsgYWJzKGxpbWl0KSArIGFicyhsaW1pdCAtIHNlbGYpKSAvIGFicyhzdGVwKSAqICN7OjpGbG9hdDo6RVBTSUxPTn07XG5cbiAgICAgICAgICBpZiAoZXJyID09PSBJbmZpbml0eSB8fCBlcnIgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmxvb3IoKGxpbWl0IC0gc2VsZikgLyBzdGVwICsgZXJyKSArIDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcFNpemUoKSB7XG4gICAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgJSAxICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXBGbG9hdFNpemUoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLCBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgICAgbGhzID0gYWJzKHNlbGYgLSBsaW1pdCkgKyAxLFxuICAgICAgICAgICAgICByaHMgPSBhYnMoc3RlcCk7XG5cbiAgICAgICAgICByZXR1cm4gY2VpbChsaHMgLyByaHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICBpZiAoIWxpbWl0IHx8IGxpbWl0LmlzX2E/KDo6TnVtZXJpYykpICYmXG4gICAgICAgICAoIXN0ZXAgfHwgc3RlcC5pc19hPyg6Ok51bWVyaWMpKVxuXG4gICAgICAgIHJldHVybiA6OkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZS5uZXcoXG4gICAgICAgICAgW2xpbWl0LCBzdGVwLCAoJ3RvOiAnIGlmIHRvKSwgKCdieTogJyBpZiBieSldLCBzZWxmXG4gICAgICAgIClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBsaW1pdCwgc3RlcCwgJmBzdGVwU2l6ZWApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFsaWRhdGVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgIHZhciBpc0Rlc2MgPSAje3N0ZXAubmVnYXRpdmU/fSxcbiAgICAgICAgICBpc0luZiA9ICN7c3RlcCA9PSAwfSB8fFxuICAgICAgICAgICAgICAgICAgKGxpbWl0ID09PSBJbmZpbml0eSAmJiAhaXNEZXNjKSB8fFxuICAgICAgICAgICAgICAgICAgKGxpbWl0ID09PSAtSW5maW5pdHkgJiYgaXNEZXNjKTtcblxuICAgICAgaWYgKHNlbGYuJCRpc19udW1iZXIgJiYgc3RlcC4kJGlzX251bWJlciAmJiBsaW1pdC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoc2VsZiAlIDEgPT09IDAgJiYgKGlzSW5mIHx8IGxpbWl0ICUgMSA9PT0gMCkgJiYgc3RlcCAlIDEgPT09IDApIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmO1xuXG4gICAgICAgICAgaWYgKGlzSW5mKSB7XG4gICAgICAgICAgICBmb3IgKDs7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZXNjKSB7XG4gICAgICAgICAgICBmb3IgKDsgdmFsdWUgPj0gbGltaXQ7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKDsgdmFsdWUgPD0gbGltaXQ7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiZWdpbiA9ICN7dG9fZn0udmFsdWVPZigpO1xuICAgICAgICAgIHN0ZXAgPSAje3N0ZXAudG9fZn0udmFsdWVPZigpO1xuICAgICAgICAgIGxpbWl0ID0gI3tsaW1pdC50b19mfS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICB2YXIgbiA9IHN0ZXBGbG9hdFNpemUoKTtcblxuICAgICAgICAgIGlmICghaXNGaW5pdGUoc3RlcCkpIHtcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSBibG9jayhiZWdpbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBibG9jayhiZWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBkID0gaSAqIHN0ZXAgKyBzZWxmO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+PSAwID8gbGltaXQgPCBkIDogbGltaXQgPiBkKSB7XG4gICAgICAgICAgICAgICAgZCA9IGxpbWl0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJsb2NrKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY291bnRlciA9IHNlbGZcblxuICAgIHdoaWxlIGBpc0Rlc2MgPyAje2NvdW50ZXIgPj0gbGltaXR9IDogI3tjb3VudGVyIDw9IGxpbWl0fWBcbiAgICAgIHlpZWxkIGNvdW50ZXJcbiAgICAgIGNvdW50ZXIgKz0gc3RlcFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fY1xuICAgIDo6S2VybmVsLkNvbXBsZXgoc2VsZiwgMClcbiAgZW5kXG5cbiAgZGVmIHRvX2ludFxuICAgIHRvX2lcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKG5kaWdpdHMgPSAwKVxuICAgIHRvX2YudHJ1bmNhdGUobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHplcm8/XG4gICAgc2VsZiA9PSAwXG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBzZWxmID4gMFxuICBlbmRcblxuICBkZWYgbmVnYXRpdmU/XG4gICAgc2VsZiA8IDBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgbmlsXG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBjb25qdWdhdGUgY29ualxuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG4gIGFsaWFzIG1vZHVsbyAlXG4gIGFsaWFzIHBoYXNlIGFyZ1xuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6TnVtZXJpYz4iLCJpbmNsdWRlIiwiQ29tcGFyYWJsZSIsImNvZXJjZSIsIm90aGVyIiwiaW5zdGFuY2Vfb2Y/IiwiY2xhc3MiLCJLZXJuZWwiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwibWV0aG9kIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJBcmd1bWVudEVycm9yIiwiPD0+IiwiZXF1YWw/IiwiMCIsIitAIiwiLUAiLCItIiwiJSIsIioiLCJkaXYiLCJhYnMiLCI8IiwiYWJzMiIsImFuZ2xlIiwiTWF0aDo6UEkiLCJNYXRoIiwiY2VpbCIsIm5kaWdpdHMiLCJ0b19mIiwiY29uaiIsImRlbm9taW5hdG9yIiwidG9fciIsIlplcm9EaXZpc2lvbkVycm9yIiwiLyIsImZsb29yIiwiZGl2bW9kIiwiZmRpdiIsImkiLCJDb21wbGV4IiwiaW1hZyIsImludGVnZXI/Iiwibm9uemVybz8iLCJ6ZXJvPyIsIm51bWVyYXRvciIsInBvbGFyIiwiYXJnIiwicXVvIiwiT3BhbCIsImNvZXJjZV90byEiLCJSYXRpb25hbCIsInJlYWwiLCJyZWFsPyIsInJlY3QiLCJyb3VuZCIsImRpZ2l0cyIsInN0ZXAiLCI9PSIsIkZsb2F0OjpJTkZJTklUWSIsImNvbXBhcmUiLCJsaW1pdCIsIkZsb2F0OjpFUFNJTE9OIiwiYmxvY2tfZ2l2ZW4/IiwiaXNfYT8iLCJOdW1lcmljIiwiRW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlIiwiRW51bWVyYXRvciIsIm5ldyIsInRvIiwiYnkiLCJlbnVtX2ZvciIsInRvX3Byb2MiLCJuZWdhdGl2ZT8iLCJjb3VudGVyIiwiPj0iLCI8PSIsIisiLCJ0b19jIiwidG9faW50IiwidG9faSIsInRydW5jYXRlIiwi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QU4sRUFBVSxPQUFWO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLEtBQWhCO0lBQ0EsYUFBTSxRQUFOLEVBQWEsR0FBYjtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQTdGLE9BQUEsYUFBTSxhQUFOLEVBQWtCLE1BQWxCO0VBdlZGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjE0MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyI6Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3J1bnRpbWUnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2hlbHBlcnMnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL21vZHVsZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY2xhc3MnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2Jhc2ljX29iamVjdCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIva2VybmVsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9lcnJvcidcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb25zdGFudHMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSw0QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsaUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZUFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUVSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixtQkFBVEU7QUFUUkY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyMTU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20vbWVyc2VubmVfdHdpc3Rlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFRoaXMgaXMgYmFzZWQgb24gYW4gYWRhcHRhdGlvbiBvZiBNYWtvdG8gTWF0c3Vtb3RvIGFuZCBUYWt1amkgTmlzaGltdXJhJ3MgY29kZVxuIyBkb25lIGJ5IFNlYW4gTWNDdWxsb3VnaCA8YmFua3NlYW5AZ21haWwuY29tPiBhbmQgRGF2ZSBIZWl0em1hblxuIyA8ZGF2ZWhlaXR6bWFuQHlhaG9vLmNvbT4sIHN1YnNlcXVlbnRseSByZWFkYXB0ZWQgZnJvbSBhbiB1cGRhdGVkIHZlcnNpb24gb2ZcbiMgcnVieSdzIHJhbmRvbS5jIChyZXYgYzM4YTE4MzAzMmE3ODI2ZGYxYWRhYmQ4YWEwNzI1YzcxM2Q1M2UxYykuXG4jXG4jIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgbm90aWNlIGZyb20gcmFuZG9tLmMgZm9sbG93cy5cbiNcbiMgICBUaGlzIGlzIGJhc2VkIG9uIHRyaW1tZWQgdmVyc2lvbiBvZiBNVDE5OTM3LiAgVG8gZ2V0IHRoZSBvcmlnaW5hbCB2ZXJzaW9uLFxuIyAgIGNvbnRhY3QgPGh0dHA6Ly93d3cubWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAvfm0tbWF0L01UL2VtdC5odG1sPi5cbiNcbiMgICBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IG5vdGljZSBmb2xsb3dzLlxuI1xuIyAgICAgIEEgQy1wcm9ncmFtIGZvciBNVDE5OTM3LCB3aXRoIGluaXRpYWxpemF0aW9uIGltcHJvdmVkIDIwMDIvMi8xMC5cbiMgICAgICBDb2RlZCBieSBUYWt1amkgTmlzaGltdXJhIGFuZCBNYWtvdG8gTWF0c3Vtb3RvLlxuIyAgICAgIFRoaXMgaXMgYSBmYXN0ZXIgdmVyc2lvbiBieSB0YWtpbmcgU2hhd24gQ29rdXMncyBvcHRpbWl6YXRpb24sXG4jICAgICAgTWF0dGhlIEJlbGxldydzIHNpbXBsaWZpY2F0aW9uLCBJc2FrdSBXYWRhJ3MgcmVhbCB2ZXJzaW9uLlxuI1xuIyAgICAgIEJlZm9yZSB1c2luZywgaW5pdGlhbGl6ZSB0aGUgc3RhdGUgYnkgdXNpbmcgaW5pdF9nZW5yYW5kKG10LCBzZWVkKVxuIyAgICAgIG9yIGluaXRfYnlfYXJyYXkobXQsIGluaXRfa2V5LCBrZXlfbGVuZ3RoKS5cbiNcbiMgICAgICBDb3B5cmlnaHQgKEMpIDE5OTcgLSAyMDAyLCBNYWtvdG8gTWF0c3Vtb3RvIGFuZCBUYWt1amkgTmlzaGltdXJhLFxuIyAgICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4jXG4jICAgICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4jICAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4jICAgICAgYXJlIG1ldDpcbiNcbiMgICAgICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4jXG4jICAgICAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuIyAgICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuIyAgICAgICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiNcbiMgICAgICAgIDMuIFRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGVcbiMgICAgICAgICAgIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlblxuIyAgICAgICAgICAgcGVybWlzc2lvbi5cbiNcbiMgICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4jICAgICAgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuIyAgICAgIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuIyAgICAgIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuIyAgICAgIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuIyAgICAgIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiMgICAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiMgICAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4jICAgICAgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiMgICAgICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiMgICAgICBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiNcbiNcbiMgICAgICBBbnkgZmVlZGJhY2sgaXMgdmVyeSB3ZWxjb21lLlxuIyAgICAgIGh0dHA6Ly93d3cubWF0aC5rZWlvLmFjLmpwL21hdHVtb3RvL2VtdC5odG1sXG4jICAgICAgZW1haWw6IG1hdHVtb3RvQG1hdGgua2Vpby5hYy5qcFxubWVyc2VubmVfdHdpc3RlciA9ICV4eyhmdW5jdGlvbigpIHtcbiAgLyogUGVyaW9kIHBhcmFtZXRlcnMgKi9cbiAgdmFyIE4gPSA2MjQ7XG4gIHZhciBNID0gMzk3O1xuICB2YXIgTUFUUklYX0EgPSAweDk5MDhiMGRmOyAgICAgIC8qIGNvbnN0YW50IHZlY3RvciBhICovXG4gIHZhciBVTUFTSyA9IDB4ODAwMDAwMDA7ICAgICAgICAgLyogbW9zdCBzaWduaWZpY2FudCB3LXIgYml0cyAqL1xuICB2YXIgTE1BU0sgPSAweDdmZmZmZmZmOyAgICAgICAgIC8qIGxlYXN0IHNpZ25pZmljYW50IHIgYml0cyAqL1xuICB2YXIgTUlYQklUUyA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKCAoKHUpICYgVU1BU0spIHwgKCh2KSAmIExNQVNLKSApOyB9O1xuICB2YXIgVFdJU1QgPSBmdW5jdGlvbih1LHYpIHsgcmV0dXJuIChNSVhCSVRTKCh1KSwodikpID4+PiAxKSBeICgodiAmIDB4MSkgPyBNQVRSSVhfQSA6IDB4MCk7IH07XG5cbiAgZnVuY3Rpb24gaW5pdChzKSB7XG4gICAgdmFyIG10ID0ge2xlZnQ6IDAsIG5leHQ6IE4sIHN0YXRlOiBuZXcgQXJyYXkoTil9O1xuICAgIGluaXRfZ2VucmFuZChtdCwgcyk7XG4gICAgcmV0dXJuIG10O1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZXMgbXRbTl0gd2l0aCBhIHNlZWQgKi9cbiAgZnVuY3Rpb24gaW5pdF9nZW5yYW5kKG10LCBzKSB7XG4gICAgdmFyIGosIGk7XG4gICAgbXQuc3RhdGVbMF0gPSBzID4+PiAwO1xuICAgIGZvciAoaj0xOyBqPE47IGorKykge1xuICAgICAgbXQuc3RhdGVbal0gPSAoMTgxMjQzMzI1MyAqICgobXQuc3RhdGVbai0xXSBeIChtdC5zdGF0ZVtqLTFdID4+IDMwKSA+Pj4gMCkpICsgaik7XG4gICAgICAvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cbiAgICAgIC8qIEluIHRoZSBwcmV2aW91cyB2ZXJzaW9ucywgTVNCcyBvZiB0aGUgc2VlZCBhZmZlY3QgICAqL1xuICAgICAgLyogb25seSBNU0JzIG9mIHRoZSBhcnJheSBzdGF0ZVtdLiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cbiAgICAgIG10LnN0YXRlW2pdICY9IDB4ZmZmZmZmZmY7ICAvKiBmb3IgPjMyIGJpdCBtYWNoaW5lcyAqL1xuICAgIH1cbiAgICBtdC5sZWZ0ID0gMTtcbiAgICBtdC5uZXh0ID0gTjtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlIE4gd29yZHMgYXQgb25lIHRpbWUgKi9cbiAgZnVuY3Rpb24gbmV4dF9zdGF0ZShtdCkge1xuICAgIHZhciBwID0gMCwgX3AgPSBtdC5zdGF0ZTtcbiAgICB2YXIgajtcblxuICAgIG10LmxlZnQgPSBOO1xuICAgIG10Lm5leHQgPSAwO1xuXG4gICAgZm9yIChqPU4tTSsxOyAtLWo7IHArKylcbiAgICAgIF9wW3BdID0gX3BbcCsoTSldIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgZm9yIChqPU07IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbcCsoMSldKTtcblxuICAgIF9wW3BdID0gX3BbcCsoTS1OKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wWzBdKTtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cbiAgZnVuY3Rpb24gZ2VucmFuZF9pbnQzMihtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgeTtcblxuICAgIGlmICgtLW10LmxlZnQgPD0gMCkgbmV4dF9zdGF0ZShtdCk7XG4gICAgeSA9IG10LnN0YXRlW210Lm5leHQrK107XG5cbiAgICAvKiBUZW1wZXJpbmcgKi9cbiAgICB5IF49ICh5ID4+PiAxMSk7XG4gICAgeSBePSAoeSA8PCA3KSAmIDB4OWQyYzU2ODA7XG4gICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgIHkgXj0gKHkgPj4+IDE4KTtcblxuICAgIHJldHVybiB5ID4+PiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYikge1xuICAgIGEgPj4+PSA1O1xuICAgIGIgPj4+PSA2O1xuICAgIHJldHVybihhKjY3MTA4ODY0LjArYikqKDEuMC85MDA3MTk5MjU0NzQwOTkyLjApO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKSB3aXRoIDUzLWJpdCByZXNvbHV0aW9uXG4gIGZ1bmN0aW9uIGdlbnJhbmRfcmVhbChtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgYSA9IGdlbnJhbmRfaW50MzIobXQpLCBiID0gZ2VucmFuZF9pbnQzMihtdCk7XG4gICAgcmV0dXJuIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpO1xuICB9XG5cbiAgcmV0dXJuIHsgZ2VucmFuZF9yZWFsOiBnZW5yYW5kX3JlYWwsIGluaXQ6IGluaXQgfTtcbn0pKCl9XG5cbmNsYXNzIDo6UmFuZG9tXG4gIGB2YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE1hdGgucG93KDIsIDUzKSAtIDFgXG5cbiAgc2VsZjo6TUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IgPSBge1xuICAgIG5ld19zZWVkOiBmdW5jdGlvbigpIHsgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE1BWF9JTlQpOyB9LFxuICAgIHJlc2VlZDogZnVuY3Rpb24oc2VlZCkgeyByZXR1cm4gbWVyc2VubmVfdHdpc3Rlci5pbml0KHNlZWQpOyB9LFxuICAgIHJhbmQ6IGZ1bmN0aW9uKG10KSB7IHJldHVybiBtZXJzZW5uZV90d2lzdGVyLmdlbnJhbmRfcmVhbChtdCk7IH1cbiAgfWBcblxuICBzZWxmLmdlbmVyYXRvciA9IHNlbGY6Ok1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwibWVyc2VubmVfdHdpc3RlciIsIjxjbGFzczpSYW5kb20+Iiwic2VsZiIsImdlbmVyYXRvcj0iLCJzZWxmOjpNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUiJdLCJtYXBwaW5ncyI6IkFBQUFBLGtEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQXNEQUMsbUJBQXNCRDtBQUN0QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtFQUVBQSxPQUFBRTtFQUFBQTs7SUFBQUE7OztJQUNHQTtJQUVELFdBQUFDLElBQUEsZ0NBQW9DRDtBQUN0Q0E7QUFDQUE7QUFDQUE7QUFDQUEsR0FKRTtJQU1BQSxPQUFJRSxNQUFBQSxDQUFhQyxJQUFBRixJQUFBRSwrQkFBYkQsQ0FBQUEsRUFBQUEsTUFBSkQsSUFBSUMsY0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7RUFUTkYsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQXhJQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyMjYxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OklPXG4gIHNlbGY6OlNFRUtfU0VUID0gMFxuICBzZWxmOjpTRUVLX0NVUiA9IDFcbiAgc2VsZjo6U0VFS19FTkQgPSAyXG4gIHNlbGY6OlNFRUtfREFUQSA9IDNcbiAgc2VsZjo6U0VFS19IT0xFID0gNFxuXG4gIHNlbGY6OlJFQURBQkxFID0gMVxuICBzZWxmOjpXUklUQUJMRSA9IDRcblxuICBhdHRyX3JlYWRlciA6ZW9mXG5cbiAgYXR0cl9hY2Nlc3NvciA6cmVhZF9wcm9jLCAgOnN5bmMsIDp0dHksIDp3cml0ZV9wcm9jXG5cbiAgZGVmIGluaXRpYWxpemUoZmQsIGZsYWdzID0gJ3InKVxuICAgIEBmZCA9IGZkXG4gICAgQGZsYWdzID0gZmxhZ3NcbiAgICBAZW9mID0gZmFsc2VcblxuICAgIGlmIGZsYWdzLmluY2x1ZGU/KCdyJykgJiYgIWZsYWdzLm1hdGNoPygvW3dhK10vKVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVsc2lmIGZsYWdzLm1hdGNoPygvW3dhXS8pICYmICFmbGFncy5tYXRjaD8oL1tyK10vKVxuICAgICAgQGNsb3NlZCA9IDpyZWFkXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBmaWxlbm9cbiAgICBAZmRcbiAgZW5kXG5cbiAgZGVmIHR0eT9cbiAgICBgc2VsZi50dHkgPT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIHdyaXRlKHN0cmluZylcbiAgICBgc2VsZi53cml0ZV9wcm9jKHN0cmluZylgXG4gICAgc3RyaW5nLnNpemVcbiAgZW5kXG5cbiAgZGVmIGZsdXNoXG4gICAgIyBub29wXG4gIGVuZFxuXG4gIGRlZiA8PChzdHJpbmcpXG4gICAgd3JpdGUoc3RyaW5nKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByaW50KCphcmdzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSAjezo6S2VybmVsLlN0cmluZyhgYXJnc1tpXWApfVxuICAgICAgfVxuICAgICAgc2VsZi4kd3JpdGUoYXJncy5qb2luKCN7JCx9KSk7XG4gICAgfVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHV0cygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBsaW5lXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3t3cml0ZSBcIlxcblwifTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGlmIChhcmdzW2ldLiQkaXNfYXJyYXkpe1xuICAgICAgICAgICAgdmFyIGFyeSA9ICN7YGFyZ3NbaV1gLmZsYXR0ZW59XG4gICAgICAgICAgICBpZiAoYXJ5Lmxlbmd0aCA+IDApICN7cHV0cygqYGFyeWApfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnc1tpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICBsaW5lID0gYXJnc1tpXS52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsaW5lID0gI3s6Oktlcm5lbC5TdHJpbmcoYGFyZ3NbaV1gKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxpbmUuZW5kc1dpdGgoXCJcXG5cIikpIGxpbmUgKz0gXCJcXG5cIlxuICAgICAgICAgICAgI3t3cml0ZSBgbGluZWB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcblxuICAjIFJlYWRpbmdcblxuICBkZWYgZ2V0Y1xuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBwYXJ0cyA9ICcnXG5cbiAgICAjIFdpbGwgZXhlY3VyZSBhdCBtb3N0IHR3aWNlIC0gb25lIHRpbWUgcmVhZGluZyBmcm9tIGEgYnVmZmVyXG4gICAgIyBzZWNvbmQgdGltZSBleGVjdXRpbmcgcmVhZCBwcm9jXG4gICAgYmVnaW5cbiAgICAgIEByZWFkX2J1ZmZlciArPSBwYXJ0c1xuICAgICAgaWYgQHJlYWRfYnVmZmVyICE9ICcnXG4gICAgICAgIHJldCA9IEByZWFkX2J1ZmZlclswXVxuICAgICAgICBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXJbMS4uLTFdXG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIGVuZFxuICAgIGVuZCB3aGlsZSBwYXJ0cyA9IHN5c3JlYWRfbm9yYWlzZSgxKVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBnZXRieXRlXG4gICAgZ2V0YyYub3JkXG4gIGVuZFxuXG4gIGRlZiByZWFkYnl0ZVxuICAgIHJlYWRjaGFyLm9yZFxuICBlbmRcblxuICBkZWYgcmVhZGNoYXJcbiAgICBnZXRjIHx8IDo6S2VybmVsLnJhaXNlKDo6RU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJylcbiAgZW5kXG5cbiAgZGVmIHJlYWRsaW5lKCphcmdzKVxuICAgIGdldHMoKmFyZ3MpIHx8IDo6S2VybmVsLnJhaXNlKDo6RU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJylcbiAgZW5kXG5cbiAgZGVmIGdldHMoc2VwID0gZmFsc2UsIGxpbWl0ID0gbmlsLCBvcHRzID0ge30pXG4gICAgaWYgYHNlcC4kJGlzX251bWJlcmAgJiYgIWxpbWl0XG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gZmFsc2UsIHNlcCwgbGltaXRcbiAgICBlbmRcbiAgICBpZiBgc2VwLiQkaXNfaGFzaGAgJiYgIWxpbWl0ICYmIG9wdHMgPT0ge31cbiAgICAgIHNlcCwgbGltaXQsIG9wdHMgPSBmYWxzZSwgbmlsLCBzZXBcbiAgICBlbHNpZiBgbGltaXQuJCRpc19oYXNoYCAmJiBvcHRzID09IHt9XG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gc2VwLCBuaWwsIGxpbWl0XG4gICAgZW5kXG5cbiAgICBvcmlnX3NlcCA9IHNlcFxuXG4gICAgc2VwID0gJC8gaWYgc2VwID09IGZhbHNlXG4gICAgc2VwID0gL1xccj9cXG5cXHI/XFxuLyBpZiBzZXAgPT0gJydcbiAgICBzZXAgfHw9ICcnXG4gICAgc2VwID0gc2VwLnRvX3N0ciB1bmxlc3Mgb3JpZ19zZXAgPT0gJydcblxuICAgICMgVHJ5IHRvIGRlZHVjZSBsZW5ndGggb2YgYSByZWdleHBcbiAgICBzZXBsZW4gPSBvcmlnX3NlcCA9PSAnJyA/IDIgOiBzZXAubGVuZ3RoXG5cbiAgICBzZXAgPSAvIC8gaWYgc2VwID09ICcgJyAjIFdURiBpcyB0aGlzLCBTdHJpbmcjc3BsaXQoXCIgXCIpIG1hdGNoZXMgYWxsIHdoaXRlc3BhY2VzPz8/XG5cbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgZGF0YSA9ICcnXG4gICAgcmV0ID0gbmlsXG5cbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IGRhdGFcbiAgICAgIGlmIHNlcCAhPSAnJyAmJiAoYHNlcC4kJGlzX3JlZ2V4cGAgPyBAcmVhZF9idWZmZXIubWF0Y2g/KHNlcCkgOiBAcmVhZF9idWZmZXIuaW5jbHVkZT8oc2VwKSlcbiAgICAgICAgb3JpZ19idWZmZXIgPSBAcmVhZF9idWZmZXJcbiAgICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIuc3BsaXQoc2VwLCAyKVxuICAgICAgICByZXQgKz0gb3JpZ19idWZmZXJbcmV0Lmxlbmd0aCwgc2VwbGVuXSBpZiByZXQgIT0gb3JpZ19idWZmZXJcbiAgICAgICAgYnJlYWtcbiAgICAgIGVuZFxuICAgIGVuZCB3aGlsZSBkYXRhID0gc3lzcmVhZF9ub3JhaXNlKHNlcCA9PSAnJyA/IDY1XzUzNiA6IDEpXG5cbiAgICB1bmxlc3MgcmV0XG4gICAgICByZXQsIEByZWFkX2J1ZmZlciA9IChAcmVhZF9idWZmZXIgfHwgJycpLCAnJ1xuICAgICAgcmV0ID0gbmlsIGlmIHJldCA9PSAnJ1xuICAgIGVuZFxuXG4gICAgaWYgcmV0XG4gICAgICBpZiBsaW1pdFxuICAgICAgICByZXQgPSByZXRbMC4uLmxpbWl0XVxuICAgICAgICBAcmVhZF9idWZmZXIgPSByZXRbbGltaXQuLi0xXSArIEByZWFkX2J1ZmZlclxuICAgICAgZW5kXG4gICAgICByZXQgPSByZXQuc3ViKC9cXHI/XFxuXFx6LywgJycpIGlmIG9wdHNbOmNob21wXVxuICAgICAgcmV0ID0gcmV0LnN1YigvXFxBW1xcclxcbl0rLywgJycpIGlmIG9yaWdfc2VwID09ICcnXG4gICAgZW5kXG5cbiAgICAkXyA9IHJldCBpZiBvcmlnX3NlcCA9PSBmYWxzZVxuICAgIHJldFxuICBlbmRcblxuICAjIFRoaXMgbWV0aG9kIGlzIHRvIGJlIG92ZXJsb2FkZWQsIG9yIHJlYWRfcHJvYyBjYW4gYmUgY2hhbmdlZFxuICBkZWYgc3lzcmVhZChpbnRlZ2VyKVxuICAgIGBzZWxmLnJlYWRfcHJvYyhpbnRlZ2VyKWAgfHwgYmVnaW5cbiAgICAgIEBlb2YgPSB0cnVlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkVPRkVycm9yLCAnZW5kIG9mIGZpbGUgcmVhY2hlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgc3lzcmVhZF9ub3JhaXNlKGludGVnZXIpXG4gICAgc3lzcmVhZChpbnRlZ2VyKVxuICByZXNjdWUgOjpFT0ZFcnJvclxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcmVhZHBhcnRpYWwoaW50ZWdlcilcbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgcGFydCA9IHN5c3JlYWQoaW50ZWdlcilcbiAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlciArIChwYXJ0IHx8ICcnKSwgJydcbiAgICByZXQgPSBuaWwgaWYgcmV0ID09ICcnXG4gICAgcmV0XG4gIGVuZFxuXG4gIGRlZiByZWFkKGludGVnZXIgPSBuaWwpXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xuICAgIHBhcnRzID0gJydcbiAgICByZXQgPSBuaWxcblxuICAgIGJlZ2luXG4gICAgICBAcmVhZF9idWZmZXIgKz0gcGFydHNcbiAgICAgIGlmIGludGVnZXIgJiYgQHJlYWRfYnVmZmVyLmxlbmd0aCA+IGludGVnZXJcbiAgICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXJbMC4uLmludGVnZXJdLCBAcmVhZF9idWZmZXJbaW50ZWdlci4uLTFdXG4gICAgICAgIHJldHVybiByZXRcbiAgICAgIGVuZFxuICAgIGVuZCB3aGlsZSBwYXJ0cyA9IHN5c3JlYWRfbm9yYWlzZShpbnRlZ2VyIHx8IDY1XzUzNilcblxuICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyLCAnJ1xuICAgIHJldFxuICBlbmRcblxuICAjIEVhY2hlc1xuXG4gIGRlZiByZWFkbGluZXMoc2VwYXJhdG9yID0gJC8pXG4gICAgZWFjaF9saW5lKHNlcGFyYXRvcikudG9fYVxuICBlbmRcblxuICBkZWYgZWFjaChzZXAgPSAkLywgKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2gsIHNlcCwgKmFyZ3MgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgKHMgPSBnZXRzKHNlcCwgKmFyZ3MpKVxuICAgICAgeWllbGQocylcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2J5dGUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgKHMgPSBnZXRieXRlKVxuICAgICAgeWllbGQocylcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2NoYXIgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgKHMgPSBnZXRjKVxuICAgICAgeWllbGQocylcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBDbG9zZWRuZXNzXG5cbiAgZGVmIGNsb3NlXG4gICAgQGNsb3NlZCA9IDpib3RoXG4gIGVuZFxuXG4gIGRlZiBjbG9zZV9yZWFkXG4gICAgaWYgQGNsb3NlZCA9PSA6d3JpdGVcbiAgICAgIEBjbG9zZWQgPSA6Ym90aFxuICAgIGVsc2VcbiAgICAgIEBjbG9zZWQgPSA6cmVhZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2Vfd3JpdGVcbiAgICBpZiBAY2xvc2VkID09IDpyZWFkXG4gICAgICBAY2xvc2VkID0gOmJvdGhcbiAgICBlbHNlXG4gICAgICBAY2xvc2VkID0gOndyaXRlXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjbG9zZWQ/XG4gICAgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VkX3JlYWQ/XG4gICAgQGNsb3NlZCA9PSA6cmVhZCB8fCBAY2xvc2VkID09IDpib3RoXG4gIGVuZFxuXG4gIGRlZiBjbG9zZWRfd3JpdGU/XG4gICAgQGNsb3NlZCA9PSA6d3JpdGUgfHwgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBjaGVja193cml0YWJsZVxuICAgIGlmIGNsb3NlZF93cml0ZT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6SU9FcnJvciwgJ25vdCBvcGVuZWQgZm9yIHdyaXRpbmcnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIGNoZWNrX3JlYWRhYmxlXG4gICAgaWYgY2xvc2VkX3JlYWQ/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OklPRXJyb3IsICdub3Qgb3BlbmVkIGZvciByZWFkaW5nJ1xuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBlYWNoX2xpbmUgZWFjaFxuICBhbGlhcyBlb2Y/IGVvZlxuZW5kXG5cbjo6U1RESU4gID0gJHN0ZGluICA9IDo6SU8ubmV3KDAsICdyJylcbjo6U1RET1VUID0gJHN0ZG91dCA9IDo6SU8ubmV3KDEsICd3Jylcbjo6U1RERVJSID0gJHN0ZGVyciA9IDo6SU8ubmV3KDIsICd3JylcblxuYHZhciBjb25zb2xlID0gT3BhbC5nbG9iYWwuY29uc29sZWBcbjo6U1RET1VULndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRvdXQpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3Rkb3V0LndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUubG9nKHMpfWBcbjo6U1RERVJSLndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRlcnIpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3RkZXJyLndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUud2FybihzKX1gXG5cbjo6U1RESU4ucmVhZF9wcm9jID0gYGZ1bmN0aW9uKHMpIHsgdmFyIHAgPSBwcm9tcHQoKTsgaWYgKHAgIT09IG51bGwpIHJldHVybiBwICsgXCJcXG5cIjsgcmV0dXJuIG5pbDsgfWBcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOklPPiIsInNlbGYiLCIwIiwiMSIsIjIiLCIzIiwiNCIsImF0dHJfcmVhZGVyIiwiYXR0cl9hY2Nlc3NvciIsImluaXRpYWxpemUiLCJmZCIsImZsYWdzIiwiQGZkIiwiQGZsYWdzIiwiQGVvZiIsImluY2x1ZGU/IiwibWF0Y2g/IiwiQGNsb3NlZCIsImZpbGVubyIsInR0eT8iLCJ3cml0ZSIsInN0cmluZyIsInNpemUiLCJmbHVzaCIsIjw8IiwicHJpbnQiLCJLZXJuZWwiLCJTdHJpbmciLCIkLCIsInB1dHMiLCJmbGF0dGVuIiwiZ2V0YyIsIkByZWFkX2J1ZmZlciIsIiRyZXRfb3JfMSIsInBhcnRzIiwiKyIsInJldCIsIltdIiwiLTEiLCJzeXNyZWFkX25vcmFpc2UiLCJnZXRieXRlIiwicmVhZGJ5dGUiLCJyZWFkY2hhciIsIm9yZCIsInJhaXNlIiwiRU9GRXJyb3IiLCJyZWFkbGluZSIsImdldHMiLCJhcmdzIiwic2VwIiwibGltaXQiLCJvcHRzIiwib3JpZ19zZXAiLCIkLyIsInRvX3N0ciIsInNlcGxlbiIsImxlbmd0aCIsImRhdGEiLCJvcmlnX2J1ZmZlciIsInNwbGl0IiwiNjU1MzYiLCJzdWIiLCIkXyIsInN5c3JlYWQiLCJpbnRlZ2VyIiwicmVhZHBhcnRpYWwiLCJwYXJ0IiwicmVhZCIsIj4iLCJyZWFkbGluZXMiLCJzZXBhcmF0b3IiLCJlYWNoX2xpbmUiLCJ0b19hIiwiZWFjaCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwicyIsImVhY2hfYnl0ZSIsImVhY2hfY2hhciIsImNsb3NlIiwiY2xvc2VfcmVhZCIsImNsb3NlX3dyaXRlIiwiY2xvc2VkPyIsIj09IiwiY2xvc2VkX3JlYWQ/IiwiY2xvc2VkX3dyaXRlPyIsImNoZWNrX3dyaXRhYmxlIiwiSU9FcnJvciIsImNoZWNrX3JlYWRhYmxlIiwiJHN0ZGluIiwiSU8iLCJuZXciLCIkc3Rkb3V0IiwiJHN0ZGVyciIsIlNURE9VVCIsIndyaXRlX3Byb2M9IiwiU1RERVJSIiwicmVhZF9wcm9jPSIsIlNURElOIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0UsV0FBQUMsSUFBQSxjQUFpQkMsQ0FBakI7SUFDQSxXQUFBRCxJQUFBLGNBQWlCRSxDQUFqQjtJQUNBLFdBQUFGLElBQUEsY0FBaUJHLENBQWpCO0lBQ0EsV0FBQUgsSUFBQSxlQUFrQkksQ0FBbEI7SUFDQSxXQUFBSixJQUFBLGVBQWtCSyxDQUFsQjtJQUVBLFdBQUFMLElBQUEsY0FBaUJFLENBQWpCO0lBQ0EsV0FBQUYsSUFBQSxjQUFpQkssQ0FBakI7SUFFQUwsSUFBQU0sYUFBQUEsQ0FBWSxLQUFaQTtJQUVBTixJQUFBTyxlQUFBQSxDQUFjLFdBQWQsRUFBMkIsTUFBM0IsRUFBa0MsS0FBbEMsRUFBd0MsWUFBeENBOztBQUVBQyxJQUFBQSwwQkFBQUEsc0JBQWVDLEVBQUQsRUFBS0MsS0FBbkJGO0FBQUFBLE1BQUFBOzs7TUFBbUIsMkJBQVFBO01BQ3pCRyxVQUFNRjtNQUNORyxhQUFTRjtNQUNURyxXQUFPO01BRVAsSUFBRyxDQUFBLFFBQUFILEtBQUtJLGFBQUFBLENBQVVOLEdBQVZNLENBQUwsQ0FBQSxJQUFBLENBQUEsS0FBd0JKLEtBQUtLLFdBQUFBLENBQVEsT0FBUkEsQ0FBN0IsQ0FBQSxDQUFBLENBQUg7UUFDRVAsT0FBQVEsQ0FBQUEsY0FBVSxPQUFWQTtNQURGLE9BRUEsSUFBTSxDQUFBLFFBQUFOLEtBQUtLLFdBQUFBLENBQVEsTUFBUkEsQ0FBTCxDQUFBLElBQUEsQ0FBQSxLQUF5QkwsS0FBS0ssV0FBQUEsQ0FBUSxNQUFSQSxDQUE5QixDQUFBLENBQUEsQ0FBTjtRQUNFUCxPQUFBUSxDQUFBQSxjQUFVLE1BQVZBO01BREY7UUFyQkpSLE9BQUE7TUFxQkk7SUFQRkEsQ0FBQUEsSUFBQUE7O0FBWUFTLElBQUFBLHNCQUFBQSxh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Q0FBS3pGLENBQVQsRUFBWUgsR0FBUjRGLENBQWRGLENBQVg7RUFDQSxXQUFBLElBQUEsWUFBV0csQ0FBQUEsZ0JBQVVGLFNBQUlDLEtBQUFBLENBQUt4RixDQUFULEVBQVlKLEdBQVI0RixDQUFkQyxDQUFYO0VBQ0EsV0FBQSxJQUFBLFlBQVdDLENBQUFBLGdCQUFVSCxTQUFJQyxLQUFBQSxDQUFLdkYsQ0FBVCxFQUFZTCxHQUFSNEYsQ0FBZEUsQ0FBWDtFQUVDOUY7RUFDRCtGLGFBQVFDLGdCQUFBQSxDQUFlaEcsd0lBQWZnRztFQUNSQyxhQUFRRCxnQkFBQUEsQ0FBZWhHLHlJQUFmZ0c7RUFFUmhHLE9BQU9rRyxNQUFBQSxDQUFjbEcsOEVBQWRrRyxDQUFBQSxFQUFBQSxNQUFQQyxZQUFPRCxjQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtBQXRUUGxHOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjY5OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaGFzaC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHlpZWxkMSwgaGFzaCwgaGFzaF9pbml0LCBoYXNoX2dldCwgaGFzaF9wdXQsIGhhc2hfZGVsZXRlLCBkZW55X2Zyb3plbl9hY2Nlc3MsIGZyZWV6ZVxuXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbiMgLS0tXG4jIEludGVybmFsIHByb3BlcnRpZXM6XG4jXG4jIC0gJCRtYXAgICAgICAgICBbSlM6Ok9iamVjdDxTdHJpbmcgPT4gaGFzaC1idWNrZXQ+XSB0aGUgaGFzaCB0YWJsZSBmb3Igb3JkaW5hcnkga2V5c1xuIyAtICQkc21hcCAgICAgICAgW0pTOjpPYmplY3Q8U3RyaW5nID0+IGhhc2gtYnVja2V0Pl0gdGhlIGhhc2ggdGFibGUgZm9yIHN0cmluZyBrZXlzXG4jIC0gJCRrZXlzICAgICAgICBbQXJyYXk8aGFzaC1idWNrZXQ+XSB0aGUgbGlzdCBvZiBhbGwga2V5c1xuIyAtICQkcHJvYyAgICAgICAgW1Byb2MsbnVsbCxuaWxdIHRoZSBkZWZhdWx0IHByb2MgdXNlZCBmb3IgbWlzc2luZyBrZXlzXG4jIC0gaGFzaC1idWNrZXQgICBbSlM6Ok9iamVjdF0gYW4gZWxlbWVudCBvZiBhIGxpbmtlZCBsaXN0IHRoYXQgaG9sZHMgaGFzaCB2YWx1ZXMsIGtleXMgYXJlIGB7a2V5OixrZXlfaGFzaDosdmFsdWU6LG5leHQ6fWBcbmNsYXNzIDo6SGFzaFxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgaGFzaCBpbnN0YW5jZXMgYXMgdmFsaWQgaGFzaGVzICh1c2VkIHRvIGNoZWNrIGtleXdvcmQgYXJncywgZXRjKVxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2hhc2ggPSB0cnVlYFxuXG4gIGRlZiBzZWxmLltdKCphcmd2KVxuICAgICV4e1xuICAgICAgdmFyIGhhc2gsIGFyZ2MgPSBhcmd2Lmxlbmd0aCwgaTtcblxuICAgICAgaWYgKGFyZ2MgPT09IDEpIHtcbiAgICAgICAgaGFzaCA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYXJndlswXSwgOjpIYXNoLCA6dG9faGFzaCl9O1xuICAgICAgICBpZiAoaGFzaCAhPT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuICN7YWxsb2NhdGUubWVyZ2UhKGBoYXNoYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgYXJndiA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYXJndlswXSwgOjpBcnJheSwgOnRvX2FyeSl9O1xuICAgICAgICBpZiAoYXJndiA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCd9XG4gICAgICAgIH1cblxuICAgICAgICBhcmdjID0gYXJndi5sZW5ndGg7XG4gICAgICAgIGhhc2ggPSAje2FsbG9jYXRlfTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFhcmd2W2ldLiQkaXNfYXJyYXkpIGNvbnRpbnVlO1xuICAgICAgICAgIHN3aXRjaChhcmd2W2ldLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIG5pbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldWzBdLCBhcmd2W2ldWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyAoI3tgYXJndltpXS5sZW5ndGhgfSBmb3IgMS4uMilcIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ2MgJSAyICE9PSAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnb2RkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIEhhc2gnfVxuICAgICAgfVxuXG4gICAgICBoYXNoID0gI3thbGxvY2F0ZX07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpICs9IDIpIHtcbiAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXSwgYXJndltpICsgMV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3IoKTtcblxuICAgICAgJGhhc2hfaW5pdChoYXNoKTtcblxuICAgICAgaGFzaC4kJG5vbmUgPSBuaWw7XG4gICAgICBoYXNoLiQkcHJvYyA9IG5pbDtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmopXG4gICAgOjpPcGFsLmNvZXJjZV90bz8ob2JqLCA6Okhhc2gsIDp0b19oYXNoKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgaWYgKGRlZmF1bHRzICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDApJ31cbiAgICAgIH1cbiAgICAgIHNlbGYuJCRub25lID0gKGRlZmF1bHRzID09PSB1bmRlZmluZWQgPyBuaWwgOiBkZWZhdWx0cyk7XG4gICAgICBzZWxmLiQkcHJvYyA9IGJsb2NrO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvdGhlci4kJGlzX2hhc2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoICE9PSBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSAkaGFzaF9nZXQob3RoZXIsIGtleS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG90aGVyX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgIXZhbHVlWyckZXFsPyddKG90aGVyX3ZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoIDwgb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQgPSB0cnVlXG5cbiAgICBvdGhlci5lYWNoIGRvIHxvdGhlcl9rZXksIG90aGVyX3ZhbHxcbiAgICAgIHZhbCA9IGZldGNoKG90aGVyX2tleSwgYG51bGxgKVxuXG4gICAgICAleHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8IHZhbCAhPT0gb3RoZXJfdmFsKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRrZXlzLmxlbmd0aCA8PSBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYgPj0gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+IHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIG90aGVyID0gOjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SGFzaCwgOnRvX2hhc2gpXG4gICAgb3RoZXIgPj0gc2VsZlxuICBlbmRcblxuICBkZWYgW10oa2V5KVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGRlZmF1bHQoa2V5KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgaWYgKCN7YGtleWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIHNlbGYuJCRzbWFwW2tleV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoI3tga2V5LmtleWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgcmV0dXJuIFtrZXkua2V5LCBrZXkudmFsdWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsZWFyXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICAkaGFzaF9pbml0KHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IHNlbGYuJCRjbGFzcygpO1xuXG4gICAgICAkaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3QhXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgY2hhbmdlc193ZXJlX21hZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIGksIGlpLCBrZXksIGtleXMgPSBzZWxmLiQka2V5cywgaWRlbnRpdHlfaGFzaDtcblxuICAgICAgaWYgKHNlbGYuJCRieV9pZGVudGl0eSkgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlkZW50aXR5X2hhc2ggPSAjeyB7fS5jb21wYXJlX2J5X2lkZW50aXR5IH07XG4gICAgICBmb3IoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICgha2V5LiQkaXNfc3RyaW5nKSBrZXkgPSBrZXkua2V5O1xuICAgICAgICAkaGFzaF9wdXQoaWRlbnRpdHlfaGFzaCwga2V5LCAkaGFzaF9nZXQoc2VsZiwga2V5KSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWU7XG4gICAgICBzZWxmLiQkbWFwID0gaWRlbnRpdHlfaGFzaC4kJG1hcDtcbiAgICAgIHNlbGYuJCRzbWFwID0gaWRlbnRpdHlfaGFzaC4kJHNtYXA7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYXJlX2J5X2lkZW50aXR5P1xuICAgIGBzZWxmLiQkYnlfaWRlbnRpdHkgPT09IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0KGtleSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCAmJiBzZWxmLiQkcHJvYyAhPT0gbmlsICYmIHNlbGYuJCRwcm9jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRwcm9jLiRjYWxsKHNlbGYsIGtleSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi4kJG5vbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRub25lO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQ9KG9iamVjdClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHNlbGYuJCRwcm9jID0gbmlsO1xuICAgICAgc2VsZi4kJG5vbmUgPSBvYmplY3Q7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2M7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHRfcHJvYz0oZGVmYXVsdF9wcm9jKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHByb2MgPSBkZWZhdWx0X3Byb2M7XG5cbiAgICAgIGlmIChwcm9jICE9PSBuaWwpIHtcbiAgICAgICAgcHJvYyA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHByb2NgLCA6OlByb2MsIDp0b19wcm9jKX07XG5cbiAgICAgICAgaWYgKCN7YHByb2NgLmxhbWJkYT99ICYmICN7YHByb2NgLmFyaXR5LmFic30gIT09IDIpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnZGVmYXVsdF9wcm9jIHRha2VzIHR3byBhcmd1bWVudHMnfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiQkbm9uZSA9IG5pbDtcbiAgICAgIHNlbGYuJCRwcm9jID0gcHJvYztcblxuICAgICAgcmV0dXJuIGRlZmF1bHRfcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGUoa2V5LCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuICAgICAgdmFyIHZhbHVlID0gJGhhc2hfZGVsZXRlKHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuICN7eWllbGQga2V5fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBzZWxmW2tleV1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcbiAgICBlbmRcblxuICAgIGl0ZW0uZGlnKCprZXlzKVxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cy5zbGljZSgpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgJHlpZWxkMShibG9jaywgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9rZXkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9rZXkpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLnNsaWNlKCksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGJsb2NrKGtleS4kJGlzX3N0cmluZyA/IGtleSA6IGtleS5rZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX3ZhbHVlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfdmFsdWUpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLnNsaWNlKCksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGJsb2NrKGtleS4kJGlzX3N0cmluZyA/IHNlbGYuJCRzbWFwW2tleV0gOiBrZXkudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlbXB0eT9cbiAgICBgc2VsZi4kJGtleXMubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZXhjZXB0KCprZXlzKVxuICAgIGR1cC5leGNlcHQhKCprZXlzKVxuICBlbmRcblxuICBkZWYgZXhjZXB0ISgqa2V5cylcbiAgICBrZXlzLmVhY2ggeyB8a2V5fCBkZWxldGUoa2V5KSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmV0Y2goa2V5LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICA6Oktlcm5lbC5yYWlzZSA6OktleUVycm9yLm5ldyhcImtleSBub3QgZm91bmQ6ICN7a2V5Lmluc3BlY3R9XCIsIGtleToga2V5LCByZWNlaXZlcjogc2VsZilcbiAgZW5kXG5cbiAgZGVmIGZldGNoX3ZhbHVlcygqa2V5cywgJmJsb2NrKVxuICAgIGtleXMubWFwIHsgfGtleXwgZmV0Y2goa2V5LCAmYmxvY2spIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSAxKVxuICAgIGxldmVsID0gOjpPcGFsLmNvZXJjZV90byEobGV2ZWwsIDo6SW50ZWdlciwgOnRvX2ludClcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcblxuICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCgje2B2YWx1ZWAuZmxhdHRlbihgbGV2ZWwgLSAyYCl9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XG5cbiAgICBgJGZyZWV6ZShzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGhhc19rZXk/KGtleSlcbiAgICBgJGhhc2hfZ2V0KHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZGBcbiAgZW5kXG5cbiAgZGVmIGhhc192YWx1ZT8odmFsdWUpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoI3tgKGtleS4kJGlzX3N0cmluZyA/IHNlbGYuJCRzbWFwW2tleV0gOiBrZXkudmFsdWUpYCA9PSB2YWx1ZX0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9IChPcGFsLmhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICByZXN1bHQgPSBbJ0hhc2gnXSxcbiAgICAgICAgICBrZXksIGl0ZW07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBPcGFsLmhhc2hfaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPcGFsW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIE9wYWwuaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gT3BhbC5oYXNoX2lkc1trZXldO1xuICAgICAgICAgIGlmICgje2VxbD8oYGl0ZW1gKX0pIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC5oYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LCBzZWxmLiQkc21hcFtrZXldLiRoYXNoKCldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2tleS5rZXlfaGFzaCwga2V5LnZhbHVlLiRoYXNoKCldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKS5qb2luKCk7XG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBPcGFsLmhhc2hfaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXgob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleGVzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBhcmdzW2ldO1xuICAgICAgICB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tkZWZhdWx0fSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBgdmFyIGluc3BlY3RfaWRzYFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKGluc3BlY3RfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICB9XG5cbiAgICBiZWdpblxuICAgICAgJXh7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBpbnNwZWN0X2lkcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3BlY3RfaWRzLmhhc093blByb3BlcnR5KGhhc2hfaWQpKSB7XG4gICAgICAgICAgcmV0dXJuICd7Li4ufSc7XG4gICAgICAgIH1cblxuICAgICAgICBpbnNwZWN0X2lkc1toYXNoX2lkXSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXkgPSAje09wYWwuaW5zcGVjdChga2V5YCl9XG4gICAgICAgICAgdmFsdWUgPSAje09wYWwuaW5zcGVjdChgdmFsdWVgKX1cblxuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSArICc9PicgKyB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnfSc7XG4gICAgICB9XG4gICAgICBuaWxcbiAgICBlbnN1cmVcbiAgICAgIGBpZiAodG9wKSBpbnNwZWN0X2lkcyA9IHVuZGVmaW5lZGBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGludmVydFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAkaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIHZhbHVlLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgIGlmICgkaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYga2V5c1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLiQka2V5cy5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSgqb3RoZXJzLCAmYmxvY2spXG4gICAgZHVwLm1lcmdlISgqb3RoZXJzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSEoKm90aGVycywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcbiAgICAgIHZhciBpLCBqLCBvdGhlciwgb3RoZXJfa2V5cywgbGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBvdGhlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgb3RoZXIgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBvdGhlcnNbaV1gLCA6Okhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgb3RoZXJfdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGtleSA9IG90aGVyX2tleXNbal07XG5cbiAgICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCBibG9jayhrZXksIHZhbHVlLCBvdGhlcl92YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWhhc2hcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG4gICAgICBPcGFsLmhhc2hfcmVoYXNoKHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIGNoYW5nZXNfd2VyZV9tYWRlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7YFxuXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcblxuICAgICV4e1xuICAgICAgJGhhc2hfaW5pdChzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IG90aGVyX2tleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBvdGhlci5kZWZhdWx0X3Byb2NcbiAgICAgIHNlbGYuZGVmYXVsdF9wcm9jID0gb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgZWxzZVxuICAgICAgc2VsZi5kZWZhdWx0ID0gb3RoZXIuZGVmYXVsdFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gJGhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IG5pbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcbiAgICAgIHZhciBrZXlzID0gc2VsZi4kJGtleXMsXG4gICAgICAgICAga2V5O1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGtleSA9IGtleXNbMF07XG5cbiAgICAgICAga2V5ID0ga2V5LiQkaXNfc3RyaW5nID8ga2V5IDoga2V5LmtleTtcblxuICAgICAgICByZXR1cm4gW2tleSwgJGhhc2hfZGVsZXRlKHNlbGYsIGtleSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChuaWwpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNsaWNlKCprZXlzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLCB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2goJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGNsYXNzID09PSBPcGFsLkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgICAkaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19oYXNoXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHByb2MgZG8gfGtleSA9IHVuZGVmaW5lZHxcbiAgICAgICV4e1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGtleSBnaXZlbid9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZltrZXldXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fa2V5cygmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fa2V5cykgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAkaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gJHlpZWxkMShibG9jaywga2V5KTtcblxuICAgICAgICAkaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fa2V5cyEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIGtleXMgPSBPcGFsLnNsaWNlLmNhbGwoc2VsZi4kJGtleXMpLFxuICAgICAgICAgIGksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBuZXdfa2V5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdfa2V5ID0gJHlpZWxkMShibG9jaywga2V5KTtcblxuICAgICAgICAkaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcbiAgICAgICAgJGhhc2hfcHV0KHNlbGYsIG5ld19rZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX3ZhbHVlcygmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fdmFsdWVzKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICRoYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICAkaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fdmFsdWVzISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fdmFsdWVzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHZhbHVlc1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi4kJHNtYXBba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHVwIGNsb25lXG4gIGFsaWFzIGVhY2hfcGFpciBlYWNoXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgZmlsdGVyIHNlbGVjdFxuICBhbGlhcyBmaWx0ZXIhIHNlbGVjdCFcbiAgYWxpYXMgaW5jbHVkZT8gaGFzX2tleT9cbiAgYWxpYXMgaW5kaWNlcyBpbmRleGVzXG4gIGFsaWFzIGtleSBpbmRleFxuICBhbGlhcyBrZXk/IGhhc19rZXk/XG4gIGFsaWFzIG1lbWJlcj8gaGFzX2tleT9cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcbiAgYWxpYXMgc3RvcmUgW109XG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuICBhbGlhcyB1cGRhdGUgbWVyZ2UhXG4gIGFsaWFzIHZhbHVlPyBoYXNfdmFsdWU/XG4gIGFsaWFzIHZhbHVlc19hdCBpbmRleGVzXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6SGFzaD4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIltdIiwiT3BhbCIsImNvZXJjZV90bz8iLCJhcmd2IiwiMCIsIkhhc2giLCJhbGxvY2F0ZSIsIm1lcmdlISIsIkFycmF5IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwidHJ5X2NvbnZlcnQiLCJvYmoiLCJpbml0aWFsaXplIiwiZGVmYXVsdHMiLCI9PSIsIm90aGVyIiwiPj0iLCJjb2VyY2VfdG8hIiwicmVzdWx0IiwiZWFjaCIsImJsb2NrIGluID49Iiwib3RoZXJfa2V5Iiwib3RoZXJfdmFsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA+PSIsInZhbCIsImZldGNoIiwiPiIsIjwiLCI8PSIsImtleSIsIltdPSIsInZhbHVlIiwiYXNzb2MiLCJvYmplY3QiLCJjbGVhciIsImNsb25lIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29tcGFyZV9ieV9pZGVudGl0eSIsImNvbXBhcmVfYnlfaWRlbnRpdHk/IiwiZGVmYXVsdCIsImRlZmF1bHQ9IiwiZGVmYXVsdF9wcm9jIiwiZGVmYXVsdF9wcm9jPSIsIlByb2MiLCJsYW1iZGE/IiwiYXJpdHkiLCJhYnMiLCJUeXBlRXJyb3IiLCJkZWxldGUiLCJkZWxldGVfaWYiLCJibG9jayIsImVudW1fZm9yIiwiYmxvY2sgaW4gZGVsZXRlX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGVfaWYiLCJzaXplIiwiZGlnIiwiaXRlbSIsInJlc3BvbmRfdG8/IiwiY2xhc3MiLCJrZXlzIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsImVhY2hfa2V5IiwiYmxvY2sgaW4gZWFjaF9rZXkiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfa2V5IiwiZWFjaF92YWx1ZSIsImJsb2NrIGluIGVhY2hfdmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfdmFsdWUiLCJlbXB0eT8iLCJleGNlcHQiLCJleGNlcHQhIiwiZHVwIiwiYmxvY2sgaW4gZXhjZXB0ISIsImJsb2NrICgyIGxldmVscykgaW4gZXhjZXB0ISIsIktleUVycm9yIiwibmV3IiwiaW5zcGVjdCIsImZldGNoX3ZhbHVlcyIsIm1hcCIsImJsb2NrIGluIGZldGNoX3ZhbHVlcyIsImJsb2NrICgyIGxldmVscykgaW4gZmV0Y2hfdmFsdWVzIiwidG9fcHJvYyIsImZsYXR0ZW4iLCJsZXZlbCIsIjEiLCJJbnRlZ2VyIiwiZnJlZXplIiwiZnJvemVuPyIsImhhc19rZXk/IiwiaGFzX3ZhbHVlPyIsImhhc2giLCJlcWw/IiwiaW5kZXgiLCJpbmRleGVzIiwiaW52ZXJ0Iiwia2VlcF9pZiIsImJsb2NrIGluIGtlZXBfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGtlZXBfaWYiLCJsZW5ndGgiLCJtZXJnZSIsIm90aGVycyIsInJhc3NvYyIsInJlaGFzaCIsInJlamVjdCIsImJsb2NrIGluIHJlamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0IiwicmVqZWN0ISIsImJsb2NrIGluIHJlamVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCEiLCJyZXBsYWNlIiwic2VsZWN0IiwiYmxvY2sgaW4gc2VsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QiLCJzZWxlY3QhIiwiYmxvY2sgaW4gc2VsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0ISIsInNoaWZ0Iiwic2xpY2UiLCJ0b19hIiwidG9faCIsImJsb2NrX2dpdmVuPyIsInRvX2hhc2giLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInRyYW5zZm9ybV9rZXlzIiwiYmxvY2sgaW4gdHJhbnNmb3JtX2tleXMiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV9rZXlzIiwidHJhbnNmb3JtX2tleXMhIiwiYmxvY2sgaW4gdHJhbnNmb3JtX2tleXMhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fa2V5cyEiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwiYmxvY2sgaW4gdHJhbnNmb3JtX3ZhbHVlcyIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX3ZhbHVlcyIsInRyYW5zZm9ybV92YWx1ZXMhIiwiYmxvY2sgaW4gdHJhbnNmb3JtX3ZhbHVlcyEiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV92YWx1ZXMhIiwidmFsdWVzIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQVVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxpQkFBUkQ7SUFHQ0Q7SUFFREcsTUFBSUwsSUFBSkssU0FBQUEsb0JBbEJGLEVBa0JFQTtBQUFBQSxNQUFBQTs7O01BbEJGO01Ba0JjOztBQUVkQTs7QUFFQUE7QUFDQUEsZUFBaUJDLEtBQU1DLGVBQUFBLENBQVlDLElBQUlILE9BQUFBLENBQUNJLENBQURKLENBQXRCLEVBQTJCSyxXQUEzQixFQUFtQyxTQUE3QkgsQ0FBdUNGO0FBQzlEQTtBQUNBQSxpQkFBbUJMLElBQUFXLFVBQUFBLENBQUFBLENBQVFDLFdBQUFBLENBQVNQLElBQVRPLENBQWdCUDtBQUMzQ0E7O0FBRUFBLGVBQWlCQyxLQUFNQyxlQUFBQSxDQUFZQyxJQUFJSCxPQUFBQSxDQUFDSSxDQUFESixDQUF0QixFQUEyQlEsWUFBM0IsRUFBb0MsUUFBOUJOLENBQXVDRjtBQUM5REE7QUFDQUEsVUFBWVMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NYLGtDQUF4QlU7QUFDcEJWOztBQUVBQTtBQUNBQSxlQUFpQkwsSUFBQVcsVUFBQUEsQ0FBQUEsQ0FBU047O0FBRTFCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxZQUFjUyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFpQ1gs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QUFOLEVBQVUsT0FBVjtJQUNBLGFBQU0sTUFBTixFQUFXLFVBQVg7SUFDQSxhQUFNLFNBQU4sRUFBYyxVQUFkO0lBQ0EsYUFBTSxNQUFOLEVBQVcsUUFBWDtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsUUFBYjtJQUNBLGFBQU0sUUFBTixFQUFhLFlBQWI7SUFDQS9JLE9BQUEsYUFBTSxXQUFOLEVBQWdCLFNBQWhCO0VBaHRDRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQVpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTQxOTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgOjpSYW5nZVxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfcmFuZ2UgPSB0cnVlYFxuXG4gIGF0dHJfcmVhZGVyIDpiZWdpbiwgOmVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGZpcnN0LCBsYXN0LCBleGNsdWRlID0gZmFsc2UpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwiJ2luaXRpYWxpemUnIGNhbGxlZCB0d2ljZVwiIGlmIEBiZWdpblxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2JhZCB2YWx1ZSBmb3IgcmFuZ2UnIHVubGVzcyBmaXJzdCA8PT4gbGFzdCB8fCBmaXJzdC5uaWw/IHx8IGxhc3QubmlsP1xuXG4gICAgQGJlZ2luID0gZmlyc3RcbiAgICBAZW5kICAgPSBsYXN0XG4gICAgQGV4Y2wgID0gZXhjbHVkZVxuICBlbmRcblxuICBkZWYgPT09KHZhbHVlKVxuICAgIGluY2x1ZGU/IHZhbHVlXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGlzX2luZmluaXRlKHNlbGYpIHtcbiAgICAgIGlmIChzZWxmLmJlZ2luID09PSBuaWwgfHwgc2VsZi5lbmQgPT09IG5pbCB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IC1JbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICBzZWxmLmJlZ2luID09PSBJbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gLUluZmluaXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkZWYgY291bnQoJmJsb2NrKVxuICAgIGlmICFibG9ja19naXZlbj8gJiYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgICAgcmV0dXJuIDo6RmxvYXQ6OklORklOSVRZXG4gICAgZW5kXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2Nhbm5vdCBjb252ZXJ0IGVuZGxlc3MgcmFuZ2UgdG8gYW4gYXJyYXknIGlmIGBpc19pbmZpbml0ZShzZWxmKWBcbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgY292ZXI/KHZhbHVlKVxuICAgIGJlZ19jbXAgPSAoQGJlZ2luLm5pbD8gJiYgLTEpIHx8IChAYmVnaW4gPD0+IHZhbHVlKSB8fCBmYWxzZVxuICAgIGVuZF9jbXAgPSAoQGVuZC5uaWw/ICYmIC0xKSB8fCAodmFsdWUgPD0+IEBlbmQpIHx8IGZhbHNlXG4gICAgaWYgQGV4Y2xcbiAgICAgIGVuZF9jbXAgJiYgZW5kX2NtcCA8IDBcbiAgICBlbHNlXG4gICAgICBlbmRfY21wICYmIGVuZF9jbXAgPD0gMFxuICAgIGVuZCAmJiBiZWdfY21wICYmIGJlZ19jbXAgPD0gMFxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsaW1pdDtcblxuICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX251bWJlciAmJiAje0BlbmR9LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmICgje0BiZWdpbn0gJSAxICE9PSAwIHx8ICN7QGVuZH0gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gRmxvYXRcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9ICN7QGJlZ2lufSwgbGltaXQgPSAje0BlbmR9ICsgI3tAZXhjbCA/IDAgOiAxfTsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICBibG9jayhpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tAYmVnaW4udXB0byhAZW5kLCBAZXhjbCwgJmJsb2NrKX1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudCA9IEBiZWdpblxuICAgIGxhc3QgICAgPSBAZW5kXG5cbiAgICB1bmxlc3MgY3VycmVudC5yZXNwb25kX3RvPyg6c3VjYylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGl0ZXJhdGUgZnJvbSAje2N1cnJlbnQuY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIHdoaWxlIEBlbmQubmlsPyB8fCAoY3VycmVudCA8PT4gbGFzdCkgPCAwXG4gICAgICB5aWVsZCBjdXJyZW50XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnN1Y2NcbiAgICBlbmRcblxuICAgIHlpZWxkIGN1cnJlbnQgaWYgIUBleGNsICYmIGN1cnJlbnQgPT0gbGFzdFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIDo6UmFuZ2UgPT09IG90aGVyXG5cbiAgICBAZXhjbCA9PT0gb3RoZXIuZXhjbHVkZV9lbmQ/ICYmXG4gICAgICBAYmVnaW4uZXFsPyhvdGhlci5iZWdpbikgJiZcbiAgICAgIEBlbmQuZXFsPyhvdGhlci5lbmQpXG4gIGVuZFxuXG4gIGRlZiBleGNsdWRlX2VuZD9cbiAgICBAZXhjbFxuICBlbmRcblxuICBkZWYgZmlyc3QobiA9IHVuZGVmaW5lZClcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZScgaWYgQGJlZ2luLm5pbD9cbiAgICByZXR1cm4gQGJlZ2luIGlmIGBuID09IG51bGxgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGxhc3QobiA9IHVuZGVmaW5lZClcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtYXhpbXVtIG9mIGVuZGxlc3MgcmFuZ2UnIGlmIEBlbmQubmlsP1xuICAgIHJldHVybiBAZW5kIGlmIGBuID09IG51bGxgXG4gICAgdG9fYS5sYXN0KG4pXG4gIGVuZFxuXG4gICMgRklYTUU6IGN1cnJlbnRseSBoYXJkY29kZWQgdG8gYXNzdW1lIHJhbmdlIGhvbGRzIG51bWVyaWNzXG4gIGRlZiBtYXhcbiAgICBpZiBAZW5kLm5pbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBiZWdpbi5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAZXhjbCAmJiBAYmVnaW4gPT0gQGVuZClcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGAje0BleGNsfSA/ICN7QGVuZH0gLSAxIDogI3tAZW5kfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG1pblxuICAgIGlmIEBiZWdpbi5uaWw/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBlbmQubmlsPyAmJiAoQGJlZ2luID4gQGVuZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgQGJlZ2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgaW5maW5pdHkgPSA6OkZsb2F0OjpJTkZJTklUWVxuXG4gICAgcmV0dXJuIDAgaWYgKEBiZWdpbiA9PSBpbmZpbml0eSAmJiAhQGVuZC5uaWw/KSB8fCAoQGVuZCA9PSAtaW5maW5pdHkgJiYgIUBiZWdpbi5uaWw/KVxuICAgIHJldHVybiBpbmZpbml0eSBpZiBgaXNfaW5maW5pdGUoc2VsZilgXG4gICAgcmV0dXJuIG5pbCB1bmxlc3MgOjpOdW1lcmljID09PSBAYmVnaW4gJiYgOjpOdW1lcmljID09PSBAZW5kXG5cbiAgICByYW5nZV9iZWdpbiA9IEBiZWdpblxuICAgIHJhbmdlX2VuZCAgID0gQGVuZFxuICAgIHJhbmdlX2VuZCAgLT0gMSBpZiBAZXhjbFxuXG4gICAgcmV0dXJuIDAgaWYgcmFuZ2VfZW5kIDwgcmFuZ2VfYmVnaW5cblxuICAgIGBNYXRoLmFicyhyYW5nZV9lbmQgLSByYW5nZV9iZWdpbikgKyAxYC50b19pXG4gIGVuZFxuXG4gIGRlZiBzdGVwKG4gPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBjb2VyY2VTdGVwU2l6ZSgpIHtcbiAgICAgICAgaWYgKG4gPT0gbnVsbCkge1xuICAgICAgICAgIG4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgbiA9ICN7OjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KX1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgbmVnYXRpdmVcIn1cbiAgICAgICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCJ9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW51bWVyYXRvclNpemUoKSB7XG4gICAgICAgIGlmICghI3tAYmVnaW4ucmVzcG9uZF90bz8oOnN1Y2MpfSkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gJSAxID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICN7KHNpemUgLyBuKS5jZWlsfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBuIGlzIGEgZmxvYXRcbiAgICAgICAgICB2YXIgYmVnaW4gPSBzZWxmLmJlZ2luLCBlbmQgPSBzZWxmLmVuZCxcbiAgICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgICAgICAgZXJyID0gKGFicyhiZWdpbikgKyBhYnMoZW5kKSArIGFicyhlbmQgLSBiZWdpbikpIC8gYWJzKG4pICogI3s6OkZsb2F0OjpFUFNJTE9OfSxcbiAgICAgICAgICAgICAgc2l6ZTtcblxuICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5leGNsKSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gLSBlcnIpO1xuICAgICAgICAgICAgaWYgKHNpemUgKiBuICsgYmVnaW4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gKyBlcnIpICsgMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgaWYgKEBiZWdpbi5pc19hPyhOdW1lcmljKSB8fCBAYmVnaW4ubmlsPykgJiZcbiAgICAgICAgIChAZW5kLmlzX2E/KE51bWVyaWMpIHx8IEBlbmQubmlsPykgJiZcbiAgICAgICAgICEoQGJlZ2luLm5pbD8gJiYgQGVuZC5uaWw/KVxuXG4gICAgICAgIHJldHVybiA6OkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZS5uZXcoc2VsZiwgbiwgOnN0ZXApXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgbikgZG9cbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGNvZXJjZVN0ZXBTaXplKCk7XG4gICAgICAgICAgICByZXR1cm4gZW51bWVyYXRvclNpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBgY29lcmNlU3RlcFNpemUoKWBcblxuICAgIGlmIGBzZWxmLmJlZ2luLiQkaXNfbnVtYmVyICYmIHNlbGYuZW5kLiQkaXNfbnVtYmVyYFxuICAgICAgaSA9IDBcbiAgICAgIGxvb3AgZG9cbiAgICAgICAgY3VycmVudCA9IEBiZWdpbiArIGkgKiBuXG4gICAgICAgIGlmIEBleGNsXG4gICAgICAgICAgYnJlYWsgaWYgY3VycmVudCA+PSBAZW5kXG4gICAgICAgIGVsc2lmIGN1cnJlbnQgPiBAZW5kXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZW5kXG4gICAgICAgIHlpZWxkKGN1cnJlbnQpXG4gICAgICAgIGkgKz0gMVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZyAmJiBuICUgMSAhPT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGZsb2F0IGZyb20gc3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWFjaF93aXRoX2luZGV4IGRvIHx2YWx1ZSwgaWR4fFxuICAgICAgICB5aWVsZCh2YWx1ZSkgaWYgaWR4ICUgbiA9PSAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiAlKG4pXG4gICAgaWYgQGJlZ2luLmlzX2E/KE51bWVyaWMpICYmIEBlbmQuaXNfYT8oTnVtZXJpYylcbiAgICAgIDo6RW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlLm5ldyhzZWxmLCBuLCA6JSlcbiAgICBlbHNlXG4gICAgICBzdGVwKG4pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmJzZWFyY2gpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGlmIGBpc19pbmZpbml0ZShzZWxmKSAmJiAoc2VsZi5iZWdpbi4kJGlzX251bWJlciB8fCBzZWxmLmVuZC4kJGlzX251bWJlcilgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3IsIFwiQ2FuJ3QgI2JzZWFyY2ggYW4gaW5maW5pdGUgcmFuZ2VcIlxuICAgIGVuZFxuXG4gICAgdW5sZXNzIGBzZWxmLmJlZ2luLiQkaXNfbnVtYmVyICYmIHNlbGYuZW5kLiQkaXNfbnVtYmVyYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgZG8gYmluYXJ5IHNlYXJjaCBmb3IgI3tAYmVnaW4uY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIHRvX2EuYnNlYXJjaCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIje0BiZWdpbiB8fCAnJ30je0BleGNsID8gJy4uLicgOiAnLi4nfSN7QGVuZCB8fCAnJ31cIlxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiI3tAYmVnaW4gJiYgQGJlZ2luLmluc3BlY3R9I3tAZXhjbCA/ICcuLi4nIDogJy4uJ30je0BlbmQgJiYgQGVuZC5pbnNwZWN0fVwiXG4gIGVuZFxuXG4gIGRlZiBtYXJzaGFsX2xvYWQoYXJncylcbiAgICBAYmVnaW4gPSBhcmdzWzpiZWdpbl1cbiAgICBAZW5kID0gYXJnc1s6ZW5kXVxuICAgIEBleGNsID0gYXJnc1s6ZXhjbF1cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBbQGJlZ2luLCBAZW5kLCBAZXhjbF0uaGFzaFxuICBlbmRcblxuICBhbGlhcyA9PSBlcWw/XG4gIGFsaWFzIGluY2x1ZGU/IGNvdmVyP1xuICBhbGlhcyBtZW1iZXI/IGNvdmVyP1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhbmdlPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiZmlyc3QiLCJsYXN0IiwiZXhjbHVkZSIsIkBiZWdpbiIsIktlcm5lbCIsInJhaXNlIiwiTmFtZUVycm9yIiwiPD0+IiwibmlsPyIsIkFyZ3VtZW50RXJyb3IiLCJAZW5kIiwiQGV4Y2wiLCI9PT0iLCJ2YWx1ZSIsImluY2x1ZGU/IiwiY291bnQiLCJibG9ja19naXZlbj8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsInRvX2EiLCJUeXBlRXJyb3IiLCJjb3Zlcj8iLCJiZWdfY21wIiwiJHJldF9vcl8xIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiLTEiLCJlbmRfY21wIiwiPCIsIjAiLCI8PSIsImVhY2giLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJzaXplIiwiMSIsInVwdG8iLCJibG9jayIsInRvX3Byb2MiLCJjdXJyZW50IiwicmVzcG9uZF90bz8iLCJjbGFzcyIsInN1Y2MiLCJlcWw/Iiwib3RoZXIiLCJSYW5nZSIsImV4Y2x1ZGVfZW5kPyIsImJlZ2luIiwiZW5kIiwibiIsIlJhbmdlRXJyb3IiLCJtYXgiLCI+IiwibWluIiwiaW5maW5pdHkiLCItQCIsIk51bWVyaWMiLCJyYW5nZV9iZWdpbiIsInJhbmdlX2VuZCIsIi0iLCJ0b19pIiwic3RlcCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsIi8iLCJjZWlsIiwiRmxvYXQ6OkVQU0lMT04iLCJpc19hPyIsIkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZSIsIkVudW1lcmF0b3IiLCJuZXciLCJibG9jayBpbiBzdGVwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdGVwIiwiaSIsImxvb3AiLCIrIiwiKiIsIj49IiwiZWFjaF93aXRoX2luZGV4IiwiaWR4IiwiJSIsImJzZWFyY2giLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwidG9fcyIsImluc3BlY3QiLCJtYXJzaGFsX2xvYWQiLCJhcmdzIiwiW10iLCJoYXNoIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxpQkFBUkQ7SUFFQ0Q7SUFFREYsSUFBQUssYUFBQUEsQ0FBWSxPQUFaLEVBQW9CLEtBQXBCQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxLQUFELEVBQVFDLElBQVIsRUFBY0MsT0FBNUJIO0FBQUFBLE1BQUFBOzs7TUFB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LE1BQUFBLENBQUFBO0lBRHZCQSxDQUFBQSxHQUFBQTtJQUlBLGFBQU0sSUFBTixFQUFTLE1BQVQ7SUFDQSxhQUFNLFVBQU4sRUFBZSxRQUFmO0lBQ0EvRixPQUFBLGFBQU0sU0FBTixFQUFjLFFBQWQ7RUExU0ZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE0NjAwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lcnJvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OkV4Y2VwdGlvbiA8IGBFcnJvcmBcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19leGNlcHRpb24nLCB0cnVlKWBcbiAgYHZhciBzdGFja190cmFjZV9saW1pdGBcblxuICBgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMTAwYFxuXG4gIGRlZiBzZWxmLm5ldygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBtZXNzYWdlICAgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWw7XG4gICAgICB2YXIgZXJyb3IgICAgID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcihtZXNzYWdlKTtcbiAgICAgIGVycm9yLm5hbWUgICAgPSBzZWxmLiQkbmFtZTtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgZXJyb3IuY2F1c2UgICA9ICN7JCF9O1xuICAgICAgT3BhbC5zZW5kKGVycm9yLCBlcnJvci4kaW5pdGlhbGl6ZSwgYXJncyk7XG5cbiAgICAgIC8vIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCkgd2lsbCB1c2UgLm5hbWUgYW5kIC50b1N0cmluZyB0byBidWlsZCB0aGVcbiAgICAgIC8vIGZpcnN0IGxpbmUgb2YgdGhlIHN0YWNrIHRyYWNlIHNvIGl0IG11c3QgYmUgY2FsbGVkIGFmdGVyIHRoZSBlcnJvclxuICAgICAgLy8gaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjYueC9kb2NzL2FwaS9lcnJvcnMuaHRtbFxuICAgICAgaWYgKE9wYWwuY29uZmlnLmVuYWJsZV9zdGFja190cmFjZSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAvLyBQYXNzaW5nIEtlcm5lbC5yYWlzZSB3aWxsIGN1dCB0aGUgc3RhY2sgdHJhY2UgZnJvbSB0aGF0IHBvaW50IGFib3ZlXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBzdGFja190cmFjZV9saW1pdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIGVuZFxuICBgc3RhY2tfdHJhY2VfbGltaXQgPSBzZWxmLiRuZXdgXG5cbiAgZGVmIHNlbGYuZXhjZXB0aW9uKCphcmdzKVxuICAgIG5ldygqYXJncylcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICBgc2VsZi5tZXNzYWdlID0gKGFyZ3MubGVuZ3RoID4gMCkgPyBhcmdzWzBdIDogbmlsYFxuICBlbmRcblxuICAleHtcbiAgICAvLyBDb252ZXJ0IGJhY2t0cmFjZSBmcm9tIGFueSBmb3JtYXQgdG8gUnVieSBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb3JyZWN0X2JhY2t0cmFjZShiYWNrdHJhY2UpIHtcbiAgICAgIHZhciBuZXdfYnQgPSBbXSwgbTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYWNrdHJhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxvYyA9IGJhY2t0cmFjZVtpXTtcbiAgICAgICAgaWYgKCFsb2MgfHwgIWxvYy4kJGlzX3N0cmluZykge1xuICAgICAgICAgIC8qIERvIG5vdGhpbmcgKi9cbiAgICAgICAgfVxuICAgICAgICAvKiBDaHJvbWl1bSBmb3JtYXQgKi9cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBsb2MubWF0Y2goL14gICAgYXQgKC4qPykgXFwoKC4qPylcXCkkLykpKSB7XG4gICAgICAgICAgbmV3X2J0LnB1c2gobVsyXSArIFwiOmluIGBcIiArIG1bMV0gKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBsb2MubWF0Y2goL14gICAgYXQgKC4qPykkLykpKSB7XG4gICAgICAgICAgbmV3X2J0LnB1c2gobVsxXSArIFwiOmluIGB1bmRlZmluZWQnXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIE5vZGUgZm9ybWF0ICovXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICBmcm9tICguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIE1vemlsbGEvQXBwbGUgZm9ybWF0ICovXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eKC4qPylAKC4qPykkLykpKSB7XG4gICAgICAgICAgbmV3X2J0LnB1c2gobVsyXSArICc6aW4gYCcgKyBtWzFdICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdfYnQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIGJhY2t0cmFjZVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuYmFja3RyYWNlKSB7XG4gICAgICAgIC8vIG5pbCBpcyBhIHZhbGlkIGJhY2t0cmFjZVxuICAgICAgICByZXR1cm4gc2VsZi5iYWNrdHJhY2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYWNrdHJhY2UgPSBzZWxmLnN0YWNrO1xuXG4gICAgICBpZiAodHlwZW9mKGJhY2t0cmFjZSkgIT09ICd1bmRlZmluZWQnICYmIGJhY2t0cmFjZS4kJGlzX3N0cmluZykge1xuICAgICAgICByZXR1cm4gc2VsZi5iYWNrdHJhY2UgPSBjb3JyZWN0X2JhY2t0cmFjZShiYWNrdHJhY2Uuc3BsaXQoXCJcXG5cIikpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmFja3RyYWNlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZSA9IGNvcnJlY3RfYmFja3RyYWNlKGJhY2t0cmFjZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBiYWNrdHJhY2VfbG9jYXRpb25zXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zKSByZXR1cm4gc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zO1xuICAgICAgc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zID0gI3tiYWNrdHJhY2UmLm1hcCBkbyB8bG9jfFxuICAgICAgICA6OlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbi5uZXcobG9jKVxuICAgICAgZW5kfVxuICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjYXVzZVxuICAgIGBzZWxmLmNhdXNlIHx8IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbihzdHIgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc3RyID09PSBuaWwgfHwgc2VsZiA9PT0gc3RyKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gI3tjbG9uZX07XG4gICAgICBjbG9uZWQubWVzc2FnZSA9IHN0cjtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkgY2xvbmVkLmJhY2t0cmFjZSA9IHNlbGYuYmFja3RyYWNlLiRkdXAoKTtcbiAgICAgIGNsb25lZC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICBjbG9uZWQuY2F1c2UgPSBzZWxmLmNhdXNlO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIGVuZFxuXG4gICMgbm90IHVzaW5nIGFsaWFzIG1lc3NhZ2UgdG9fcyBiZWNhdXNlIHlvdSBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcnJpZGUgdG9fcyBhbmQgaGF2ZSBtZXNzYWdlIHVzZSBvdmVycmlkZGVuIG1ldGhvZCwgd29uJ3Qgd29yayB3aXRoIGFsaWFzXG4gIGRlZiBtZXNzYWdlXG4gICAgdG9fc1xuICBlbmRcblxuICBkZWYgZnVsbF9tZXNzYWdlKGt3YXJncyA9IG5pbClcbiAgICB1bmxlc3MgZGVmaW5lZD8gSGFzaFxuICAgICAgIyBXZSBhcmUgZGVhbGluZyB3aXRoIGFuIHVuZnVsbHkgbG9hZGVkIE9wYWwgbGlicmFyeSwgc28gd2Ugc2hvdWxkXG4gICAgICAjIGRvIHdpdGggYXMgbGl0dGxlIGFzIHdlIGNhbi5cblxuICAgICAgcmV0dXJuIFwiI3tAbWVzc2FnZX1cXG4je2BzZWxmLnN0YWNrYH1cIlxuICAgIGVuZFxuXG4gICAga3dhcmdzID0geyBoaWdobGlnaHQ6ICRzdGRlcnIudHR5Pywgb3JkZXI6IDp0b3AgfS5tZXJnZShrd2FyZ3MgfHwge30pXG4gICAgaGlnaGxpZ2h0LCBvcmRlciA9IGt3YXJnc1s6aGlnaGxpZ2h0XSwga3dhcmdzWzpvcmRlcl1cblxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJleHBlY3RlZCB0cnVlIG9yIGZhbHNlIGFzIGhpZ2hsaWdodDogI3toaWdobGlnaHR9XCIgdW5sZXNzIFt0cnVlLCBmYWxzZV0uaW5jbHVkZT8gaGlnaGxpZ2h0XG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImV4cGVjdGVkIDp0b3Agb3IgOmJvdHRvbSBhcyBvcmRlcjogI3tvcmRlcn1cIiB1bmxlc3MgJWlbdG9wIGJvdHRvbV0uaW5jbHVkZT8gb3JkZXJcblxuICAgIGlmIGhpZ2hsaWdodFxuICAgICAgYm9sZF91bmRlcmxpbmUgPSBcIlxcZVsxOzRtXCJcbiAgICAgIGJvbGQgPSBcIlxcZVsxbVwiXG4gICAgICByZXNldCA9IFwiXFxlW21cIlxuICAgIGVsc2VcbiAgICAgIGJvbGRfdW5kZXJsaW5lID0gYm9sZCA9IHJlc2V0ID0gJydcbiAgICBlbmRcblxuICAgIGJ0ID0gYmFja3RyYWNlLmR1cFxuICAgIGJ0ID0gY2FsbGVyIGlmICFidCB8fCBidC5lbXB0eT9cbiAgICBmaXJzdCA9IGJ0LnNoaWZ0XG5cbiAgICBtc2cgPSBcIiN7Zmlyc3R9OiBcIlxuICAgIG1zZyArPSBcIiN7Ym9sZH0je3RvX3N9ICgje2JvbGRfdW5kZXJsaW5lfSN7c2VsZi5jbGFzc30je3Jlc2V0fSN7Ym9sZH0pI3tyZXNldH1cXG5cIlxuXG4gICAgbXNnICs9IGJ0Lm1hcCB7IHxsb2N8IFwiXFx0ZnJvbSAje2xvY31cXG5cIiB9LmpvaW5cblxuICAgIG1zZyArPSBjYXVzZS5mdWxsX21lc3NhZ2UoaGlnaGxpZ2h0OiBoaWdobGlnaHQpIGlmIGNhdXNlXG5cbiAgICBpZiBvcmRlciA9PSA6Ym90dG9tXG4gICAgICBtc2cgPSBtc2cuc3BsaXQoXCJcXG5cIikucmV2ZXJzZS5qb2luKFwiXFxuXCIpXG4gICAgICBtc2cgPSBcIiN7Ym9sZH1UcmFjZWJhY2sje3Jlc2V0fSAobW9zdCByZWNlbnQgY2FsbCBsYXN0KTpcXG5cIiArIG1zZ1xuICAgIGVuZFxuXG4gICAgbXNnXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgYXNfc3RyID0gdG9fc1xuICAgIGFzX3N0ci5lbXB0eT8gPyBzZWxmLmNsYXNzLnRvX3MgOiBcIiM8I3tzZWxmLmNsYXNzLnRvX3N9OiAje3RvX3N9PlwiXG4gIGVuZFxuXG4gIGRlZiBzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSlcbiAgICAleHtcbiAgICAgIHZhciB2YWxpZCA9IHRydWUsIGksIGlpO1xuXG4gICAgICBpZiAoYmFja3RyYWNlID09PSBuaWwpIHtcbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBuaWw7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gW2JhY2t0cmFjZV07XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnICBmcm9tICcgKyBiYWNrdHJhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFja3RyYWNlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJhY2t0cmFjZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJhY2t0cmFjZVtpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnYmFja3RyYWNlIG11c3QgYmUgQXJyYXkgb2YgU3RyaW5nJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gYmFja3RyYWNlO1xuICAgICAgICBzZWxmLnN0YWNrID0gI3tgYmFja3RyYWNlYC5tYXAgeyB8aXwgJyAgZnJvbSAnICsgaSB9fS5qb2luKFwiXFxuXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFja3RyYWNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICAjIHVzaW5nIHNlbGYubWVzc2FnZSBha2EgQG1lc3NhZ2UgdG8gcmV0YWluIGNvbXBhdGliaWxpdHkgd2l0aCBuYXRpdmUgZXhjZXB0aW9uJ3MgbWVzc2FnZSBwcm9wZXJ0eVxuICAgIChAbWVzc2FnZSAmJiBAbWVzc2FnZS50b19zKSB8fCBzZWxmLmNsYXNzLnRvX3NcbiAgZW5kXG5lbmRcblxuIyBrZWVwIHRoZSBpbmRlbnRhdGlvbiwgaXQgbWFrZXMgdGhlIGV4Y2VwdGlvbiBoaWVyYXJjaHkgY2xlYXJcbmNsYXNzIDo6U2NyaXB0RXJyb3IgICAgICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OlN5bnRheEVycm9yICAgICAgICAgPCA6OlNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIDo6TG9hZEVycm9yICAgICAgICAgICA8IDo6U2NyaXB0RXJyb3I7IGVuZFxuY2xhc3MgOjpOb3RJbXBsZW1lbnRlZEVycm9yIDwgOjpTY3JpcHRFcnJvcjsgZW5kXG5cbmNsYXNzIDo6U3lzdGVtRXhpdCAgICAgICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6Ok5vTWVtb3J5RXJyb3IgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpTaWduYWxFeGNlcHRpb24gICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6SW50ZXJydXB0ICAgICAgICAgICA8IDo6U2lnbmFsRXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6U2VjdXJpdHlFcnJvciAgICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OlN5c3RlbVN0YWNrRXJyb3IgIDwgOjpFeGNlcHRpb247IGVuZFxuXG5jbGFzcyA6OlN0YW5kYXJkRXJyb3IgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpFbmNvZGluZ0Vycm9yICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6WmVyb0RpdmlzaW9uRXJyb3IgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6Ok5hbWVFcnJvciAgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpOb01ldGhvZEVycm9yICAgICAgICAgPCA6Ok5hbWVFcnJvcjsgZW5kXG5jbGFzcyA6OlJ1bnRpbWVFcnJvciAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpGcm96ZW5FcnJvciAgICAgICAgICAgPCA6OlJ1bnRpbWVFcnJvcjsgZW5kXG5jbGFzcyA6OkxvY2FsSnVtcEVycm9yICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpUeXBlRXJyb3IgICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6QXJndW1lbnRFcnJvciAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OlVuY2F1Z2h0VGhyb3dFcnJvciAgICA8IDo6QXJndW1lbnRFcnJvcjsgZW5kXG5jbGFzcyA6OkluZGV4RXJyb3IgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpTdG9wSXRlcmF0aW9uICAgICAgICAgPCA6OkluZGV4RXJyb3I7IGVuZFxuY2xhc3MgOjpDbG9zZWRRdWV1ZUVycm9yICAgICAgICA8IDo6U3RvcEl0ZXJhdGlvbjsgZW5kXG5jbGFzcyA6OktleUVycm9yICAgICAgICAgICAgICA8IDo6SW5kZXhFcnJvcjsgZW5kXG5jbGFzcyA6OlJhbmdlRXJyb3IgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpGbG9hdERvbWFpbkVycm9yICAgICAgPCA6OlJhbmdlRXJyb3I7IGVuZFxuY2xhc3MgOjpJT0Vycm9yICAgICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6RU9GRXJyb3IgICAgICAgICAgICAgIDwgOjpJT0Vycm9yOyBlbmRcbmNsYXNzIDo6U3lzdGVtQ2FsbEVycm9yICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OlJlZ2V4cEVycm9yICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpUaHJlYWRFcnJvciAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6RmliZXJFcnJvciAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5cbjo6T2JqZWN0LmF1dG9sb2FkIDpFcnJubywgJ2NvcmVsaWIvZXJyb3IvZXJybm8nXG5cbmNsYXNzIDo6RnJvemVuRXJyb3IgPCA6OlJ1bnRpbWVFcnJvclxuICBhdHRyX3JlYWRlciA6cmVjZWl2ZXJcblxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCByZWNlaXZlcjogbmlsKVxuICAgIHN1cGVyIG1lc3NhZ2VcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlVuY2F1Z2h0VGhyb3dFcnJvciA8IDo6QXJndW1lbnRFcnJvclxuICBhdHRyX3JlYWRlciA6dGFnLCA6dmFsdWVcblxuICBkZWYgaW5pdGlhbGl6ZSh0YWcsIHZhbHVlID0gbmlsKVxuICAgIEB0YWcgPSB0YWdcbiAgICBAdmFsdWUgPSB2YWx1ZVxuXG4gICAgc3VwZXIoXCJ1bmNhdWdodCB0aHJvdyAje0B0YWcuaW5zcGVjdH1cIilcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpOYW1lRXJyb3JcbiAgYXR0cl9yZWFkZXIgOm5hbWVcblxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBuYW1lID0gbmlsKVxuICAgIHN1cGVyIG1lc3NhZ2VcbiAgICBAbmFtZSA9IG5hbWVcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpOb01ldGhvZEVycm9yXG4gIGF0dHJfcmVhZGVyIDphcmdzXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbCwgYXJncyA9IFtdKVxuICAgIHN1cGVyIG1lc3NhZ2UsIG5hbWVcbiAgICBAYXJncyA9IGFyZ3NcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpTdG9wSXRlcmF0aW9uXG4gIGF0dHJfcmVhZGVyIDpyZXN1bHRcbmVuZFxuXG5jbGFzcyA6OktleUVycm9yXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIHJlY2VpdmVyOiBuaWwsIGtleTogbmlsKVxuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgQHJlY2VpdmVyID0gcmVjZWl2ZXJcbiAgICBAa2V5ID0ga2V5XG4gIGVuZFxuXG4gIGRlZiByZWNlaXZlclxuICAgIEByZWNlaXZlciB8fCA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBpcyBhdmFpbGFibGUnKVxuICBlbmRcblxuICBkZWYga2V5XG4gICAgQGtleSB8fCA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsICdubyBrZXkgaXMgYXZhaWxhYmxlJylcbiAgZW5kXG5lbmRcblxubW9kdWxlIDo6SlNcbiAgY2xhc3MgRXJyb3JcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkV4Y2VwdGlvbj4iLCJuZXciLCJzZWxmIiwiJCEiLCJleGNlcHRpb24iLCJhcmdzIiwiaW5pdGlhbGl6ZSIsImJhY2t0cmFjZSIsImJhY2t0cmFjZV9sb2NhdGlvbnMiLCJibG9jayBpbiBiYWNrdHJhY2VfbG9jYXRpb25zIiwibG9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBiYWNrdHJhY2VfbG9jYXRpb25zIiwiVGhyZWFkOjpCYWNrdHJhY2U6OkxvY2F0aW9uIiwiVGhyZWFkOjpCYWNrdHJhY2UiLCJUaHJlYWQiLCJjYXVzZSIsInN0ciIsImNsb25lIiwibWVzc2FnZSIsInRvX3MiLCJmdWxsX21lc3NhZ2UiLCJrd2FyZ3MiLCJAbWVzc2FnZSIsIiRzdGRlcnIiLCJ0dHk/IiwibWVyZ2UiLCIkcmV0X29yXzEiLCJbXSIsImhpZ2hsaWdodCIsIm9yZGVyIiwiaW5jbHVkZT8iLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJib2xkX3VuZGVybGluZSIsImJvbGQiLCJyZXNldCIsImJ0IiwiZHVwIiwiZW1wdHk/IiwiY2FsbGVyIiwiZmlyc3QiLCJzaGlmdCIsIm1zZyIsIisiLCJjbGFzcyIsIm1hcCIsImJsb2NrIGluIGZ1bGxfbWVzc2FnZSIsImJsb2NrICgyIGxldmVscykgaW4gZnVsbF9tZXNzYWdlIiwiam9pbiIsInNwbGl0IiwicmV2ZXJzZSIsImluc3BlY3QiLCJhc19zdHIiLCJzZXRfYmFja3RyYWNlIiwiVHlwZUVycm9yIiwiYmxvY2sgaW4gc2V0X2JhY2t0cmFjZSIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIHNldF9iYWNrdHJhY2UiLCIkcmV0X29yXzIiLCI8Y2xhc3M6U2NyaXB0RXJyb3I+IiwiRXhjZXB0aW9uIiwiPGNsYXNzOlN5bnRheEVycm9yPiIsIlNjcmlwdEVycm9yIiwiPGNsYXNzOkxvYWRFcnJvcj4iLCI8Y2xhc3M6Tm90SW1wbGVtZW50ZWRFcnJvcj4iLCI8Y2xhc3M6U3lzdGVtRXhpdD4iLCI8Y2xhc3M6Tm9NZW1vcnlFcnJvcj4iLCI8Y2xhc3M6U2lnbmFsRXhjZXB0aW9uPiIsIjxjbGFzczpJbnRlcnJ1cHQ+IiwiU2lnbmFsRXhjZXB0aW9uIiwiPGNsYXNzOlNlY3VyaXR5RXJyb3I+IiwiPGNsYXNzOlN5c3RlbVN0YWNrRXJyb3I+IiwiPGNsYXNzOlN0YW5kYXJkRXJyb3I+IiwiPGNsYXNzOkVuY29kaW5nRXJyb3I+IiwiU3RhbmRhcmRFcnJvciIsIjxjbGFzczpaZXJvRGl2aXNpb25FcnJvcj4iLCI8Y2xhc3M6TmFtZUVycm9yPiIsIjxjbGFzczpOb01ldGhvZEVycm9yPiIsIk5hbWVFcnJvciIsIjxjbGFzczpSdW50aW1lRXJyb3I+IiwiPGNsYXNzOkZyb3plbkVycm9yPiIsIlJ1bnRpbWVFcnJvciIsIjxjbGFzczpMb2NhbEp1bXBFcnJvcj4iLCI8Y2xhc3M6VHlwZUVycm9yPiIsIjxjbGFzczpBcmd1bWVudEVycm9yPiIsIjxjbGFzczpVbmNhdWdodFRocm93RXJyb3I+IiwiPGNsYXNzOkluZGV4RXJyb3I+IiwiPGNsYXNzOlN0b3BJdGVyYXRpb24+IiwiSW5kZXhFcnJvciIsIjxjbGFzczpDbG9zZWRRdWV1ZUVycm9yPiIsIlN0b3BJdGVyYXRpb24iLCI8Y2xhc3M6S2V5RXJyb3I+IiwiPGNsYXNzOlJhbmdlRXJyb3I+IiwiPGNsYXNzOkZsb2F0RG9tYWluRXJyb3I+IiwiUmFuZ2VFcnJvciIsIjxjbGFzczpJT0Vycm9yPiIsIjxjbGFzczpFT0ZFcnJvcj4iLCJJT0Vycm9yIiwiPGNsYXNzOlN5c3RlbUNhbGxFcnJvcj4iLCI8Y2xhc3M6UmVnZXhwRXJyb3I+IiwiPGNsYXNzOlRocmVhZEVycm9yPiIsIjxjbGFzczpGaWJlckVycm9yPiIsIk9iamVjdCIsImF1dG9sb2FkIiwiYXR0cl9yZWFkZXIiLCIka3dhcmdzIiwiQHJlY2VpdmVyIiwicmVjZWl2ZXIiLCJ0YWciLCJ2YWx1ZSIsIkB0YWciLCJAdmFsdWUiLCJuYW1lIiwiQG5hbWUiLCJAYXJncyIsIkBrZXkiLCJrZXkiLCI8bW9kdWxlOkpTPiIsIjxjbGFzczpFcnJvcj4iXSwibWFwcGluZ3MiOiJBQUFBQSxnQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDR0E7SUFDQUE7SUFFQUE7SUFFREMsTUFBSUMsSUFBSkQsVUFBQUEsMEJBTkYsRUFNRUE7QUFBQUEsTUFBQUE7QUFBQUE7OztNQU5GO01BTWU7O0FBRWZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLHNCQUF3QkUsV0FBR0Y7QUFDM0JBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFuQkVBLENBQUFBLElBQUFBO0lBcUJDRDtJQUVESSxNQUFJRixJQUFKRSxnQkFBQUEscUJBN0JGLEVBNkJFQTtBQUFBQSxNQUFBQTs7O01BN0JGO01BNkJxQjtNQUNqQkEsT0FBQUgsTUFBQUMsSUFBQUQsT0FBQUEsRUFBSSxNQUFDSSxJQUFELENBQUpKO0lBREZHLENBQUFBLElBQUFBOztBQUlBRSxJQUFBQSwwQkFBQUEsc0JBakNGLEVBaUNFQTtBQUFBQSxNQUFBQTs7O01BakNGO01BaUNpQjtNQUViQSxPQUFDQSxnREFBREE7SUFGRkEsQ0FBQUEsSUFBQUE7O0FBTUZOO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUVPLElBQUFBLHlCQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNB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UzBCLHNDQUFBLGlDQUFVOztNQUFLLDRCQUFBLHVCQUFLO01BQzFDLE9BQUFKLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTWdCLE9BQU4sQ0FBQSxFQUFBLElBQUE7TUFDQXlGLGdCQUFZQztNQUNadEcsT0FBQThHLENBQUFBLFdBQU9DLEdBQVBEO0lBSEY5RyxDQUFBQSxJQUFBQTs7QUFNQXNHLElBQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBbEYsQ0FBQUEsWUFBQWlGLGFBQUFqRixDQUFBLENBQUE7UUFBQWtGLE9BQUE7TUFBQTtRQUFhQSxPQUFBN0UsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0MyRSwwQkFBeEI1RTtNQUFyQjtJQURGNEUsQ0FBQUEsR0FBQUE7SUFJQWhCLE9BQUF5QixtQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBM0YsQ0FBQUEsWUFBQTBGLFFBQUExRixDQUFBLENBQUE7UUFBQTJGLE9BQUE7TUFBQTtRQUFRQSxPQUFBdEYsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NvRixxQkFBeEJyRjtNQUFoQjtJQURGcUYsQ0FBQUEsR0FBQUE7RUFYRnpCLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUFnQkE3RixPQUFBdUg7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQyxRQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQURGRCxHQUFPLElBQVBBO0FBbFRBdkg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE1MDI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpNZXRob2RcbiAgYXR0cl9yZWFkZXIgOm93bmVyLCA6cmVjZWl2ZXIsIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUocmVjZWl2ZXIsIG93bmVyLCBtZXRob2QsIG5hbWUpXG4gICAgQHJlY2VpdmVyID0gcmVjZWl2ZXJcbiAgICBAb3duZXIgICAgPSBvd25lclxuICAgIEBuYW1lICAgICA9IG5hbWVcbiAgICBAbWV0aG9kICAgPSBtZXRob2RcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgQG1ldGhvZC5hcml0eVxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGAje0BtZXRob2R9LiQkc291cmNlX2xvY2F0aW9uYCB8fCBbJyhldmFsKScsIDBdXG4gIGVuZFxuXG4gIGRlZiBjb21tZW50c1xuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXG4gIGVuZFxuXG4gIGRlZiBjYWxsKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAje0BtZXRob2R9LiQkcCA9IGJsb2NrO1xuXG4gICAgICByZXR1cm4gI3tAbWV0aG9kfS5hcHBseSgje0ByZWNlaXZlcn0sIGFyZ3MpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN1cnJ5KGFyaXR5ID0gdW5kZWZpbmVkKVxuICAgIEBtZXRob2QuY3VycnkoYXJpdHkpXG4gIGVuZFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICBAbWV0aG9kID4+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICBAbWV0aG9kIDw8IG90aGVyXG4gIGVuZFxuXG4gIGRlZiB1bmJpbmRcbiAgICA6OlVuYm91bmRNZXRob2QubmV3KEByZWNlaXZlci5jbGFzcywgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSlcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICAleHtcbiAgICAgIHZhciBwcm9jID0gc2VsZi4kY2FsbC5iaW5kKHNlbGYpO1xuICAgICAgcHJvYy4kJHVuYm91bmQgPSAje0BtZXRob2R9O1xuICAgICAgcHJvYy4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgICBwcm9jLiQkYXJpdHkgPSAje0BtZXRob2R9LiQkYXJpdHk7XG4gICAgICBwcm9jLiQkcGFyYW1ldGVycyA9ICN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0ByZWNlaXZlci5jbGFzc30jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbmVuZFxuXG5jbGFzcyA6OlVuYm91bmRNZXRob2RcbiAgYXR0cl9yZWFkZXIgOnNvdXJjZSwgOm93bmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHNvdXJjZSwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAc291cmNlID0gc291cmNlXG4gICAgQG93bmVyICA9IG93bmVyXG4gICAgQG1ldGhvZCA9IG1ldGhvZFxuICAgIEBuYW1lICAgPSBuYW1lXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgYmluZChvYmplY3QpXG4gICAgJXh7XG4gICAgICBpZiAoI3tAb3duZXJ9LiQkaXNfbW9kdWxlIHx8IE9wYWwuaXNfYSgje29iamVjdH0sICN7QG93bmVyfSkpIHtcbiAgICAgICAgcmV0dXJuICN7OjpNZXRob2QubmV3KG9iamVjdCwgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgYmluZCBzaW5nbGV0b24gbWV0aG9kIHRvIGEgZGlmZmVyZW50IGNsYXNzIChleHBlY3RlZCAje29iamVjdH0ua2luZF9vZj8oI3tAb3duZXJ9IHRvIGJlIHRydWUpXCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJpbmRfY2FsbChvYmplY3QsICphcmdzLCAmYmxvY2spXG4gICAgYmluZChvYmplY3QpLmNhbGwoKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAc291cmNlfSMje0BuYW1lfSAoZGVmaW5lZCBpbiAje0Bvd25lcn0gaW4gI3tzb3VyY2VfbG9jYXRpb24uam9pbignOicpfSk+XCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk1ldGhvZD4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwicmVjZWl2ZXIiLCJvd25lciIsIm1ldGhvZCIsIm5hbWUiLCJAcmVjZWl2ZXIiLCJAb3duZXIiLCJAbmFtZSIsIkBtZXRob2QiLCJhcml0eSIsInBhcmFtZXRlcnMiLCJzb3VyY2VfbG9jYXRpb24iLCIkcmV0X29yXzEiLCIwIiwiY29tbWVudHMiLCJjYWxsIiwiY3VycnkiLCI+PiIsIm90aGVyIiwiPDwiLCJ1bmJpbmQiLCJVbmJvdW5kTWV0aG9kIiwibmV3IiwiY2xhc3MiLCJ0b19wcm9jIiwiaW5zcGVjdCIsImpvaW4iLCI8Y2xhc3M6VW5ib3VuZE1ldGhvZD4iLCJzb3VyY2UiLCJAc291cmNlIiwiYmluZCIsIm9iamVjdCIsIk1ldGhvZCIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiYmluZF9jYWxsIiwiYXJncyIsImJsb2NrIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7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b3VyY2VzIjpbImNvcmVsaWIvbWFpbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA8PCBzZWxmXG4gIGRlZiB0b19zXG4gICAgJ21haW4nXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlKG1vZClcbiAgICA6Ok9iamVjdC5pbmNsdWRlIG1vZFxuICBlbmRcblxuICBkZWYgYXV0b2xvYWQoKmFyZ3MpXG4gICAgYE9wYWwuT2JqZWN0LiRhdXRvbG9hZC5hcHBseShPcGFsLk9iamVjdCwgYXJncylgXG4gIGVuZFxuXG4gICMgQ29tcGlsZXIgb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG4gIGRlZiB1c2luZyhtb2QpXG4gICAgOjpLZXJuZWwucmFpc2UgJ21haW4udXNpbmcgaXMgcGVybWl0dGVkIG9ubHkgYXQgdG9wbGV2ZWwnXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInRvX3MiLCJpbmNsdWRlIiwibW9kIiwiT2JqZWN0IiwiYXV0b2xvYWQiLCJ1c2luZyIsIktlcm5lbCIsInJhaXNlIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUFBLCtCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUE7Ozs7QUFDRUMsSUFBQUEsb0JBQUFBLFlBQ0UsTUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHVCQUFBQSxtQkFBWUMsR0FBWkQ7QUFBQUE7TUFDRUEsT0FBQUUsT0FBUUYsU0FBQUEsQ0FBU0MsR0FBVEQ7SUFEVkEsQ0FBQUEsR0FBQUE7O0FBSUFHLElBQUFBLHdCQUFBQSxvQkFURixFQVNFQTtBQUFBQSxNQUFBQTs7O01BVEY7TUFTZTtNQUNYQSxPQUFDQSw4Q0FBREE7SUFERkEsQ0FBQUEsSUFBQUE7SUFLQSxPQUFBQyxxQkFBQUEsaUJBQVVILEdBQVZHO0FBQUFBO01BQ0VBLE9BQUFDLE9BQVFDLE9BQUFBLENBQU9GLDBDQUFQRTtJQURWRixDQUFBQSxHQUFBQTtFQWRGLDRCQUFTRyxJQUFUO0FBQUFUOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNTI1NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlXG5cbmNsYXNzIDo6UHJvYyA8IGBGdW5jdGlvbmBcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19wcm9jJywgdHJ1ZSlgXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgYSBQcm9jIG9iamVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgZW5kXG5cbiAgICBibG9ja1xuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kJHAgPSBibG9jaztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCwgJGJyayA9IHNlbGYuJCRicmssICRyZXQgPSBzZWxmLiQkcmV0O1xuXG4gICAgICBpZiAoJGJyayB8fCAoJHJldCAmJiBzZWxmLiQkaXNfbGFtYmRhKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJGJyaykge1xuICAgICAgICAgICAgcmV0dXJuIGVyci4kdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBlcnIgPT09ICRyZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIuJHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBPcGFsLnlpZWxkWChzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID4+KG90aGVyKVxuICAgIDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICBvdXQgPSBjYWxsKCphcmdzLCAmYmxvY2spXG4gICAgICBvdGhlci5jYWxsKG91dClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw8KG90aGVyKVxuICAgIDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICBvdXQgPSBvdGhlci5jYWxsKCphcmdzLCAmYmxvY2spXG4gICAgICBjYWxsKG91dClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsYW1iZGE/XG4gICAgIyBUaGlzIG1ldGhvZCBzaG91bGQgdGVsbCB0aGUgdXNlciBpZiB0aGUgcHJvYyB0cmlja3MgYXJlIHVuYXZhaWxhYmxlLFxuICAgICMgKHNlZSBQcm9jI2xhbWJkYT8gb24gcnVieSBkb2NzIHRvIGZpbmQgb3V0IG1vcmUpLlxuICAgIGAhIXNlbGYuJCRpc19sYW1iZGFgXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkYXJpdHk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc291cmNlX2xvY2F0aW9uXG4gICAgYGlmIChzZWxmLiQkaXNfY3VycmllZCkgeyByZXR1cm4gbmlsOyB9YFxuICAgIGBzZWxmLiQkc291cmNlX2xvY2F0aW9uYCB8fCBuaWxcbiAgZW5kXG5cbiAgZGVmIGJpbmRpbmdcbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIkNhbid0IGNyZWF0ZSBCaW5kaW5nXCJ9IH1gXG5cbiAgICBpZiBkZWZpbmVkPyA6OkJpbmRpbmdcbiAgICAgIDo6QmluZGluZy5uZXcobmlsLCBbXSwgYHNlbGYuJCRzYCwgc291cmNlX2xvY2F0aW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAje1tbOnJlc3RdXX07XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi4kJHBhcmFtZXRlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBzZWxmLiQkcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXSA9PT0gJ3JlcScpIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRzIGFsd2F5cyBoYXZlIG5hbWVcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyaXR5ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJpdHkgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGFyaXR5LCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEgJiYgYXJpdHkgIT09IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJpdHlgfSBmb3IgI3tgc2VsZi5sZW5ndGhgfSlcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyaWVkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgbGVuZ3RoYH0gZm9yICN7YGFyaXR5YH0pXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoID49IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJGNhbGwuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJpZWQuYXBwbHkobnVsbCxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KCRzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgICByZXN1bHQuJCRpc19jdXJyaWVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgY3VycmllZC4kJGlzX2xhbWJkYSA9IHNlbGYuJCRpc19sYW1iZGE7XG4gICAgICBjdXJyaWVkLiQkaXNfY3VycmllZCA9IHRydWU7XG4gICAgICByZXR1cm4gY3VycmllZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbF9wcm9jID0gc2VsZi4kJG9yaWdpbmFsX3Byb2MgfHwgc2VsZixcbiAgICAgICAgICBwcm9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsX3Byb2MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBwcm9jW3Byb3BdID0gc2VsZltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzID09PSBjYWxsXG4gIGFsaWFzIGNsb25lIGR1cFxuICBhbGlhcyB5aWVsZCBjYWxsXG4gIGFsaWFzIFtdIGNhbGxcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UHJvYz4iLCJuZXciLCJzZWxmIiwiYmxvY2siLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJjYWxsIiwiPj4iLCJvdGhlciIsInByb2MiLCJibG9jayBpbiA+PiIsImJsb2NrICgyIGxldmVscykgaW4gPj4iLCJvdXQiLCJhcmdzIiwidG9fcHJvYyIsIjw8IiwiYmxvY2sgaW4gPDwiLCJibG9jayAoMiBsZXZlbHMpIGluIDw8IiwibGFtYmRhPyIsImFyaXR5Iiwic291cmNlX2xvY2F0aW9uIiwiJHJldF9vcl8xIiwiYmluZGluZyIsIkJpbmRpbmciLCJwYXJhbWV0ZXJzIiwiY3VycnkiLCJPcGFsIiwiY29lcmNlX3RvISIsIkludGVnZXIiLCJkdXAiXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7OztJQUNHQTtJQUNBQTtJQUVEQyxNQUFJQyxJQUFKRCxVQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRSxLQUFBLFFBQU9FLEtBQVAsQ0FBQTtRQUNFQyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ0wsK0NBQXhCSTtNQURWO01BSUFKLE9BQUFFO0lBTEZGLENBQUFBLEdBQUFBOztBQVFBTSxJQUFBQSxvQkFBQUEsZ0JBZEYsRUFjRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFkRjtNQWNXOztBQUVYQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FB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cUI7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxVQUFZdEIsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUNvQiw2QkFBRCxHQUFBLENBQStCQSxNQUEvQixDQUFBLEdBQXVDQSxPQUF2QyxHQUFBLENBQStDQSxLQUEvQyxDQUFBLEdBQXNEQSxHQUE5RXJCO0FBQ3BCcUI7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBdENFQSxDQUFBQSxJQUFBQTs7QUF5Q0FJLElBQUFBLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFkRUEsQ0FBQUEsR0FBQUE7SUFpQkEsYUFBTSxLQUFOLEVBQVUsTUFBVjtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQSxhQUFNLE9BQU4sRUFBWSxNQUFaO0lBQ0E5QixPQUFBLGFBQU0sSUFBTixFQUFTLE1BQVQ7RUE5TEZBLEdBQU0sSUFBTkEsRUFBZ0JELFFBQWhCQztBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTU1MDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBhcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcblxubW9kdWxlIDo6Q29tcGFyYWJsZVxuICAleHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemUod2hhdCkge1xuICAgICAgaWYgKE9wYWwuaXNfYSh3aGF0LCBPcGFsLkludGVnZXIpKSB7IHJldHVybiB3aGF0OyB9XG5cbiAgICAgIGlmICgje2B3aGF0YCA+IDB9KSB7IHJldHVybiAxOyB9XG4gICAgICBpZiAoI3tgd2hhdGAgPCAwfSkgeyByZXR1cm4gLTE7IH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocykge1xuICAgICAgdmFyIGNsYXNzX25hbWU7XG4gICAgICAje1xuICAgICAgICBjYXNlIGByaHNgXG4gICAgICAgIHdoZW4gbmlsLCB0cnVlLCBmYWxzZSwgOjpJbnRlZ2VyLCA6OkZsb2F0XG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJGluc3BlY3QoKWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGBjbGFzc19uYW1lID0gcmhzLiQkY2xhc3NgXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2BsaHNgLmNsYXNzfSB3aXRoICN7YGNsYXNzX25hbWVgfSBmYWlsZWRcIn1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbXBfb3JfZmFpbChsaHMsIHJocykge1xuICAgICAgdmFyIGNtcCA9ICN7YGxoc2AgPD0+IGByaHNgfTtcbiAgICAgIGlmICghJHRydXRoeShjbXApKSBmYWlsX2NvbXBhcmlzb24obGhzLCByaHMpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShjbXApO1xuICAgIH1cbiAgfVxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gdHJ1ZSBpZiBlcXVhbD8ob3RoZXIpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmW1wiJDw9PlwiXSA9PSBPcGFsLktlcm5lbFtcIiQ8PT5cIl0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBmb3IgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICBpZiAoc2VsZi4kJGNvbXBhcmFibGUpIHtcbiAgICAgICAgc2VsZi4kJGNvbXBhcmFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuXG4gICAgYG5vcm1hbGl6ZShjbXApID09IDBgXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPiAwYFxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA+PSAwYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDwgMGBcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPD0gMGBcbiAgZW5kXG5cbiAgZGVmIGJldHdlZW4/KG1pbiwgbWF4KVxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmIDwgbWluXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNlbGYgPiBtYXhcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBjbGFtcChtaW4sIG1heCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBjLCBleGNsO1xuXG4gICAgICBpZiAobWF4ID09PSBuaWwpIHtcbiAgICAgICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCBhIG5ldyBSdWJ5IDIuNyBiZWhhdmlvdXIgdGhhdCB3ZSBhcmUgYWJsZSB0b1xuICAgICAgICAvLyBwcm92aWRlIGEgc2luZ2xlIFJhbmdlIGFyZ3VtZW50IGluc3RlYWQgb2YgMiBDb21wYXJhYmxlcy5cblxuICAgICAgICBpZiAoIU9wYWwuaXNfYShtaW4sIE9wYWwuUmFuZ2UpKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7bWluLmNsYXNzfSAoZXhwZWN0ZWQgUmFuZ2UpXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBleGNsID0gbWluLmV4Y2w7XG4gICAgICAgIG1heCA9IG1pbi5lbmQ7XG4gICAgICAgIG1pbiA9IG1pbi5iZWdpbjtcblxuICAgICAgICBpZiAobWF4ICE9PSBuaWwgJiYgZXhjbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY2Fubm90IGNsYW1wIHdpdGggYW4gZXhjbHVzaXZlIHJhbmdlJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwgJiYgbWF4ICE9PSBuaWwgJiYgY21wX29yX2ZhaWwobWluLCBtYXgpID4gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21pbiBhcmd1bWVudCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggYXJndW1lbnQnfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwpIHtcbiAgICAgICAgYyA9IGNtcF9vcl9mYWlsKHNlbGYsIG1pbik7XG5cbiAgICAgICAgaWYgKGMgPT0gMCkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjIDwgMCkgcmV0dXJuIG1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heCAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtYXgpO1xuXG4gICAgICAgIGlmIChjID4gMCkgcmV0dXJuIG1heDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkNvbXBhcmFibGU+IiwiPiIsIjAiLCI8IiwiJHJldF9vcl8xIiwiSW50ZWdlciIsIkZsb2F0IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiY2xhc3MiLCI8PT4iLCI9PSIsIm90aGVyIiwic2VsZiIsImVxdWFsPyIsImNtcCIsIj49IiwiPD0iLCJiZXR3ZWVuPyIsIm1pbiIsIm1heCIsImNsYW1wIiwiVHlwZUVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7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b0JBQWYsRUFBZ0NhLHNDQUF4QmQ7QUFDcEJjO0FBQ0FBOztBQUVBQTtBQUNBQSxRQUFVZixPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2EsZ0RBQXhCZDtBQUNsQmM7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQXZDRUEsQ0FBQUEsSUFBQUE7RUF4RUZ0QixHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNTY0MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYmFzaWNfb2JqZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgdXNlX3N0cmljdDogdHJ1ZVxuXG5jbGFzcyA6OkJhc2ljT2JqZWN0XG4gIGRlZiBpbml0aWFsaXplKCopXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG5cbiAgZGVmIF9faWRfX1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgICB9XG4gICAgICBPcGFsLnByb3Aoc2VsZiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19zZW5kX18oc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFzeW1ib2wuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tyYWlzZSA6OlR5cGVFcnJvciwgXCIje2luc3BlY3R9IGlzIG5vdCBhIHN5bWJvbCBub3IgYSBzdHJpbmdcIn1cbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bmMgPSBzZWxmWyckJyArIHN5bWJvbF07XG5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgZnVuYy4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRtZXRob2RfbWlzc2luZy4kJHAgPSBibG9jaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHNlbGYsIFtzeW1ib2xdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgIVxuICAgIGZhbHNlXG4gIGVuZFxuICA6Ok9wYWwucHJpc3RpbmUgOiFcblxuICBkZWYgIT0ob3RoZXIpXG4gICAgIShzZWxmID09IG90aGVyKVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXZhbCgqYXJncywgJmJsb2NrKVxuICAgIGlmIGJsb2NrLm5pbD8gJiYgYCEhT3BhbC5jb21waWxlYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gOjpPcGFsLmNvbXBpbGUgc3RyaW5nLCBjb21waWxpbmdfb3B0aW9uc1xuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIGRvXG4gICAgICAgICV4e25ldyBGdW5jdGlvbihcIk9wYWwsc2VsZlwiLCBcInJldHVybiBcIiArIGNvbXBpbGVkKShPcGFsLCBzZWxmKX1cbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrLm5pbD8gJiYgYXJncy5sZW5ndGggPj0gMSAmJiBhcmdzLmZpcnN0WzBdID09ICdAJ1xuICAgICAgIyBnZXQgaW5zdGFuY2UgdmFyaWFibGVcbiAgICAgIHJldHVybiBpbnN0YW5jZV92YXJpYWJsZV9nZXQoYXJncy5maXJzdClcbiAgICBlbHNpZiBhcmdzLmFueT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3Muc2l6ZX0gZm9yIDApXCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIG9sZCA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG5cbiAgICAgIC8vIE5lZWQgdG8gcGFzcyAkJGV2YWwgc28gdGhhdCBtZXRob2QgZGVmaW5pdGlvbnMga25vdyBpZiB0aGlzIGlzXG4gICAgICAvLyBiZWluZyBkb25lIG9uIGEgY2xhc3MvbW9kdWxlLiBDYW5ub3QgYmUgY29tcGlsZXIgZHJpdmVuIHNpbmNlXG4gICAgICAvLyBzZW5kKDppbnN0YW5jZV9ldmFsKSBuZWVkcyB0byB3b3JrLlxuICAgICAgaWYgKHNlbGYuJCRpc19hX21vZHVsZSkge1xuICAgICAgICBzZWxmLiQkZXZhbCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gYmxvY2suY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYmxvY2suY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgIH1cblxuICAgICAgYmxvY2suJCRzID0gb2xkO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX2V4ZWMoKmFyZ3MsICZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBibG9ja19zZWxmID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgaWYgKHNlbGYuJCRpc19hX21vZHVsZSkge1xuICAgICAgICBzZWxmLiQkZXZhbCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgc2VsZi4kJGV2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBibG9jay4kJHMgPSBibG9ja19zZWxmO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfYWRkZWQoKilcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCgqKVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICBpbnNwZWN0X3Jlc3VsdCA9IDo6T3BhbC5pbnNwZWN0KHNlbGYpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb01ldGhvZEVycm9yLm5ldyhcbiAgICAgIFwidW5kZWZpbmVkIG1ldGhvZCBgI3tzeW1ib2x9JyBmb3IgI3tpbnNwZWN0X3Jlc3VsdH1cIiwgc3ltYm9sLCBhcmdzXG4gICAgKSwgbmlsLCA6Oktlcm5lbC5jYWxsZXIoMSlcbiAgZW5kXG5cbiAgOjpPcGFsLnByaXN0aW5lKHNlbGYsIDptZXRob2RfbWlzc2luZylcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtZXRob2RfbmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6QmFzaWNPYmplY3Q+IiwiaW5pdGlhbGl6ZSIsIj09Iiwib3RoZXIiLCJlcWw/Iiwic2VsZiIsIl9faWRfXyIsIl9fc2VuZF9fIiwic3ltYm9sIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJpbnNwZWN0IiwiISIsIk9wYWwiLCJwcmlzdGluZSIsIiE9IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwibmlsPyIsIjEiLCIzIiwiY292ZXI/IiwiYXJncyIsInNpemUiLCJLZXJuZWwiLCJBcmd1bWVudEVycm9yIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsIiRyZXRfb3JfMSIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYmxvY2sgaW4gaW5zdGFuY2VfZXZhbCIsImJsb2NrICgyIGxldmVscykgaW4gaW5zdGFuY2VfZXZhbCIsIj49IiwibGVuZ3RoIiwiZmlyc3QiLCJbXSIsIjAiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCJhbnk/IiwiaW5zdGFuY2VfZXhlYyIsInNpbmdsZXRvbl9tZXRob2RfYWRkZWQiLCJzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQiLCJzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCIsIm1ldGhvZF9taXNzaW5nIiwiaW5zcGVjdF9yZXN1bHQiLCJOb01ldGhvZEVycm9yIiwibmV3IiwiY2FsbGVy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QjtNQXJJN0JBLE9BQUE7SUFxSUVBLENBQUFBLElBQUFBOztBQUdBQyxJQUFBQSx3Q0FBQUEsb0NBeElGLEVBd0lFQTtBQUFBQSxNQUFBQTs7O01BeElGO01Bd0krQjtNQXhJL0JBLE9BQUE7SUF3SUVBLENBQUFBLElBQUFBOztBQUdBQyxJQUFBQSwwQ0FBQUEsc0NBM0lGLEVBMklFQTtBQUFBQSxNQUFBQTs7O01BM0lGO01BMklpQztNQTNJakNBLE9BQUE7SUEySUVBLENBQUFBLElBQUFBOztBQUdBQyxJQUFBQSw4QkFBQUEsMEJBQW1CMUMsTUFBRCxFQTlJcEIsRUE4SUUwQztBQUFBQSxNQUFBQTs7TUFBQUE7OztNQTlJRjtNQThJNkI7TUFDekJDLGlCQUFpQnRDLEtBQU1GLFNBQUFBLENBQVNOLElBQVRNO01BQ3ZCdUMsT0FBQTFCLE9BQVFmLE9BQUFBLENBQU8yQyxvQkFBZUMsS0FBQUEsQ0FDM0JILG9CQUFELEdBQUEsQ0FBcUIxQyxNQUFyQixDQUFBLEdBQTRCMEMsUUFBNUIsR0FBQSxDQUFvQ0MsY0FBcEMsQ0FEYSxFQUN5QzNDLE1BRHpDLEVBQ2lEYyxJQURsQytCLENBQTlCLEVBRUcsR0FGSCxFQUVRN0IsT0FBUThCLFFBQUFBLENBQVFuQyxDQUFSbUMsQ0FGUjdDO0lBRlZ5QyxDQUFBQSxJQUFBQTtJQU9BckMsS0FBTUMsVUFBQUEsQ0FBVVQsSUFBaEIsRUFBc0IsZ0JBQWhCUztJQUVOZCxPQUFBdUQsbUNBQUFBLGdEQUF3QkMsV0FBRCxFQUFjQyxXQUFyQ0Y7QUFBQUE7O01BQXFDLHVDQUFjO01BQ2pEQSxPQUFBO0lBREZBLENBQUFBLElBQUFBO0VBckpGdkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTU4NjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZSwgY29lcmNlX3RvLCBkZW55X2Zyb3plbl9hY2Nlc3NcblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyA6OkVudW1lcmF0b3JcbiAgaW5jbHVkZSA6OkVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2VudW1lcmF0b3IgPSB0cnVlYFxuXG4gIGRlZiBzZWxmLmZvcihvYmplY3QsIG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9iaiA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBvYmoub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgb2JqLnNpemUgICA9IGJsb2NrO1xuICAgICAgb2JqLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIG9iai5hcmdzICAgPSBhcmdzO1xuICAgICAgb2JqLmN1cnNvciA9IDA7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqLCAmYmxvY2spXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBAY3Vyc29yID0gMFxuICAgIGlmIGJsb2NrXG4gICAgICBAb2JqZWN0ID0gR2VuZXJhdG9yLm5ldygmYmxvY2spXG4gICAgICBAbWV0aG9kID0gOmVhY2hcbiAgICAgIEBhcmdzICAgPSBbXVxuICAgICAgQHNpemUgICA9IGBhcmd1bWVudHNbMF0gfHwgbmlsYFxuXG4gICAgICBpZiBAc2l6ZSAmJiAhQHNpemUucmVzcG9uZF90bz8oOmNhbGwpXG4gICAgICAgIEBzaXplID0gYCRjb2VyY2VfdG8oI3tAc2l6ZX0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgQG9iamVjdCA9IGBhcmd1bWVudHNbMF1gXG4gICAgICBAbWV0aG9kID0gYGFyZ3VtZW50c1sxXSB8fCBcImVhY2hcImBcbiAgICAgIEBhcmdzICAgPSBgJHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKWBcbiAgICAgIEBzaXplICAgPSBuaWxcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gc2VsZiBpZiBibG9jay5uaWw/ICYmIGFyZ3MuZW1wdHk/XG5cbiAgICBhcmdzID0gQGFyZ3MgKyBhcmdzXG5cbiAgICByZXR1cm4gc2VsZi5jbGFzcy5uZXcoQG9iamVjdCwgQG1ldGhvZCwgKmFyZ3MpIGlmIGJsb2NrLm5pbD9cblxuICAgIEBvYmplY3QuX19zZW5kX18oQG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHNpemVcbiAgICBAc2l6ZS5yZXNwb25kX3RvPyg6Y2FsbCkgPyBAc2l6ZS5jYWxsKCpAYXJncykgOiBAc2l6ZVxuICBlbmRcblxuICBkZWYgd2l0aF9pbmRleChvZmZzZXQgPSAwLCAmYmxvY2spXG4gICAgb2Zmc2V0ID0gaWYgb2Zmc2V0XG4gICAgICAgICAgICAgICBgJGNvZXJjZV90byhvZmZzZXQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBlbnVtX2Zvcig6d2l0aF9pbmRleCwgb2Zmc2V0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCwgaW5kZXggPSBvZmZzZXQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCBpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRlYWNoKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF93aXRoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfd2l0aF9pbmRleCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc3VwZXJcbiAgICBAb2JqZWN0XG4gIGVuZFxuXG4gIGRlZiByZXdpbmRcbiAgICBAY3Vyc29yID0gMFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcGVla192YWx1ZXNcbiAgICBAdmFsdWVzIHx8PSBtYXAgeyB8Kml8IGkgfVxuICAgIDo6S2VybmVsLnJhaXNlIDo6U3RvcEl0ZXJhdGlvbiwgJ2l0ZXJhdGlvbiByZWFjaGVkIGFuIGVuZCcgaWYgQGN1cnNvciA+PSBAdmFsdWVzLmxlbmd0aFxuICAgIEB2YWx1ZXNbQGN1cnNvcl1cbiAgZW5kXG5cbiAgZGVmIHBlZWtcbiAgICB2YWx1ZXMgPSBwZWVrX3ZhbHVlc1xuICAgIHZhbHVlcy5sZW5ndGggPD0gMSA/IHZhbHVlc1swXSA6IHZhbHVlc1xuICBlbmRcblxuICBkZWYgbmV4dF92YWx1ZXNcbiAgICBvdXQgPSBwZWVrX3ZhbHVlc1xuICAgIEBjdXJzb3IgKz0gMVxuICAgIG91dFxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgIHZhbHVlcyA9IG5leHRfdmFsdWVzXG4gICAgdmFsdWVzLmxlbmd0aCA8PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzXG4gIGVuZFxuXG4gIGRlZiBmZWVkKGFyZylcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIk9wYWwgZG9lc24ndCBzdXBwb3J0IEVudW1lcmF0b3IjZmVlZFwiXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIDo6RW51bWVyYXRvcjo6Q2hhaW4ubmV3KHNlbGYsIG90aGVyKVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9OiAje0BvYmplY3QuaW5zcGVjdH06I3tAbWV0aG9kfVwiXG5cbiAgICBpZiBAYXJncy5hbnk/XG4gICAgICByZXN1bHQgKz0gXCIoI3tAYXJncy5pbnNwZWN0Wzo6UmFuZ2UubmV3KDEsIC0yKV19KVwiXG4gICAgZW5kXG5cbiAgICByZXN1bHQgKyAnPidcbiAgZW5kXG5cbiAgYWxpYXMgd2l0aF9vYmplY3QgZWFjaF93aXRoX29iamVjdFxuXG4gIGF1dG9sb2FkIDpBcml0aG1ldGljU2VxdWVuY2UsICdjb3JlbGliL2VudW1lcmF0b3IvYXJpdGhtZXRpY19zZXF1ZW5jZSdcbiAgYXV0b2xvYWQgOkNoYWluLCAnY29yZWxpYi9lbnVtZXJhdG9yL2NoYWluJ1xuICBhdXRvbG9hZCA6R2VuZXJhdG9yLCAnY29yZWxpYi9lbnVtZXJhdG9yL2dlbmVyYXRvcidcbiAgYXV0b2xvYWQgOkxhenksICdjb3JlbGliL2VudW1lcmF0b3IvbGF6eSdcbiAgYXV0b2xvYWQgOllpZWxkZXIsICdjb3JlbGliL2VudW1lcmF0b3IveWllbGRlcidcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpFbnVtZXJhdG9yPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiZm9yIiwib2JqZWN0IiwiYWxsb2NhdGUiLCJpbml0aWFsaXplIiwiQGN1cnNvciIsIjAiLCJibG9jayIsIkBvYmplY3QiLCJuZXciLCJHZW5lcmF0b3IiLCJ0b19wcm9jIiwiQG1ldGhvZCIsIkBhcmdzIiwiQHNpemUiLCJyZXNwb25kX3RvPyIsIkludGVnZXIiLCJlYWNoIiwibmlsPyIsImFyZ3MiLCJlbXB0eT8iLCIrIiwiY2xhc3MiLCJfX3NlbmRfXyIsInNpemUiLCJjYWxsIiwid2l0aF9pbmRleCIsIm9mZnNldCIsImVudW1fZm9yIiwiYmxvY2sgaW4gd2l0aF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gd2l0aF9pbmRleCIsIk9wYWwiLCJkZXN0cnVjdHVyZSIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrX2dpdmVuPyIsImJsb2NrIGluIGVhY2hfd2l0aF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF93aXRoX2luZGV4IiwicmV3aW5kIiwicGVla192YWx1ZXMiLCJAdmFsdWVzIiwiJHJldF9vcl8xIiwibWFwIiwiYmxvY2sgaW4gcGVla192YWx1ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIHBlZWtfdmFsdWVzIiwiaSIsIj49IiwibGVuZ3RoIiwiS2VybmVsIiwicmFpc2UiLCJTdG9wSXRlcmF0aW9uIiwiW10iLCJwZWVrIiwidmFsdWVzIiwiPD0iLCIxIiwibmV4dF92YWx1ZXMiLCJvdXQiLCJuZXh0IiwiZmVlZCIsImFyZyIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJvdGhlciIsIkVudW1lcmF0b3I6OkNoYWluIiwiRW51bWVyYXRvciIsImluc3BlY3QiLCJyZXN1bHQiLCJhbnk/IiwiUmFuZ2UiLCItMiIsImF1dG9sb2FkIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxpQkFBUkQ7SUFFQ0Q7SUFFREcsTUFBSUwsSUFBSkssVUFBQUEsMkJBQWFDLE1BQUQsRUFUZCxFQVNjLEVBVGQsRUFTRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFURjs7TUFTdUIsdURBQUEsNkJBQVM7TUFBTzs7QUFFdkNBLGdCQUFrQkwsSUFBQU8sVUFBQUEsQ0FBQUEsQ0FBU0Y7O0FBRTNCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFYRUEsQ0FBQUEsSUFBQUE7O0FBY0FHLElBQUFBLDBCQUFBQSxzQkF2QkYsRUF1QkVBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BdkJGO01BdUJpQjtNQUNaQTtNQUVEQyxjQUFVQztNQUNWLElBQUEsUUFBR0MsS0FBSCxDQUFBOztRQUNFQyxjQUFtQkMsTUFBVEMsZUFBU0QsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTUYsS0FBREksU0FBQUEsQ0FBQUEsQ0FBTEY7UUFDbkJHLGNBQVU7UUFDVkMsWUFBVTtRQUNWQyxZQUFXVjtR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RSx3Q0FBOUJ1RTtJQUNBekUsSUFBQXlFLFVBQUFBLENBQVMsT0FBVCxFQUFpQnZFLDBCQUFqQnVFO0lBQ0F6RSxJQUFBeUUsVUFBQUEsQ0FBUyxXQUFULEVBQXFCdkUsOEJBQXJCdUU7SUFDQXpFLElBQUF5RSxVQUFBQSxDQUFTLE1BQVQsRUFBZ0J2RSx5QkFBaEJ1RTtJQUNBdkUsT0FBQUYsSUFBQXlFLFVBQUFBLENBQVMsU0FBVCxFQUFtQnZFLDRCQUFuQnVFO0VBMUlGdkUsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTYwOTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jvb2xlYW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyB1c2Vfc3RyaWN0OiB0cnVlXG5cbmNsYXNzIDo6Qm9vbGVhbiA8IGBCb29sZWFuYFxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2Jvb2xlYW4nLCB0cnVlKWBcblxuICAleHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFsnJCRjbGFzcycsICckJG1ldGEnXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsIHByb3BlcnRpZXNbaV0sIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcyA9PSB0cnVlICA/IE9wYWwuVHJ1ZUNsYXNzIDpcbiAgICAgICAgICAgICAgICAgdGhpcyA9PSBmYWxzZSA/IE9wYWwuRmFsc2VDbGFzcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcGFsLkJvb2xlYW47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCBcIiQkaWRcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSB0cnVlICA/IDIgOlxuICAgICAgICAgICAgICAgdGhpcyA9PSBmYWxzZSA/IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudmFsdWVPZigpID8gMiA6IDBgXG4gIGVuZFxuXG4gIGRlZiAhXG4gICAgYHNlbGYgIT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKSA6IGZhbHNlYFxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyB0cnVlIDogKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKWBcbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyID09PSBmYWxzZSB8fCBvdGhlciA9PT0gbmlsKSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPT09IG90aGVyLnZhbHVlT2YoKWBcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBzZWxmLiQkbWV0YWBcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvaXNzdWVzLzIyMzBcbiAgI1xuICAjIFRoaXMgaXMgYSBoYWNrIHRoYXQgYWxsb3dzIHlvdSB0byBhZGQgbWV0aG9kcyB0byBUcnVlQ2xhc3MgYW5kIEZhbHNlQ2xhc3MuXG4gICMgRG8gbm90ZSwgdGhhdCB3aGlsZSB0cnVlIGFuZCBmYWxzZSBoYXZlIGEgY29ycmVjdCAkJGNsYXNzIChpdCdzIGVpdGhlclxuICAjIFRydWVDbGFzcyBvciBGYWxzZUNsYXNzKSwgdGhlaXIgcHJvdG90eXBlIGlzIGBCb29sZWFuLiQkcHJvdG90eXBlYCwgd2hpY2hcbiAgIyBiYXNpY2FsbHkgbWVhbnMgdGhhdCB3aGVuIGNhbGxpbmcgYHRydWUuc29tZXRoaW5nYCB3ZSBhY3R1YWxseSBjYWxsXG4gICMgYEJvb2xlYW4jc29tZXRoaW5nYCBpbnN0ZWFkIG9mIGBUcnVlQ2xhc3Mjc29tZXRoaW5nYC4gU28gdXNpbmdcbiAgIyBtZXRob2RfbWlzc2luZyB3ZSBkaXNwYXRjaCBpdCB0byBgVHJ1ZUNsYXNzL0ZhbHNlQ2xhc3Mjc29tZXRoaW5nYCBjb3JyZWN0bHkuXG4gICNcbiAgIyBUaGUgZG93bnNpZGUgaXMgdGhhdCBhIGNvcnJlY3QgaW1wbGVtZW50YXRpb24gd291bGQgYWxzbyBhbGxvdyB1cyB0byBvdmVycmlkZVxuICAjIHRoZSBtZXRob2RzIGRlZmluZWQgb24gQm9vbGVhbiwgYnV0IG91ciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IGFsbG93IHRoYXQsXG4gICMgdW5sZXNzIHlvdSBkZWZpbmUgdGhlbSBvbiBCb29sZWFuIGFuZCBub3Qgb24gVHJ1ZUNsYXNzL0ZhbHNlQ2xhc3MuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgYHZhciBib2R5ID0gc2VsZi4kJGNsYXNzLiQkcHJvdG90eXBlWyckJyArICN7bWV0aG9kfV1gXG4gICAgc3VwZXIgdW5sZXNzIGB0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWJvZHkuJCRzdHViYFxuICAgIGBPcGFsLnNlbmQoc2VsZiwgYm9keSwgI3thcmdzfSwgI3tibG9ja30pYFxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtZXRob2QsIF9pbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGB2YXIgYm9keSA9IHNlbGYuJCRjbGFzcy4kJHByb3RvdHlwZVsnJCcgKyAje21ldGhvZH1dYFxuICAgIGB0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWJvZHkuJCRzdHViYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIGVxdWFsPyA9PVxuICBhbGlhcyBpbnNwZWN0IHRvX3NcbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuZW5kXG5cbmNsYXNzIDo6VHJ1ZUNsYXNzIDwgOjpCb29sZWFuOyBlbmRcbmNsYXNzIDo6RmFsc2VDbGFzcyA8IDo6Qm9vbGVhbjsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpCb29sZWFuPiIsImFsbG9jYXRlIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJzZWxmIiwibmFtZSIsIl9faWRfXyIsIiEiLCImIiwib3RoZXIiLCJ8IiwiXiIsIj09Iiwic2luZ2xldG9uX2NsYXNzIiwidG9fcyIsImR1cCIsImNsb25lIiwiJGt3YXJncyIsIm1ldGhvZF9taXNzaW5nIiwibWV0aG9kIiwiYXJncyIsImJsb2NrIiwicmVzcG9uZF90b19taXNzaW5nPyIsIl9pbmNsdWRlX2FsbCIsIjxjbGFzczpUcnVlQ2xhc3M+IiwiQm9vbGVhbiIsIjxjbGFz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QTFCLE9BQUE0QixRQUFNLElBQU5BLEVBQXFCRCxjQUFyQkM7QUE3R0E1QjsifX0seyJvZmZzZXQiOnsibGluZSI6MTYyMzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCByZXNwb25kX3RvLCBPcGFsLCBkZW55X2Zyb3plbl9hY2Nlc3MsIGZyZWV6ZSwgZnJlZXplX3Byb3BzXG4jIHVzZV9zdHJpY3Q6IHRydWVcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiA9fihvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmICF+KG9iailcbiAgICAhKHNlbGYgPX4gb2JqKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIG9iamVjdF9pZCA9PSBvdGhlci5vYmplY3RfaWQgfHwgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgICV4e1xuICAgICAgLy8gc2V0IGd1YXJkIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIHNlbGYuJCRjb21wYXJhYmxlID0gdHJ1ZTtcblxuICAgICAgdmFyIHggPSAje3NlbGYgPT0gb3RoZXJ9O1xuXG4gICAgICBpZiAoeCAmJiB4ICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aCA9IHNlbGZbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLmNsYXNzfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6Ok1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGYuY2xhc3N9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kcyhhbGwgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCR0cnV0aHkoI3thbGx9KSkge1xuICAgICAgICByZXR1cm4gT3BhbC5tZXRob2RzKHNlbGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwub3duX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHVibGljX21ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLnJlY2VpdmVyX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgQXJyYXkob2JqZWN0KVxuICAgICV4e1xuICAgICAgdmFyIGNvZXJjZWQ7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBjb2VyY2VkID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhvYmplY3QsIDo6QXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7OjpPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCA6OkFycmF5LCA6dG9fYSl9O1xuICAgICAgaWYgKGNvZXJjZWQgIT09IG5pbCkgeyByZXR1cm4gY29lcmNlZDsgfVxuXG4gICAgICByZXR1cm4gW29iamVjdF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXRfZXhpdCgmYmxvY2spXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuICAgICRfX2F0X2V4aXRfXyA8PCBibG9ja1xuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBjYWxsZXIoc3RhcnQgPSAxLCBsZW5ndGggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgc3RhY2ssIHJlc3VsdDtcblxuICAgICAgc3RhY2sgPSBuZXcgRXJyb3IoKS4kYmFja3RyYWNlKCk7XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9ICN7c3RhcnR9ICsgMSwgaWkgPSBzdGFjay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICghc3RhY2tbaV0ubWF0Y2goL3J1bnRpbWVcXC5qcy8pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2tbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoICE9IG5pbCkgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhbGxlcl9sb2NhdGlvbnMoKmFyZ3MpXG4gICAgY2FsbGVyKCphcmdzKS5tYXAgZG8gfGxvY3xcbiAgICAgIDo6VGhyZWFkOjpCYWNrdHJhY2U6OkxvY2F0aW9uLm5ldyhsb2MpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjbGFzc1xuICAgIGBzZWxmLiQkY2xhc3NgXG4gIGVuZFxuXG4gIGRlZiBjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3RoZXIpLCBpLCBpaSwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHNlbGZbbmFtZV0gPSBvdGhlcltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfc2luZ2xldG9uX21ldGhvZHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbmFtZSwgbmFtZXMsIGxlbmd0aDtcblxuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KCckJG1ldGEnKSAmJiBvdGhlci4kJG1ldGEgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG90aGVyX3NpbmdsZXRvbl9jbGFzcyA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvdGhlcik7XG4gICAgICAgIHZhciBzZWxmX3NpbmdsZXRvbl9jbGFzcyA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKTtcbiAgICAgICAgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChuYW1lKSkge1xuICAgICAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGVbbmFtZV0gPSBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGVbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCA9IE9iamVjdC5hc3NpZ24oe30sIG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJGNvbnN0KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFxuICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlLFxuICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXIpLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJyQnICYmIG5hbWUuY2hhckF0KDEpICE9PSAnJCcgJiYgb3RoZXIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBzZWxmW25hbWVdID0gb3RoZXJbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IG5pbClcbiAgICB1bmxlc3MgZnJlZXplLm5pbD8gfHwgZnJlZXplID09IHRydWUgfHwgZnJlZXplID09IGZhbHNlXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdmFsdWUgZm9yIGZyZWV6ZTogI3tmcmVlemUuY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYsIGZyZWV6ZTogZnJlZXplKVxuXG4gICAgaWYgZnJlZXplID09IHRydWUgfHwgKGZyZWV6ZS5uaWw/ICYmIGZyb3plbj8pXG4gICAgICBjb3B5LmZyZWV6ZVxuICAgIGVuZFxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jbG9uZShvdGhlciwgZnJlZXplOiBuaWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHNpbmdsZXRvbl9jbGFzcy5kZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHNlbGYuY2xhc3MuYWxsb2NhdGVcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICA6OkVudW1lcmF0b3IuZm9yKHNlbGYsIG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBleGl0KHN0YXR1cyA9IHRydWUpXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuXG4gICAgdW50aWwgJF9fYXRfZXhpdF9fLmVtcHR5P1xuICAgICAgYmxvY2sgPSAkX19hdF9leGl0X18ucG9wXG4gICAgICBibG9jay5jYWxsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzdGF0dXMuJCRpc19ib29sZWFuKSB7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyA/IDAgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gJGNvZXJjZV90byhzdGF0dXMsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpXG4gICAgICB9XG5cbiAgICAgIE9wYWwuZXhpdChzdGF0dXMpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIGlmIChtb2RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMCwgZXhwZWN0ZWQgMSspJ31cbiAgICAgIH1cblxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHNpbmdsZXRvbiA9ICN7c2luZ2xldG9uX2NsYXNzfTtcblxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBgc2luZ2xldG9uYH07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kX29iamVjdCBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5leHRlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Yoc2VsZikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgJGZyZWV6ZV9wcm9wcyhzZWxmKTtcbiAgICAgICAgcmV0dXJuICRmcmVlemUoc2VsZik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgJXh7XG4gICAgICBzd2l0Y2ggKHR5cGVvZihzZWxmKSkge1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIHJldHVybiAoc2VsZi4kJGZyb3plbiB8fCBmYWxzZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0cygqYXJncylcbiAgICAkc3RkaW4uZ2V0cygqYXJncylcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBfX2lkX19cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgYHZhciBpbnNwZWN0X3N0YWNrID0gW11gXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpdnMgPSAnJ1xuICAgIGlkID0gX19pZF9fXG4gICAgaWYgYGluc3BlY3Rfc3RhY2tgLmluY2x1ZGU/IGlkXG4gICAgICBpdnMgPSAnIC4uLidcbiAgICBlbHNlXG4gICAgICBgaW5zcGVjdF9zdGFja2AgPDwgaWRcbiAgICAgIHB1c2hlZCA9IHRydWVcbiAgICAgIGluc3RhbmNlX3ZhcmlhYmxlcy5lYWNoIGRvIHxpfFxuICAgICAgICBpdmFyID0gaW5zdGFuY2VfdmFyaWFibGVfZ2V0KGkpXG4gICAgICAgIGluc3BlY3QgPSBPcGFsLmluc3BlY3QoaXZhcilcbiAgICAgICAgaXZzICs9IFwiICN7aX09I3tpbnNwZWN0fVwiXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7aWQudG9fcygxNil9I3tpdnN9PlwiXG4gIHJlc2N1ZSA9PiBlXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje2lkLnRvX3MoMTYpfT5cIlxuICBlbnN1cmVcbiAgICBgaW5zcGVjdF9zdGFja2AucG9wIGlmIHB1c2hlZFxuICBlbmRcblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2xhc3MgPT09IGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLCBuYW1lLnN1YnN0cigxKSlgXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBpdmFyID0gc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXTtcblxuICAgICAgcmV0dXJuIGl2YXIgPT0gbnVsbCA/IG5pbCA6IGl2YXI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfc2V0KG5hbWUsIHZhbHVlKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgbmFtZSA9IDo6T3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYHNlbGZbT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKV0gPSB2YWx1ZWBcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9pbnN0YW5jZV92YXJpYWJsZShuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgdmFyIGtleSA9IE9wYWwuaXZhcihuYW1lLnN1YnN0cigxKSksXG4gICAgICAgICAgdmFsO1xuICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWwgPSBzZWxmW2tleV07XG4gICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwiaW5zdGFuY2UgdmFyaWFibGUgI3tuYW1lfSBub3QgZGVmaW5lZFwiXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaXZhcjtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUuY2hhckF0KDApICE9PSAnJCcpIHtcbiAgICAgICAgICBpZiAobmFtZS5zdWJzdHIoLTEpID09PSAnJCcpIHtcbiAgICAgICAgICAgIGl2YXIgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl2YXIgPSBuYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCgnQCcgKyBpdmFyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEludGVnZXIodmFsdWUsIGJhc2UgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc3RyLCBiYXNlX2RpZ2l0cztcblxuICAgICAgaWYgKCF2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdiYXNlIHNwZWNpZmllZCBmb3Igbm9uIHN0cmluZyB2YWx1ZSd9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgbmlsIGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHwgdmFsdWUgPT09IC1JbmZpbml0eSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCB2YWx1ZX1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/KDp0b19pbnQpfSkge1xuICAgICAgICAgIGkgPSAje3ZhbHVlLnRvX2ludH07XG4gICAgICAgICAgaWYgKGkgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAjezo6T3BhbC5jb2VyY2VfdG8hKHZhbHVlLCA6OkludGVnZXIsIDp0b19pKX07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCIwXCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmFzZSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlID0gJGNvZXJjZV90byhiYXNlLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKGJhc2UgPT09IDEgfHwgYmFzZSA8IDAgfHwgYmFzZSA+IDM2KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJ9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgJyQxJyk7XG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pLywgZnVuY3Rpb24gKF8sIGhlYWQsIGZsYWcpIHtcbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAyKSB7XG4gICAgICAgICAgICBiYXNlID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDgpIHtcbiAgICAgICAgICAgIGJhc2UgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAxMCkge1xuICAgICAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAxNikge1xuICAgICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9KTtcblxuICAgICAgYmFzZSA9IChiYXNlID09PSAwID8gMTAgOiBiYXNlKTtcblxuICAgICAgYmFzZV9kaWdpdHMgPSAnMC0nICsgKGJhc2UgPD0gMTAgPyBiYXNlIC0gMSA6ICc5YS0nICsgU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIChiYXNlIC0gMTEpKSk7XG5cbiAgICAgIGlmICghKG5ldyBSZWdFeHAoJ15cXFxccypbKy1dP1snICsgYmFzZV9kaWdpdHMgKyAnXStcXFxccyokJykpLnRlc3Qoc3RyKSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgaSA9IHBhcnNlSW50KHN0ciwgYmFzZSk7XG5cbiAgICAgIGlmIChpc05hTihpKSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgRmxvYXQodmFsdWUpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgbmlsIGludG8gRmxvYXRcIn1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgJyQxJyk7XG5cbiAgICAgICAgLy9TcGVjaWFsIGNhc2UgZm9yIGhleCBzdHJpbmdzIG9ubHk6XG4gICAgICAgIGlmICgvXlxccypbLStdPzBbeFhdWzAtOWEtZkEtRl0rXFxzKiQvLnRlc3Qoc3RyKSkge1xuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkludGVnZXIoYHN0cmApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghL15cXHMqWy0rXT9bMC05XSpcXC4/WzAtOV0rKFtlRV1bLStdP1swLTldKyk/XFxzKiQvLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEZsb2F0KCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAjezo6T3BhbC5jb2VyY2VfdG8hKHZhbHVlLCA6OkZsb2F0LCA6dG9fZil9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEhhc2goYXJnKVxuICAgIHJldHVybiB7fSBpZiBhcmcubmlsPyB8fCBhcmcgPT0gW11cbiAgICByZXR1cm4gYXJnIGlmIDo6SGFzaCA9PT0gYXJnXG4gICAgOjpPcGFsLmNvZXJjZV90byEoYXJnLCA6Okhhc2gsIDp0b19oYXNoKVxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgJXh7XG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MgJiYgIWtsYXNzLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdjbGFzcyBvciBtb2R1bGUgcmVxdWlyZWQnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9wYWwuaXNfYShzZWxmLCBrbGFzcyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaXRzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhKCZibG9jaylcbiAgICBgT3BhbC5sYW1iZGEoYmxvY2spYFxuICBlbmRcblxuICBkZWYgbG9hZChmaWxlKVxuICAgIGZpbGUgPSA6Ok9wYWwuY29lcmNlX3RvIShmaWxlLCA6OlN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5sb2FkKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgbG9vcFxuICAgIHJldHVybiBlbnVtX2Zvcig6bG9vcCkgeyA6OkZsb2F0OjpJTkZJTklUWSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIHRydWVcbiAgICAgIGJlZ2luXG4gICAgICAgIHlpZWxkXG4gICAgICByZXNjdWUgOjpTdG9wSXRlcmF0aW9uID0+IGVcbiAgICAgICAgcmV0dXJuIGUucmVzdWx0XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgcHJpbnRmKCphcmdzKVxuICAgIGlmIGFyZ3MuYW55P1xuICAgICAgcHJpbnQgZm9ybWF0KCphcmdzKVxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBwcm9jKCZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBQcm9jIG9iamVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgZW5kXG5cbiAgICBgYmxvY2suJCRpc19sYW1iZGEgPSBmYWxzZWBcbiAgICBibG9ja1xuICBlbmRcblxuICBkZWYgcHV0cygqc3RycylcbiAgICAkc3Rkb3V0LnB1dHMoKnN0cnMpXG4gIGVuZFxuXG4gIGRlZiBwKCphcmdzKVxuICAgIGFyZ3MuZWFjaCB7IHxvYmp8ICRzdGRvdXQucHV0cyBvYmouaW5zcGVjdCB9XG5cbiAgICBhcmdzLmxlbmd0aCA8PSAxID8gYXJnc1swXSA6IGFyZ3NcbiAgZW5kXG5cbiAgZGVmIHByaW50KCpzdHJzKVxuICAgICRzdGRvdXQucHJpbnQoKnN0cnMpXG4gIGVuZFxuXG4gIGRlZiByZWFkbGluZSgqYXJncylcbiAgICAkc3RkaW4ucmVhZGxpbmUoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiB3YXJuKCpzdHJzLCB1cGxldmVsOiBuaWwpXG4gICAgaWYgdXBsZXZlbFxuICAgICAgdXBsZXZlbCA9IDo6T3BhbC5jb2VyY2VfdG8hKHVwbGV2ZWwsIDo6SW50ZWdlciwgOnRvX3N0cilcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJuZWdhdGl2ZSBsZXZlbCAoI3t1cGxldmVsfSlcIiBpZiB1cGxldmVsIDwgMFxuICAgICAgbG9jYXRpb24gPSBjYWxsZXIodXBsZXZlbCArIDEsIDEpLmZpcnN0Ji5zcGxpdCgnOmluIGAnKSYuZmlyc3RcbiAgICAgIGxvY2F0aW9uID0gXCIje2xvY2F0aW9ufTogXCIgaWYgbG9jYXRpb25cbiAgICAgIHN0cnMgPSBzdHJzLm1hcCB7IHxzfCBcIiN7bG9jYXRpb259d2FybmluZzogI3tzfVwiIH1cbiAgICBlbmRcblxuICAgICRzdGRlcnIucHV0cygqc3RycykgdW5sZXNzICRWRVJCT1NFLm5pbD8gfHwgc3Rycy5lbXB0eT9cbiAgZW5kXG5cbiAgZGVmIHJhaXNlKGV4Y2VwdGlvbiA9IHVuZGVmaW5lZCwgc3RyaW5nID0gbmlsLCBiYWNrdHJhY2UgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwgJiYgI3skIX0gIT09IG5pbCkge1xuICAgICAgICB0aHJvdyAjeyQhfTtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBleGNlcHRpb24gPSAjezo6UnVudGltZUVycm9yLm5ldyAnJ307XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgkcmVzcG9uZF90byhleGNlcHRpb24sICckdG9fc3RyJykpIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3s6OlJ1bnRpbWVFcnJvci5uZXcgZXhjZXB0aW9uLnRvX3N0cn07XG4gICAgICB9XG4gICAgICAvLyB1c2luZyByZXNwb25kX3RvPyBhbmQgbm90IGFuIHVuZGVmaW5lZCBjaGVjayB0byBhdm9pZCBtZXRob2RfbWlzc2luZyBtYXRjaGluZyBhcyB0cnVlXG4gICAgICBlbHNlIGlmIChleGNlcHRpb24uJCRpc19jbGFzcyAmJiAkcmVzcG9uZF90byhleGNlcHRpb24sICckZXhjZXB0aW9uJykpIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3tleGNlcHRpb24uZXhjZXB0aW9uIHN0cmluZ307XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChleGNlcHRpb24uJCRpc19leGNlcHRpb24pIHtcbiAgICAgICAgLy8gZXhjZXB0aW9uIGlzIGZpbmVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBleGNlcHRpb24gPSAjezo6VHlwZUVycm9yLm5ldyAnZXhjZXB0aW9uIGNsYXNzL29iamVjdCBleHBlY3RlZCd9O1xuICAgICAgfVxuXG4gICAgICBpZiAoYmFja3RyYWNlICE9PSBuaWwpIHtcbiAgICAgICAgZXhjZXB0aW9uLiRzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgjeyQhfSAhPT0gbmlsKSB7XG4gICAgICAgIE9wYWwuZXhjZXB0aW9ucy5wdXNoKCN7JCF9KTtcbiAgICAgIH1cblxuICAgICAgI3skIX0gPSBleGNlcHRpb247XG4gICAgICAjeyRAfSA9ICN7YGV4Y2VwdGlvbmAuYmFja3RyYWNlfTtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJhbmQobWF4ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAjezo6UmFuZG9tOjpERUZBVUxULnJhbmR9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChtYXggPCAwKSB7XG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggJSAxICE9PSAwKSB7XG4gICAgICAgICAgbWF4ID0gbWF4LiR0b19pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ID09PSAwKSB7XG4gICAgICAgICAgbWF4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIDo6UmFuZG9tOjpERUZBVUxULnJhbmQobWF4KVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZlsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZihib2R5KSA9PT0gXCJmdW5jdGlvblwiICYmICFib2R5LiQkc3R1Yikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGZbJyRyZXNwb25kX3RvX21pc3Npbmc/J10uJCRwcmlzdGluZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tyZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtZXRob2RfbmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBmYWxzZVxuICBlbmRcblxuICA6Ok9wYWwucHJpc3RpbmUoc2VsZiwgOnJlc3BvbmRfdG8/LCA6cmVzcG9uZF90b19taXNzaW5nPylcblxuICBkZWYgcmVxdWlyZShmaWxlKVxuICAgICV4e1xuICAgICAgLy8gQXMgT2JqZWN0LnJlcXVpcmUgcmVmZXJzIHRvIEtlcm5lbC5yZXF1aXJlIG9uY2UgS2VybmVsIGhhcyBiZWVuIGxvYWRlZCB0aGUgU3RyaW5nXG4gICAgICAvLyBjbGFzcyBtYXkgbm90IGJlIGF2YWlsYWJsZSB5ZXQsIHRoZSBjb2VyY2lvbiByZXF1aXJlcyBib3RoICBTdHJpbmcgYW5kIEFycmF5IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmICh0eXBlb2YgI3tmaWxlfSAhPT0gJ3N0cmluZycgJiYgT3BhbC5TdHJpbmcgJiYgT3BhbC5BcnJheSkge1xuICAgICAgICAje2ZpbGUgPSA6Ok9wYWwuY29lcmNlX3RvIShmaWxlLCA6OlN0cmluZywgOnRvX3N0cikgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIE9wYWwucmVxdWlyZSgje2ZpbGV9KVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlcXVpcmVfcmVsYXRpdmUoZmlsZSlcbiAgICA6Ok9wYWwudHJ5X2NvbnZlcnQhKGZpbGUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuICAgIGZpbGUgPSA6OkZpbGUuZXhwYW5kX3BhdGggOjpGaWxlLmpvaW4oYE9wYWwuY3VycmVudF9maWxlYCwgJy4uJywgZmlsZSlcblxuICAgIGBPcGFsLnJlcXVpcmUoI3tmaWxlfSlgXG4gIGVuZFxuXG4gICMgYHBhdGhgIHNob3VsZCBiZSB0aGUgZnVsbCBwYXRoIHRvIGJlIGZvdW5kIGluIHJlZ2lzdGVyZWQgbW9kdWxlcyAoYE9wYWwubW9kdWxlc2ApXG4gIGRlZiByZXF1aXJlX3RyZWUocGF0aCwgYXV0b2xvYWQ6IGZhbHNlKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBwYXRoID0gI3s6OkZpbGUuZXhwYW5kX3BhdGgocGF0aCl9XG4gICAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAocGF0aCA9PT0gJy4nKSBwYXRoID0gJyc7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIE9wYWwubW9kdWxlcykge1xuICAgICAgICBpZiAoI3tgbmFtZWAuc3RhcnRfd2l0aD8ocGF0aCl9KSB7XG4gICAgICAgICAgaWYoISN7YXV0b2xvYWR9KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgT3BhbC5yZXF1aXJlKG5hbWUpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtuYW1lLCB0cnVlXSk7IC8vIGRvIG5vdGhpbmcsIGRlbGVnYXRlZCB0byBhIGF1dG9sb2FkaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIHNsZWVwKHNlY29uZHMgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc2Vjb25kcyA9PT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBOaWxDbGFzcyBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cbiAgICAgIH1cbiAgICAgIGlmICghc2Vjb25kcy4kJGlzX251bWJlcikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWNvbmRzLmNsYXNzfSBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cbiAgICAgIH1cbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RpbWUgaW50ZXJ2YWwgbXVzdCBiZSBwb3NpdGl2ZSd9XG4gICAgICB9XG4gICAgICB2YXIgZ2V0X3RpbWUgPSBPcGFsLmdsb2JhbC5wZXJmb3JtYW5jZSA/XG4gICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX0gOlxuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gbmV3IERhdGUoKX1cblxuICAgICAgdmFyIHQgPSBnZXRfdGltZSgpO1xuICAgICAgd2hpbGUgKGdldF90aW1lKCkgLSB0IDw9IHNlY29uZHMgKiAxMDAwKTtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNlY29uZHMpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNyYW5kKHNlZWQgPSBSYW5kb20ubmV3X3NlZWQpXG4gICAgOjpSYW5kb20uc3JhbmQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIFN0cmluZyhzdHIpXG4gICAgOjpPcGFsLmNvZXJjZV90bz8oc3RyLCA6OlN0cmluZywgOnRvX3N0cikgfHxcbiAgICAgIDo6T3BhbC5jb2VyY2VfdG8hKHN0ciwgOjpTdHJpbmcsIDp0b19zKVxuICBlbmRcblxuICBkZWYgdGFwKCZibG9jaylcbiAgICB5aWVsZCBzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBkZWYgY2F0Y2godGFnID0gbmlsKVxuICAgIHRhZyB8fD0gOjpPYmplY3QubmV3XG4gICAgeWllbGQodGFnKVxuICByZXNjdWUgOjpVbmNhdWdodFRocm93RXJyb3IgPT4gZVxuICAgIHJldHVybiBlLnZhbHVlIGlmIGUudGFnID09IHRhZ1xuICAgIDo6S2VybmVsLnJhaXNlXG4gIGVuZFxuXG4gIGRlZiB0aHJvdyh0YWcsIG9iaiA9IG5pbClcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlVuY2F1Z2h0VGhyb3dFcnJvci5uZXcodGFnLCBvYmopXG4gIGVuZFxuXG4gICMgYmFzaWMgaW1wbGVtZW50YXRpb24gb2Ygb3BlbiwgZGVsZWdhdGUgdG8gRmlsZS5vcGVuXG4gIGRlZiBvcGVuKCphcmdzLCAmYmxvY2spXG4gICAgOjpGaWxlLm9wZW4oKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHlpZWxkX3NlbGZcbiAgICByZXR1cm4gZW51bV9mb3IoOnlpZWxkX3NlbGYpIHsgMSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICB5aWVsZCBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGZhaWwgcmFpc2VcbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuICBhbGlhcyBwdWJsaWNfc2VuZCBfX3NlbmRfX1xuICBhbGlhcyBzZW5kIF9fc2VuZF9fXG4gIGFsaWFzIHRoZW4geWllbGRfc2VsZlxuICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG5lbmRcblxuY2xhc3MgOjpPYmplY3RcbiAgIyBPYmplY3QucmVxdWlyZSBoYXMgYmVlbiBzZXQgdG8gcnVudGltZS5qcyBPcGFsLnJlcXVpcmVcbiAgIyBOb3cgd2UgaGF2ZSBLZXJuZWwgbG9hZGVkLCBtYWtlIHN1cmUgT2JqZWN0LnJlcXVpcmUgcmVmZXJzIHRvIEtlcm5lbC5yZXF1aXJlXG4gICMgd2hpY2ggaXMgd2hhdCBydWJ5IGRvZXMgYW5kIGFsbG93cyBmb3Igb3ZlcndyaXRpbmcgYnkgYXV0b2xvYWRlcnNcbiAgYGRlbGV0ZSAkT2JqZWN0LiQkcHJvdG90eXBlLiRyZXF1aXJlYFxuICBpbmNsdWRlIDo6S2VybmVsXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiPX4iLCIhfiIsIm9iaiIsInNlbGYiLCIhIiwiPT09Iiwib3RoZXIiLCIkcmV0X29yXzEiLCJvYmplY3RfaWQiLCI9PSIsIjw9PiIsIm1ldGhvZCIsIm5hbWUiLCJLZXJuZWwiLCJyYWlzZSIsIk5hbWVFcnJvciIsIm5ldyIsImNsYXNzIiwiTWV0aG9kIiwibWV0aG9kcyIsImFsbCIsInB1YmxpY19tZXRob2RzIiwiQXJyYXkiLCJvYmplY3QiLCJPcGFsIiwiY29lcmNlX3RvPyIsImF0X2V4aXQiLCIkX19hdF9leGl0X18iLCI8PCIsImJsb2NrIiwiY2FsbGVyIiwic3RhcnQiLCJsZW5ndGgiLCIxIiwiY2FsbGVyX2xvY2F0aW9ucyIsIm1hcCIsImFyZ3MiLCJibG9jayBpbiBjYWxsZXJfbG9jYXRpb25zIiwibG9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjYWxsZXJfbG9jYXRpb25zIiwiVGhyZWFkOjpCYWNrdHJhY2U6OkxvY2F0aW9uIiwiVGhyZWFkOjpCYWNrdHJhY2UiLCJUaHJlYWQiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJjbG9uZSIsIiRrd2FyZ3MiLCJmcmVlemUiLCJuaWw/IiwiQXJndW1lbnRFcnJvciIsImNvcHkiLCJhbGxvY2F0ZSIsImluaXRpYWxpemVfY2xvbmUiLCJmcm96ZW4/IiwiaW5pdGlhbGl6ZV9jb3B5IiwiZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QiLCJkZWZpbmVfbWV0aG9kIiwic2luZ2xldG9uX2NsYXNzIiwidG9fcHJvYyIsImR1cCIsImluaXRpYWxpemVfZHVwIiwiZW51bV9mb3IiLCJmb3IiLCJFbnVtZXJhdG9yIiwiZXF1YWw/IiwiZXhpdCIsInN0YXR1cyIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJJbnRlZ2VyIiwiZXh0ZW5kIiwiVHlwZUVycm9yIiwiYXBwZW5kX2ZlYXR1cmVzIiwiZXh0ZW5kX29iamVjdCIsImV4dGVuZGVkIiwiZ2V0cyIsIiRzdGRpbiIsImhhc2giLCJfX2lkX18iLCJpbnNwZWN0IiwiaXZzIiwiaWQiLCJpbmNsdWRlPyIsInB1c2hlZCIsImVhY2giLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJibG9jayBpbiBpbnNwZWN0IiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsIml2YXIiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCIrIiwidG9fcyIsIjE2IiwiU3RhbmRhcmRFcnJvciIsImUiLCJpbnN0YW5jZV9vZj8iLCJrbGFzcyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJ2YWx1ZSIsInJlbW92ZV9pbnN0YW5jZV92YXJpYWJsZSIsImJhc2UiLCJGbG9hdERvbWFpbkVycm9yIiwicmVzcG9uZF90bz8iLCJ0b19pbnQiLCJjb2VyY2VfdG8hIiwiRmxvYXQiLCJIYXNoIiwiYXJnIiwiaXNfYT8iLCJpdHNlbGYiLCJsYW1iZGEiLCJsb2FkIiwiZmlsZSIsIlN0cmluZyIsImxvb3AiLCJibG9ja19naXZlbj8iLCJibG9jayBpbiBsb29wIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBsb29wIiwiRmxvYXQ6OklORklOSVRZIiwiU3RvcEl0ZXJhdGlvbiIsInJlc3VsdCIsInByaW50ZiIsImFueT8iLCJwcmludCIsImZvcm1hdCIsInByb2MiLCJwdXRzIiwiJHN0ZG91dCIsInN0cnMiLCJwIiwiYmxvY2sgaW4gcCIsImJsb2NrICgyIGxldmVscykgaW4gcCIsIjw9IiwiW10iLCIwIiwicmVhZGxpbmUiLCJ3YXJuIiwidXBsZXZlbCIsIjwiLCJsb2NhdGlvbiIsImZpcnN0IiwiYmxvY2sgaW4gd2FybiIsInMiLCJibG9jayAoMiBsZXZlbHMpIGluIHdhcm4iLCIkVkVSQk9TRSIsIiRzdGRlcnIiLCJleGNlcHRpb24iLCJzdHJpbmciLCJiYWNrdHJhY2UiLCIkISIsIlJ1bnRpbWVFcnJvciIsInRvX3N0ciIsIiRAIiwicmFuZCIsIm1heCIsIlJhbmRvbTo6REVGQVVMVCIsIlJhbmRvbSIsImluY2x1ZGVfYWxsIiwicmVzcG9uZF90b19taXNzaW5nPyIsIm1ldGhvZF9uYW1lIiwicHJpc3RpbmUiLCJyZXF1aXJlIiwicmVxdWlyZV9yZWxhdGl2ZSIsInRyeV9jb252ZXJ0ISIsIkZpbGUiLCJleHBhbmRfcGF0aCIsImpvaW4iLCJyZXF1aXJlX3RyZWUiLCJwYXRoIiwic3RhcnRfd2l0aD8iLCJhdXRvbG9hZCIsInNsZWVwIiwic2Vjb25kcyIsInNyYW5kIiwic2VlZCIsIm5ld19zZWVkIiwic3RyIiwidGFwIiwiY2F0Y2giLCJ0YWciLCJPYmplY3QiLCJVbmNhdWdodFRocm93RXJyb3IiLCJ0aHJvdyIsIm9wZW4iLCJ5aWVsZF9zZWxmIiwiYmxvY2sgaW4geWllbGRfc2VsZiIsIjxjbGFzczpPYmplY3Q+IiwiaW5jbHVkZSJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUdBQztFQUFBQTs7SUFBQUE7Ozs7QUFDRUMsSUFBQUEsa0JBQUFBLFlBQ0UsS0FERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLGtCQUFBQSwrQkFBT0MsR0FBUEQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUVF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R0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQWx5QkFoTTsifX0seyJvZmZzZXQiOnsibGluZSI6MTczMjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yL2Vycm5vLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSA6OkVycm5vXG4gIGVycm9ycyA9IFtcbiAgICBbOkVJTlZBTCwgJ0ludmFsaWQgYXJndW1lbnQnLCAyMl0sXG4gICAgWzpFRVhJU1QsICdGaWxlIGV4aXN0cycsIDE3XSxcbiAgICBbOkVJU0RJUiwgJ0lzIGEgZGlyZWN0b3J5JywgMjFdLFxuICAgIFs6RU1GSUxFLCAnVG9vIG1hbnkgb3BlbiBmaWxlcycsIDI0XSxcbiAgICBbOkVTUElQRSwgJ0lsbGVnYWwgc2VlaycsIDI5XSxcbiAgICBbOkVBQ0NFUywgJ1Blcm1pc3Npb24gZGVuaWVkJywgMTNdLFxuICAgIFs6RVBFUk0sICdPcGVyYXRpb24gbm90IHBlcm1pdHRlZCcsIDFdLFxuICAgIFs6RU5PRU5ULCAnTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsIDJdLFxuICAgIFs6RU5BTUVUT09MT05HLCAnRmlsZSBuYW1lIHRvbyBsb25nJywgMzZdXG4gIF1cblxuICBrbGFzcyA9IG5pbFxuXG4gICV4e1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbigpIHsgLy8gQ3JlYXRlIGEgY2xvc3VyZVxuICAgICAgICB2YXIgY2xhc3NfbmFtZSA9IGVycm9yc1tpXVswXTtcbiAgICAgICAgdmFyIGRlZmF1bHRfbWVzc2FnZSA9IGVycm9yc1tpXVsxXTtcbiAgICAgICAgdmFyIGVycm5vID0gZXJyb3JzW2ldWzJdO1xuXG4gICAgICAgIGtsYXNzID0gT3BhbC5rbGFzcyhzZWxmLCBPcGFsLlN5c3RlbUNhbGxFcnJvciwgY2xhc3NfbmFtZSk7XG4gICAgICAgIGtsYXNzLmVycm5vID0gZXJybm87XG5cbiAgICAgICAgI3tcbiAgICAgICAgICBjbGFzcyA8PCBrbGFzc1xuICAgICAgICAgICAgZGVmIG5ldyhuYW1lID0gbmlsKVxuICAgICAgICAgICAgICBtZXNzYWdlID0gYGRlZmF1bHRfbWVzc2FnZWBcbiAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAtICN7bmFtZX1cIiBpZiBuYW1lXG4gICAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG4gIH1cbmVuZFxuXG5jbGFzcyA6OlN5c3RlbUNhbGxFcnJvciA8IDo6U3RhbmRhcmRFcnJvclxuICBkZWYgZXJybm9cbiAgICBzZWxmLmNsYXNzLmVycm5vXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhdHRyX3JlYWRlciA6ZXJybm9cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpFcnJubz4iLCJlcnJvcnMiLCIyMiIsIjE3IiwiMjEiLCIyNCIsIjI5IiwiMTMiLCIxIiwiMiIsIjM2Iiwia2xhc3MiLCJuZXciLCJuYW1lIiwibWVzc2FnZSIsIisiLCJzZWxmIiwiPGNsYXNzOlN5c3RlbUNhbGxFcnJvcj4iLCJlcnJubyIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJTdGFuZGFyZEVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDLFNBQVMsQ0FDUCxDQUFDLFFBQUQsRUFBVUQsa0JBQVYsRUFBOEJFLEVBQTlCLENBRE8sRUFFUCxDQUFDLFFBQUQsRUFBVUYsYUFBVixFQUF5QkcsRUFBekIsQ0FGTyxFQUdQLENBQUMsUUFBRCxFQUFVSCxnQkFBVixFQUE0QkksRUFBNUIsQ0FITyxFQUlQLENBQUMsUUFBRCxFQUFVSixxQkFBVixFQUFpQ0ssRUFBakMsQ0FKTyxFQUtQLENBQUMsUUFBRCxFQUFVTCxjQUFWLEVBQTBCTSxFQUExQixDQUxPLEVBTVAsQ0FBQyxRQUFELEVBQVVOLG1CQUFWLEVBQStCTyxFQUEvQixDQU5PLEVBT1AsQ0FBQyxPQUFELEVBQVNQLHlCQUFULEVBQW9DUSxDQUFwQyxDQVBPLEVBUVAsQ0FBQyxRQUFELEVBQVVSLDJCQUFWLEVBQXVDUyxDQUF2QyxDQVJPLEVBU1AsQ0FBQyxjQUFELEVBQWdCVCxvQkFBaEIsRUFBc0NVLEVBQXRDLENBVE87SUFZVEMsUUFBUTs7QUFHVlg7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQSxRQUNVOztNQUNFLE9BQUFZLG1CQUFBQSxnQkFBUUMsSUFBUkQ7QUFBQUEsUUFBQUE7O1FBQUFBOztRQUFRLHlCQUFPO1FBQ2JFLFVBQVdGO1FBQ1gsSUFBQSxRQUEyQkMsSUFBM0IsQ0FBQTtVQUFBQyxVQUFRQyxTQUFSRCxPQUFRQyxFQUFJSCxLQUFELEdBQUEsQ0FBTUMsSUFBTixDQUFIRTtRQUFSO1FBQ0FILE9BQUEsT0FBQUksSUFBQSxFQUFBLDZDQUFBLE9BQUEsRUFBQSxDQUFNRixPQUFOLENBQUEsRUFBQSxJQUFBO01BSEZGLENBQUFBLElBQUFBO0lBREYsNEJBQVNELEtBQVQ7QUFRVlg7QUFDQUE7QUFDQUE7RUFyQ0FBLEdBQU8sSUFBUEE7RUF3Q0FELE9BQUFrQjtFQUFBQTs7SUFBQUE7Ozs7QUFDRUMsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUYsSUFBSUcsT0FBQUEsQ0FBQUEsQ0FBTUQsT0FBQUEsQ0FBQUE7SUFEWkEsQ0FBQUEsR0FBQUE7SUFJQUQsT0FBQTs7TUFDRSxPQUFBRCxJQUFBSSxhQUFBQSxDQUFZLE9BQVpBO0lBREYsNEJBQVNKLElBQVQ7RUFMRkMsR0FBTSxJQUFOQSxFQUEwQkksb0JBQTFCSjtBQXhDQWxCOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzM4NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY2xhc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5cbmNsYXNzIDo6Q2xhc3NcbiAgZGVmIHNlbGYubmV3KHN1cGVyY2xhc3MgPSBPYmplY3QsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3VwZXJjbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MpO1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgICN7YGtsYXNzYC5jbGFzc19ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/fVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZXNjZW5kYW50c1xuICAgIHN1YmNsYXNzZXMgKyBzdWJjbGFzc2VzLm1hcCgmOmRlc2NlbmRhbnRzKS5mbGF0dGVuXG4gIGVuZFxuXG4gIGRlZiBpbmhlcml0ZWQoY2xzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3JpZ2luYWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG9yaWdpbmFsKVxuICAgICV4e1xuICAgICAgc2VsZi4kJG5hbWUgPSBudWxsO1xuICAgICAgc2VsZi4kJGZ1bGxfbmFtZSA9IG51bGw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV3KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqZWN0ID0gI3thbGxvY2F0ZX07XG4gICAgICBPcGFsLnNlbmQob2JqZWN0LCBvYmplY3QuJGluaXRpYWxpemUsIGFyZ3MsIGJsb2NrKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3ViY2xhc3Nlc1xuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBXZWFrUmVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaSwgc3ViY2xhc3MsIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi4kJHN1YmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJjbGFzcyA9IHNlbGYuJCRzdWJjbGFzc2VzW2ldLmRlcmVmKCk7XG4gICAgICAgICAgaWYgKHN1YmNsYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHN1YmNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHN1YmNsYXNzZXM7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VwZXJjbGFzc1xuICAgIGBzZWxmLiQkc3VwZXIgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICV4e1xuICAgICAgdmFyIHNpbmdsZXRvbl9vZiA9IHNlbGYuJCRzaW5nbGV0b25fb2Y7XG5cbiAgICAgIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiN7YHNpbmdsZXRvbl9vZmAubmFtZX0+XCJ9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2luZ2xldG9uX29mKSB7XG4gICAgICAgIC8vIGEgc2luZ2xldG9uIGNsYXNzIGNyZWF0ZWQgZnJvbSBhbiBvYmplY3RcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiM8I3tgc2luZ2xldG9uX29mLiQkY2xhc3NgLm5hbWV9OjB4I3tgT3BhbC5pZChzaW5nbGV0b25fb2YpYC50b19zKDE2KX0+PlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c3VwZXIoKX07XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBpbnNwZWN0IHRvX3NcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpDbGFzcz4iLCJuZXciLCJzdXBlcmNsYXNzIiwiT2JqZWN0IiwiYmxvY2tfZ2l2ZW4/IiwiY2xhc3NfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImFsbG9jYXRlIiwiZGVzY2VuZGFudHMiLCIrIiwic3ViY2xhc3NlcyIsIm1hcCIsImZsYXR0ZW4iLCJpbmhlcml0ZWQiLCJpbml0aWFsaXplX2R1cCIsIm9yaWdpbmFsIiwiaW5pdGlhbGl6ZV9jb3B5IiwidG9fcyIsIm5hbWUiLCIxNiJdLCJtYXBwaW5ncyI6IkFBQUFBLGdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUMsTUFBSUgsSUFBSkcsVUFBQUEsc0JBQWFDLFVBQWJEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWEscUNBQWFFOztBQUU1QkY7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLE1BQVEsQ0FBOEJHLGVBQTlCLEdBQUEsQ0FBT0MsTUFBUEosQ0FBQ0EsS0FBREEsQ0FBT0ksY0FBQUEsRUFBQUEsRUFBQUEsRUFBYUMsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBWkYsQ0FBUCxJQUFBLEdBQUE7QUFDUko7QUFDQUE7SUFWRUEsQ0FBQUEsSUFBQUE7O0FBYUFPLElBQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSxHQUFBQTs7QUFRQUMsSUFBQUEsMkJBQUFBLHVCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBV0MsU0FBWFosSUFBQWEsWUFBQUEsQ0FBQUEsQ0FBV0QsRUFBWUUsTUFBVmQsSUFBQWEsWUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTSxhQUFETCxTQUFBQSxDQUFBQSxDQUFMSyxDQUFtQkMsU0FBQUEsQ0FBQUEsQ0FBL0JIO0lBRGJELENBQUFBLEdBQUFBOztBQUlBSyxJQUFBQSx5QkFBQUEsWUE1QkYsR0E0QkVBLENBQUFBLEdBQUFBOztBQUdBQyxJQUFBQSw4QkFBQUEsMEJBQW1CQyxRQUFuQkQ7QUFBQUEsTUFBQUE7OztNQUNFakIsSUFBQW1CLGlCQUFBQSxDQUFnQkQsUUFBaEJDOztBQUVKRjtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSxHQUFBQTs7QUFRQWQsSUFBQUEsbUJBQUFBLHNCQXZDRixFQXVDRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUF2Q0Y7TUF1Q1U7O0FBRVZBLG1CQUFxQkgsSUFBQVUsVUFBQUEsQ0FBQUEsQ0FBU1A7QUFDOUJBO0FBQ0FBO0FBQ0FBO0lBTEVBLENBQUFBLElBQUFBOztBQVFBVSxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFmRUEsQ0FBQUEsR0FBQUE7O0FBa0JBVCxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxtQkFBREE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFnQixJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7QUFFRkE7O0FBRUFBO0FBQ0FBLGVBQWtCQSxVQUFELEdBQUEsQ0FBV0EsQ0FBQ0EsWUFBREEsQ0FBY0MsTUFBQUEsQ0FBQUEsQ0FBekIsQ0FBQSxHQUErQkQsR0FBR0E7QUFDbkRBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGVBQWtCQSxZQUFELEdBQUEsQ0FBYUEsQ0FBQ0Esb0JBQURBLENBQXNCQyxNQUFBQSxDQUFBQSxDQUFuQyxDQUFBLEdBQXlDRCxLQUF6QyxHQUFBLENBQThDQSxDQUFDQSxxQkFBREEsQ0FBdUJBLE1BQUFBLENBQU1FLEVBQU5GLENBQXJFLENBQUEsR0FBK0VBLElBQUlBO0FBQ3BHQTs7QUFFQUEsYUFBZSxPQUFBcEIsSUFBQSxFQUFBLDhDQUFBLFFBQUEsRUFBQSxFQUFBLEVBQUEsSUFBQSxDQUFRb0I7QUFDdkJBO0lBYkVBLENBQUFBLEdBQUFBO0lBZ0JBbEIsT0FBQSxhQUFNLFNBQU4sRUFBYyxNQUFkO0VBbkZGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzUwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6OlJhbmRvbVxuICBtb2R1bGUgc2VsZjo6Rm9ybWF0dGVyXG4gICAgZGVmIGhleChjb3VudCA9IG5pbClcbiAgICAgIGNvdW50ID0gOjpSYW5kb20uX3ZlcmlmeV9jb3VudChjb3VudClcbiAgICAgICV4e1xuICAgICAgICB2YXIgYnl0ZXMgPSAje2J5dGVzKGNvdW50KX07XG4gICAgICAgIHZhciBvdXQgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICN7Y291bnR9OyBpKyspIHtcbiAgICAgICAgICBvdXQgKz0gYnl0ZXMuY2hhckNvZGVBdChpKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tgb3V0YC5lbmNvZGUoJ1VTLUFTQ0lJJyl9O1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIHJhbmRvbV9ieXRlcyhjb3VudCA9IG5pbClcbiAgICAgIGJ5dGVzKGNvdW50KVxuICAgIGVuZFxuXG4gICAgZGVmIGJhc2U2NChjb3VudCA9IG5pbClcbiAgICAgIDo6QmFzZTY0LnN0cmljdF9lbmNvZGU2NChyYW5kb21fYnl0ZXMoY291bnQpKS5lbmNvZGUoJ1VTLUFTQ0lJJylcbiAgICBlbmRcblxuICAgIGRlZiB1cmxzYWZlX2Jhc2U2NChjb3VudCA9IG5pbCwgcGFkZGluZyA9IGZhbHNlKVxuICAgICAgOjpCYXNlNjQudXJsc2FmZV9lbmNvZGU2NChyYW5kb21fYnl0ZXMoY291bnQpLCBwYWRkaW5nKS5lbmNvZGUoJ1VTLUFTQ0lJJylcbiAgICBlbmRcblxuICAgIGRlZiB1dWlkXG4gICAgICBzdHIgPSBoZXgoMTYpLnNwbGl0KCcnKVxuICAgICAgc3RyWzEyXSA9ICc0J1xuICAgICAgc3RyWzE2XSA9IGAocGFyc2VJbnQoI3tzdHJbMTZdfSwgMTYpICYgMyB8IDgpLnRvU3RyaW5nKDE2KWBcbiAgICAgIHN0ciA9IFtzdHJbMC4uLjhdLCBzdHJbOC4uLjEyXSwgc3RyWzEyLi4uMTZdLCBzdHJbMTYuLi4yMF0sIHN0clsyMC4uLjMyXV1cbiAgICAgIHN0ciA9IHN0ci5tYXAoJjpqb2luKVxuICAgICAgc3RyLmpvaW4oJy0nKVxuICAgIGVuZFxuXG4gICAgIyBJbXBsZW1lbnRlZCBpbiB0ZXJtcyBvZiBgI2J5dGVzYCBmb3IgU2VjdXJlUmFuZG9tLCBidXQgUmFuZG9tIG92ZXJyaWRlcyB0aGlzXG4gICAgIyBtZXRob2QgdG8gaW1wbGVtZW50IGAjYnl0ZXNgIGluIHRlcm1zIG9mIGAjcmFuZG9tX2Zsb2F0YC4gTm90IHBhcnQgb2Ygc3RhbmRhcmRcbiAgICAjIFJ1YnkgaW50ZXJmYWNlIC0gdXNlIHJhbmRvbV9udW1iZXIgZm9yIHBvcnRhYmlsaXR5LlxuICAgIGRlZiByYW5kb21fZmxvYXRcbiAgICAgIGJzID0gYnl0ZXMoNClcbiAgICAgIG51bSA9IDBcbiAgICAgIDQudGltZXMgZG8gfGl8XG4gICAgICAgIG51bSA8PD0gOFxuICAgICAgICBudW0gfD0gYnNbaV0ub3JkXG4gICAgICBlbmRcbiAgICAgIG51bS5hYnMgLyAweDdmZmZmZmZmXG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZG9tX251bWJlcihsaW1pdCA9IHVuZGVmaW5lZClcbiAgICAgICV4e1xuICAgICAgICBmdW5jdGlvbiByYW5kb21GbG9hdCgpIHtcbiAgICAgICAgICByZXR1cm4gI3tyYW5kb21fZmxvYXR9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tSW50KG1heCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmRvbUZsb2F0KCkgKiBtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tUmFuZ2UoKSB7XG4gICAgICAgICAgdmFyIG1pbiA9IGxpbWl0LmJlZ2luLFxuICAgICAgICAgICAgICBtYXggPSBsaW1pdC5lbmQ7XG5cbiAgICAgICAgICBpZiAobWluID09PSBuaWwgfHwgbWF4ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxlbmd0aCA9IG1heCAtIG1pbjtcblxuICAgICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1heCAlIDEgPT09IDAgJiYgbWluICUgMSA9PT0gMCAmJiAhbGltaXQuZXhjbCkge1xuICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUludChsZW5ndGgpICsgbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZG9tRmxvYXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW1pdC4kJGlzX3JhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmRvbVJhbmdlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBhcmd1bWVudCAtICN7bGltaXR9XCJ9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxpbWl0ICUgMSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaW50ZWdlclxuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUludChsaW1pdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpICogbGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbWl0ID0gI3s6Ok9wYWwuY29lcmNlX3RvIShsaW1pdCwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBhcmd1bWVudCAtICN7bGltaXR9XCJ9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUludChsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBhbHBoYW51bWVyaWMoY291bnQgPSBuaWwpXG4gICAgICBjb3VudCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICAgbWFwID0gWycwJy4uJzknLCAnYScuLid6JywgJ0EnLi4nWiddLm1hcCgmOnRvX2EpLmZsYXR0ZW5cbiAgICAgIDo6QXJyYXkubmV3KGNvdW50KSBkbyB8aXxcbiAgICAgICAgbWFwW3JhbmRvbV9udW1iZXIobWFwLmxlbmd0aCldXG4gICAgICBlbmQuam9pblxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIDo6UmFuZG9tOjpGb3JtYXR0ZXJcbiAgZXh0ZW5kIDo6UmFuZG9tOjpGb3JtYXR0ZXJcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UmFuZG9tPiIsIjxtb2R1bGU6c2VsZjo6Rm9ybWF0dGVyPiIsImhleCIsImNvdW50IiwiUmFuZG9tIiwiX3ZlcmlmeV9jb3VudCIsInNlbGYiLCJieXRlcyIsImVuY29kZSIsInJhbmRvbV9ieXRlcyIsImJhc2U2NCIsIkJhc2U2NCIsInN0cmljdF9lbmNvZGU2NCIsInVybHNhZmVfYmFzZTY0IiwicGFkZGluZyIsInVybHNhZmVfZW5jb2RlNjQiLCJ1dWlkIiwic3RyIiwiMTYiLCJzcGxpdCIsIltdPSIsIjEyIiwiW10iLCIwIiwiOCIsIjIwIiwiMzIiLCJtYXAiLCJ0b19wcm9jIiwiam9pbiIsInJhbmRvbV9mbG9hdCIsImJzIiwiNCIsIm51bSIsInRpbWVzIiwiYmxvY2sgaW4gcmFuZG9tX2Zsb2F0IiwiaSIsIjw8IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByYW5kb21fZmxvYXQiLCJ8Iiwib3JkIiwiLyIsImFicyIsIjIxNDc0ODM2NDciLCJyYW5kb21fbnVtYmVyIiwibGltaXQiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJPcGFsIiwiY29lcmNlX3RvISIsIkludGVnZXIiLCJhbHBoYW51bWVyaWMiLCJmbGF0dGVuIiwibmV3IiwiQXJyYXkiLCJibG9jayBpbiBhbHBoYW51bWVyaWMiLCJibG9jayAoMiBsZXZlbHMpIGluIGFscGhhbnVtZXJpYyIsImxlbmd0aCIsImluY2x1ZGUiLCJSYW5kb206OkZvcm1hdHRlciIsImV4dGVuZCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDO0lBQUFBOztNQUFBQTs7OztBQUNFQyxNQUFBQSxtQkFBQUEsZUFBUUMsS0FBUkQ7QUFBQUEsUUFBQUE7OztRQUFRLDJCQUFRO1FBQ2RDLFFBQVFDLGFBQVFD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T0FBQTlCLEdBQUdMLE9BQUFBLENBQUNoQixJQUFBc0MsZUFBQUEsQ0FBY2pCLEdBQUcrQixRQUFBQSxDQUFBQSxDQUFqQmQsQ0FBRHRCLEVBRExrQyxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBT0YsQ0FFSnpCLE1BQUFBLENBQUFBO01BTEx1QixDQUFBQSxJQUFBQTtJQTdHRm5ELEdBQU9LLElBQVBMO0lBc0hBSyxJQUFBcUQsU0FBQUEsQ0FBUUMsSUFBQXhELGFBQUF3RCxjQUFSRDtJQUNBM0QsT0FBQU0sSUFBQXVELFFBQUFBLENBQU9ELElBQUF4RCxhQUFBd0QsY0FBUEM7RUF4SEY3RCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzY3NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYXJyYXkucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGZhbHN5LCBoYXNoX2lkcywgeWllbGQxLCBoYXNoX2dldCwgaGFzaF9wdXQsIGhhc2hfZGVsZXRlLCBjb2VyY2VfdG8sIHJlc3BvbmRfdG8sIGRlbnlfZnJvemVuX2FjY2VzcywgZnJlZXplXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgOjpBcnJheSA8IGBBcnJheWBcbiAgaW5jbHVkZSA6OkVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGphdmFzY3JpcHQgYXJyYXlzIGFzIGJlaW5nIHZhbGlkIHJ1YnkgYXJyYXlzXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYXJyYXknLCB0cnVlKWBcblxuICAleHtcbiAgICAvLyBSZWNlbnQgdmVyc2lvbnMgb2YgVjggKD4gNy4xKSBvbmx5IHVzZSBhbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gd2hlbiBBcnJheS5wcm90b3R5cGUgaXMgdW5tb2RpZmllZC5cbiAgICAvLyBGb3IgaW5zdGFuY2UsIFwiYXJyYXktc3BsaWNlLnRxXCIgaGFzIGEgXCJmYXN0IHBhdGhcIiAoRXh0cmFjdEZhc3RKU0FycmF5LCBkZWZpbmVkIGluIFwic3JjL2NvZGVnZW4vY29kZS1zdHViLWFzc2VtYmxlci5jY1wiKVxuICAgIC8vIGJ1dCBpdCdzIG9ubHkgZW5hYmxlZCB3aGVuIFwiSXNQcm90b3R5cGVJbml0aWFsQXJyYXlQcm90b3R5cGUoKVwiIGlzIHRydWUuXG4gICAgLy9cbiAgICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBWOCB3ZXJlIHVzaW5nIHJlbGF0aXZlbHkgZmFzdCBKUy13aXRoLWV4dGVuc2lvbnMgY29kZSBldmVuIHdoZW4gQXJyYXkucHJvdG90eXBlIGlzIG1vZGlmaWVkOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzcuMC4xL3NyYy9qcy9hcnJheS5qcyNMNTk5LUw2NDJcbiAgICAvL1xuICAgIC8vIEluIHNob3J0LCBBcnJheSBvcGVyYXRpb25zIGFyZSBzbG93IGluIHJlY2VudCB2ZXJzaW9ucyBvZiBWOCB3aGVuIHRoZSBBcnJheS5wcm90b3R5cGUgaGFzIGJlZW4gdGFtcGVyZWQuXG4gICAgLy8gU28sIHdoZW4gcG9zc2libGUsIHdlIGFyZSB1c2luZyBmYXN0ZXIgb3Blbi1jb2RlZCB2ZXJzaW9uIHRvIGJvb3N0IHRoZSBwZXJmb3JtYW5jZS5cblxuICAgIC8vIEFzIG9mIFY4IDguNCwgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoZSBhcnJheSwgdGhpcyBpcyB1cCB0byB+MjV4IHRpbWVzIGZhc3RlciB0aGFuIEFycmF5I3NoaWZ0KClcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBpcyBoZWF2aWx5IGluc3BpcmVkIGJ5OiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iYTY4NDgwNWI2YzBlZGVkNzZlNWNkODllZTAwMzI4YWM3YTU5MzY1L2xpYi9pbnRlcm5hbC91dGlsLmpzI0wzNDEtTDM0N1xuICAgIGZ1bmN0aW9uIHNoaWZ0Tm9BcmcobGlzdCkge1xuICAgICAgdmFyIHIgPSBsaXN0WzBdO1xuICAgICAgdmFyIGluZGV4ID0gMTtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBsaXN0W2luZGV4IC0gMV0gPSBsaXN0W2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGxpc3QucG9wKCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5U3ViY2xhc3Mob2JqLCBrbGFzcykge1xuICAgICAgaWYgKGtsYXNzLiQkbmFtZSA9PT0gT3BhbC5BcnJheSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtsYXNzLiRhbGxvY2F0ZSgpLiRyZXBsYWNlKCN7YG9iamAudG9fYX0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEEgaGVscGVyIGZvciBrZWVwX2lmIGFuZCBkZWxldGVfaWYsIGZpbHRlciBpcyBlaXRoZXIgT3BhbC50cnV0aHlcbiAgICAvLyBvciBPcGFsLmZhbHN5LlxuICAgIGZ1bmN0aW9uIGZpbHRlcklmKHNlbGYsIGZpbHRlciwgYmxvY2spIHtcbiAgICAgIHZhciB2YWx1ZSwgcmFpc2VkID0gbnVsbCwgdXBkYXRlZCA9IG5ldyBBcnJheShzZWxmLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpMiA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFyYWlzZWQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKVxuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIHJhaXNlZCA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYWlzZWQgfHwgZmlsdGVyKHZhbHVlKSkge1xuICAgICAgICAgIHVwZGF0ZWRbaTJdID0gc2VsZltpXVxuICAgICAgICAgIGkyICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGkyICE9PSBpKSB7XG4gICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFswLCB1cGRhdGVkLmxlbmd0aF0uY29uY2F0KHVwZGF0ZWQpKTtcbiAgICAgICAgc2VsZi5zcGxpY2UoaTIsIHVwZGF0ZWQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhaXNlZCkgdGhyb3cgcmFpc2VkO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBzZWxmLltdKCpvYmplY3RzKVxuICAgIGB0b0FycmF5U3ViY2xhc3Mob2JqZWN0cywgc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHNpemUgPSBuaWwsIG9iaiA9IG5pbCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgaWYgKG9iaiAhPT0gbmlsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC53YXJuKCd3YXJuaW5nOiBibG9jayBzdXBlcnNlZGVzIGRlZmF1bHQgdmFsdWUgYXJndW1lbnQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpemUgPiAjezo6SW50ZWdlcjo6TUFYfSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2FycmF5IHNpemUgdG9vIGJpZyd9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjIpXCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChzaXplLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAje3JlcGxhY2Uoc2l6ZS50b19hKX1cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSBlbHNlIGlmICgje3NpemUucmVzcG9uZF90bz8gOnRvX2FyeX0pIHtcbiAgICAgICAgICAje3JlcGxhY2Uoc2l6ZS50b19hcnkpfVxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNpemUgPSAkY29lcmNlX3RvKHNpemUsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ31cbiAgICAgIH1cblxuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCB2YWx1ZTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soaSk7XG4gICAgICAgICAgc2VsZltpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqKVxuICAgIDo6T3BhbC5jb2VyY2VfdG8/IG9iaiwgOjpBcnJheSwgOnRvX2FyeVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBvdGhlciA9IGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGlmICgkaGFzaF9kZWxldGUoaGFzaCwgaXRlbSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBvdGhlciA9IGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgc2VsZltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoLiRrZXlzKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICByZXR1cm4gam9pbihvdGhlci50b19zdHIpIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcblxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG90aGVyIDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29udmVydGVkID0gI3t0b19hfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlcjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY29udmVydGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgIGBzZWxmLmNvbmNhdChvdGhlcilgXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIG90aGVyID0gaWYgOjpBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3s6OkFycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgcmV0dXJuIGBzZWxmLnNsaWNlKClgIGlmIGBvdGhlci5sZW5ndGggPT09IDBgXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwgaXRlbSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPDwob2JqZWN0KVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuICAgIGBzZWxmLnB1c2gob2JqZWN0KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiA6OkFycmF5ID09PSBvdGhlclxuICAgICAgb3RoZXIgPSBvdGhlci50b19hXG4gICAgZWxzaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgb3RoZXIgPSBvdGhlci50b19hcnkudG9fYVxuICAgIGVsc2VcbiAgICAgIHJldHVyblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoI3toYXNofSA9PT0gI3tvdGhlci5oYXNofSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4oc2VsZi5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgdG1wID0gI3tgc2VsZltpXWAgPD0+IGBvdGhlcltpXWB9O1xuXG4gICAgICAgIGlmICh0bXAgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje2BzZWxmLmxlbmd0aGAgPD0+IGBvdGhlci5sZW5ndGhgfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZCA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoYXJyYXkgPT09IG90aGVyKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmICghb3RoZXIuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19hcnknKSkge1xuICAgICAgICAgICAgcmV0dXJuICN7YG90aGVyYCA9PSBgYXJyYXlgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheS4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcbiAgICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcbiAgICAgICAgaWYgKG90aGVyLiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIG90aGVyID0gI3tgb3RoZXJgLnRvX2F9O1xuXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhID0gYXJyYXlbaV07XG4gICAgICAgICAgYiA9IG90aGVyW2ldO1xuICAgICAgICAgIGlmIChhLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xuICAgICAgZnJvbSAgICA9IGluZGV4LmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhpbmRleC5iZWdpbiwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG4gICAgICB0byAgICAgID0gaW5kZXguZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8oaW5kZXguZW5kLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleC5leGNsX3JldiAmJiBpbmRleC5iZWdpbiAhPT0gbmlsKSB7XG4gICAgICAgIGZyb20gKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgdG8gKz0gc2l6ZTtcblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhjbHVkZSB8fCBpbmRleC5lbmQgPT09IG5pbCkge1xuICAgICAgICB0byArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2FyaXRobWV0aWNfc2VxKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgYXJyYXksIG91dCA9IFtdLCBpID0gMCwgcHNldWRvcmFuZ2U7XG5cbiAgICAgIGlmIChpbmRleC5zdGVwIDwgMCkge1xuICAgICAgICBwc2V1ZG9yYW5nZSA9IHtcbiAgICAgICAgICBiZWdpbjogaW5kZXgucmFuZ2UuZW5kLFxuICAgICAgICAgIGVuZDogaW5kZXgucmFuZ2UuYmVnaW4sXG4gICAgICAgICAgZXhjbDogZmFsc2UsXG4gICAgICAgICAgZXhjbF9yZXY6IGluZGV4LnJhbmdlLmV4Y2xcbiAgICAgICAgfTtcbiAgICAgICAgYXJyYXkgPSAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgcHNldWRvcmFuZ2UpLiRyZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJyYXkgPSAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgaW5kZXgucmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICBvdXQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIGkgKz0gTWF0aC5hYnMoaW5kZXguc3RlcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpbmRleC4kJGlzX2FyaXRobWV0aWNfc2VxKSB7XG4gICAgICAgIHJldHVybiAkYXJyYXlfc2xpY2VfYXJpdGhtZXRpY19zZXEoc2VsZiwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShpbmRleCwgdmFsdWUsIGV4dHJhID0gdW5kZWZpbmVkKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgZGF0YSA9IG5pbFxuICAgICV4e1xuICAgICAgdmFyIGksIHNpemUgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpXG4gICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYX07XG4gICAgICAgIGVsc2UgaWYgKCN7dmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeX0pXG4gICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYXJ5LnRvX2F9O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZGF0YSA9IFt2YWx1ZV07XG5cbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSBpbmRleC5leGNsLFxuICAgICAgICAgICAgZnJvbSAgICA9IGluZGV4LmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhpbmRleC5iZWdpbiwgT3BhbC5JbnRlZ2VyLCAndG9faW50JyksXG4gICAgICAgICAgICB0byAgICAgID0gaW5kZXguZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8oaW5kZXguZW5kLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICBmcm9tICs9IHNpemU7XG5cbiAgICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcIiN7aW5kZXguaW5zcGVjdH0gb3V0IG9mIHJhbmdlXCJ9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICB0byArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlIHx8IGluZGV4LmVuZCA9PT0gbmlsKSB7XG4gICAgICAgICAgdG8gKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tID4gc2l6ZSkge1xuICAgICAgICAgIGZvciAoaSA9IHNpemU7IGkgPCBmcm9tOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCAwXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCB0byAtIGZyb21dLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7bGVuZ3RoID0gMX1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZSAgPSBleHRyYTtcblxuICAgICAgICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KVxuICAgICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYX07XG4gICAgICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSlcbiAgICAgICAgICAgIGRhdGEgPSAje3ZhbHVlLnRvX2FyeS50b19hfTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkYXRhID0gW3ZhbHVlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGQ7XG5cbiAgICAgICAgaW5kZXggID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgb2xkICAgID0gaW5kZXg7XG4gICAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImluZGV4ICN7YG9sZGB9IHRvbyBzbWFsbCBmb3IgYXJyYXk7IG1pbmltdW0gI3tgLXNlbGYubGVuZ3RoYH1cIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJuZWdhdGl2ZSBsZW5ndGggKCN7bGVuZ3RofSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA+IHNpemUpIHtcbiAgICAgICAgICBmb3IgKGkgPSBzaXplOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGZbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCBsZW5ndGhdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgYGlmIChzZWxmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbSA9IHNlbGZbaV0sIGl0ZW0ubGVuZ3RoICYmICN7YGl0ZW1bMF1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2hfaW5kZXggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gMCxcbiAgICAgICAgICBtYXggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBtaWQsXG4gICAgICAgICAgdmFsLFxuICAgICAgICAgIHJldCxcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2UsXG4gICAgICAgICAgc2F0aXNmaWVkID0gbmlsO1xuXG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyAyKTtcbiAgICAgICAgdmFsID0gc2VsZlttaWRdO1xuICAgICAgICByZXQgPSAkeWllbGQxKGJsb2NrLCB2YWwpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgICBzYXRpc2ZpZWQgPSBtaWQ7XG4gICAgICAgICAgc21hbGxlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmV0ID09PSBmYWxzZSB8fCByZXQgPT09IG5pbCkge1xuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAocmV0ID09PSAwKSB7IHJldHVybiBtaWQ7IH1cbiAgICAgICAgICBzbWFsbGVyID0gKHJldCA8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2ByZXRgLmNsYXNzfSAobXVzdCBiZSBudW1lcmljLCB0cnVlLCBmYWxzZSBvciBuaWwpXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc21hbGxlcikgeyBtYXggPSBtaWQ7IH0gZWxzZSB7IG1pbiA9IG1pZCArIDE7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNhdGlzZmllZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaW5kZXggPSBic2VhcmNoX2luZGV4KCZibG9jaylcblxuICAgICV4e1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwgJiYgaW5kZXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmN5Y2xlLCBuKSBkb1xuICAgICAgICBpZiBuLm5pbD9cbiAgICAgICAgICA6OkZsb2F0OjpJTkZJTklUWVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXR1cm4gaWYgZW1wdHk/IHx8IG4gPT0gMFxuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbiA9ICN7OjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgb2JqZWN0ICE9PSB1bmRlZmluZWRgIHx8IGJsb2NrXG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIHNpemVcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICByZXBsYWNlIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICBzZWxmW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBiaW5vbWlhbF9jb2VmZmljaWVudChuLCBrKSB7XG4gICAgICBpZiAobiA9PT0gayB8fCBrID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoayA+IDAgJiYgbiA+IGspIHtcbiAgICAgICAgcmV0dXJuIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrIC0gMSkgKyBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb21iaW5hdGlvbihuKVxuICAgIG51bSA9IDo6T3BhbC5jb2VyY2VfdG8hIG4sIDo6SW50ZWdlciwgOnRvX2ludFxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29tYmluYXRpb24sIG51bSkgeyBgYmlub21pYWxfY29lZmZpY2llbnQoI3tzZWxmfS5sZW5ndGgsIG51bSlgIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCBzdGFjaywgY2hvc2VuLCBsZXYsIGRvbmUsIG5leHQ7XG5cbiAgICAgIGlmIChudW0gPT09IDApIHtcbiAgICAgICAgI3t5aWVsZCBbXX1cbiAgICAgIH0gZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAje3lpZWxkIGBbc2VsZltpXV1gfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW0gPT09IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICN7eWllbGQgYHNlbGYuc2xpY2UoKWB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW0gPj0gMCAmJiBudW0gPCBzZWxmLmxlbmd0aCkge1xuICAgICAgICBzdGFjayA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IG51bSArIDE7IGkrKykge1xuICAgICAgICAgIHN0YWNrLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaG9zZW4gPSBbXTtcbiAgICAgICAgbGV2ID0gMDtcbiAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICBzdGFja1swXSA9IC0xO1xuXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgIGNob3NlbltsZXZdID0gc2VsZltzdGFja1tsZXYrMV1dO1xuICAgICAgICAgIHdoaWxlIChsZXYgPCBudW0gLSAxKSB7XG4gICAgICAgICAgICBsZXYrKztcbiAgICAgICAgICAgIG5leHQgPSBzdGFja1tsZXYrMV0gPSBzdGFja1tsZXZdICsgMTtcbiAgICAgICAgICAgIGNob3NlbltsZXZdID0gc2VsZltuZXh0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgI3sgeWllbGQgYGNob3Nlbi5zbGljZSgpYCB9XG4gICAgICAgICAgbGV2Kys7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZG9uZSA9IChsZXYgPT09IDApO1xuICAgICAgICAgICAgc3RhY2tbbGV2XSsrO1xuICAgICAgICAgICAgbGV2LS07XG4gICAgICAgICAgfSB3aGlsZSAoIHN0YWNrW2xldisxXSArIG51bSA9PT0gc2VsZi5sZW5ndGggKyBsZXYgKyAxICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwZWF0ZWRfY29tYmluYXRpb24obilcbiAgICBudW0gPSA6Ok9wYWwuY29lcmNlX3RvISBuLCA6OkludGVnZXIsIDp0b19pbnRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6cmVwZWF0ZWRfY29tYmluYXRpb24sIG51bSkgeyBgYmlub21pYWxfY29lZmZpY2llbnQoc2VsZi5sZW5ndGggKyBudW0gLSAxLCBudW0pYCB9XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdGUobWF4LCBmcm9tLCBidWZmZXIsIHNlbGYpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbWF4KSB7XG4gICAgICAgICAgdmFyIGNvcHkgPSBidWZmZXIuc2xpY2UoKTtcbiAgICAgICAgICAje3lpZWxkIGBjb3B5YH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goc2VsZltpXSk7XG4gICAgICAgICAgaXRlcmF0ZShtYXgsIGksIGJ1ZmZlciwgc2VsZik7XG4gICAgICAgICAgYnVmZmVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPj0gMCkge1xuICAgICAgICBpdGVyYXRlKG51bSwgMCwgW10sIHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoaXRlbSA9IHNlbGZbaV0pICE9PSBuaWwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3QhXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGZbaV0gPT09IG5pbCkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwgPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbmNhdCgqb3RoZXJzKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgb3RoZXJzID0gb3RoZXJzLm1hcCBkbyB8b3RoZXJ8XG4gICAgICBvdGhlciA9IGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgICBlbmRcblxuICAgICAgaWYgb3RoZXIuZXF1YWw/KHNlbGYpXG4gICAgICAgIG90aGVyID0gb3RoZXIuZHVwXG4gICAgICBlbmRcblxuICAgICAgb3RoZXJcbiAgICBlbmRcblxuICAgIG90aGVycy5lYWNoIGRvIHxvdGhlcnxcbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzZWxmLnB1c2gob3RoZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkZWxldGUob2JqZWN0KVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvcmlnaW5hbDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIHJldHVybiAje3lpZWxkfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBzZWxmW2luZGV4XTtcblxuICAgICAgc2VsZi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGZpbHRlcklmKHNlbGYsICRmYWxzeSwgYmxvY2spXG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRpZmZlcmVuY2UoKmFycmF5cylcbiAgICBhcnJheXMucmVkdWNlKHRvX2EuZHVwKSB7IHxhLCBifCBhIC0gYiB9XG4gIGVuZFxuXG4gIGRlZiBkaWcoaWR4LCAqaWR4cylcbiAgICBpdGVtID0gc2VsZltpZHhdXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwgaWR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqaWR4cylcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgICV4e1xuICAgICAgbnVtYmVyID0gJGNvZXJjZV90byhudW1iZXIsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvcn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UobnVtYmVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuQXJyYXkgJiZcbiAgICAgICAgICBzZWxmLiQkY2xhc3MuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcy4kJHByaXN0aW5lICYmXG4gICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfaW5kZXgoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9pbmRleCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlbXB0eT9cbiAgICBgc2VsZi5sZW5ndGggPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWwoYXJyYXksIG90aGVyKSB7XG4gICAgICAgIHZhciBpLCBsZW5ndGgsIGEsIGI7XG5cbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSAje290aGVyLnRvX2F9O1xuXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhID0gYXJyYXlbaV07XG4gICAgICAgICAgYiA9IG90aGVyW2ldO1xuICAgICAgICAgIGlmIChhLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAuZXFsPyhgYmApfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFsKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmZXRjaChpbmRleCwgZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbCA9IGluZGV4O1xuXG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwgJiYgZGVmYXVsdHMgIT0gbnVsbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGJsb2NrIHN1cGVyc2VkZXMgZGVmYXVsdCB2YWx1ZSBhcmd1bWVudCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gYmxvY2sob3JpZ2luYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdHMgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJpbmRleCAje2BvcmlnaW5hbGB9IG91dHNpZGUgb2YgYXJyYXkgYm91bmRzOiAwLi4uMFwifVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IC0je2BzZWxmLmxlbmd0aGB9Li4uI3tgc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaWxsKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiBibG9ja1xuICAgICAgaWYgYGFyZ3MubGVuZ3RoID4gMmBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5sZW5ndGh9IGZvciAwLi4yKVwiXG4gICAgICBlbmRcblxuICAgICAgb25lLCB0d28gPSBhcmdzXG4gICAgZWxzZVxuICAgICAgaWYgYGFyZ3MubGVuZ3RoID09IDBgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJ1xuICAgICAgZWxzaWYgYGFyZ3MubGVuZ3RoID4gM2BcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5sZW5ndGh9IGZvciAxLi4zKVwiXG4gICAgICBlbmRcblxuICAgICAgb2JqLCBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbmRcblxuICAgIGlmIDo6UmFuZ2UgPT09IG9uZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdsZW5ndGggaW52YWxpZCB3aXRoIHJhbmdlJyBpZiB0d29cblxuICAgICAgbGVmdCAgID0gYG9uZS5iZWdpbiA9PT0gbmlsID8gMCA6ICRjb2VyY2VfdG8ob25lLmJlZ2luLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiI3tvbmUuaW5zcGVjdH0gb3V0IG9mIHJhbmdlXCIgaWYgYGxlZnQgPCAwYFxuXG4gICAgICByaWdodCA9IGBvbmUuZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8ob25lLmVuZCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgcmlnaHQgKz0gdGhpcy5sZW5ndGhgIGlmIGByaWdodCA8IDBgXG4gICAgICBgcmlnaHQgKz0gMWAgdW5sZXNzIG9uZS5leGNsdWRlX2VuZD9cblxuICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0IDw9IGxlZnRgXG4gICAgZWxzaWYgb25lXG4gICAgICBsZWZ0ICAgPSBgJGNvZXJjZV90byhvbmUsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYGxlZnQgKz0gdGhpcy5sZW5ndGhgIGlmIGBsZWZ0IDwgMGBcbiAgICAgIGxlZnQgICA9IDAgaWYgYGxlZnQgPCAwYFxuXG4gICAgICBpZiB0d29cbiAgICAgICAgcmlnaHQgPSBgJGNvZXJjZV90byh0d28sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgIHJldHVybiBzZWxmIGlmIGByaWdodCA9PSAwYFxuXG4gICAgICAgIGByaWdodCArPSBsZWZ0YFxuICAgICAgZWxzZVxuICAgICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGxlZnQgID0gMFxuICAgICAgcmlnaHQgPSBgdGhpcy5sZW5ndGhgXG4gICAgZW5kXG5cbiAgICBpZiBgbGVmdCA+IHRoaXMubGVuZ3RoYFxuICAgICAgJXh7XG4gICAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoOyBpIDwgcmlnaHQ7IGkrKykge1xuICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGlmIGByaWdodCA+IHRoaXMubGVuZ3RoYFxuICAgICAgYHRoaXMubGVuZ3RoID0gcmlnaHRgXG4gICAgZW5kXG5cbiAgICBpZiBibG9ja1xuICAgICAgJXh7XG4gICAgICAgIGZvciAobGVuZ3RoID0gdGhpcy5sZW5ndGg7IGxlZnQgPCByaWdodDsgbGVmdCsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBibG9jayhsZWZ0KTtcbiAgICAgICAgICBzZWxmW2xlZnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICBzZWxmW2xlZnRdID0gI3tvYmp9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbMF07XG4gICAgICB9XG5cbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKDAsIGNvdW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gX2ZsYXR0ZW4oYXJyYXksIGxldmVsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGksIGxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW0sIGFyeTtcblxuICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBhcnJheVtpXTtcblxuICAgICAgICAgIGlmICghJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19hcnknLCB0cnVlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnkgPSAje2BpdGVtYC50b19hcnl9O1xuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhcnkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KF9mbGF0dGVuKGFyeSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJ5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF9mbGF0dGVuKGFyeSwgbGV2ZWwgLSAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsID0gJGNvZXJjZV90byhsZXZlbCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmxhdHRlbihzZWxmLCBsZXZlbCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmxhdHRlbiEobGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgZmxhdHRlbmVkID0gI3tmbGF0dGVuIGxldmVsfTtcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09IGZsYXR0ZW5lZC5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2VsZltpXSAhPT0gZmxhdHRlbmVkW2ldKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PSBsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICN7cmVwbGFjZSBgZmxhdHRlbmVkYH07XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgYCRmcmVlemUoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKCRoYXNoX2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICByZXN1bHQgPSBbJ0EnXSxcbiAgICAgICAgICBoYXNoX2lkID0gc2VsZi4kb2JqZWN0X2lkKCksXG4gICAgICAgICAgaXRlbSwgaSwga2V5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgJGhhc2hfaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBlYXJseSBmb3IgcmVjdXJzaXZlIHN0cnVjdHVyZXNcbiAgICAgICAgaWYgKCRoYXNoX2lkc1toYXNoX2lkXSkge1xuICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiAkaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gJGhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkaGFzaF9pZHNbaGFzaF9pZF0gPSBzZWxmO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbS4kaGFzaCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignLCcpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICRoYXNoX2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1lbWJlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBtZW1iZXJ9KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6aW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc2VydChpbmRleCwgKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAjeyA6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiI3tpbmRleH0gaXMgb3V0IG9mIGJvdW5kc1wiIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYubGVuZ3RoOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5wdXNoKG5pbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCAwXS5jb25jYXQob2JqZWN0cykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYHZhciBpbnNwZWN0X3N0YWNrID0gW11gXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGlkID0gI3tfX2lkX199LFxuICAgICAgcHVzaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBiZWdpblxuICAgICAgJXh7XG4gICAgICAgIGlmIChpbnNwZWN0X3N0YWNrLmluZGV4T2YoaWQpICE9PSAtMSkge1xuICAgICAgICAgIHB1c2hlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiAnWy4uLl0nO1xuICAgICAgICB9XG4gICAgICAgIGluc3BlY3Rfc3RhY2sucHVzaChpZClcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gI3tzZWxmW2BpYF19O1xuXG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tPcGFsLmluc3BlY3QoYGl0ZW1gKX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsICcpICsgJ10nO1xuICAgICAgfVxuICAgICAgbmlsXG4gICAgZW5zdXJlXG4gICAgICBgaWYgKHB1c2hlZCkgaW5zcGVjdF9zdGFjay5wb3AoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGludGVyc2VjdGlvbigqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgJiBiIH1cbiAgZW5kXG5cbiAgZGVmIGludGVyc2VjdD8ob3RoZXIpXG4gICAgIWludGVyc2VjdGlvbihvdGhlcikuZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiBqb2luKHNlcCA9IG5pbClcbiAgICByZXR1cm4gJycgaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgaWYgYHNlcCA9PT0gbmlsYFxuICAgICAgc2VwID0gJCxcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGksIGxlbmd0aCwgaXRlbSwgdG1wO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX3N0cicpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc3RyfTtcblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC50b19zfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fYXJ5fTtcblxuICAgICAgICAgIGlmICh0bXAgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YHRtcGAuam9pbihzZXApfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX3MnKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX3N9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0bXApO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcoXCIje09wYWwuaW5zcGVjdChpdGVtKX0gZG9lc24ndCByZXNwb25kIHRvICN0b19zdHIsICN0b19hcnkgb3IgI3RvX3NcIiwgJ3RvX3N0cicpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlcCA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCN7OjpPcGFsLmNvZXJjZV90byEoc2VwLCA6OlN0cmluZywgOnRvX3N0cikudG9fc30pO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZmlsdGVySWYoc2VsZiwgJHRydXRoeSwgYmxvY2spXG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxhc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IDAgPyBuaWwgOiBzZWxmW3NlbGYubGVuZ3RoIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ307XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIGNvdW50ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKHNlbGYubGVuZ3RoIC0gY291bnQsIHNlbGYubGVuZ3RoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiBtYXgobiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGVhY2gubWF4KG4sICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1pbigmYmxvY2spXG4gICAgZWFjaC5taW4oJmJsb2NrKVxuICBlbmRcblxuICAleHtcbiAgICAvLyBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIGZyb20sIGZyb20tMSwgLi4uLCBmcm9tIC0gaG93X21hbnkgKyAxLlxuICAgIGZ1bmN0aW9uIGRlc2NlbmRpbmdfZmFjdG9yaWFsKGZyb20sIGhvd19tYW55KSB7XG4gICAgICB2YXIgY291bnQgPSBob3dfbWFueSA+PSAwID8gMSA6IDA7XG4gICAgICB3aGlsZSAoaG93X21hbnkpIHtcbiAgICAgICAgY291bnQgKj0gZnJvbTtcbiAgICAgICAgZnJvbS0tO1xuICAgICAgICBob3dfbWFueS0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBwZXJtdXRhdGlvbihudW0gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnBlcm11dGF0aW9uLCBudW0pIGRvXG4gICAgICAgIGBkZXNjZW5kaW5nX2ZhY3RvcmlhbChzZWxmLmxlbmd0aCwgbnVtID09PSB1bmRlZmluZWQgPyBzZWxmLmxlbmd0aCA6IG51bSlgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHBlcm11dGUsIG9mZmVuc2l2ZSwgb3V0cHV0O1xuXG4gICAgICBpZiAobnVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbnVtID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbnVtID0gJGNvZXJjZV90byhudW0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtIDwgMCB8fCBzZWxmLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAvLyBubyBwZXJtdXRhdGlvbnMsIHlpZWxkIG5vdGhpbmdcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAvLyBleGFjdGx5IG9uZSBwZXJtdXRhdGlvbjogdGhlIHplcm8tbGVuZ3RoIGFycmF5XG4gICAgICAgICN7IHlpZWxkIFtdIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCwgZWFzeSBjYXNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7IHlpZWxkIGBbc2VsZltpXV1gIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGdlbmVyYWwgY2FzZVxuICAgICAgICAjeyBwZXJtID0gQXJyYXkubmV3KG51bSkgfTtcbiAgICAgICAgI3sgdXNlZCA9IEFycmF5Lm5ldyhgc2VsZi5sZW5ndGhgLCBmYWxzZSkgfTtcblxuICAgICAgICBwZXJtdXRlID0gZnVuY3Rpb24obnVtLCBwZXJtLCBpbmRleCwgdXNlZCwgYmxrKSB7XG4gICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYoI3sgIXVzZWRbYGlgXSB9KSB7XG4gICAgICAgICAgICAgIHBlcm1baW5kZXhdID0gaTtcbiAgICAgICAgICAgICAgaWYoaW5kZXggPCBudW0gLSAxKSB7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGVybXV0ZS5jYWxsKHNlbGYsIG51bSwgcGVybSwgaW5kZXggKyAxLCB1c2VkLCBibGspO1xuICAgICAgICAgICAgICAgIHVzZWRbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBlcm0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNlbGZbcGVybVtqXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkeWllbGQxKGJsaywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICAvLyBvZmZlbnNpdmUgKGJvdGggZGVmaW5pdGlvbnMpIGNvcHkuXG4gICAgICAgICAgb2ZmZW5zaXZlID0gc2VsZi5zbGljZSgpO1xuICAgICAgICAgIHBlcm11dGUuY2FsbChvZmZlbnNpdmUsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHBlcm11dGUuY2FsbChzZWxmLCBudW0sIHBlcm0sIDAsIHVzZWQsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGVhdGVkX3Blcm11dGF0aW9uKG4pXG4gICAgbnVtID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXBlYXRlZF9wZXJtdXRhdGlvbiwgbnVtKSB7IG51bSA+PSAwID8gc2l6ZSoqbnVtIDogMCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gaXRlcmF0ZShtYXgsIGJ1ZmZlciwgc2VsZikge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBtYXgpIHtcbiAgICAgICAgICB2YXIgY29weSA9IGJ1ZmZlci5zbGljZSgpO1xuICAgICAgICAgICN7eWllbGQgYGNvcHlgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXIucHVzaChzZWxmW2ldKTtcbiAgICAgICAgICBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKTtcbiAgICAgICAgICBidWZmZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZShudW0sIFtdLCBzZWxmLnNsaWNlKCkpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHBvcChjb3VudCA9IHVuZGVmaW5lZClcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2VsZi5wb3AoKWBcbiAgICBlbmRcblxuICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgaWYgYGNvdW50ID09PSAxYFxuICAgICAgYFtzZWxmLnBvcCgpXWBcbiAgICBlbHNpZiBgY291bnQgPiBzZWxmLmxlbmd0aGBcbiAgICAgIGBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aClgXG4gICAgZWxzZVxuICAgICAgYHNlbGYuc3BsaWNlKHNlbGYubGVuZ3RoIC0gY291bnQsIHNlbGYubGVuZ3RoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHByb2R1Y3QoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAje2Jsb2NrX2dpdmVuP30gPyBudWxsIDogW10sXG4gICAgICAgICAgbiA9IGFyZ3MubGVuZ3RoICsgMSxcbiAgICAgICAgICBjb3VudGVycyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBsZW5ndGhzICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBhcnJheXMgICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBpLCBtLCBzdWJhcnJheSwgbGVuLCByZXN1bHRsZW4gPSAxO1xuXG4gICAgICBhcnJheXNbMF0gPSBzZWxmO1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBhcnJheXNbaV0gPSAkY29lcmNlX3RvKGFyZ3NbaSAtIDFdLCAjezo6QXJyYXl9LCAndG9fYXJ5Jyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGVuID0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRsZW4gKj0gbGVuO1xuICAgICAgICBpZiAocmVzdWx0bGVuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAndG9vIGJpZyB0byBwcm9kdWN0J31cbiAgICAgICAgfVxuICAgICAgICBsZW5ndGhzW2ldID0gbGVuO1xuICAgICAgICBjb3VudGVyc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIG91dGVyX2xvb3A6IGZvciAoOzspIHtcbiAgICAgICAgc3ViYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHN1YmFycmF5LnB1c2goYXJyYXlzW2ldW2NvdW50ZXJzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN1YmFycmF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje3lpZWxkIGBzdWJhcnJheWB9XG4gICAgICAgIH1cbiAgICAgICAgbSA9IG4gLSAxO1xuICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB3aGlsZSAoY291bnRlcnNbbV0gPT09IGxlbmd0aHNbbV0pIHtcbiAgICAgICAgICBjb3VudGVyc1ttXSA9IDA7XG4gICAgICAgICAgaWYgKC0tbSA8IDApIGJyZWFrIG91dGVyX2xvb3A7XG4gICAgICAgICAgY291bnRlcnNbbV0rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0IHx8IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHVzaCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChvYmplY3RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICYmIGl0ZW1bMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgje2BpdGVtWzFdYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc2VsZltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG9yaWdpbmFsID0gbGVuZ3RoXG4gICAgZGVsZXRlX2lmKCZibG9jaylcblxuICAgIHVubGVzcyBsZW5ndGggPT0gb3JpZ2luYWxcbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBvdGhlciA9IGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHNlbGYucHVzaC5hcHBseShzZWxmLCBvdGhlcik7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNsaWNlKDApLnJldmVyc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2UhXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBgc2VsZi5yZXZlcnNlKClgXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlX2VhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICByZXZlcnNlLmVhY2goJmJsb2NrKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IGBvYmplY3RgfSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IHNlbGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6cmluZGV4fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3RhdGUobiA9IDEpXG4gICAgJXh7XG4gICAgICB2YXIgYXJ5LCBpZHgsIGZpcnN0UGFydCwgbGFzdFBhcnQ7XG5cbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpXG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgYXJ5ID0gc2VsZi5zbGljZSgpO1xuICAgICAgaWR4ID0gbiAlIGFyeS5sZW5ndGg7XG5cbiAgICAgIGZpcnN0UGFydCA9IGFyeS5zbGljZShpZHgpO1xuICAgICAgbGFzdFBhcnQgPSBhcnkuc2xpY2UoMCwgaWR4KTtcbiAgICAgIHJldHVybiBmaXJzdFBhcnQuY29uY2F0KGxhc3RQYXJ0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3RhdGUhKGNudCA9IDEpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDAgfHwgc2VsZi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICBjbnQgPSAkY29lcmNlX3RvKGNudCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgfVxuICAgIGFyeSA9IHJvdGF0ZShjbnQpXG4gICAgcmVwbGFjZSBhcnlcbiAgZW5kXG5cbiAgY2xhc3Mgc2VsZjo6U2FtcGxlUmFuZG9tXG4gICAgZGVmIGluaXRpYWxpemUocm5nKVxuICAgICAgQHJuZyA9IHJuZ1xuICAgIGVuZFxuXG4gICAgZGVmIHJhbmQoc2l6ZSlcbiAgICAgIHJhbmRvbSA9IGAkY29lcmNlX3RvKCN7QHJuZy5yYW5kKHNpemUpfSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdyYW5kb20gdmFsdWUgbXVzdCBiZSA+PSAwJyBpZiBgcmFuZG9tIDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiBBcnJheSBzaXplJyB1bmxlc3MgYHJhbmRvbSA8IHNpemVgXG5cbiAgICAgIHJhbmRvbVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2FtcGxlKGNvdW50ID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBhdCA6Oktlcm5lbC5yYW5kKGBzZWxmLmxlbmd0aGApIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuXG4gICAgaWYgYG9wdGlvbnMgPT09IHVuZGVmaW5lZGBcbiAgICAgIGlmIChvID0gOjpPcGFsLmNvZXJjZV90bz8gY291bnQsIDo6SGFzaCwgOnRvX2hhc2gpXG4gICAgICAgIG9wdGlvbnMgPSBvXG4gICAgICAgIGNvdW50ID0gbmlsXG4gICAgICBlbHNlXG4gICAgICAgIG9wdGlvbnMgPSBuaWxcbiAgICAgICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIG9wdGlvbnMgPSBgJGNvZXJjZV90byhvcHRpb25zLCAjezo6SGFzaH0sICd0b19oYXNoJylgXG4gICAgZW5kXG5cbiAgICBpZiBjb3VudCAmJiBgY291bnQgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY291bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCdcbiAgICBlbmRcblxuICAgIHJuZyA9IG9wdGlvbnNbOnJhbmRvbV0gaWYgb3B0aW9uc1xuICAgIHJuZyA9IGlmIHJuZyAmJiBybmcucmVzcG9uZF90bz8oOnJhbmQpXG4gICAgICAgICAgICBTYW1wbGVSYW5kb20ubmV3IHJuZ1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIDo6S2VybmVsXG4gICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gYHNlbGZbI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX1dYCB1bmxlc3MgY291bnRcblxuICAgICV4e1xuXG4gICAgICB2YXIgYWJhbmRvbiwgc3BpbiwgcmVzdWx0LCBpLCBqLCBrLCB0YXJnZXRJbmRleCwgb2xkVmFsdWU7XG5cbiAgICAgIGlmIChjb3VudCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIGNvdW50ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBbc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgIGogPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgaiA9IGkgPT09IDAgPyBpICsgMSA6IGkgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW3NlbGZbaV0sIHNlbGZbal1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChzZWxmLmxlbmd0aCAvIGNvdW50ID4gMykge1xuICAgICAgICAgICAgYWJhbmRvbiA9IGZhbHNlO1xuICAgICAgICAgICAgc3BpbiA9IDA7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9ICN7IEFycmF5Lm5ldyhjb3VudCkgfTtcbiAgICAgICAgICAgIGkgPSAxO1xuXG4gICAgICAgICAgICByZXN1bHRbMF0gPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgY291bnQpIHtcbiAgICAgICAgICAgICAgayA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgICB3aGlsZSAoaiA8IGkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA9PT0gcmVzdWx0W2pdKSB7XG4gICAgICAgICAgICAgICAgICBzcGluKys7XG4gICAgICAgICAgICAgICAgICBpZiAoc3BpbiA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBhYmFuZG9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWJhbmRvbikgeyBicmVhazsgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGs7XG5cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFiYW5kb24pIHtcbiAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChpIDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBzZWxmW3Jlc3VsdFtpXV07XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvdW50OyBjKyspIHtcbiAgICAgICAgICAgIHRhcmdldEluZGV4ID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHJlc3VsdFtjXTtcbiAgICAgICAgICAgIHJlc3VsdFtjXSA9IHJlc3VsdFt0YXJnZXRJbmRleF07XG4gICAgICAgICAgICByZXN1bHRbdGFyZ2V0SW5kZXhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvdW50ID09PSBzZWxmLmxlbmd0aCA/IHJlc3VsdCA6ICN7YHJlc3VsdGBbMCwgY291bnRdfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgaXRlbSk7XG5cbiAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKVxuXG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcbiAgICAgICN7IGtlZXBfaWYoJmJsb2NrKSB9O1xuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2hpZnQoY291bnQgPSB1bmRlZmluZWQpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcbiAgICAgIHJldHVybiBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgICByZXR1cm4gYHNoaWZ0Tm9Bcmcoc2VsZilgXG4gICAgZW5kXG5cbiAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBjb3VudCA8IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGBzZWxmLnNwbGljZSgwLCBjb3VudClgXG4gIGVuZFxuXG4gIGRlZiBzaHVmZmxlKHJuZyA9IHVuZGVmaW5lZClcbiAgICBkdXAudG9fYS5zaHVmZmxlIShybmcpXG4gIGVuZFxuXG4gIGRlZiBzaHVmZmxlIShybmcgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgcmFuZGdlbiwgaSA9IHNlbGYubGVuZ3RoLCBqLCB0bXA7XG5cbiAgICAgIGlmIChybmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBybmcgPSAjezo6T3BhbC5jb2VyY2VfdG8/KHJuZywgOjpIYXNoLCA6dG9faGFzaCl9O1xuXG4gICAgICAgIGlmIChybmcgIT09IG5pbCkge1xuICAgICAgICAgIHJuZyA9ICN7cm5nWzpyYW5kb21dfTtcblxuICAgICAgICAgIGlmIChybmcgIT09IG5pbCAmJiAje3JuZy5yZXNwb25kX3RvPyg6cmFuZCl9KSB7XG4gICAgICAgICAgICByYW5kZ2VuID0gcm5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSkge1xuICAgICAgICBpZiAocmFuZGdlbikge1xuICAgICAgICAgIGogPSByYW5kZ2VuLiRyYW5kKGkpLiR0b19pbnQoKTtcblxuICAgICAgICAgIGlmIChqIDwgMCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwicmFuZG9tIG51bWJlciB0b28gc21hbGwgI3tgamB9XCJ9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGogPj0gaSkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwicmFuZG9tIG51bWJlciB0b28gYmlnICN7YGpgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBqID0gI3tyYW5kKGBpYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gc2VsZlstLWldO1xuICAgICAgICBzZWxmW2ldID0gc2VsZltqXTtcbiAgICAgICAgc2VsZltqXSA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2xpY2UhKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICByZXN1bHQgPSBuaWxcblxuICAgIGlmIGBsZW5ndGggPT09IHVuZGVmaW5lZGBcbiAgICAgIGlmIDo6UmFuZ2UgPT09IGluZGV4XG4gICAgICAgIHJhbmdlID0gaW5kZXhcbiAgICAgICAgcmVzdWx0ID0gc2VsZltyYW5nZV1cblxuICAgICAgICByYW5nZV9zdGFydCA9IGByYW5nZS5iZWdpbiA9PT0gbmlsID8gMCA6ICRjb2VyY2VfdG8ocmFuZ2UuYmVnaW4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICByYW5nZV9lbmQgPSBgcmFuZ2UuZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8ocmFuZ2UuZW5kLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAocmFuZ2Vfc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9zdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFuZ2VfZW5kIDwgMCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2VfZW5kID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgPSBzZWxmLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZXhjbCkge1xuICAgICAgICAgICAgICByYW5nZV9lbmQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmFuZ2VfbGVuZ3RoID0gcmFuZ2VfZW5kIC0gcmFuZ2Vfc3RhcnQ7XG4gICAgICAgICAgaWYgKHJhbmdlLmV4Y2wgJiYgcmFuZ2UuZW5kICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCAtPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZV9sZW5ndGggKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFuZ2Vfc3RhcnQgPCBzZWxmLmxlbmd0aCAmJiByYW5nZV9zdGFydCA+PSAwICYmIHJhbmdlX2VuZCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX2VuZCA+PSAwICYmIHJhbmdlX2xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNlbGYuc3BsaWNlKHJhbmdlX3N0YXJ0LCByYW5nZV9sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBzdGFydCA9IGAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmW3N0YXJ0XTtcblxuICAgICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZi5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdGFydCA9IGAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGxlbmd0aCA9IGAkY29lcmNlX3RvKGxlbmd0aCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBsZW5ndGg7XG5cbiAgICAgICAgcmVzdWx0ID0gI3tzZWxmW3N0YXJ0LCBsZW5ndGhdfTtcblxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgc3RhcnQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgKyBsZW5ndGggPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPCBzZWxmLmxlbmd0aCAmJiBzdGFydCA+PSAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2Uoc3RhcnQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIHNvcnQoJmJsb2NrKVxuICAgIHJldHVybiBzZWxmIHVubGVzcyBgc2VsZi5sZW5ndGggPiAxYFxuXG4gICAgJXh7XG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBibG9jayA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gI3tgYWAgPD0+IGBiYH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKCkuc29ydChmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciByZXQgPSBibG9jayh4LCB5KTtcblxuICAgICAgICBpZiAocmV0ID09PSBuaWwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7YHhgLmluc3BlY3R9IHdpdGggI3tgeWAuaW5zcGVjdH0gZmFpbGVkXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7YHJldGAgPiAwfSA/IDEgOiAoI3tgcmV0YCA8IDB9ID8gLTEgOiAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnQhKCZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilcblxuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICByZXN1bHQgPSAje2BzZWxmLnNsaWNlKClgLnNvcnQoJmJsb2NrKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0fTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5sZW5ndGggPSAwO1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChyZXN1bHRbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzb3J0X2J5ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICByZXBsYWNlIHNvcnRfYnkoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdGFrZShjb3VudClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3J9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBjb3VudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IGJsb2NrKGl0ZW0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGNsYXNzID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLkFycmF5LiRuZXcoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYXJ5XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgYXJyYXkgPSBzZWxmXG4gICAgYXJyYXkgPSBhcnJheS5tYXAoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbiA9IGFycmF5Lmxlbmd0aCwgYXJ5LCBrZXksIHZhbCwgaGFzaCA9ICN7e319O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJ5ID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhgYXJyYXlbaV1gLCA6OkFycmF5LCA6dG9fYXJ5KX07XG4gICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSBhdCAje2BpYH0gKGV4cGVjdGVkIGFycmF5KVwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcnkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgYXJyYXkgbGVuZ3RoIGF0ICN7YGlgfSAoZXhwZWN0ZWQgMiwgd2FzICN7YGFyeWAubGVuZ3RofSlcIn1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBhcnlbMF07XG4gICAgICAgIHZhbCA9IGFyeVsxXTtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNwb3NlXG4gICAgcmV0dXJuIFtdIGlmIGVtcHR5P1xuXG4gICAgcmVzdWx0ID0gW11cbiAgICBtYXggICAgPSBuaWxcblxuICAgIGVhY2ggZG8gfHJvd3xcbiAgICAgIHJvdyA9IGlmIDo6QXJyYXkgPT09IHJvd1xuICAgICAgICAgICAgICByb3cudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhyb3csICN7OjpBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAgIG1heCB8fD0gYHJvdy5sZW5ndGhgXG5cbiAgICAgIGlmIGByb3cubGVuZ3RoYCAhPSBtYXhcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImVsZW1lbnQgc2l6ZSBkaWZmZXJzICgje2Byb3cubGVuZ3RoYH0gc2hvdWxkIGJlICN7bWF4fSlcIlxuICAgICAgZW5kXG5cbiAgICAgIGByb3cubGVuZ3RoYC50aW1lcyBkbyB8aXxcbiAgICAgICAgZW50cnkgPSAocmVzdWx0W2ldIHx8PSBbXSlcbiAgICAgICAgZW50cnkgPDwgcm93LmF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdW5pb24oKmFycmF5cylcbiAgICBhcnJheXMucmVkdWNlKHVuaXEpIHsgfGEsIGJ8IGEgfCBiIH1cbiAgZW5kXG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XG5cbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBpdGVtLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAga2V5ID0gJHlpZWxkMShibG9jaywgaXRlbSk7XG4gICAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tgaGFzaGAudmFsdWVzfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1bmlxISgmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgb3JpZ2luYWxfbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsX2xlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBrZXkgPSAoYmxvY2sgPT09IG5pbCA/IGl0ZW0gOiAkeWllbGQxKGJsb2NrLCBpdGVtKSk7XG5cbiAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsX2xlbmd0aCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5zaGlmdCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBzZWxmTGVuZ3RoID0gc2VsZi5sZW5ndGhcbiAgICAgIHZhciBvYmplY3RzTGVuZ3RoID0gb2JqZWN0cy5sZW5ndGhcbiAgICAgIGlmIChvYmplY3RzTGVuZ3RoID09IDApIHJldHVybiBzZWxmO1xuICAgICAgdmFyIGluZGV4ID0gc2VsZkxlbmd0aCAtIG9iamVjdHNMZW5ndGhcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChzZWxmW2luZGV4ICsgaV0pXG4gICAgICB9XG4gICAgICB2YXIgbGVuID0gc2VsZkxlbmd0aCAtIDFcbiAgICAgIHdoaWxlIChsZW4gLSBvYmplY3RzTGVuZ3RoID49IDApIHtcbiAgICAgICAgc2VsZltsZW5dID0gc2VsZltsZW4gLSBvYmplY3RzTGVuZ3RoXVxuICAgICAgICBsZW4tLVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3RzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2VsZltqXSA9IG9iamVjdHNbal1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICBvdXQgPSBbXVxuXG4gICAgYXJncy5lYWNoIGRvIHxlbGVtfFxuICAgICAgaWYgZWxlbS5pc19hPyA6OlJhbmdlXG4gICAgICAgIGZpbmlzaCA9IGAje2VsZW0uZW5kfSA9PT0gbmlsID8gLTEgOiAkY29lcmNlX3RvKCN7ZWxlbS5lbmR9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgc3RhcnQgPSBgI3tlbGVtLmJlZ2lufSA9PT0gbmlsID8gMCA6ICRjb2VyY2VfdG8oI3tlbGVtLmJlZ2lufSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgICAgI3tuZXh0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoZmluaXNoIDwgMCkge1xuICAgICAgICAgICAgZmluaXNoID0gZmluaXNoICsgc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgje2VsZW0uZXhjbHVkZV9lbmQ/fSAmJiAje2VsZW0uZW5kfSAhPT0gbmlsKSB7XG4gICAgICAgICAgICBmaW5pc2gtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAje25leHR9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0LnVwdG8oZmluaXNoKSB7IHxpfCBvdXQgPDwgYXQoaSkgfVxuICAgICAgZWxzZVxuICAgICAgICBpID0gYCRjb2VyY2VfdG8oZWxlbSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIG91dCA8PCBhdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvdXRcbiAgZW5kXG5cbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHNpemUgPSBzZWxmLmxlbmd0aCwgcGFydCwgbywgaSwgaiwgamo7XG5cbiAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgbyA9IG90aGVyc1tqXTtcbiAgICAgICAgaWYgKG8uJCRpc19hcnJheSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLiQkaXNfcmFuZ2UgfHwgby4kJGlzX2VudW1lcmF0b3IpIHtcbiAgICAgICAgICBvdGhlcnNbal0gPSBvLiR0YWtlKHNpemUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyc1tqXSA9ICN7KFxuICAgICAgICAgIDo6T3BhbC5jb2VyY2VfdG8/KGBvYCwgOjpBcnJheSwgOnRvX2FyeSkgfHxcbiAgICAgICAgICA6Ok9wYWwuY29lcmNlX3RvIShgb2AsIDo6RW51bWVyYXRvciwgOnRvX2VudW0sIDplYWNoKVxuICAgICAgICApLnRvX2F9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHBhcnQgPSBbc2VsZltpXV07XG5cbiAgICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIG8gPSBvdGhlcnNbal1baV07XG5cbiAgICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvID0gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRbaiArIDFdID0gbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgcmVzdWx0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmhlcml0ZWQoa2xhc3MpXG4gICAgJXh7XG4gICAgICBrbGFzcy4kJHByb3RvdHlwZS4kdG9fYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgc3VwZXIucmVqZWN0IHsgfGl2YXJ8IGAvXkBcXGQrJC8udGVzdCgje2l2YXJ9KWAgfHwgaXZhciA9PSAnQGxlbmd0aCcgfVxuICBlbmRcblxuICBkZWYgcGFjaygqYXJncylcbiAgICA6Oktlcm5lbC5yYWlzZSBcIlRvIHVzZSBBcnJheSNwYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL2FycmF5L3BhY2snLlwiXG4gIGVuZFxuXG4gIGFsaWFzIGFwcGVuZCBwdXNoXG4gIGFsaWFzIGZpbHRlciBzZWxlY3RcbiAgYWxpYXMgZmlsdGVyISBzZWxlY3QhXG4gIGFsaWFzIG1hcCBjb2xsZWN0XG4gIGFsaWFzIG1hcCEgY29sbGVjdCFcbiAgYWxpYXMgcHJlcGVuZCB1bnNoaWZ0XG4gIGFsaWFzIHNpemUgbGVuZ3RoXG4gIGFsaWFzIHNsaWNlIFtdXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIDo6T3BhbC5wcmlzdGluZSBzaW5nbGV0b25fY2xhc3MsIDphbGxvY2F0ZVxuICA6Ok9wYWwucHJpc3RpbmUgc2VsZiwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpBcnJheT4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsInRvX2EiLCJbXSIsImluaXRpYWxpemUiLCJzaXplIiwib2JqIiwiS2VybmVsIiwid2FybiIsIkludGVnZXI6Ok1BWCIsIkludGVnZXIiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJyZXBsYWNlIiwicmVzcG9uZF90bz8iLCJ0b19hcnkiLCJ0cnlfY29udmVydCIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiQXJyYXkiLCImIiwib3RoZXIiLCJ8IiwiKiIsImpvaW4iLCJ0b19zdHIiLCIrIiwiLSIsIjw8Iiwib2JqZWN0IiwiPD0+IiwiaGFzaCIsIj09Iiwib2JqZWN0X2lkIiwiaW5kZXgiLCJsZW5ndGgiLCJbXT0iLCJ2YWx1ZSIsImV4dHJhIiwiZGF0YSIsIlJhbmdlRXJyb3IiLCJpbnNwZWN0IiwiMSIsIkluZGV4RXJyb3IiLCJhbnk/IiwicGF0dGVybiIsImFzc29jIiwiYXQiLCJic2VhcmNoX2luZGV4IiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJUeXBlRXJyb3IiLCJjbGFzcyIsImJzZWFyY2giLCJibG9jayIsInRvX3Byb2MiLCJjeWNsZSIsIm4iLCJibG9jayBpbiBjeWNsZSIsImJsb2NrICgyIGxldmVscykgaW4gY3ljbGUiLCJuaWw/IiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJjb2VyY2VfdG8hIiwiPiIsIjAiLCJlbnVtZXJhdG9yX3NpemUiLCJlbXB0eT8iLCJjbGVhciIsImNvdW50IiwiaW5pdGlhbGl6ZV9jb3B5IiwiY29sbGVjdCIsImJsb2NrIGluIGNvbGxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QiLCJjb2xsZWN0ISIsImJsb2NrIGluIGNvbGxlY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0ISIsImNvbWJpbmF0aW9uIiwibnVtIiwiYmxvY2sgaW4gY29tYmluYXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbWJpbmF0aW9uIiwicmVwZWF0ZWRfY29tYmluYXRpb24iLCJibG9jayBpbiByZXBlYXRlZF9jb21iaW5hdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcmVwZWF0ZWRfY29tYmluYXRpb24iLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb25jYXQiLCJvdGhlcnMiLCJtYXAiLCJibG9jayBpbiBjb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbmNhdCIsImVxdWFsPyIsImR1cCIsImVhY2giLCJkZWxldGUiLCJkZWxldGVfYXQiLCJkZWxldGVfaWYiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsImRpZmZlcmVuY2UiLCJyZWR1Y2UiLCJhcnJheXMiLCJibG9jayBpbiBkaWZmZXJlbmNlIiwiYSIsImIiLCJibG9jayAoMiBsZXZlbHMpIGluIGRpZmZlcmVuY2UiLCJkaWciLCJpZHgiLCJpdGVtIiwiaWR4cyIsImRyb3AiLCJudW1iZXIiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9pbmRleCIsImJsb2NrIGluIGVhY2hfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfaW5kZXgiLCJlcWw/IiwiZmV0Y2giLCJkZWZhdWx0cyIsImZpbGwiLCJhcmdzIiwib25lIiwidHdvIiwiUmFuZ2UiLCJsZWZ0IiwicmlnaHQiLCJleGNsdWRlX2VuZD8iLCJmaXJzdCIsImZsYXR0ZW4iLCJsZXZlbCIsImZsYXR0ZW4hIiwiZnJlZXplIiwiZnJvemVuPyIsImluY2x1ZGU/IiwibWVtYmVyIiwiaW5zZXJ0IiwiX19pZF9fIiwiaW50ZXJzZWN0aW9uIiwiYmxvY2sgaW4gaW50ZXJzZWN0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Q/IiwiISIsInNlcCIsIiQsIiwidG9fcyIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJTdHJpbmciLCJrZWVwX2lmIiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsImxhc3QiLCJtYXgiLCJtaW4iLCJwZXJtdXRhdGlvbiIsImJsb2NrIGluIHBlcm11dGF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwZXJtdXRhdGlvbiIsInBlcm0iLCJ1c2VkIiwicmVwZWF0ZWRfcGVybXV0YXRpb24iLCJibG9jayBpbiByZXBlYXRlZF9wZXJtdXRhdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcmVwZWF0ZWRfcGVybXV0YXRpb24iLCI+PSIsIioqIiwicG9wIiwicHJvZHVjdCIsInB1c2giLCJyYXNzb2MiLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwib3JpZ2luYWwiLCJyZXZlcnNlIiwicmV2ZXJzZSEiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXZlcnNlX2VhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHJldmVyc2VfZWFjaCIsInJpbmRleCIsInJvdGF0ZSIsInJvdGF0ZSEiLCJjbnQiLCJhcnkiLCI8Y2xhc3M6c2VsZjo6U2FtcGxlUmFuZG9tPiIsInJhbmQiLCJyYW5kb20iLCJAcm5nIiwic2FtcGxlIiwib3B0aW9ucyIsIm8iLCJIYXNoIiwicm5nIiwiU2FtcGxlUmFuZG9tIiwic2VsZWN0IiwiYmxvY2sgaW4gc2VsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QiLCJzZWxlY3QhIiwiYmxvY2sgaW4gc2VsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0ISIsInNoaWZ0Iiwic2h1ZmZsZSIsInNodWZmbGUhIiwic2xpY2UhIiwicmVzdWx0IiwicmFuZ2UiLCJyYW5nZV9zdGFydCIsInJhbmdlX2VuZCIsInN0YXJ0Iiwic29ydCIsIjwiLCJzb3J0ISIsInNvcnRfYnkhIiwiYmxvY2sgaW4gc29ydF9ieSEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNvcnRfYnkhIiwic29ydF9ieSIsInRha2UiLCJ0YWtlX3doaWxlIiwidG9faCIsImFycmF5IiwidHJhbnNwb3NlIiwiYmxvY2sgaW4gdHJhbnNwb3NlIiwicm93IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc3Bvc2UiLCIkcmV0X29yXzEiLCJ0aW1lcyIsImkiLCJibG9jayAoMyBsZXZlbHMpIGluIHRyYW5zcG9zZSIsImVudHJ5IiwidW5pb24iLCJ1bmlxIiwiYmxvY2sgaW4gdW5pb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHVuaW9uIiwidmFsdWVzIiwidW5pcSEiLCJ1bnNoaWZ0IiwidmFsdWVzX2F0Iiwib3V0IiwiYmxvY2sgaW4gdmFsdWVzX2F0IiwiZWxlbSIsImJsb2NrICgyIGxldmVscykgaW4gdmFsdWVzX2F0IiwiaXNfYT8iLCJmaW5pc2giLCJlbmQiLCJiZWdpbiIsInVwdG8iLCJibG9jayAoMyBsZXZlbHMpIGluIHZhbHVlc19hdCIsInppcCIsIkVudW1lcmF0b3IiLCJpbmhlcml0ZWQiLCJrbGFzcyIsImluc3RhbmNlX3ZhcmlhYmxlcyIsImJsb2NrIGluIGluc3RhbmNlX3ZhcmlhYmxlcyIsIml2YXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3RhbmNlX3ZhcmlhYmxlcyIsInBhY2siLCJwcmlzdGluZSIsInNpbmdsZXRvbl9jbGFzcyJdLCJtYXBwaW5ncyI6IkFBQUFBLGdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUdDRDs7QUFHSEE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FB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QUEsRUFBQSxFQUFBLEVBQUEsTUFBQSxDQUFLNEssVUFBQUEsRUFBQUEsRUFBQUEsRUFBTHFGLGNBQWdCQyxJQUFoQkQsRUFBQUU7OztRQUFnQjtRQUFNLElBQUEsUUFBQTlCLENBQUFBLFlBQUM4QixjQUFnQkQsSUFBS0MsQ0FBdEI5QixDQUFBLENBQUE7VUFBQThCLE9BQUE7UUFBQTtVQUE0QkEsT0FBQUQsSUFBSy9OLE9BQUFBLENBQUdnTyxTQUFIaE87UUFBakMsRUFBdEI4TixDQUFBQSxHQUFLckY7SUFEUG9GLENBQUFBLEdBQUFBOztBQUlBSSxJQUFBQSxvQkFBQUEsZ0JBcjhFRixFQXE4RUVBO0FBQUFBLE1BQUFBOzs7TUFyOEVGO01BcThFVztNQUNQQSxPQUFBMVAsT0FBUUksT0FBQUEsQ0FBT3NQLGlFQUFQdFA7SUFEVnNQLENBQUFBLElBQUFBO0lBSUEsYUFBTSxRQUFOLEVBQWEsTUFBYjtJQUNBLGFBQU0sUUFBTixFQUFhLFFBQWI7SUFDQSxhQUFNLFNBQU4sRUFBYyxTQUFkO0lBQ0EsYUFBTSxLQUFOLEVBQVUsU0FBVjtJQUNBLGFBQU0sTUFBTixFQUFXLFVBQVg7SUFDQSxhQUFNLFNBQU4sRUFBYyxTQUFkO0lBQ0EsYUFBTSxNQUFOLEVBQVcsUUFBWDtJQUNBLGFBQU0sT0FBTixFQUFZLElBQVo7SUFDQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0lBRUFoUCxLQUFNaVAsVUFBQUEsQ0FBVXJRLElBQUFzUSxpQkFBQUEsQ0FBQUEsQ0FBaEIsRUFBaUMsVUFBM0JEO0lBQ05uUSxPQUFBa0IsS0FBTWlQLFVBQUFBLENBQVVyUSxJQUFoQixFQUFzQix5QkFBdEIsRUFBZ0QsZ0JBQTFDcVE7RUEvOEVSblEsR0FBTSxJQUFOQSxFQUFpQkgsS0FBakJHO0FBTEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDYyNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9jaGFpbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGRlbnlfZnJvemVuX2FjY2Vzc1xuXG5jbGFzcyA6OkVudW1lcmF0b3JcbiAgY2xhc3Mgc2VsZjo6Q2hhaW4gPCBzZWxmXG4gICAgZGVmIGluaXRpYWxpemUoKmVudW1zKVxuICAgICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICAgIEBlbnVtcyA9IGVudW1zXG4gICAgICBAaXRlcmF0ZWQgPSBbXVxuICAgICAgQG9iamVjdCA9IHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaCwgKmFyZ3MpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICAgQGVudW1zLmVhY2ggZG8gfGVudW18XG4gICAgICAgIEBpdGVyYXRlZCA8PCBlbnVtXG4gICAgICAgIGVudW0uZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgZW5kXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBzaXplKCphcmdzKVxuICAgICAgYWNjdW0gPSAwXG4gICAgICBAZW51bXMuZWFjaCBkbyB8ZW51bXxcbiAgICAgICAgc2l6ZSA9IGVudW0uc2l6ZSgqYXJncylcbiAgICAgICAgcmV0dXJuIHNpemUgaWYgW25pbCwgOjpGbG9hdDo6SU5GSU5JVFldLmluY2x1ZGU/IHNpemVcbiAgICAgICAgYWNjdW0gKz0gc2l6ZVxuICAgICAgZW5kXG4gICAgICBhY2N1bVxuICAgIGVuZFxuXG4gICAgZGVmIHJld2luZFxuICAgICAgQGl0ZXJhdGVkLnJldmVyc2VfZWFjaCBkbyB8ZW51bXxcbiAgICAgICAgZW51bS5yZXdpbmQgaWYgZW51bS5yZXNwb25kX3RvPyA6cmV3aW5kXG4gICAgICBlbmRcbiAgICAgIEBpdGVyYXRlZCA9IFtdXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgXCIjPEVudW1lcmF0b3I6OkNoYWluOiAje0BlbnVtcy5pbnNwZWN0fT5cIlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6c2VsZjo6Q2hhaW4+IiwiaW5pdGlhbGl6ZSIsIkBlbnVtcyIsImVudW1zIiwiQGl0ZXJhdGVkIiwiQG9iamVjdCIsInNlbGYiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwidG9fZW51bSIsImFyZ3MiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwic2l6ZSIsImVudW0kIiwiPDwiLCJibG9jayIsInRvX3Byb2MiLCJhY2N1bSIsIjAiLCJibG9jayBpbiBzaXplIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzaXplIiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJpbmNsdWRlPyIsIisiLCJyZXdpbmQiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXdpbmQiLCJyZXNwb25kX3RvPyIsImJsb2NrICgyIGxldmVscykgaW4gcmV3aW5kIiwiaW5zcGVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0VDLE1BQUFBLDBCQUFBQSxzQkFKSixFQUlJQTtBQUFBQSxRQUFBQTs7O1FBSko7UUFJbUI7UUFDWkE7UUFFREMsYUFBU0M7UUFDVEMsZ0JBQVk7UUFDWkgsT0FBQUksQ0FBQUEsY0FBVUMsSUFBVkQ7TUFMRkosQ0FBQUEsSUFBQUE7O0FBUUFNLE1BQUFBLG9CQUFBQSxnQkFaSixFQVlJQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQVpKO1FBWWE7UUFDUCxLQUE2Q0MsZUFBN0M7VUFBQSxPQUFPQyxNQUFBSCxJQUFBRyxXQUFBQSxFQUFBLENBQVEsTUFBUixDQUFBLFFBQWUsTUFBQ0MsSUFBRCxDQUFmLENBQUFELEVBQUFFLGFBQUFBLEVBQUFDOztZQUF3QkEsT0FBQU4sSUFBQU8sTUFBQUEsQ0FBQUEsQ0FBeEJGLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRjtRQUFQO1FBRU1GLE1BQU5MLFVBQU1LLFFBQUFBLEVBQUFBLEVBQUFBLEVBQU5JLGFBQWdCRyxLQUFoQkgsRUFBQUM7QUFBQUE7OztVQUFnQjtVQUNkUixhQUFVVyxPQUFBQSxDQUFHRCxLQUFIQztVQUNWSCxPQUFJTCxNQUFKTyxLQUFJUCxRQUFBQSxFQUFNLE1BQUNHLElBQUQsQ0FBTkgsRUFBY1MsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBYlYsRUFGTkksQ0FBQUEsR0FBQUEscUJBQUFBLENBQU1KO1FBS05BLE9BQUFEO01BUkZDLENBQUFBLElBQUFBOztBQVdBTSxNQUFBQSxvQkFBQUEsZ0JBdkJKLEVBdUJJQSxHQUFBQSxNQUFBQSxJQUFBQSw4QkFBQUE7QUFBQUEsUUFBQUE7OztRQXZCSjtRQXVCYTtRQUNQSyxRQUFRQztRQUNGWixNQUFOTCxVQUFNSyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFOYSxhQUFnQk4sS0FBaEJNLEVBQUFDOzs7VUFBZ0I7VUFDZFIsT0FBV0EsTUFBSkMsS0FBSUQsUUFBQUEsRUFBTSxNQUFDSCxJQUFELENBQU5HO1VBQ1gsSUFBQSxRQUFlLENBQUMsR0FBRCxFQUFNUyxJQUFBQyxZQUFBRCxhQUFOLENBQXdCRSxhQUFBQSxDQUFVWCxJQUFWVyxDQUF2QyxDQUFBO1lBQUEsU0FBQSxRQUFPWCxJQUFQO1VBQUE7VUFDQVEsT0FBQUgsQ0FBQUEsUUFBTU8sU0FBTlAsS0FBTU8sRUFBR1osSUFBSFksQ0FBTlAsRUFIRkUsQ0FBQUEsR0FBQUEsNEJBQUFBLENBQU1iO1FBS05NLE9BQUFLLE1BUEZMO1VBQUFBO1VBQUFBO1FBQUFBO01BQUFBLENBQUFBLElBQUFBOztBQVVBYSxNQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOzs7UUFDV0MsTUFBVHZCLGFBQVN1QixnQkFBQUEsRUFBQUEsRUFBQUEsRUFBVEMsYUFBMkJkLEtBQTNCYzs7VUFBMkI7VUFDekIsSUFBQSxRQUFlZCxLQUFJZSxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFuQixDQUFBO1lBQUFDLE9BQUFoQixLQUFJWSxRQUFBQSxDQUFBQTtVQUFKO1lBbkNSSSxPQUFBO1VBbUNRLEVBREZGLENBQUFBLEdBQVNEO1FBR1R2QixnQkFBWTtRQUNac0IsT0FBQXBCO01BTEZvQixDQUFBQSxHQUFBQTtNQVFBMUIsT0FBQStCLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLHVCQUFELEdBQUEsQ0FBd0I3QixVQUFNNkIsU0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUF1Q0E7TUFEekNBLENBQUFBLEdBQUFBO0lBdENGL0IsR0FBTU0sSUFBTk4sRUFBb0JNLElBQXBCTjtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDcyNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbW9kdWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIGNvbnN0X3NldCwgT2JqZWN0LCByZXR1cm5faXZhciwgYXNzaWduX2l2YXIsIGl2YXIsIGRlbnlfZnJvemVuX2FjY2VzcywgZnJlZXplLCBwcm9wXG5cbmNsYXNzIDo6TW9kdWxlXG4gIGRlZiBzZWxmLmFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgbW9kdWxlID0gT3BhbC5hbGxvY2F0ZV9tb2R1bGUobmlsLCBmdW5jdGlvbigpe30pO1xuICAgICAgLy8gTGluayB0aGUgcHJvdG90eXBlIG9mIE1vZHVsZSBzdWJjbGFzc2VzXG4gICAgICBpZiAoc2VsZiAhPT0gT3BhbC5Nb2R1bGUpIE9iamVjdC5zZXRQcm90b3R5cGVPZihtb2R1bGUsIHNlbGYuJCRwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICBtb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuICBlbmRcblxuICBkZWYgPT09KG9iamVjdClcbiAgICByZXR1cm4gZmFsc2UgaWYgYG9iamVjdCA9PSBudWxsYFxuXG4gICAgYE9wYWwuaXNfYShvYmplY3QsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICB1bmxlc3MgOjpNb2R1bGUgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgICMgY2xhc3MgY2Fubm90IGJlIGEgZGVzY2VuZGFudCBvZiBpdHNlbGZcbiAgICAleHtcbiAgICAgIHZhciB3b3JraW5nID0gc2VsZixcbiAgICAgICAgICBhbmNlc3RvcnMsXG4gICAgICAgICAgaSwgbGVuZ3RoO1xuXG4gICAgICBpZiAod29ya2luZyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhzZWxmKSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob3RoZXIpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gc2VsZikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA8IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIHVubGVzcyA6Ok1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY29tcGFyZWQgd2l0aCBub24gY2xhc3MvbW9kdWxlJ1xuICAgIGVuZFxuXG4gICAgb3RoZXIgPCBzZWxmXG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICBlcXVhbD8ob3RoZXIpIHx8IHNlbGYgPiBvdGhlclxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyA6Ok1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJldHVybiBuaWxcbiAgICBlbmRcblxuICAgIGx0ID0gc2VsZiA8IG90aGVyXG4gICAgcmV0dXJuIG5pbCBpZiBsdC5uaWw/XG4gICAgbHQgPyAtMSA6IDFcbiAgZW5kXG5cbiAgZGVmIGFsaWFzX21ldGhvZChuZXduYW1lLCBvbGRuYW1lKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgbmV3bmFtZSA9IGAkY29lcmNlX3RvKG5ld25hbWUsICN7OjpTdHJpbmd9LCAndG9fc3RyJylgXG4gICAgb2xkbmFtZSA9IGAkY29lcmNlX3RvKG9sZG5hbWUsICN7OjpTdHJpbmd9LCAndG9fc3RyJylgXG4gICAgYE9wYWwuYWxpYXMoc2VsZiwgbmV3bmFtZSwgb2xkbmFtZSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19uYXRpdmUobWlkLCBqc2lkID0gbWlkKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgYE9wYWwuYWxpYXNfbmF0aXZlKHNlbGYsIG1pZCwganNpZClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbmNlc3RvcnNcbiAgICBgT3BhbC5hbmNlc3RvcnMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhcHBlbmRfZmVhdHVyZXMoaW5jbHVkZXIpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3MoaW5jbHVkZXIpYFxuXG4gICAgYE9wYWwuYXBwZW5kX2ZlYXR1cmVzKHNlbGYsIGluY2x1ZGVyKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhdHRyX2FjY2Vzc29yKCpuYW1lcylcbiAgICBhdHRyX3JlYWRlcigqbmFtZXMpXG4gICAgYXR0cl93cml0ZXIoKm5hbWVzKVxuICBlbmRcblxuICBkZWYgYXR0cigqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyICYmIChhcmdzWzFdID09PSB0cnVlIHx8IGFyZ3NbMV0gPT09IGZhbHNlKSkge1xuICAgICAgICAje3dhcm4gJ29wdGlvbmFsIGJvb2xlYW4gYXJndW1lbnQgaXMgb2Jzb2xldGVkJywgdXBsZXZlbDogMX1cblxuICAgICAgICBhcmdzWzFdID8gI3thdHRyX2FjY2Vzc29yKGBhcmdzWzBdYCl9IDogI3thdHRyX3JlYWRlcihgYXJnc1swXWApfTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyX3JlYWRlcigqYXJncylcbiAgZW5kXG5cbiAgZGVmIGF0dHJfcmVhZGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUsXG4gICAgICAgICAgICBpdmFyID0gJGl2YXIobmFtZSk7XG5cbiAgICAgICAgdmFyIGJvZHkgPSAkcmV0dXJuX2l2YXIoaXZhcik7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwucHJvcChwcm90bywgaXZhciwgbmlsKTtcblxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBib2R5LiQkYXJpdHkgPSAwO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdHRyX3dyaXRlcigqbmFtZXMpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgcHJvdG8gPSBzZWxmLiQkcHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXSxcbiAgICAgICAgICAgIGlkICAgPSAnJCcgKyBuYW1lICsgJz0nLFxuICAgICAgICAgICAgaXZhciA9ICRpdmFyKG5hbWUpO1xuXG4gICAgICAgIHZhciBib2R5ID0gJGFzc2lnbl9pdmFyKGl2YXIpXG5cbiAgICAgICAgYm9keS4kJHBhcmFtZXRlcnMgPSBbWydyZXEnXV07XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDE7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwucHJvcChwcm90bywgaXZhciwgbmlsKTtcblxuICAgICAgICBPcGFsLmRlZm4oc2VsZiwgaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgYXV0b2xvYWQoY29uc3QsIHBhdGgpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAoISN7T3BhbC5jb25zdF9uYW1lPyhjb25zdCl9KSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwiYXV0b2xvYWQgbXVzdCBiZSBjb25zdGFudCBuYW1lOiAje2NvbnN0fVwifVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0aCA9PSBcIlwiKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnZW1wdHkgZmlsZSBuYW1lJ31cbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLiQkY29uc3QuaGFzT3duUHJvcGVydHkoI3tjb25zdH0pKSB7XG4gICAgICAgIGlmICghc2VsZi4kJGF1dG9sb2FkKSB7XG4gICAgICAgICAgc2VsZi4kJGF1dG9sb2FkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG4gICAgICAgIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0gPSB7IHBhdGg6ICN7cGF0aH0sIGxvYWRlZDogZmFsc2UsIHJlcXVpcmVkOiBmYWxzZSwgc3VjY2VzczogZmFsc2UsIGV4Y2VwdGlvbjogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXV0b2xvYWQ/KGNvbnN0KVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRhdXRvbG9hZCAmJiBzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dICYmICFzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dLnJlcXVpcmVkICYmICFzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dLnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0ucGF0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2VzdG9ycyA9IHNlbGYuJGFuY2VzdG9ycygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZCAmJiBhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0gJiYgIWFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XS5yZXF1aXJlZCAmJiAhYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dLnBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVzXG4gICAgYE9iamVjdC5rZXlzKE9wYWwuY2xhc3NfdmFyaWFibGVzKHNlbGYpKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX2dldChuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX2dldChzZWxmLCBuYW1lLCBmYWxzZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZV9zZXQoc2VsZiwgbmFtZSwgdmFsdWUpYFxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8obmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikuaGFzT3duUHJvcGVydHkobmFtZSlgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY2xhc3NfdmFyaWFibGUobmFtZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG5hbWUgPSA6Ok9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgaWYgKE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLiQkY3ZhcnMsIG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNlbGYuJCRjdmFyc1tuYW1lXTtcbiAgICAgICAgZGVsZXRlIHNlbGYuJCRjdmFyc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCJjYW5ub3QgcmVtb3ZlICN7bmFtZX0gZm9yICN7c2VsZn1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdGFudHMoaW5oZXJpdCA9IHRydWUpXG4gICAgYE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdGFudHMoaW5oZXJpdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIG5lc3RpbmcgPSAoc2VsZi4kJG5lc3RpbmcgfHwgW10pLmNvbmNhdCgkT2JqZWN0KSxcbiAgICAgICAgICAgIGNvbnN0YW50LCBjb25zdGFudHMgPSB7fSxcbiAgICAgICAgICAgIGksIGlpO1xuXG4gICAgICAgIGZvcihpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBmb3IgKGNvbnN0YW50IGluIG5lc3RpbmdbaV0uJCRjb25zdCkge1xuICAgICAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXN0aW5nXG4gICAgYHNlbGYuJCRuZXN0aW5nIHx8IFtdYFxuICBlbmRcblxuICAjIGNoZWNrIGZvciBjb25zdGFudCB3aXRoaW4gY3VycmVudCBzY29wZVxuICAjIGlmIGluaGVyaXQgaXMgdHJ1ZSBvciBzZWxmIGlzIE9iamVjdCwgd2lsbCBhbHNvIGNoZWNrIGFuY2VzdG9yc1xuICBkZWYgY29uc3RfZGVmaW5lZD8obmFtZSwgaW5oZXJpdCA9IHRydWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKSB1bmxlc3MgbmFtZSA9fiA6Ok9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbc2VsZl0sIG1vZHVsZV9jb25zdGFudHMsIGksIGlpO1xuXG4gICAgICAvLyBBZGQgdXAgYW5jZXN0b3JzIGlmIGluaGVyaXQgaXMgdHJ1ZVxuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KE9wYWwuYW5jZXN0b3JzKHNlbGYpKTtcblxuICAgICAgICAvLyBBZGQgT2JqZWN0J3MgYW5jZXN0b3JzIGlmIGl0J3MgYSBtb2R1bGUg4oCTIG1vZHVsZXMgaGF2ZSBubyBhbmNlc3RvcnMgb3RoZXJ3aXNlXG4gICAgICAgIGlmIChzZWxmLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFskT2JqZWN0XSkuY29uY2F0KE9wYWwuYW5jZXN0b3JzKCRPYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IG1vZHVsZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuICAgICAgICBpZiAobW9kdWxlLiQkY29uc3RbI3tuYW1lfV0gIT0gbnVsbCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbW9kdWxlLiQkYXV0b2xvYWQgJiZcbiAgICAgICAgICBtb2R1bGUuJCRhdXRvbG9hZFsje25hbWV9XSAmJlxuICAgICAgICAgICFtb2R1bGUuJCRhdXRvbG9hZFsje25hbWV9XS5yZXF1aXJlZCAmJlxuICAgICAgICAgICFtb2R1bGUuJCRhdXRvbG9hZFsje25hbWV9XS5zdWNjZXNzXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdF9nZXQobmFtZSwgaW5oZXJpdCA9IHRydWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgaWYgKG5hbWUuaW5kZXhPZignOjonKSA9PT0gMCAmJiBuYW1lICE9PSAnOjonKXtcbiAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgYG5hbWUuaW5kZXhPZignOjonKSAhPSAtMSAmJiBuYW1lICE9ICc6OidgXG4gICAgICByZXR1cm4gbmFtZS5zcGxpdCgnOjonKS5pbmplY3Qoc2VsZikgeyB8bywgY3wgby5jb25zdF9nZXQoYykgfVxuICAgIGVuZFxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IDo6T3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuJCQoW3NlbGZdLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLmNvbnN0X2dldF9sb2NhbChzZWxmLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdF9taXNzaW5nKG5hbWUpXG4gICAgZnVsbF9jb25zdF9uYW1lID0gc2VsZiA9PSA6Ok9iamVjdCA/IG5hbWUgOiBcIiN7c2VsZn06OiN7bmFtZX1cIlxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwidW5pbml0aWFsaXplZCBjb25zdGFudCAje2Z1bGxfY29uc3RfbmFtZX1cIiwgbmFtZSlcbiAgZW5kXG5cbiAgZGVmIGNvbnN0X3NldChuYW1lLCB2YWx1ZSlcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG5hbWUgPSA6Ok9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIGlmIG5hbWUgIX4gOjpPcGFsOjpDT05TVF9OQU1FX1JFR0VYUCB8fCBuYW1lLnN0YXJ0X3dpdGg/KCc6OicpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIGAkY29uc3Rfc2V0KHNlbGYsIG5hbWUsIHZhbHVlKWBcblxuICAgIHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBwdWJsaWNfY29uc3RhbnQoY29uc3RfbmFtZSlcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9tZXRob2QobmFtZSwgbWV0aG9kID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbClcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgYSBQcm9jIG9iamVjdCB3aXRob3V0IGEgYmxvY2snfVxuICAgIH1cblxuICAgIGJsb2NrIHx8PSBjYXNlIG1ldGhvZFxuICAgICAgICAgICAgICB3aGVuIDo6UHJvY1xuICAgICAgICAgICAgICAgIG1ldGhvZFxuXG4gICAgICAgICAgICAgIHdoZW4gOjpNZXRob2RcbiAgICAgICAgICAgICAgICBgI3ttZXRob2QudG9fcHJvY30uJCR1bmJvdW5kYFxuXG4gICAgICAgICAgICAgIHdoZW4gOjpVbmJvdW5kTWV0aG9kXG4gICAgICAgICAgICAgICAgLT4oKmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kID0gbWV0aG9kLmJpbmQoc2VsZilcbiAgICAgICAgICAgICAgICAgIGJvdW5kLmNhbGwoKmFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YmxvY2suY2xhc3N9IChleHBlY3RlZCBQcm9jL01ldGhvZClcIlxuICAgICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZihQcm94eSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBtZXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgICAgIGJsb2NrLiQkcHJveHlfdGFyZ2V0ID0gYmxvY2tcbiAgICAgICAgYmxvY2sgPSBuZXcgUHJveHkoYmxvY2ssIHtcbiAgICAgICAgICBhcHBseTogZnVuY3Rpb24odGFyZ2V0LCBzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgb2xkX25hbWUgPSB0YXJnZXQuJCRqc2lkXG4gICAgICAgICAgICB0YXJnZXQuJCRqc2lkID0gbmFtZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgPT09IHRhcmdldC4kJGJyayB8fCBlID09PSB0YXJnZXQuJCRyZXQpIHJldHVybiBlLiR2O1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGFyZ2V0LiQkanNpZCA9IG9sZF9uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBibG9jay4kJGpzaWQgICAgICAgID0gbmFtZTtcbiAgICAgIGJsb2NrLiQkcyAgICAgICAgICAgPSBudWxsO1xuICAgICAgYmxvY2suJCRkZWYgICAgICAgICA9IGJsb2NrO1xuICAgICAgYmxvY2suJCRkZWZpbmVfbWV0aCA9IHRydWU7XG5cbiAgICAgIHJldHVybiBPcGFsLmRlZm4oc2VsZiwgJyQnICsgbmFtZSwgYmxvY2spO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZyZWV6ZVxuICAgICMgU3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBmcmVlemUsIGJlY2F1c2UgdGhlICQkYmFzZV9tb2R1bGUgcHJvcGVydHkgbmVlZHMgdG8gYmVcbiAgICAjIGFjY2Vzc2libGUgZGVzcGl0ZSB0aGUgZnJvemVuIHN0YXR1c1xuXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoIXNlbGYuaGFzT3duUHJvcGVydHkoJyQkYmFzZV9tb2R1bGUnKSkgeyAkcHJvcChzZWxmLCAnJCRiYXNlX21vZHVsZScsIG51bGwpOyB9XG5cbiAgICAgIHJldHVybiAkZnJlZXplKHNlbGYpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAoISh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiB8fCBuYW1lLiQkaXNfc3RyaW5nKSkge1xuICAgICAgICAgICN7cmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tuYW1lfSBpcyBub3QgYSBzeW1ib2wgbm9yIGEgc3RyaW5nXCJ9XG4gICAgICAgIH1cbiAgICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgICBPcGFsLnJkZWYoc2VsZiwgXCIkXCIgKyBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3M/XG4gICAgYCEhc2VsZi4kJGlzX3NpbmdsZXRvbmBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUoKm1vZHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAuYXBwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLmluY2x1ZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkX21vZHVsZXNcbiAgICBgT3BhbC5pbmNsdWRlZF9tb2R1bGVzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obW9kKVxuICAgICV4e1xuICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaWksIG1vZDIsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG1vZDIgPSBhbmNlc3RvcnNbaV07XG4gICAgICAgIGlmIChtb2QyID09PSBtb2QgJiYgbW9kMiAhPT0gc2VsZikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9tZXRob2QobmFtZSlcbiAgICAleHtcbiAgICAgIHZhciBtZXRoID0gc2VsZi4kJHByb3RvdHlwZVsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKCFtZXRoIHx8IG1ldGguJCRzdHViKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgI3tuYW1lfScgZm9yIGNsYXNzIGAje3NlbGYubmFtZX0nXCIsIG5hbWUpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7OjpVbmJvdW5kTWV0aG9kLm5ldyhzZWxmLCBgbWV0aC4kJG93bmVyIHx8ICN7c2VsZn1gLCBgbWV0aGAsIG5hbWUpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9tZXRob2RzKGluY2x1ZGVfc3VwZXIgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCR0cnV0aHkoI3tpbmNsdWRlX3N1cGVyfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuaW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZF9vYmplY3Qob2JqZWN0KVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKG9iamVjdClgXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfYWRkZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9yZW1vdmVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfdW5kZWZpbmVkKCopXG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZXZhbCgqYXJncywgJmJsb2NrKVxuICAgIGlmIGJsb2NrLm5pbD8gJiYgYCEhT3BhbC5jb21waWxlYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gOjpPcGFsLmNvbXBpbGUgc3RyaW5nLCBjb21waWxpbmdfb3B0aW9uc1xuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIGRvXG4gICAgICAgICV4e25ldyBGdW5jdGlvbihcIk9wYWwsc2VsZlwiLCBcInJldHVybiBcIiArIGNvbXBpbGVkKShPcGFsLCBzZWxmKX1cbiAgICAgIGVuZFxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcblxcbiAgTk9URTpJZiB5b3Ugd2FudCB0byBlbmFibGUgcGFzc2luZyBhIFN0cmluZyBhcmd1bWVudCBwbGVhc2UgYWRkIFxcXCJyZXF1aXJlICdvcGFsLXBhcnNlcidcXFwiIHRvIHlvdXIgc2NyaXB0XFxuXCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIG9sZCA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBbc2VsZl0pO1xuICAgICAgYmxvY2suJCRzID0gb2xkO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9leGVjKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbid9XG4gICAgICB9XG5cbiAgICAgIHZhciBibG9ja19zZWxmID0gYmxvY2suJCRzLCByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kX2RlZmluZWQ/KG1ldGhvZClcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZi4kJHByb3RvdHlwZVsnJCcgKyBtZXRob2RdO1xuICAgICAgcmV0dXJuICghIWJvZHkpICYmICFib2R5LiQkc3R1YjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZnVuY3Rpb24oKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aCA9IG1ldGhvZHNbaV0sXG4gICAgICAgICAgICAgIGlkICAgPSAnJCcgKyBtZXRoLFxuICAgICAgICAgICAgICBmdW5jID0gc2VsZi4kJHByb3RvdHlwZVtpZF07XG5cbiAgICAgICAgICBPcGFsLmRlZnMoc2VsZiwgaWQsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2RzLmxlbmd0aCA9PT0gMSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuYW1lXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGZ1bGxfbmFtZSkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBiYXNlID0gc2VsZjtcblxuICAgICAgd2hpbGUgKGJhc2UpIHtcbiAgICAgICAgLy8gR2l2ZSB1cCBpZiBhbnkgb2YgdGhlIGFuY2VzdG9ycyBpcyB1bm5hbWVkXG4gICAgICAgIGlmIChiYXNlLiQkbmFtZSA9PT0gbmlsIHx8IGJhc2UuJCRuYW1lID09IG51bGwpIHJldHVybiBuaWw7XG5cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoYmFzZS4kJG5hbWUpO1xuXG4gICAgICAgIGJhc2UgPSBiYXNlLiQkYmFzZV9tb2R1bGU7XG5cbiAgICAgICAgaWYgKGJhc2UgPT09ICRPYmplY3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZSA9IHJlc3VsdC5qb2luKCc6OicpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByZXBlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICBpZiAobW9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAwLCBleHBlY3RlZCAxKyknfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAucHJlcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJlcGVuZF9mZWF0dXJlcyhwcmVwZW5kZXIpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHByZXBlbmRlcik7XG5cbiAgICAgIGlmICghc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tzZWxmLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5wcmVwZW5kX2ZlYXR1cmVzKHNlbGYsIHByZXBlbmRlcilcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJlcGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9jb25zdChuYW1lKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgYE9wYWwuY29uc3RfcmVtb3ZlKHNlbGYsIG5hbWUpYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGBPcGFsLk1vZHVsZS4kbmFtZS5jYWxsKHNlbGYpYCB8fCBcIiM8I3tgc2VsZi4kJGlzX21vZHVsZSA/ICdNb2R1bGUnIDogJ0NsYXNzJ2B9OjB4I3tfX2lkX18udG9fcygxNil9PlwiXG4gIGVuZFxuXG4gIGRlZiB1bmRlZl9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAoISh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiB8fCBuYW1lLiQkaXNfc3RyaW5nKSkge1xuICAgICAgICAgICN7cmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tuYW1lfSBpcyBub3QgYSBzeW1ib2wgbm9yIGEgc3RyaW5nXCJ9XG4gICAgICAgIH1cbiAgICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgICBPcGFsLnVkZWYoc2VsZiwgXCIkXCIgKyBuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgY29uc3RzID0gY29uc3RhbnRzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnICYmIG5hbWUgIT09ICdjb25zdHJ1Y3RvcicgJiYgISN7Y29uc3RzLmluY2x1ZGU/KGBuYW1lYCl9KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gc3VwZXJcbiAgICBjb3B5LmNvcHlfY2xhc3NfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X2NvbnN0YW50cyhzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGNvcHlfY2xhc3NfdmFyaWFibGVzKG90aGVyKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlci4kJGN2YXJzKSB7XG4gICAgICAgIHNlbGYuJCRjdmFyc1tuYW1lXSA9IG90aGVyLiQkY3ZhcnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29weV9jb25zdGFudHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgbmFtZSwgb3RoZXJfY29uc3RhbnRzID0gb3RoZXIuJCRjb25zdDtcblxuICAgICAgZm9yIChuYW1lIGluIG90aGVyX2NvbnN0YW50cykge1xuICAgICAgICAkY29uc3Rfc2V0KHNlbGYsIG5hbWUsIG90aGVyX2NvbnN0YW50c1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVmaW5lKGtsYXNzLCAmYmxvY2spXG4gICAgcmVmaW5lbWVudF9tb2R1bGUsIG0sIGtsYXNzX2lkID0gc2VsZiwgbmlsLCBuaWxcbiAgICAleHtcbiAgICAgIGtsYXNzX2lkID0gT3BhbC5pZChrbGFzcyk7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuJCRyZWZpbmVfbW9kdWxlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZWxmLiQkcmVmaW5lX21vZHVsZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBtID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXSA9ICN7OjpSZWZpbmVtZW50Lm5ld307XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbSA9IHNlbGYuJCRyZWZpbmVfbW9kdWxlc1trbGFzc19pZF07XG4gICAgICB9XG4gICAgICBtLnJlZmluZW1lbnRfbW9kdWxlID0gcmVmaW5lbWVudF9tb2R1bGVcbiAgICAgIG0ucmVmaW5lZF9jbGFzcyA9IGtsYXNzXG4gICAgfVxuICAgIG0uY2xhc3NfZXhlYygmYmxvY2spXG4gICAgbVxuICBlbmRcblxuICAjIENvbXBpbGVyIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxuICBkZWYgdXNpbmcobW9kKVxuICAgIDo6S2VybmVsLnJhaXNlICdNb2R1bGUjdXNpbmcgaXMgbm90IHBlcm1pdHRlZCBpbiBtZXRob2RzJ1xuICBlbmRcblxuICBhbGlhcyBjbGFzc19ldmFsIG1vZHVsZV9ldmFsXG4gIGFsaWFzIGNsYXNzX2V4ZWMgbW9kdWxlX2V4ZWNcbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5lbmRcblxuY2xhc3MgOjpSZWZpbmVtZW50IDwgOjpNb2R1bGVcbiAgZGVmIGluc3BlY3RcbiAgICBpZiBAcmVmaW5lbWVudF9tb2R1bGVcbiAgICAgIFwiIzxyZWZpbmVtZW50OiN7QHJlZmluZWRfY2xhc3MuaW5zcGVjdH1AI3tAcmVmaW5lbWVudF9tb2R1bGUuaW5zcGVjdH0+XCJcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TW9kdWxlPiIsImFsbG9jYXRlIiwic2VsZiIsImluaXRpYWxpemUiLCJibG9ja19naXZlbj8iLCJtb2R1bGVfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsIj09PSIsIm9iamVjdCIsIjwiLCJvdGhlciIsIk1vZHVsZSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwiPD0iLCIkcmV0X29yXzEiLCJlcXVhbD8iLCI+IiwiPj0iLCI8PT4iLCJsdCIsIm5pbD8iLCItMSIsIjEiLCJhbGlhc19tZXRob2QiLCJuZXduYW1lIiwib2xkbmFtZSIsIlN0cmluZyIsImFsaWFzX25hdGl2ZSIsIm1pZCIsImpzaWQiLCJhbmNlc3RvcnMiLCJhcHBlbmRfZmVhdHVyZXMiLCJpbmNsdWRlciIsImF0dHJfYWNjZXNzb3IiLCJhdHRyX3JlYWRlciIsIm5hbWVzIiwiYXR0cl93cml0ZXIiLCJhdHRyIiwid2FybiIsImFyZ3MiLCJhdXRvbG9hZCIsImNvbnN0JCIsInBhdGgiLCJPcGFsIiwiY29uc3RfbmFtZT8iLCJOYW1lRXJyb3IiLCJBcmd1bWVudEVycm9yIiwiYXV0b2xvYWQ/IiwiY2xhc3NfdmFyaWFibGVzIiwiY2xhc3NfdmFyaWFibGVfZ2V0IiwibmFtZSIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY2xhc3NfdmFyaWFibGVfc2V0IiwidmFsdWUiLCJjbGFzc192YXJpYWJsZV9kZWZpbmVkPyIsInJlbW92ZV9jbGFzc192YXJpYWJsZSIsImNvbnN0YW50cyIsImluaGVyaXQiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwiT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFAiLCJuZXciLCJjb25zdF9nZXQiLCJpbmplY3QiLCJzcGxpdCIsImJsb2NrIGluIGNvbnN0X2dldCIsIm8iLCJjIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25zdF9nZXQiLCJjb25zdF9taXNzaW5nIiwiZnVsbF9jb25zdF9uYW1lIiwiT2JqZWN0IiwiY29uc3Rfc2V0IiwiIX4iLCJzdGFydF93aXRoPyIsInB1YmxpY19jb25zdGFudCIsImRlZmluZV9tZXRob2QiLCJtZXRob2QiLCJQcm9jIiwiJHJldF9vcl8yIiwiTWV0aG9kIiwiVW5ib3VuZE1ldGhvZCIsImJsb2NrIGluIGRlZmluZV9tZXRob2QiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9tZXRob2QiLCJib3VuZCIsImJpbmQiLCJjYWxsIiwiY2xhc3MiLCJmcmVlemUiLCJmcm96ZW4/IiwicmVtb3ZlX21ldGhvZCIsInNpbmdsZXRvbl9jbGFzcz8iLCJpbmNsdWRlIiwiaW5jbHVkZWQiLCJpbmNsdWRlZF9tb2R1bGVzIiwiaW5jbHVkZT8iLCJtb2QiLCJpbnN0YW5jZV9tZXRob2QiLCJpbnN0YW5jZV9tZXRob2RzIiwiaW5jbHVkZV9zdXBlciIsImV4dGVuZGVkIiwiZXh0ZW5kX29iamVjdCIsIm1ldGhvZF9hZGRlZCIsIm1ldGhvZF9yZW1vdmVkIiwibWV0aG9kX3VuZGVmaW5lZCIsIjMiLCJjb3Zlcj8iLCJzaXplIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYmxvY2sgaW4gbW9kdWxlX2V2YWwiLCJibG9jayAoMiBsZXZlbHMpIGluIG1vZHVsZV9ldmFsIiwiYW55PyIsIm1vZHVsZV9leGVjIiwiTG9jYWxKdW1wRXJyb3IiLCJtZXRob2RfZGVmaW5lZD8iLCJtb2R1bGVfZnVuY3Rpb24iLCJwcmVwZW5kIiwicHJlcGVuZF9mZWF0dXJlcyIsInByZXBlbmRlZCIsInByZXBlbmRlciIsInJlbW92ZV9jb25zdCIsInRvX3MiLCJfX2lkX18iLCIxNiIsInVuZGVmX21ldGhvZCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsImNvbnN0cyIsImR1cCIsImNvcHkiLCJjb3B5X2NsYXNzX3ZhcmlhYmxlcyIsImNvcHlfY29uc3RhbnRzIiwicmVmaW5lIiwia2xhc3MiLCJyZWZpbmVtZW50X21vZHVsZSIsIm0iLCJrbGFzc19pZCIsIlJlZmluZW1lbnQiLCJjbGFzc19leGVjIiwidXNpbmciLCI8Y2xhc3M6UmVmaW5lbWVudD4iLCJpbnNwZWN0IiwiQHJlZmluZW1lbnRfbW9kdWxlIiwiQHJlZmluZWRfY2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsTUFBSUMsSUFBSkQsZUFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFORUEsQ0FBQUEsR0FBQUE7O0FBU0FFLElBQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRSxJQUF1QkMs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LEVBQWlCLGFBQWpCO0lBQ0F4SixPQUFBLGFBQU0sU0FBTixFQUFjLE1BQWQ7RUF4d0JGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0VBMndCQUQsT0FBQTBKO0VBQUFBOztJQUFBQTs7QUFBQUE7SUFDRUEsT0FBQUMsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7TUFDRSxJQUFBLFFBQUdDLHNCQUFILENBQUE7UUFDRUQsT0FBQ0EsZUFBRCxHQUFBLENBQWdCRSxrQkFBY0YsU0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUF1Q0EsR0FBdkMsR0FBQSxDQUEwQ0Msc0JBQWtCRCxTQUFBQSxDQUFBQSxDQUE1RCxDQUFBLEdBQXFFQTtNQUR2RTtRQUdFQSxPQUFBLE9BQUF4SixJQUFBLEVBQUEsb0RBQUEsV0FBQSxFQUFBLEVBQUEsRUFBQSxNQUFBO01BSEY7SUFERndKLENBQUFBLEdBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBcUI3SSxPQUFyQjZJO0FBN3dCQTFKOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTcxMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9nZW5lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBkZW55X2Zyb3plbl9hY2Nlc3NcblxuY2xhc3MgRW51bWVyYXRvclxuICBjbGFzcyBHZW5lcmF0b3JcbiAgICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgeWllbGRlciA9IFlpZWxkZXIubmV3KCZibG9jaylcblxuICAgICAgJXh7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgT3BhbC55aWVsZFgoI3tAYmxvY2t9LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlICYmIGUuJHRocm93ZXJfdHlwZSA9PSBcImJyZWFrZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGUuJHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6R2VuZXJhdG9yPiIsInNlbGYiLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImluaXRpYWxpemUiLCJibG9jayIsIktlcm5lbCIsInJhaXNlIiwiTG9jYWxKdW1wRXJyb3IiLCJAYmxvY2siLCJlYWNoIiwieWllbGRlciIsIm5ldyIsIllpZWxkZXIiLCJ0b19wcm9jIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxpQkFBUkQ7O0FBRUFFLE1BQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFDR0E7UUFFRCxLQUFBLFFBQXlEQyxLQUF6RCxDQUFBO1VBQUFDLE9BQVFDLE9BQUFBLENBQU9DLHFCQUFmLEVBQWlDSixnQkFBekJHO1FBQVI7UUFFQUgsT0FBQUssQ0FBQUEsYUFBU0osS0FBVEk7TUFMRkwsQ0FBQUEsR0FBQUE7TUFRQUosT0FBQVUsb0JBQUFBLGdCQWRKLEVBY0lBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBZEo7UUFjYTtRQUNQQyxVQUFpQkMsTUFBUEMsYUFBT0QsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTVAsS0FBRFMsU0FBQUEsQ0FBQUEsQ0FBTEY7O0FBR3ZCRjtBQUNBQSx1QkFBeUJDLE9BQVFEOztBQUVqQ0Esc0JBQXdCRCxVQUFPQztBQUMvQkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7UUFFTUEsT0FBQVQ7TUFuQkZTLENBQUFBLElBQUFBO0lBWEZWLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTc3MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29uc3RhbnRzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6UlVCWV9QTEFURk9STSAgICAgICA9ICdvcGFsJ1xuOjpSVUJZX0VOR0lORSAgICAgICAgID0gJ29wYWwnXG46OlJVQllfVkVSU0lPTiAgICAgICAgPSAnMy4xLjAnXG46OlJVQllfRU5HSU5FX1ZFUlNJT04gPSAnMS42LjAnXG46OlJVQllfUkVMRUFTRV9EQVRFICAgPSAnMjAyMi0xMS0yNCdcbjo6UlVCWV9QQVRDSExFVkVMICAgICA9IDBcbjo6UlVCWV9SRVZJU0lPTiAgICAgICA9ICcwJ1xuOjpSVUJZX0NPUFlSSUdIVCAgICAgID0gJ29wYWwgLSBDb3B5cmlnaHQgKEMpIDIwMTMtMjAyMiBBZGFtIEJleW5vbiBhbmQgdGhlIE9wYWwgY29udHJpYnV0b3JzJ1xuOjpSVUJZX0RFU0NSSVBUSU9OICAgID0gXCJvcGFsICN7OjpSVUJZX0VOR0lORV9WRVJTSU9OfSAoI3s6OlJVQllfUkVMRUFTRV9EQVRFfSByZXZpc2lvbiAjezo6UlVCWV9SRVZJU0lPTn0pXCJcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiMCIsIlJVQllfRU5HSU5FX1ZFUlNJT04iLCJSVUJZX1JFTEVBU0VfREFURSIsIlJVQllfUkVWSVNJT04iXSwibWFwcGluZ3MiOiJBQUFBQSxvQ0FBQUEsZ0JBQUFBO0VBQUFBOzs7RUFBQSxXQUFBLElBQUEsbUJBQXdCQSxNQUF4QjtFQUNBLFdBQUEsSUFBQSxpQkFBd0JBLE1BQXhCO0VBQ0EsV0FBQSxJQUFBLGtCQUF3QkEsT0FBeEI7RUFDQSxXQUFBLElBQUEseUJBQXdCQSxPQUF4QjtFQUNBLFdBQUEsSUFBQSx1QkFBd0JBLFlBQXhCO0VBQ0EsV0FBQSxJQUFBLHFCQUF3QkMsQ0FBeEI7RUFDQSxXQUFBLElBQUEsbUJBQXdCRCxHQUF4QjtFQUNBLFdBQUEsSUFBQSxvQkFBd0JBLHNFQUF4QjtFQUNBQSxPQUFBLFdBQUEsSUFBQSxzQkFBeUJBLE9BQUQsR0FBQSxDQUFRRSwwQkFBUixDQUFBLEdBQThCRixJQUE5QixHQUFBLENBQWtDRyx3QkFBbEMsQ0FBQSxHQUFzREgsWUFBdEQsR0FBQSxDQUFrRUksb0JBQWxFLENBQUEsR0FBa0ZKLEdBQTFHO0FBUkFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTc4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9sYXp5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIHlpZWxkMSwgeWllbGRYLCBkZW55X2Zyb3plbl9hY2Nlc3NcblxuY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGNsYXNzIHNlbGY6OkxhenkgPCBzZWxmXG4gICAgY2xhc3Mgc2VsZjo6U3RvcExhenlFcnJvciA8IDo6RXhjZXB0aW9uOyBlbmRcblxuICAgIGRlZiBzZWxmLmZvcihvYmplY3QsICopXG4gICAgICBsYXp5ID0gc3VwZXJcbiAgICAgIGBsYXp5LmVudW1lcmF0b3IgPSBvYmplY3RgXG4gICAgICBsYXp5XG4gICAgZW5kXG5cbiAgICBkZWYgaW5pdGlhbGl6ZShvYmplY3QsIHNpemUgPSBuaWwsICZibG9jaylcbiAgICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBuZXcgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIEBlbnVtZXJhdG9yID0gb2JqZWN0XG5cbiAgICAgIHN1cGVyIHNpemUgZG8gfHlpZWxkZXIsICplYWNoX2FyZ3N8XG4gICAgICAgIG9iamVjdC5lYWNoKCplYWNoX2FyZ3MpIGRvIHwqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCgje3lpZWxkZXJ9KTtcblxuICAgICAgICAgICAgJHlpZWxkWChibG9jaywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIHJlc2N1ZSBTdG9wTGF6eUVycm9yXG4gICAgICAgIG5pbFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbGF6eVxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgICN7ZW51bS55aWVsZCBgdmFsdWVgfTtcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdF9jb25jYXQoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XG4gICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAjezo6T3BhbC50cnlfY29udmVydCBgdmFsdWVgLCA6OkFycmF5LCA6dG9fYXJ5fTtcblxuICAgICAgICAgICAgaWYgKGFycmF5ID09PSBuaWwpIHtcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGB2YWx1ZWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICN7YHZhbHVlYC5lYWNoIHsgfHZ8IGVudW0ueWllbGQgdiB9fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRyb3AobilcbiAgICAgIG4gPSBgJGNvZXJjZV90bygje259LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiA6OkludGVnZXIgPT09IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICBuIDwgY3VycmVudF9zaXplID8gbiA6IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICBkcm9wcGVkID0gMFxuICAgICAgTGF6eS5uZXcoc2VsZiwgc2V0X3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgZHJvcHBlZCA8IG5cbiAgICAgICAgICBkcm9wcGVkICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcF93aGlsZSgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IGRyb3Bfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIHN1Y2NlZWRpbmcgPSB0cnVlXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAgIGlmICghJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3VjY2VlZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgICBzZWxmLmNsYXNzLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgZW5kXG5cbiAgICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBzZWxlY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBncmVwKHBhdHRlcm4sICZibG9jaylcbiAgICAgIGlmIGJsb2NrXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgJHlpZWxkMShibG9jaywgcGFyYW0pYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGBwYXJhbWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiByZWplY3QoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSByZWplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICghJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdGFrZShuKVxuICAgICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBjdXJyZW50X3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgIHNldF9zaXplICAgICA9IGlmIDo6SW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIHRha2VuID0gMFxuICAgICAgTGF6eS5uZXcoc2VsZiwgc2V0X3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgdGFrZW4gPCBuXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgICB0YWtlbiArPSAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICA6Oktlcm5lbC5yYWlzZSBTdG9wTGF6eUVycm9yXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHRha2Vfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBTdG9wTGF6eUVycm9yfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGluc3BlY3RcbiAgICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0BlbnVtZXJhdG9yLmluc3BlY3R9PlwiXG4gICAgZW5kXG5cbiAgICBhbGlhcyBmb3JjZSB0b19hXG4gICAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG4gICAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcbiAgICBhbGlhcyBtYXAgY29sbGVjdFxuICAgIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxuICAgIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiPGNsYXNzOnNlbGY6Okxhenk+IiwiPGNsYXNzOnNlbGY6OlN0b3BMYXp5RXJyb3I+Iiwic2VsZiIsIkV4Y2VwdGlvbiIsImZvciIsIm9iamVjdCIsImxhenkiLCJpbml0aWFsaXplIiwic2l6ZSIsImJsb2NrX2dpdmVuPyIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIkBlbnVtZXJhdG9yIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsInlpZWxkZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJlYWNoIiwiZWFjaF9hcmdzIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiU3RvcExhenlFcnJvciIsImNvbGxlY3QiLCJibG9jayIsIm5ldyIsIkxhenkiLCJlbnVtZXJhdG9yX3NpemUiLCJibG9jayBpbiBjb2xsZWN0IiwiZW51bSQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QiLCJ5aWVsZCIsImNvbGxlY3RfY29uY2F0IiwiYmxvY2sgaW4gY29sbGVjdF9jb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3RfY29uY2F0IiwicmVzcG9uZF90bz8iLCJ2IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBjb2xsZWN0X2NvbmNhdCIsIk9wYWwiLCJ0cnlfY29udmVydCIsIkFycmF5IiwiZHJvcCIsIm4iLCJJbnRlZ2VyIiwiPCIsIjAiLCJjdXJyZW50X3NpemUiLCJzZXRfc2l6ZSIsImRyb3BwZWQiLCJibG9jayBpbiBkcm9wIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkcm9wIiwiKyIsIjEiLCJhcmdzIiwiZHJvcF93aGlsZSIsInN1Y2NlZWRpbmciLCJibG9jayBpbiBkcm9wX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkcm9wX3doaWxlIiwiZW51bV9mb3IiLCJjbGFzcyIsIm1ldGhvZCIsInRvX3Byb2MiLCJmaW5kX2FsbCIsImJsb2NrIGluIGZpbmRfYWxsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2FsbCIsImdyZXAiLCJwYXR0ZXJuIiwiYmxvY2sgaW4gZ3JlcCIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcCIsImRlc3RydWN0dXJlIiwiPT09IiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJ0YWtlIiwidGFrZW4iLCJibG9jayBpbiB0YWtlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlIiwidGFrZV93aGlsZSIsImJsb2NrIGluIHRha2Vfd2hpbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2Vfd2hpbGUiLCJpbnNwZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxPQUFNQyxJQUFORCxFQUE0QkUsZ0JBQTVCRjtNQUVBRyxNQUFJRixJQUFKRSxVQUFBQSxxQkFBYUMsTUFBRCxFQU5oQixFQU1JRDtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBTko7UUFNeUI7UUFDbkJFLE9BQU8sT0FBQUosSUFBQSxFQUFBLGtEQUFBLE9BQUEsRUFBQSxDQUFBRyxNQUFBLENBQUEsUUFBQSxNQUFBLFNBQUEsQ0FBQSxDQUFBLEVBQUEsTUFBQTtRQUNORDtRQUNEQSxPQUFBRTtNQUhGRixDQUFBQSxJQUFBQTs7QUFNQUcsTUFBQUEsMEJBQUFBLHNCQUFlRixNQUFELEVBQVNHLElBQXZCRDtB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QVY7TUFDQSxhQUFNLFFBQU4sRUFBYSxVQUFiO01BQ0EvRSxPQUFBLGFBQU0sU0FBTixFQUFjLFVBQWQ7SUEvT0ZBLEdBQU1FLElBQU5GLEVBQW1CRSxJQUFuQkY7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjIxNDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IveWllbGRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBFbnVtZXJhdG9yXG4gIGNsYXNzIFlpZWxkZXJcbiAgICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgICBAYmxvY2sgPSBibG9ja1xuICAgICAgIyBydWJvY29wOmRpc2FibGUgTGludC9Wb2lkXG4gICAgICBzZWxmXG4gICAgICAjIHJ1Ym9jb3A6ZW5hYmxlIExpbnQvVm9pZFxuICAgIGVuZFxuXG4gICAgZGVmIHlpZWxkKCp2YWx1ZXMpXG4gICAgICAleHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoI3tAYmxvY2t9LCB2YWx1ZXMpO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS4kdGhyb3dlcl90eXBlID09IFwiYnJlYWtcIikge1xuICAgICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIDw8KHZhbHVlKVxuICAgICAgc2VsZi55aWVsZCh2YWx1ZSlcblxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIHRvX3Byb2NcbiAgICAgIHByb2MgZG8gfCp2YWx1ZXN8XG4gICAgICAgIHNlbGYueWllbGQoKnZhbHVlcylcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6WWllbGRlcj4iLCJpbml0aWFsaXplIiwiQGJsb2NrIiwiYmxvY2siLCJzZWxmIiwieWllbGQiLCI8PCIsInZhbHVlIiwidG9fcHJvYyIsInByb2MiLCJibG9jayBpbiB0b19wcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19wcm9jIiwidmFsdWVzIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOzs7QUFDRUMsTUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNFQyxhQUFTQztRQUVURixPQUFBRztNQUhGSCxDQUFBQSxHQUFBQTs7QUFPQUksTUFBQUEscUJBQUFBLDBCQVRKLEVBU0lBO0FBQUFBLFFBQUFBOzs7UUFUSjtRQVNjOztBQUVkQSxnQ0FBa0NILFVBQU9HOztBQUV6Q0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO01BVElBLENBQUFBLElBQUFBOztBQVlBQyxNQUFBQSxrQkFBQUEsMkJBQU9DLEtBQVBEO0FBQUFBLFFBQUFBOzs7UUFDRUYsSUFBSUMsT0FBQUEsQ0FBT0UsS0FBUEY7UUFFSkMsT0FBQUY7TUFIRkUsQ0FBQUEsR0FBQUE7TUFNQU4sT0FBQVEsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsTUFBQUwsSUFBQUssUUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsYUE1Qk4sRUE0Qk1BLEVBQUFDOzs7VUE1Qk47VUE0QmU7VUFDUEEsT0FBSU4sTUFBSkQsSUFBSUMsU0FBQUEsRUFBTyxNQUFDTyxNQUFELENBQVBQLEVBRE5LLENBQUFBLEdBQUFBLHNCQUFBQSxDQUFBRDtNQURGRCxDQUFBQSxHQUFBQTtJQTFCRlIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMjA2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL2FyaXRobWV0aWNfc2VxdWVuY2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGNsYXNzIHNlbGY6OkFyaXRobWV0aWNTZXF1ZW5jZSA8IHNlbGZcbiAgICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FyaXRobWV0aWNfc2VxJywgdHJ1ZSlgXG5cbiAgICBgdmFyIGluZiA9IEluZmluaXR5YFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBpbml0aWFsaXplKHJhbmdlLCBzdGVwID0gdW5kZWZpbmVkLCBjcmVhdGlvbl9tZXRob2QgPSA6c3RlcClcbiAgICAgIEBjcmVhdGlvbl9tZXRob2QgPSBjcmVhdGlvbl9tZXRob2RcbiAgICAgIGlmIHJhbmdlLmlzX2E/IDo6QXJyYXlcbiAgICAgICAgQHN0ZXBfYXJnMSwgQHN0ZXBfYXJnMiwgQHRvcGZ4LCBAYnlwZnggPSAqcmFuZ2VcbiAgICAgICAgQHJlY2VpdmVyX251bSA9IHN0ZXBcbiAgICAgICAgQHN0ZXAgPSAxXG5cbiAgICAgICAgQHJhbmdlID0gaWYgQHN0ZXBfYXJnMlxuICAgICAgICAgICAgICAgICAgIEBzdGVwID0gQHN0ZXBfYXJnMlxuICAgICAgICAgICAgICAgICAgIChAcmVjZWl2ZXJfbnVtLi5Ac3RlcF9hcmcxKVxuICAgICAgICAgICAgICAgICBlbHNpZiBAc3RlcF9hcmcxXG4gICAgICAgICAgICAgICAgICAgKEByZWNlaXZlcl9udW0uLkBzdGVwX2FyZzEpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAoQHJlY2VpdmVyX251bS4ubmlsKVxuICAgICAgICAgICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgQHNraXBwZWRfYXJnID0gdHJ1ZSB1bmxlc3Mgc3RlcFxuICAgICAgICBAcmFuZ2UsIEBzdGVwID0gcmFuZ2UsIHN0ZXAgfHwgMVxuICAgICAgZW5kXG5cbiAgICAgIEBvYmplY3QgPSBzZWxmXG5cbiAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCIgaWYgQHN0ZXAgPT0gMFxuICAgICAgdW5sZXNzIEBzdGVwLnJlc3BvbmRfdG8/IDp0b19pbnRcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7QHN0ZXAuY2xhc3N9IFwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbnRvIEludGVnZXInXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGF0dHJfcmVhZGVyIDpzdGVwXG5cbiAgICBkZWYgYmVnaW5cbiAgICAgIEByYW5nZS5iZWdpblxuICAgIGVuZFxuXG4gICAgZGVmIGVuZFxuICAgICAgQHJhbmdlLmVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGV4Y2x1ZGVfZW5kP1xuICAgICAgQHJhbmdlLmV4Y2x1ZGVfZW5kP1xuICAgIGVuZFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBfbGVzc2VyX3RoYW5fZW5kPyh2YWwpXG4gICAgICBlbmRfID0gc2VsZi5lbmQgfHwgYGluZmBcbiAgICAgIGlmIHN0ZXAgPiAwXG4gICAgICAgIGV4Y2x1ZGVfZW5kPyA/IHZhbCA8IGVuZF8gOiB2YWwgPD0gZW5kX1xuICAgICAgZWxzZVxuICAgICAgICBleGNsdWRlX2VuZD8gPyB2YWwgPiBlbmRfIDogdmFsID49IGVuZF9cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBfZ3JlYXRlcl90aGFuX2JlZ2luPyh2YWwpXG4gICAgICBiZWdpbl8gPSBzZWxmLmJlZ2luIHx8IC1gaW5mYFxuICAgICAgaWYgc3RlcCA+IDBcbiAgICAgICAgdmFsID4gYmVnaW5fXG4gICAgICBlbHNlXG4gICAgICAgIHZhbCA8IGJlZ2luX1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZmlyc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgICBpdGVyID0gc2VsZi5iZWdpbiB8fCAtYGluZmBcblxuICAgICAgcmV0dXJuIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpID8gaXRlciA6IG5pbCB1bmxlc3MgY291bnRcblxuICAgICAgb3V0ID0gW11cblxuICAgICAgd2hpbGUgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcikgJiYgY291bnQgPiAwXG4gICAgICAgIG91dCA8PCBpdGVyXG4gICAgICAgIGl0ZXIgKz0gc3RlcFxuICAgICAgICBjb3VudCAtPSAxXG4gICAgICBlbmRcblxuICAgICAgb3V0XG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgmYmxvY2spXG4gICAgICByZXR1cm4gc2VsZiB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAgIGNhc2Ugc2VsZi5iZWdpblxuICAgICAgd2hlbiBuaWxcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgVHlwZUVycm9yLCBcIm5pbCBjYW4ndCBiZSBjb2VyY2VkIGludG8gSW50ZWdlclwiXG4gICAgICBlbmRcblxuICAgICAgaXRlciA9IHNlbGYuYmVnaW4gfHwgLWBpbmZgXG5cbiAgICAgIHdoaWxlIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpXG4gICAgICAgIHlpZWxkIGl0ZXJcbiAgICAgICAgaXRlciArPSBzdGVwXG4gICAgICBlbmRcbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBsYXN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICAgY2FzZSBzZWxmLmVuZFxuICAgICAgd2hlbiBgaW5mYCwgLWBpbmZgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgc2VsZi5lbmRcbiAgICAgIHdoZW4gbmlsXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBlbmRsZXNzIGFyaXRobWV0aWMgc2VxdWVuY2UnXG4gICAgICBlbmRcblxuICAgICAgaXRlciA9IHNlbGYuZW5kIC0gKChzZWxmLmVuZCAtIHNlbGYuYmVnaW4pICUgc3RlcClcbiAgICAgIGl0ZXIgLT0gc3RlcCB1bmxlc3MgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcilcblxuICAgICAgcmV0dXJuIF9ncmVhdGVyX3RoYW5fYmVnaW4/KGl0ZXIpID8gaXRlciA6IG5pbCB1bmxlc3MgY291bnRcblxuICAgICAgb3V0ID0gW11cblxuICAgICAgd2hpbGUgX2dyZWF0ZXJfdGhhbl9iZWdpbj8oaXRlcikgJiYgY291bnQgPiAwXG4gICAgICAgIG91dCA8PCBpdGVyXG4gICAgICAgIGl0ZXIgLT0gc3RlcFxuICAgICAgICBjb3VudCAtPSAxXG4gICAgICBlbmRcblxuICAgICAgb3V0LnJldmVyc2VcbiAgICBlbmRcblxuICAgIGRlZiBzaXplXG4gICAgICBzdGVwX3NpZ24gPSBzdGVwID4gMCA/IDEgOiAtMVxuXG4gICAgICBpZiAhX2xlc3Nlcl90aGFuX2VuZD8oc2VsZi5iZWdpbilcbiAgICAgICAgMFxuICAgICAgZWxzaWYgWy1gaW5mYCwgYGluZmBdLmluY2x1ZGU/KHN0ZXApXG4gICAgICAgIDFcbiAgICAgIGVsc2lmIFstYGluZmAgKiBzdGVwX3NpZ24sIG5pbF0uaW5jbHVkZT8oc2VsZi5iZWdpbikgfHxcbiAgICAgICAgICAgIFtgaW5mYCAqIHN0ZXBfc2lnbiwgbmlsXS5pbmNsdWRlPyhzZWxmLmVuZClcbiAgICAgICAgYGluZmBcbiAgICAgIGVsc2VcbiAgICAgICAgaXRlciA9IHNlbGYuZW5kIC0gKChzZWxmLmVuZCAtIHNlbGYuYmVnaW4pICUgc3RlcClcbiAgICAgICAgaXRlciAtPSBzdGVwIHVubGVzcyBfbGVzc2VyX3RoYW5fZW5kPyhpdGVyKVxuICAgICAgICAoKGl0ZXIgLSBzZWxmLmJlZ2luKSAvIHN0ZXApLmFicy50b19pICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgPT0ob3RoZXIpXG4gICAgICBzZWxmLmNsYXNzID09IG90aGVyLmNsYXNzICYmXG4gICAgICAgIHNlbGYuYmVnaW4gPT0gb3RoZXIuYmVnaW4gJiZcbiAgICAgICAgc2VsZi5lbmQgPT0gb3RoZXIuZW5kICYmXG4gICAgICAgIHN0ZXAgPT0gb3RoZXIuc3RlcCAmJlxuICAgICAgICBleGNsdWRlX2VuZD8gPT0gb3RoZXIuZXhjbHVkZV9lbmQ/XG4gICAgZW5kXG5cbiAgICBkZWYgaGFzaFxuICAgICAgW3NlbGYuYmVnaW4sIHNlbGYuZW5kLCBzdGVwLCBleGNsdWRlX2VuZD9dLmhhc2hcbiAgICBlbmRcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBpZiBAcmVjZWl2ZXJfbnVtXG4gICAgICAgIGFyZ3MgPSBpZiBAc3RlcF9hcmcyXG4gICAgICAgICAgICAgICAgIFwiKCN7QHRvcGZ4fSN7QHN0ZXBfYXJnMS5pbnNwZWN0fSwgI3tAYnlwZnh9I3tAc3RlcF9hcmcyLmluc3BlY3R9KVwiXG4gICAgICAgICAgICAgICBlbHNpZiBAc3RlcF9hcmcxXG4gICAgICAgICAgICAgICAgIFwiKCN7QHRvcGZ4fSN7QHN0ZXBfYXJnMS5pbnNwZWN0fSlcIlxuICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgXCIoI3tAcmVjZWl2ZXJfbnVtLmluc3BlY3R9LiN7QGNyZWF0aW9uX21ldGhvZH0je2FyZ3N9KVwiXG4gICAgICBlbHNlXG4gICAgICAgIGFyZ3MgPSB1bmxlc3MgQHNraXBwZWRfYXJnXG4gICAgICAgICAgICAgICAgIFwiKCN7QHN0ZXB9KVwiXG4gICAgICAgICAgICAgICBlbmRcbiAgICAgICAgXCIoKCN7QHJhbmdlLmluc3BlY3R9KS4je0BjcmVhdGlvbl9tZXRob2R9I3thcmdzfSlcIlxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyA9PT0gPT1cbiAgICBhbGlhcyBlcWw/ID09XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpzZWxmOjpBcml0aG1ldGljU2VxdWVuY2U+IiwiaW5pdGlhbGl6ZSIsInJhbmdlIiwic3RlcCIsImNyZWF0aW9uX21ldGhvZCIsIkBjcmVhdGlvbl9tZXRob2QiLCJpc19hPyIsIkFycmF5IiwiQHN0ZXBfYXJnMSIsIkBzdGVwX2FyZzIiLCJAdG9wZngiLCJAYnlwZngiLCJAcmVjZWl2ZXJfbnVtIiwiQHN0ZXAiLCIxIiwiQHJhbmdlIiwiQHNraXBwZWRfYXJnIiwiJHJldF9vcl8xIiwiQG9iamVjdCIsInNlbGYiLCIwIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwicmVzcG9uZF90bz8iLCJjbGFzcyIsImF0dHJfcmVhZGVyIiwiYmVnaW4iLCJlbmQiLCJleGNsdWRlX2VuZD8iLCJfbGVzc2VyX3RoYW5fZW5kPyIsInZhbCIsImVuZF8iLCI+IiwiPCIsIjw9IiwiPj0iLCJfZ3JlYXRlcl90aGFuX2JlZ2luPyIsImJlZ2luXyIsIi1AIiwiZmlyc3QiLCJjb3VudCIsIml0ZXIiLCJvdXQiLCI8PCIsIisiLCItIiwiZWFjaCIsImJsb2NrX2dpdmVuPyIsIlR5cGVFcnJvciIsImxhc3QiLCJGbG9hdERvbWFpbkVycm9yIiwiUmFuZ2VFcnJvciIsIiUiLCJyZXZlcnNlIiwic2l6ZSIsInN0ZXBfc2lnbiIsIi0xIiwiaW5jbHVkZT8iLCIqIiwiLyIsImFicyIsInRvX2kiLCI9PSIsIm90aGVyIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiJHJldF9vcl80IiwiaGFzaCIsImluc3BlY3QiLCJhcmdzIl0sIm1hcHBpbmdzIjoiQUFBQUEseURBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNHQTtNQUVBQTs7QUFHREMsTUFBQUEsMEJBQUFBLHNCQUFlQyxLQUFELEVBQVFDLElBQVIsRUFBMEJDLGVBQXhDSDtBQUFBQSxRQUFBQTs7OztRQUF3QywrQ0FBa0I7UUFDeERJLHVCQUFtQkQ7UUFDbkIsSUFB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QUosQ0FBQSxHQUFVd0QsR0FEWixDQUFBO1VBR1BBLE9BQUNBLElBQUQsR0FBQSxDQUFLdEQsVUFBTXNELFNBQUFBLENBQUFBLENBQVgsQ0FBQSxHQUFvQkEsSUFBcEIsR0FBQSxDQUF3QmhFLG9CQUF4QixDQUFBLEdBQUEsQ0FBMkNpRSxJQUEzQyxDQUFBLEdBQWdERDtRQVpsRDtNQURGQSxDQUFBQSxHQUFBQTtNQWlCQSxhQUFNLEtBQU4sRUFBVSxJQUFWO01BQ0FyRSxPQUFBLGFBQU0sTUFBTixFQUFXLElBQVg7SUE3S0ZBLEdBQU1tQixJQUFObkIsRUFBaUNtQixJQUFqQ25CO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyNDMyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIHlpZWxkMSwgeWllbGRYLCBkZW55X2Zyb3plbl9hY2Nlc3NcblxubW9kdWxlIDo6RW51bWVyYWJsZVxuICAleHtcbiAgICBmdW5jdGlvbiBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IFtuaWxdO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBkZWYgYWxsPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIHVubGVzcyB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICB1bmxlc3MgOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIHRydWUgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGNodW5rKCZibG9jaylcbiAgICByZXR1cm4gdG9fZW51bSg6Y2h1bmspIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBuaWwsIGFjY3VtdWxhdGUgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiByZWxlYXNlQWNjdW11bGF0ZSgpIHtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHByZXZpb3VzYCwgYGFjY3VtdWxhdGVgKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGtleSA9ICR5aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICAgIGlmIChrZXkgPT09IG5pbCkge1xuICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbXTtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbmlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMgPT09IG5pbCB8fCBwcmV2aW91cyA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldmlvdXMgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjaHVua193aGlsZSgmYmxvY2spXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNsaWNlX3doZW4geyB8YmVmb3JlLCBhZnRlcnwgISh5aWVsZCBiZWZvcmUsIGFmdGVyKSB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3RfY29uY2F0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBtYXAoJmJsb2NrKS5mbGF0dGVuKDEpXG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgdG9fYS5jb21wYWN0XG4gIGVuZFxuXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXN1bHQgPSAwXG5cbiAgICAleHtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG8gfCphcmdzfFxuICAgICAgICA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqZWN0XG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9jay5uaWw/XG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgeyB0cnVlIH1cbiAgICBlbmRcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgYHJlc3VsdCsrYCBpZiBgJHlpZWxkWChibG9jaywgYXJncylgXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmN5Y2xlLCBuKSBkb1xuICAgICAgICBpZiBuLm5pbD9cbiAgICAgICAgICByZXNwb25kX3RvPyg6c2l6ZSkgPyA6OkZsb2F0OjpJTkZJTklUWSA6IG5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgIHJldHVybiBpZiBgbiA8PSAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYWxsID0gW10sIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKGFsbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRldGVjdChpZm5vbmUgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmRldGVjdCwgaWZub25lIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAgIGlmIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaWZub25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihpZm5vbmUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpZm5vbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbnVtYmVyIDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ICA9IFtdLFxuICAgICAgICAgIGN1cnJlbnQgPSAwO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobnVtYmVyIDw9IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZHJvcF93aGlsZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgICA9IFtdLFxuICAgICAgICAgIGRyb3BwaW5nID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBpZiAoZHJvcHBpbmcpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICBkcm9wcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvbnMobiwgJmJsb2NrKVxuICAgIGlmIGBhcmd1bWVudHMubGVuZ3RoICE9IDFgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAxKVwiXG4gICAgZW5kXG5cbiAgICBuID0gOjpPcGFsLnRyeV9jb252ZXJ0IG4sIDo6SW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2l6ZSdcbiAgICBlbmRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb25zLCBuKSBkb1xuICAgICAgICBlbnVtX3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgICAgaWYgZW51bV9zaXplLm5pbD9cbiAgICAgICAgICBuaWxcbiAgICAgICAgZWxzaWYgZW51bV9zaXplID09IDAgfHwgZW51bV9zaXplIDwgblxuICAgICAgICAgIDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW1fc2l6ZSAtIG4gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBidWZmZXIgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBidWZmZXIucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiBuKSB7XG4gICAgICAgICAgYnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbikge1xuICAgICAgICAgICR5aWVsZDEoYmxvY2ssIGJ1ZmZlci5zbGljZSgwLCBuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2VudHJ5KCpkYXRhLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIHRvX2VudW0oOmVhY2hfZW50cnksICpkYXRhKSB7IGVudW1lcmF0b3Jfc2l6ZSB9XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAkeWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBkYXRhKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9zbGljZShuLCAmYmxvY2spXG4gICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2xpY2Ugc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9zbGljZSwgbikgeyByZXNwb25kX3RvPyg6c2l6ZSkgPyAoc2l6ZSAvIG4pLmNlaWwgOiBuaWwgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBzbGljZSA9IFtdXG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgICR5aWVsZDEoYmxvY2ssIHNsaWNlKTtcbiAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIC8vIG91ciBcImxhc3RcIiBncm91cCwgaWYgc21hbGxlciB0aGFuIG4gdGhlbiB3b24ndCBoYXZlIGJlZW4geWllbGRlZFxuICAgICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX2luZGV4LCAqYXJncykgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfb2JqZWN0KG9iamVjdCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX29iamVjdCwgb2JqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgb2JqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcbiAgICB9XG5cbiAgICBvYmplY3RcbiAgZW5kXG5cbiAgZGVmIGVudHJpZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0pO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaWx0ZXJfbWFwKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmZpbHRlcl9tYXApIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgbWFwKCZibG9jaykuc2VsZWN0KCY6aXRzZWxmKVxuICBlbmRcblxuICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmluZF9hbGwpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaW5kX2luZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gMFxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpID09IG9iamVjdFxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChudW1iZXIgPSB1bmRlZmluZWQpXG4gICAgaWYgYG51bWJlciA9PT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8dmFsdWV8XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgcmVzdWx0ID0gW11cbiAgICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgIGlmIGBudW1iZXIgPCAwYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbnVtYmVyID09IDBgXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnQgPSAwXG5cbiAgICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgICBgcmVzdWx0LnB1c2goI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9KWBcblxuICAgICAgICBpZiBgbnVtYmVyIDw9ICsrY3VycmVudGBcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IHVubGVzcyBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IGlmIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JvdXBfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Z3JvdXBfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaGFzaCA9IHt9XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAjeyhoYXNoW2B2YWx1ZWBdIHx8PSBbXSkgPDwgYHBhcmFtYH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaFxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8ob2JqKVxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaWYgOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9ialxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gJHlpZWxkWChibG9jaywgW3Jlc3VsdCwgdmFsdWVdKTtcblxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICghI3s6OlN5bWJvbCA9PT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje29iamVjdC5pbnNwZWN0fSBpcyBub3QgYSBTeW1ib2xcIn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3ltICAgID0gb2JqZWN0O1xuICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gI3tgcmVzdWx0YC5fX3NlbmRfXyBzeW0sIGB2YWx1ZWB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxhenlcbiAgICA6OkVudW1lcmF0b3I6OkxhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVudW1lcmF0b3Jfc2l6ZVxuICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IHNpemUgOiBuaWxcbiAgZW5kXG5cbiAgZGVmIG1heChuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAobiA9PT0gdW5kZWZpbmVkIHx8IG4gPT09IG5pbCkge1xuICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBbaXRlbSwgcmVzdWx0XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gI3tgaXRlbWAgPD0+IGByZXN1bHRgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuID0gJGNvZXJjZV90byhuLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG5cbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxuICBlbmRcblxuICBkZWYgbWF4X2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1heF9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykucmV2ZXJzZS50YWtlIG5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPD0+IGBieWB9ID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtXG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbihuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHJldHVybiBzb3J0IHsgfGEsIGJ8IHlpZWxkIGEsIGIgfS50YWtlIG5cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNvcnQudGFrZSBuXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBibG9jayhwYXJhbSwgcmVzdWx0KTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCN7OjpPcGFsLmNvbXBhcmUoYHBhcmFtYCwgYHJlc3VsdGApfSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWluX2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbl9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykudGFrZSBuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgYnk7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA8IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXgoJmJsb2NrKVxuICAgIGJsb2NrIHx8PSA6Oktlcm5lbC5wcm9jIHsgfGEsIGJ8IGEgPD0+IGIgfVxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gbmlsLCBtYXggPSBuaWwsIGZpcnN0X3RpbWUgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGlmIChmaXJzdF90aW1lKSB7XG4gICAgICAgICAgbWluID0gbWF4ID0gZWxlbWVudDtcbiAgICAgICAgICBmaXJzdF90aW1lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbl9jbXAgPSAje2Jsb2NrLmNhbGwoYG1pbmAsIGBlbGVtZW50YCl9O1xuXG4gICAgICAgICAgaWYgKG1pbl9jbXAgPT09IG5pbCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5fY21wID4gMCkge1xuICAgICAgICAgICAgbWluID0gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWF4X2NtcCA9ICN7YmxvY2suY2FsbChgbWF4YCwgYGVsZW1lbnRgKX07XG5cbiAgICAgICAgICBpZiAobWF4X2NtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1heF9jbXAgPCAwKSB7XG4gICAgICAgICAgICBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5tYXhfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW5fcmVzdWx0ID0gbmlsLFxuICAgICAgICAgIG1heF9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWluX2J5LFxuICAgICAgICAgIG1heF9ieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgobWluX2J5ID09PSB1bmRlZmluZWQpIHx8ICN7YHZhbHVlYCA8PT4gYG1pbl9ieWB9IDwgMCkge1xuICAgICAgICAgIG1pbl9yZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBtaW5fYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG1heF9ieSA9PT0gdW5kZWZpbmVkKSB8fCAje2B2YWx1ZWAgPD0+IGBtYXhfYnlgfSA+IDApIHtcbiAgICAgICAgICBtYXhfcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgbWF4X2J5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluX3Jlc3VsdCwgbWF4X3Jlc3VsdF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbm9uZT8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGl0ZW0gPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgb25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgY291bnQgPSAwXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICByZXR1cm4gZmFsc2UgaWYgY291bnQgPiAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIG5leHQgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjb3VudCA9PSAxXG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cGFydGl0aW9uKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHRydXRoeSA9IFtdLCBmYWxzeSA9IFtdLCByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICB0cnV0aHkucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmFsc3kucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCEkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgJHlpZWxkWChibG9jaywgcmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzbGljZV9iZWZvcmUocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICA6OkVudW1lcmF0b3IubmV3IGRvIHxlfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmxvY2socGFyYW0sICN7cGF0dGVybi5kdXB9KTtcblxuICAgICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkgJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2VfYWZ0ZXIocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIHsgfGV8IHBhdHRlcm4gPT09IGUgfVxuICAgIGVuZFxuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWNjdW11bGF0ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgZW5kX2NodW5rID0gJHlpZWxkMShibG9jaywgZWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCR0cnV0aHkoZW5kX2NodW5rKSkge1xuICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBhY2N1bXVsYXRlYCl9O1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoYWNjdW11bGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBhY2N1bXVsYXRlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzbGljZV93aGVuKCZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKScgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBuaWwsIGxhc3RfYWZ0ZXIgPSBuaWw7XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbXMgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICBiZWZvcmUgPSBwYXJhbXNbMF0sXG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyYW1zWzFdLFxuICAgICAgICAgICAgICBtYXRjaCA9ICR5aWVsZFgoYmxvY2ssIFtiZWZvcmUsIGFmdGVyXSk7XG5cbiAgICAgICAgICBsYXN0X2FmdGVyID0gYWZ0ZXI7XG5cbiAgICAgICAgICBpZiAoc2xpY2UgPT09IG5pbCkge1xuICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShtYXRjaCkpIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zKDIpO1xuXG4gICAgICAgIGlmIChzbGljZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2xpY2UucHVzaChsYXN0X2FmdGVyKTtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICBhcnkgPSB0b19hXG4gICAgYmxvY2sgPSAtPihhLCBiKSB7IGEgPD0+IGIgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc29ydF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGR1cCA9IG1hcCBkb1xuICAgICAgYXJnID0gOjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKVxuICAgICAgW3lpZWxkKGFyZyksIGFyZ11cbiAgICBlbmRcbiAgICBkdXAuc29ydCEgeyB8YSwgYnwgYGFbMF1gIDw9PiBgYlswXWAgfVxuICAgIGR1cC5tYXAhIHsgfGl8IGBpWzFdYCB9XG4gIGVuZFxuXG4gICMgVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgS2FoYW4gc3VtbWF0aW9uIGFsZ29yaXRobSBpZiBpdCBpcyBwb3NzaWJsZSB0byBhcHBseSBvbmUuXG4gIGRlZiBzdW0oaW5pdGlhbCA9IDApXG4gICAgcmVzdWx0ID0gaW5pdGlhbFxuICAgIGNvbXBlbnNhdGlvbiA9IDBcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaXRlbSA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgICAgICAgICAgZW5kXG5cbiAgICAgIGlmICFbOjpGbG9hdDo6SU5GSU5JVFksIC06OkZsb2F0OjpJTkZJTklUWV0uaW5jbHVkZT8oaXRlbSkgJiYgaXRlbS5yZXNwb25kX3RvPyg6LSlcbiAgICAgICAgeSA9IGl0ZW0gLSBjb21wZW5zYXRpb25cbiAgICAgICAgdCA9IHJlc3VsdCArIHlcbiAgICAgICAgY29tcGVuc2F0aW9uID0gKHQgLSByZXN1bHQpIC0geVxuICAgICAgICByZXN1bHQgPSB0XG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdCArPSBpdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdGFrZShudW0pXG4gICAgZmlyc3QobnVtKVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp0YWtlX3doaWxlIHVubGVzcyBibG9ja1xuXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcblxuICAgICAgdW5sZXNzIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICBlbmRcblxuICAgICAgYHJlc3VsdC5wdXNoKHZhbHVlKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgIGhhc2ggPSB7fVxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuXG4gICAgICBwcm9kdWNlZCA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgICAgIHlpZWxkKHZhbHVlKVxuICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIHVubGVzcyBoYXNoLmtleT8ocHJvZHVjZWQpXG4gICAgICAgIGhhc2hbcHJvZHVjZWRdID0gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaGFzaC52YWx1ZXNcbiAgZW5kXG5cbiAgZGVmIHRhbGx5KGhhc2ggPSB1bmRlZmluZWQpXG4gICAgYGlmIChoYXNoICYmIGhhc2ggIT09IG5pbCkgeyAkZGVueV9mcm96ZW5fYWNjZXNzKGhhc2gpOyB9YFxuXG4gICAgb3V0ID0gZ3JvdXBfYnkoJjppdHNlbGYpLnRyYW5zZm9ybV92YWx1ZXMoJjpjb3VudClcbiAgICBpZiBoYXNoXG4gICAgICBvdXQuZWFjaCB7IHxrLCB2fCBoYXNoW2tdID0gaGFzaC5mZXRjaChrLCAwKSArIHYgfVxuICAgICAgaGFzaFxuICAgIGVsc2VcbiAgICAgIG91dFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9faCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgdmFyIGFyeSA9ICN7OjpPcGFsLmNvZXJjZV90bz8oYHBhcmFtYCwgOjpBcnJheSwgOnRvX2FyeSl9LCBrZXksIHZhbDtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFyeWAuY2xhc3N9IChleHBlY3RlZCBhcnJheSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJ5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCAoZXhwZWN0ZWQgMiwgd2FzICN7YGFyeWAubGVuZ3RofSlcIn1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBhcnlbMF07XG4gICAgICAgIHZhbCA9IGFyeVsxXTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXG4gICAgdG9fYS56aXAoKm90aGVycylcbiAgZW5kXG5cbiAgYWxpYXMgZmluZCBkZXRlY3RcbiAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG4gIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG4gIGFsaWFzIG1hcCBjb2xsZWN0XG4gIGFsaWFzIG1lbWJlcj8gaW5jbHVkZT9cbiAgYWxpYXMgcmVkdWNlIGluamVjdFxuICBhbGlhcyBzZWxlY3QgZmluZF9hbGxcbiAgYWxpYXMgdG9fYSBlbnRyaWVzXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpFbnVtZXJhYmxlPiIsImFsbD8iLCJwYXR0ZXJuIiwiZWFjaCIsInNlbGYiLCJibG9jayBpbiBhbGw/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbGw/IiwiY29tcGFyYWJsZSIsInB1YmxpY19zZW5kIiwiYmxvY2tfZ2l2ZW4/IiwidmFsdWUiLCJPcGFsIiwiZGVzdHJ1Y3R1cmUiLCJhbnk/IiwiYmxvY2sgaW4gYW55PyIsImJsb2NrICgyIGxldmVscykgaW4gYW55PyIsImNodW5rIiwidG9fZW51bSIsImJsb2NrIGluIGNodW5rIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjaHVuayIsImVudW1lcmF0b3Jfc2l6ZSIsIm5ldyIsIkVudW1lcmF0b3IiLCJ5aWVsZGVyIiwieWllbGQiLCJjaHVua193aGlsZSIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInNsaWNlX3doZW4iLCJibG9jayBpbiBjaHVua193aGlsZSIsImJlZm9yZSIsImFmdGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjaHVua193aGlsZSIsIiEiLCJjb2xsZWN0IiwiZW51bV9mb3IiLCJibG9jayBpbiBjb2xsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwiY29sbGVjdF9jb25jYXQiLCJibG9jayBpbiBjb2xsZWN0X2NvbmNhdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdF9jb25jYXQiLCJtYXAiLCJibG9jayIsInRvX3Byb2MiLCJmbGF0dGVuIiwiMSIsImNvbXBhY3QiLCJ0b19hIiwiY291bnQiLCJvYmplY3QiLCJyZXN1bHQiLCIwIiwid2FybiIsInByb2MiLCJibG9jayBpbiBjb3VudCIsImJsb2NrICgyIGxldmVscykgaW4gY291bnQiLCJhcmdzIiwiPT0iLCJuaWw/IiwiY3ljbGUiLCJuIiwiYmxvY2sgaW4gY3ljbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGN5Y2xlIiwicmVzcG9uZF90bz8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiPiIsIioiLCJkZXRlY3QiLCJpZm5vbmUiLCJibG9jayBpbiBkZXRlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGRldGVjdCIsImRyb3AiLCJudW1iZXIiLCJkcm9wX3doaWxlIiwiZWFjaF9jb25zIiwidHJ5X2NvbnZlcnQiLCJibG9jayBpbiBlYWNoX2NvbnMiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfY29ucyIsImVudW1fc2l6ZSIsIjwiLCIrIiwiLSIsImVhY2hfZW50cnkiLCJkYXRhIiwiYmxvY2sgaW4gZWFjaF9lbnRyeSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9lbnRyeSIsImVhY2hfc2xpY2UiLCJibG9jayBpbiBlYWNoX3NsaWNlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3NsaWNlIiwiLyIsInNpemUiLCJjZWlsIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfaW5kZXgiLCJlYWNoX3dpdGhfb2JqZWN0IiwiYmxvY2sgaW4gZWFjaF93aXRoX29iamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF93aXRoX29iamVjdCIsImVudHJpZXMiLCJmaWx0ZXJfbWFwIiwiYmxvY2sgaW4gZmlsdGVyX21hcCIsImJsb2NrICgyIGxldmVscykgaW4gZmlsdGVyX21hcCIsInNlbGVjdCIsImZpbmRfYWxsIiwiYmxvY2sgaW4gZmluZF9hbGwiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfYWxsIiwiZmluZF9pbmRleCIsImluZGV4IiwiYmxvY2sgaW4gZmluZF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZmluZF9pbmRleCIsImZpcnN0IiwiYmxvY2sgaW4gZmlyc3QiLCJjdXJyZW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaXJzdCIsImdyZXAiLCJibG9jayBpbiBncmVwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBncmVwIiwiY21wIiwiX19zZW5kX18iLCJsZW5ndGgiLCI8PSIsIltdIiwicHVzaCIsImdyZXBfdiIsImJsb2NrIGluIGdyZXBfdiIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcF92IiwiZ3JvdXBfYnkiLCJibG9jayBpbiBncm91cF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gZ3JvdXBfYnkiLCJoYXNoIiwiJHJldF9vcl8xIiwiW109IiwiPDwiLCJpbmNsdWRlPyIsIm9iaiIsImJsb2NrIGluIGluY2x1ZGU/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbmNsdWRlPyIsImluamVjdCIsInN5bSIsIlN5bWJvbCIsIj09PSIsIlR5cGVFcnJvciIsImluc3BlY3QiLCJsYXp5IiwiRW51bWVyYXRvcjo6TGF6eSIsImJsb2NrIGluIGxhenkiLCJlbnVtJCIsImJsb2NrICgyIGxldmVscykgaW4gbGF6eSIsIm1heCIsIjw9PiIsInNvcnQiLCJyZXZlcnNlIiwibWF4X2J5IiwiYmxvY2sgaW4gbWF4X2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtYXhfYnkiLCJzb3J0X2J5IiwidGFrZSIsIm1pbiIsImJsb2NrIGluIG1pbiIsImEiLCJiIiwiY29tcGFyZSIsIm1pbl9ieSIsImJsb2NrIGluIG1pbl9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWluX2J5IiwibWlubWF4IiwiYmxvY2sgaW4gbWlubWF4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW5tYXgiLCJjYWxsIiwibWlubWF4X2J5IiwiYmxvY2sgaW4gbWlubWF4X2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW5tYXhfYnkiLCJub25lPyIsImJsb2NrIGluIG5vbmU/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBub25lPyIsIml0ZW0iLCJvbmU/IiwiYmxvY2sgaW4gb25lPyIsImJsb2NrICgyIGxldmVscykgaW4gb25lPyIsInBhcnRpdGlvbiIsImJsb2NrIGluIHBhcnRpdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcGFydGl0aW9uIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXZlcnNlX2VhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHJldmVyc2VfZWFjaCIsInNsaWNlX2JlZm9yZSIsImJsb2NrIGluIHNsaWNlX2JlZm9yZSIsImUiLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX2JlZm9yZSIsImR1cCIsInNsaWNlX2FmdGVyIiwiYmxvY2sgaW4gc2xpY2VfYWZ0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX2FmdGVyIiwiYmxvY2sgaW4gc2xpY2Vfd2hlbiIsImJsb2NrICgyIGxldmVscykgaW4gc2xpY2Vfd2hlbiIsImFyeSIsImJsb2NrIGluIHNvcnQiLCJibG9jayAoMiBsZXZlbHMpIGluIHNvcnQiLCJibG9jayBpbiBzb3J0X2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0X2J5IiwiYXJnIiwic29ydCEiLCJtYXAhIiwiaSIsInN1bSIsImluaXRpYWwiLCJjb21wZW5zYXRpb24iLCJibG9jayBpbiBzdW0iLCJibG9jayAoMiBsZXZlbHMpIGluIHN1bSIsIi1AIiwieSIsInQiLCJudW0iLCJ0YWtlX3doaWxlIiwiYmxvY2sgaW4gdGFrZV93aGlsZSIsImJsb2NrICgyIGxldmVscykgaW4gdGFrZV93aGlsZSIsInVuaXEiLCJibG9jayBpbiB1bmlxIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1bmlxIiwicHJvZHVjZWQiLCJrZXk/IiwidmFsdWVzIiwidGFsbHkiLCJvdXQiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwiYmxvY2sgaW4gdGFsbHkiLCJrIiwidiIsImJsb2NrICgyIGxldmVscykgaW4gdGFsbHkiLCJmZXRjaCIsInRvX2giLCJjb2VyY2VfdG8/IiwiQXJyYXkiLCJjbGFzcyIsInppcCIsIm90aGVycyJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOzs7OztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVFQyxJQUFBQSxvQkFBQUEsZ0NBQVNDLE9BQVRELEdBQUFBLE1BQUFBLElBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7TUFDRSxJQUFBLFFBQUlBLHFCQUFKLENBQUE7UUFDRUUsTUFBQUMsSUFBQUQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBQUUsYUFuQk4sRUFtQk1BLEVBQUFDOzs7VUFuQk47VUFtQmU7VUFDUEMsYUFBY0Q7VUFFZCxJQUFBLFFBQTJCRSxNQUFQTixPQUFPTSxlQUFBQSxFQUFQLENBQW9CLEtBQXBCLENBQUEsUUFBMEIsTUFBQ0QsVUFBRCxDQUExQixDQUFPQyxDQUEzQixDQUFBO1lBdEJSRixPQUFBO1VBc0JRO1lBQUEsU0FBQSxRQUFPLEtBQVA7VUFBQSxFQUhGRCxDQUFBQSxHQUFBQSw2QkFBQUEsQ0FBQUY7TUFERixPQU1BLElBQU1NLGVBQU47UUFDRU4sTUFBQUMsSUFBQUQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBQUUsYUF6Qk4sRUF5Qk1BLEVBQUFDOzs7VUF6Qk47VUF5QmU7VUFDUCxJQUFBLFFBQU8sbUJBQU0sTUFBQ0ksS0FBRCxDQUFOLENBQVAsQ0FBQTtZQTFCUkosT0FBQTtVQTBCUTtZQUNFLFNBQUEsUUFBTyxL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S0csT0FBQUEsQ0FBQUEsQ0FBM0IsQ0FBQSxHQUFrQ0gsbUJBQXREbE47QUFDcEJrTjtBQUNBQTtBQUNBQSxVQUFZbk4sT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUNpTixzQ0FBRCxHQUFBLENBQXVDQSxDQUFDQSxHQUFEQSxDQUFLbEgsUUFBQUEsQ0FBQUEsQ0FBNUMsQ0FBQSxHQUFvRGtILEdBQTVFbE47QUFDcEJrTjtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtJQXhCRUEsQ0FBQUEsSUFBQUE7O0FBMkJBSSxJQUFBQSxtQkFBQUEsZUF0dkNGLEVBc3ZDRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUF0dkNGO01Bc3ZDVTtNQUNOQSxPQUFJQSxNQUFKN08sSUFBQTRDLE1BQUFBLENBQUFBLENBQUlpTSxPQUFBQSxFQUFLLE1BQUNDLE1BQUQsQ0FBTEQ7SUFETkEsQ0FBQUEsSUFBQUE7SUFJQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsVUFBYjtJQUNBLGFBQU0sVUFBTixFQUFlLGdCQUFmO0lBQ0EsYUFBTSxLQUFOLEVBQVUsU0FBVjtJQUNBLGFBQU0sU0FBTixFQUFjLFVBQWQ7SUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO0lBQ0EsYUFBTSxRQUFOLEVBQWEsVUFBYjtJQUNBalAsT0FBQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0VBL3ZDRkEsR0FBTyxJQUFQQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjQyMDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL25pbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyA6Ok5pbENsYXNzXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkbWV0YSA9ICN7c2VsZn1gXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiAhXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgIGBvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciA9PT0gbmlsYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJ25pbCdcbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3NcbiAgICA6Ok5pbENsYXNzXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHRvX2hcbiAgICBgT3BhbC5oYXNoKClgXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgMFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICcnXG4gIGVuZFxuXG4gIGRlZiB0b19jXG4gICAgOjpDb21wbGV4Lm5ldygwLCAwKVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoKmFyZ3MpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yIGlmIGFyZ3MubGVuZ3RoID4gMVxuICAgIDo6S2VybmVsLlJhdGlvbmFsKDAsIDEpXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoMCwgMSlcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIFtdXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2YgdG9faVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpOaWxDbGFzcz4iLCJzZWxmIiwiYWxsb2NhdGUiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5hbWUiLCIhIiwiJiIsInwiLCJvdGhlciIsIl4iLCI9PSIsImR1cCIsImNsb25lIiwiJGt3YXJncyIsImluc3BlY3QiLCJuaWw/Iiwic2luZ2xldG9uX2NsYXNzIiwiTmlsQ2xhc3MiLCJ0b19hIiwidG9faCIsInRvX2kiLCIwIiwidG9fcyIsInRvX2MiLCJDb21wbGV4IiwibmV3IiwicmF0aW9uYWxpemUiLCI+IiwiYXJncyIsImxlbmd0aCIsIjEiLCJBcmd1bWVudEVycm9yIiwiUmF0aW9uYWwiLCJ0b19yIiwiaW5zdGFuY2VfdmFyaWFibGVzIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDR0EsMEJBQTRCQztJQUU3Qjs7OztBQUNFQyxNQUFBQSx3QkFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBQyxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE2QkgsMEJBQUQsR0FBQSxDQUEyQkQsSUFBQUssTUFBQUEsQ0FBQUEsQ0FBM0IsQ0FBcEJGO01BRFZGLENBQUFBLEdBQUFBOzs7TUFJQSxzQkFBTSxLQUFOO01BUkosT0FBQTtJQUdFLDRCQUFTRCxJQUFUOztBQVFBTSxJQUFBQSxpQkFBQUEsWUFDRSxJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsaUJBQUFBLFlBQ0UsS0FERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLGlCQUFBQSx1QkFBTUMsS0FBTkQ7QUFBQUE7TUFDRUEsT0FBQ0EsZ0NBQURBO0lBREZBLENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxpQkFBQUEsdUJBQU1ELEtBQU5DO0FBQUFBO01BQ0VBLE9BQUNBLGdDQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsa0JBQUFBLDRCQUFPRixLQUFQRTtBQUFBQTtNQUNFQSxPQUFDQSxhQUFEQTtJQURGQSxDQUFBQSxHQUFBQTs7QUFJQUMsSUFBQUEsbUJBQUFBLFlBQ0UsR0FERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxpQkFuQ0ZDLE9BbUNFRDtBQUFBQSxNQUFBQTs7O01BbkNGOztNQW1DWSxrQ0FBQSw2QkFBUTtNQUNoQkEsT0FBQTtJQURGQSxDQUFBQSxJQUFBQTs7QUFJQUUsSUFBQUEsdUJBQUFBLFlBQ0VoQixLQURGZ0IsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxZQUNFLElBREZBLENBQUFBLEdBQUFBOztBQUlBQyxJQUFBQSwrQkFBQUEsMkJBQUFBO0FBQUFBO01BQ0VBLE9BQUFDO0lBREZELENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBO01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQ0EsV0FBREE7SUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxZQUNFQyxDQURGRCxDQUFBQSxHQUFBQTs7QUFJQUUsSUFBQUEsb0JBQUFBLFlBQ0V4QixFQURGd0IsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQUMsY0FBU0MsS0FBQUEsQ0FBS0osQ0FBZCxFQUFpQkEsQ0FBUkk7SUFEWEYsQ0FBQUEsR0FBQUE7O0FBSUFHLElBQUFBLDJCQUFBQSx1QkF2RUYsRUF1RUVBO0FBQUFBLE1BQUFBOzs7TUF2RUY7TUF1RWtCO01BQ2QsSUFBQSxRQUE4Q0MsT0FBWkMsSUFBSUMsUUFBQUEsQ0FBQUEsQ0FBUUYsRUFBRUcsQ0FBRkgsQ0FBOUMsQ0FBQTtRQUFBMUIsT0FBUUMsT0FBQUEsQ0FBTzZCLG9CQUFQN0I7TUFBUjtNQUNBd0IsT0FBQXpCLE9BQVErQixVQUFBQSxDQUFVWCxDQUFsQixFQUFxQlMsQ0FBYkU7SUFGVk4sQ0FBQUEsSUFBQUE7O0FBS0FPLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQWhDLE9BQVErQixVQUFBQSxDQUFVWCxDQUFsQixFQUFxQlMsQ0FBYkU7SUFEVkMsQ0FBQUEsR0FBQUE7O0FBSUFDLElBQUFBLGtDQUFBQSw4QkFBQUE7QUFBQUE7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSxHQUFBQTtJQUlBcEMsT0FBQSxhQUFNLE1BQU4sRUFBVyxNQUFYO0VBcEZGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDMxMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaGVscGVycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHR5cGVfZXJyb3IsIGNvZXJjZV90b1xuXG5tb2R1bGUgOjpPcGFsXG4gIGRlZiBzZWxmLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpXG4gICAgYE9wYWwuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90byEob2JqZWN0LCB0eXBlLCBtZXRob2QsICphcmdzKVxuICAgIGNvZXJjZWQgPSBgJGNvZXJjZV90byhvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncylgXG5cbiAgICB1bmxlc3MgdHlwZSA9PT0gY29lcmNlZFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcbiAgICBlbmRcblxuICAgIGNvZXJjZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvPyhvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXG4gICAgcmV0dXJuIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG5cbiAgICBjb2VyY2VkID0gYCRjb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpYFxuXG4gICAgcmV0dXJuIGlmIGNvZXJjZWQubmlsP1xuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZClgXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuICAgIHJldHVybiBvYmplY3QgaWYgdHlwZSA9PT0gb2JqZWN0XG5cbiAgICBpZiBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICBvYmplY3QuX19zZW5kX18gbWV0aG9kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbXBhcmUoYSwgYilcbiAgICBjb21wYXJlID0gYSA8PT4gYlxuXG4gICAgaWYgYGNvbXBhcmUgPT09IG5pbGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7YS5jbGFzc30gd2l0aCAje2IuY2xhc3N9IGZhaWxlZFwiXG4gICAgZW5kXG5cbiAgICBjb21wYXJlXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgYXJnc19hcnkgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJnc19hcnkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGFyZ3NfYXJ5W2ldID0gYXJnc1tpXTsgfVxuXG4gICAgICAgIHJldHVybiBhcmdzX2FyeTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJlc3BvbmRfdG8/KG9iaiwgbWV0aG9kLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgICV4e1xuICAgICAgaWYgKG9iaiA9PSBudWxsIHx8ICFvYmouJCRjbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JqLnJlc3BvbmRfdG8/KG1ldGhvZCwgaW5jbHVkZV9hbGwpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgdW5sZXNzIGAvXkBbYS16QS1aX11bYS16QS1aMC05X10qPyQvLnRlc3QobmFtZSlgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCInI3tuYW1lfScgaXMgbm90IGFsbG93ZWQgYXMgYW4gaW5zdGFuY2UgdmFyaWFibGUgbmFtZVwiLCBuYW1lKVxuICAgIGVuZFxuXG4gICAgbmFtZVxuICBlbmRcblxuICBkZWYgc2VsZi5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShuYW1lLCA6OlN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGBuYW1lLmxlbmd0aCA8IDMgfHwgbmFtZS5zbGljZSgwLDIpICE9PSAnQEAnYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwiYCN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGEgY2xhc3MgdmFyaWFibGUgbmFtZVwiLCBuYW1lKVxuICAgIGVuZFxuXG4gICAgbmFtZVxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdF9uYW1lPyhjb25zdF9uYW1lKVxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBjb25zdF9uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAje2NvbnN0X25hbWUgPSA6Ok9wYWwuY29lcmNlX3RvIShjb25zdF9uYW1lLCA6OlN0cmluZywgOnRvX3N0cil9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje2NvbnN0X25hbWV9WzBdID09PSAje2NvbnN0X25hbWV9WzBdLnRvVXBwZXJDYXNlKClcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0X25hbWUhKGNvbnN0X25hbWUpXG4gICAgY29uc3RfbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKSBpZiBkZWZpbmVkPyA6OlN0cmluZ1xuXG4gICAgJXh7XG4gICAgICBpZiAoIWNvbnN0X25hbWUgfHwgY29uc3RfbmFtZVswXSAhPSBjb25zdF9uYW1lWzBdLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgI3tyYWlzZSA6Ok5hbWVFcnJvciwgXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7Y29uc3RfbmFtZX1cIn1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdF9uYW1lXG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgIyBNYXJrIHNvbWUgbWV0aG9kcyBhcyBwcmlzdGluZSBpbiBvcmRlciB0byBhcHBseSBvcHRpbWl6YXRpb25zIHdoZW4gdGhleVxuICAjIGFyZSBzdGlsbCBpbiB0aGVpciBvcmlnaW5hbCBmb3JtLiBUaGlzIGNvdWxkIHByb2JhYmx5IGJlIG1vdmVkIHRvXG4gICMgdGhlIGBPcGFsLmRlZigpYCBKUyBBUEksIGJ1dCBmb3Igbm93IGl0IHdpbGwgc3RheSBtYW51YWwuXG4gICNcbiAgIyBAZXhhbXBsZVxuICAjXG4gICMgICBPcGFsLnByaXN0aW5lIEFycmF5LCA6YWxsb2NhdGUsIDpjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcywgOmluaXRpYWxpemVfZHVwXG4gICNcbiAgIyAgIGNsYXNzIEFycmF5XG4gICMgICAgIGRlZiBkdXBcbiAgIyAgICAgICAleHtcbiAgIyAgICAgICAgIGlmIChcbiAgIyAgICAgICAgICAgc2VsZi4kYWxsb2NhdGUuJCRwcmlzdGluZSAmJlxuICAjICAgICAgICAgICBzZWxmLiRjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcy4kJHByaXN0aW5lICYmXG4gICMgICAgICAgICAgIHNlbGYuJGluaXRpYWxpemVfZHVwLiQkcHJpc3RpbmVcbiAgIyAgICAgICAgICkgcmV0dXJuIHNlbGYuc2xpY2UoMCk7XG4gICMgICAgICAgfVxuICAjXG4gICMgICAgICAgc3VwZXJcbiAgIyAgICAgZW5kXG4gICMgICBlbmRcbiAgI1xuICAjIEBwYXJhbSBvd25lcl9jbGFzcyBbQ2xhc3NdIHRoZSBjbGFzcyBvd25pbmcgdGhlIG1ldGhvZHNcbiAgIyBAcGFyYW0gbWV0aG9kX25hbWVzIFtBcnJheTxTeW1ib2w+XSB0aGUgbGlzdCBvZiBtZXRob2RzIG5hbWVzIHRvIG1hcmtcbiAgIyBAcmV0dXJuIFtuaWxdXG4gIGRlZiBzZWxmLnByaXN0aW5lKG93bmVyX2NsYXNzLCAqbWV0aG9kX25hbWVzKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGhvZF9uYW1lLCBtZXRob2Q7XG4gICAgICBmb3IgKHZhciBpID0gbWV0aG9kX25hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG1ldGhvZF9uYW1lID0gbWV0aG9kX25hbWVzW2ldO1xuICAgICAgICBtZXRob2QgPSBvd25lcl9jbGFzcy4kJHByb3RvdHlwZVsnJCcrbWV0aG9kX25hbWVdO1xuXG4gICAgICAgIGlmIChtZXRob2QgJiYgIW1ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgICBtZXRob2QuJCRwcmlzdGluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9zdGFjayA9IFtdYFxuXG4gICMgUGVyZm9ybXMgYSBzYWZlIGNhbGwgdG8gaW5zcGVjdCBmb3IgYW55IHZhbHVlLCB3aGV0aGVyXG4gICMgbmF0aXZlIG9yIE9wYWwtd3JhcHBlZC5cbiAgI1xuICAjIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICAjIEByZXR1cm4gW1N0cmluZ11cbiAgZGVmIHNlbGYuaW5zcGVjdCh2YWx1ZSA9IHVuZGVmaW5lZClcbiAgICBgdmFyIHB1c2hlZCA9IGZhbHNlYFxuICAgIGJlZ2luXG4gICAgICAleHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSlMgbnVsbCB2YWx1ZVxuICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEpTIHVuZGVmaW5lZCB2YWx1ZVxuICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuJCRjbGFzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBKUyBvYmplY3QgLyBvdGhlciB2YWx1ZSB0aGF0IGlzIG5vdCBicmlkZ2VkXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS4kaW5zcGVjdCAhPT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZS4kaW5zcGVjdC4kJHN0dWIpIHtcbiAgICAgICAgICAvLyBCYXNpY09iamVjdCBhbmQgZnJpZW5kc1xuICAgICAgICAgIHJldHVybiAje1wiIzwje2B2YWx1ZS4kJGNsYXNzYH06MHgje3ZhbHVlLl9faWRfXy50b19zKDE2KX0+XCJ9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zcGVjdF9zdGFjay5pbmRleE9mKCN7dmFsdWUuX19pZF9ffSkgIT09IC0xKSB7XG4gICAgICAgICAgLy8gaW5zcGVjdCByZWN1cnNpbmcgaW5zaWRlIGluc3BlY3QgdG8gZmluZCBvdXQgYWJvdXQgdGhlXG4gICAgICAgICAgLy8gc2FtZSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gI3tcIiM8I3tgdmFsdWUuJCRjbGFzc2B9OjB4I3t2YWx1ZS5fX2lkX18udG9fcygxNil9PlwifVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGFueXRoaW5nIHN1cHBvcnRpbmcgT3BhbFxuICAgICAgICAgIGluc3BlY3Rfc3RhY2sucHVzaCgje3ZhbHVlLl9faWRfX30pO1xuICAgICAgICAgIHB1c2hlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLiRpbnNwZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5pbFxuICAgIHJlc2N1ZSA6OkV4Y2VwdGlvbiA9PiBlICMgcnVib2NvcDpkaXNhYmxlIExpbnQvUmVzY3VlRXhjZXB0aW9uXG4gICAgICBcIiM8I3tgdmFsdWUuJCRjbGFzc2B9OjB4I3t2YWx1ZS5fX2lkX18udG9fcygxNil9PlwiXG4gICAgZW5zdXJlXG4gICAgICBgaWYgKHB1c2hlZCkgaW5zcGVjdF9zdGFjay5wb3AoKWBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsImJyaWRnZSIsInNlbGYiLCJjb25zdHJ1Y3RvciIsImtsYXNzIiwiY29lcmNlX3RvISIsIm9iamVjdCIsInR5cGUiLCJtZXRob2QiLCJjb2VyY2VkIiwiS2VybmVsIiwicmFpc2UiLCJjb2VyY2VfdG8/IiwicmVzcG9uZF90bz8iLCJuaWw/IiwidHJ5X2NvbnZlcnQiLCJfX3NlbmRfXyIsImNvbXBhcmUiLCJhIiwiYiIsIjw9PiIsIkFyZ3VtZW50RXJyb3IiLCJjbGFzcyIsImRlc3RydWN0dXJlIiwiYXJncyIsIm9iaiIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJuYW1lIiwiT3BhbCIsIlN0cmluZyIsIk5hbWVFcnJvciIsIm5ldyIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY29uc3RfbmFtZT8iLCJjb25zdF9uYW1lIiwiY29uc3RfbmFtZSEiLCJwcmlzdGluZSIsIm93bmVyX2NsYXNzIiwi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LENBQTBCQyxLQUFLQyxRQUFBQSxDQUFBQSxDQUFPQyxNQUFBQSxDQUFNQyxFQUFORCxDQUF0QyxDQUFBLEdBQWdESDtVQURsRDtRQUFBLENBOUJFO01BQUE7TUFBQTtRQWlDQ0E7TUFqQ0QsQ0FBQTtJQUhKQSxDQUFBQSxJQUFBQTtFQXBLRnZDLEdBQU8sSUFBUEE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvYmFzZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvbWluaSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG46Ok9iamVjdC5hdXRvbG9hZCA6TWF0aCwgJ2NvcmVsaWIvbWF0aCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkNvbXBsZXgsICdjb3JlbGliL2NvbXBsZXgnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsL2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmF0aW9uYWwsICdjb3JlbGliL3JhdGlvbmFsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlN0cnVjdCwgJ2NvcmVsaWIvc3RydWN0J1xuOjpPYmplY3QuYXV0b2xvYWQgOkRpciwgJ2NvcmVsaWIvZGlyJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkZpbGUsICdjb3JlbGliL2ZpbGUnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcHJvY2Vzcy9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlByb2Nlc3MsICdjb3JlbGliL3Byb2Nlc3MnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmFuZG9tLCAnY29yZWxpYi9yYW5kb20nXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYmluZGluZydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaXJiJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIiwiYXV0b2xvYWQiXSwibWFwcGluZ3MiOiJBQUFBQSx1QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHlCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLE1BQWxCLEVBQXlCSCxjQUFqQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsU0FBbEIsRUFBNEJILGlCQUFwQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsVUFBbEIsRUFBNkJILGtCQUFyQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxRQUFsQixFQUEyQkgsZ0JBQW5CRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLEtBQWxCLEVBQXdCSCxhQUFoQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxNQUFsQixFQUF5QkgsY0FBakJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHNCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFNBQWxCLEVBQTRCSCxpQkFBcEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsUUFBbEIsRUFBMkJILGdCQUFuQkc7RUFFUkYsT0FBUUMsU0FBQUEsQ0FBU0YscUJBQVRFO0VBRVJELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixhQUFURTtBQXRCUkY7O0FBQUFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDU0NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvc2V0dXAvZnVsbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJyb3dzZXIvc2V0dXAvZnVsbCAtIGEgZnVsbCBzZXQgb2YgcmVxdWlyZXMgdG8gcHJvdmlkZSBhbGwgZmVhdHVyZXMgYXQgb25jZVxuXG5yZXF1aXJlICdwYWdnaW8nXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvc2V0dXAvbGFyZ2UnXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvYWxsJ1xuXG5yZXF1aXJlICdicm93c2VyL2RvbS9idWlsZGVyJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vbXV0YXRpb25fb2JzZXJ2ZXInXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L2N1c3RvbSdcblxucmVxdWlyZSAnYnJvd3Nlci9jYW52YXMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLFFBQVJFO0VBRUFELElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUVBRCxJQUFBQyxTQUFBQSxDQUFRRixtQkFBUkU7RUFFQUQsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLCtCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw0QkFBUkU7RUFFQUYsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0FBWkFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDU2MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vcHJvbWlzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHtQcm9taXNlfSBpcyB1c2VkIHRvIGhlbHAgc3RydWN0dXJlIGFzeW5jaHJvbm91cyBjb2RlLlxuI1xuIyBJdCBpcyBhdmFpbGFibGUgaW4gdGhlIE9wYWwgc3RhbmRhcmQgbGlicmFyeSwgYW5kIGNhbiBiZSByZXF1aXJlZCBpbiBhbnkgT3BhbFxuIyBhcHBsaWNhdGlvbjpcbiNcbiMgICAgIHJlcXVpcmUgJ3Byb21pc2UnXG4jXG4jICMjIEJhc2ljIFVzYWdlXG4jXG4jIFByb21pc2VzIGFyZSBjcmVhdGVkIGFuZCByZXR1cm5lZCBhcyBvYmplY3RzIHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCB0aGV5XG4jIHdpbGwgZXZlbnR1YWxseSBiZSByZXNvbHZlZCBvciByZWplY3RlZCwgYnV0IG5ldmVyIGJvdGguIEEge1Byb21pc2V9IGhhc1xuIyBhIHsjdGhlbn0gYW5kIHsjZmFpbH0gbWV0aG9kIChvciBvbmUgb2YgdGhlaXIgYWxpYXNlcykgdGhhdCBjYW4gYmUgdXNlZCB0b1xuIyByZWdpc3RlciBhIGJsb2NrIHRoYXQgZ2V0cyBjYWxsZWQgb25jZSByZXNvbHZlZCBvciByZWplY3RlZC5cbiNcbiMgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuI1xuIyAgICAgcHJvbWlzZS50aGVuIHtcbiMgICAgICAgcHV0cyBcInJlc29sdmVkIVwiXG4jICAgICB9LmZhaWwge1xuIyAgICAgICBwdXRzIFwicmVqZWN0ZWQhXCJcbiMgICAgIH1cbiNcbiMgICAgICMgc29tZSB0aW1lIGxhdGVyXG4jICAgICBwcm9taXNlLnJlc29sdmVcbiNcbiMgICAgICMgPT4gXCJyZXNvbHZlZCFcIlxuI1xuIyBJdCBpcyBpbXBvcnRhbnQgdG8gcmVtZW1iZXIgdGhhdCBhIHByb21pc2UgY2FuIG9ubHkgYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWRcbiMgb25jZSwgc28gdGhlIGJsb2NrIHdpbGwgb25seSBldmVyIGJlIGNhbGxlZCBvbmNlIChvciBub3QgYXQgYWxsKS5cbiNcbiMgIyMgUmVzb2x2aW5nIFByb21pc2VzXG4jXG4jIFRvIHJlc29sdmUgYSBwcm9taXNlLCBtZWFucyB0byBpbmZvcm0gdGhlIHtQcm9taXNlfSB0aGF0IGl0IGhhcyBzdWNjZWVkZWRcbiMgb3IgZXZhbHVhdGVkIHRvIGEgdXNlZnVsIHZhbHVlLiB7I3Jlc29sdmV9IGNhbiBiZSBwYXNzZWQgYSB2YWx1ZSB3aGljaCBpc1xuIyB0aGVuIHBhc3NlZCBpbnRvIHRoZSBibG9jayBoYW5kbGVyOlxuI1xuIyAgICAgZGVmIGdldF9qc29uXG4jICAgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuI1xuIyAgICAgICBIVFRQLmdldChcInNvbWVfdXJsXCIpIGRvIHxyZXF8XG4jICAgICAgICAgcHJvbWlzZS5yZXNvbHZlIHJlcS5qc29uXG4jICAgICAgIGVuZFxuI1xuIyAgICAgICBwcm9taXNlXG4jICAgICBlbmRcbiNcbiMgICAgIGdldF9qc29uLnRoZW4gZG8gfGpzb258XG4jICAgICAgIHB1dHMgXCJnb3Qgc29tZSBKU09OIGZyb20gc2VydmVyXCJcbiMgICAgIGVuZFxuI1xuIyAjIyBSZWplY3RpbmcgUHJvbWlzZXNcbiNcbiMgUHJvbWlzZXMgYXJlIGFsc28gZGVzaWduZWQgdG8gaGFuZGxlIGVycm9yIGNhc2VzLCBvciBzaXR1YXRpb25zIHdoZXJlIGFuXG4jIG91dGNvbWUgaXMgbm90IGFzIGV4cGVjdGVkLiBUYWtpbmcgdGhlIHByZXZpb3VzIGV4YW1wbGUsIHdlIGNhbiBhbHNvIHBhc3NcbiMgYSB2YWx1ZSB0byBhIHsjcmVqZWN0fSBjYWxsLCB3aGljaCBwYXNzZXMgdGhhdCBvYmplY3QgdG8gdGhlIHJlZ2lzdGVyZWRcbiMgeyNmYWlsfSBoYW5kbGVyOlxuI1xuIyAgICAgZGVmIGdldF9qc29uXG4jICAgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuI1xuIyAgICAgICBIVFRQLmdldChcInNvbWVfdXJsXCIpIGRvIHxyZXF8XG4jICAgICAgICAgaWYgcmVxLm9rP1xuIyAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlIHJlcS5qc29uXG4jICAgICAgICAgZWxzZVxuIyAgICAgICAgICAgcHJvbWlzZS5yZWplY3QgcmVxXG4jICAgICAgICAgZW5kXG4jXG4jICAgICAgIHByb21pc2VcbiMgICAgIGVuZFxuI1xuIyAgICAgZ2V0X2pzb24udGhlbiB7XG4jICAgICAgICMgLi4uXG4jICAgICB9LmZhaWwgeyB8cmVxfFxuIyAgICAgICBwdXRzIFwiaXQgd2VudCB3cm9uZzogI3tyZXEubWVzc2FnZX1cIlxuIyAgICAgfVxuI1xuIyAjIyBDaGFpbmluZyBQcm9taXNlc1xuI1xuIyBQcm9taXNlcyBiZWNvbWUgZXZlbiBtb3JlIHVzZWZ1bCB3aGVuIGNoYWluZWQgdG9nZXRoZXIuIEVhY2ggeyN0aGVufSBvclxuIyB7I2ZhaWx9IGNhbGwgcmV0dXJucyBhIG5ldyB7UHJvbWlzZX0gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2hhaW4gbW9yZSBhbmQgbW9yZVxuIyBoYW5kbGVycyB0b2dldGhlci5cbiNcbiMgICAgIHByb21pc2UudGhlbiB7IHdhaXRfZm9yX3NvbWV0aGluZyB9LnRoZW4geyBkb19zb21ldGhpbmdfZWxzZSB9XG4jXG4jIFJlamVjdGlvbnMgYXJlIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZW50aXJlIGNoYWluLCBzbyBhIFwiY2F0Y2ggYWxsXCIgaGFuZGxlclxuIyBjYW4gYmUgYXR0YWNoZWQgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbDpcbiNcbiMgICAgIHByb21pc2UudGhlbiB7IC4uLiB9LnRoZW4geyAuLi4gfS5mYWlsIHsgLi4uIH1cbiNcbiMgIyMgQ29tcG9zaW5nIFByb21pc2VzXG4jXG4jIHtQcm9taXNlLndoZW59IGNhbiBiZSB1c2VkIHRvIHdhaXQgZm9yIG1vcmUgdGhhbiBvbmUgcHJvbWlzZSB0byByZXNvbHZlIChvclxuIyByZWplY3QpLiBVc2luZyB0aGUgcHJldmlvdXMgZXhhbXBsZSwgd2UgY291bGQgcmVxdWVzdCB0d28gZGlmZmVyZW50IGpzb25cbiMgcmVxdWVzdHMgYW5kIHdhaXQgZm9yIGJvdGggdG8gZmluaXNoOlxuI1xuIyAgICAgUHJvbWlzZS53aGVuKGdldF9qc29uLCBnZXRfanNvbjIpLnRoZW4gfGZpcnN0LCBzZWNvbmR8XG4jICAgICAgIHB1dHMgXCJnb3QgdHdvIGpzb24gcGF5bG9hZHM6ICN7Zmlyc3R9LCAje3NlY29uZH1cIlxuIyAgICAgZW5kXG4jXG5jbGFzcyBQcm9taXNlXG4gIGRlZiBzZWxmLnZhbHVlKHZhbHVlKVxuICAgIG5ldy5yZXNvbHZlKHZhbHVlKVxuICBlbmRcblxuICBkZWYgc2VsZi5lcnJvcih2YWx1ZSlcbiAgICBuZXcucmVqZWN0KHZhbHVlKVxuICBlbmRcblxuICBkZWYgc2VsZi53aGVuKCpwcm9taXNlcylcbiAgICBXaGVuLm5ldyhwcm9taXNlcylcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOmVycm9yLCA6cHJldiwgOm5leHRcblxuICBkZWYgaW5pdGlhbGl6ZShhY3Rpb24gPSB7fSlcbiAgICBAYWN0aW9uID0gYWN0aW9uXG5cbiAgICBAcmVhbGl6ZWQgID0gZmFsc2VcbiAgICBAZXhjZXB0aW9uID0gZmFsc2VcbiAgICBAdmFsdWUgICAgID0gbmlsXG4gICAgQGVycm9yICAgICA9IG5pbFxuICAgIEBkZWxheWVkICAgPSBmYWxzZVxuXG4gICAgQHByZXYgPSBuaWxcbiAgICBAbmV4dCA9IFtdXG4gIGVuZFxuXG4gIGRlZiB2YWx1ZVxuICAgIGlmIFByb21pc2UgPT09IEB2YWx1ZVxuICAgICAgQHZhbHVlLnZhbHVlXG4gICAgZWxzZVxuICAgICAgQHZhbHVlXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhY3Q/XG4gICAgQGFjdGlvbi5rZXk/KDpzdWNjZXNzKSB8fCBAYWN0aW9uLmtleT8oOmFsd2F5cylcbiAgZW5kXG5cbiAgZGVmIGFjdGlvblxuICAgIEBhY3Rpb24ua2V5c1xuICBlbmRcblxuICBkZWYgZXhjZXB0aW9uP1xuICAgIEBleGNlcHRpb25cbiAgZW5kXG5cbiAgZGVmIHJlYWxpemVkP1xuICAgIEByZWFsaXplZCAhPSBmYWxzZVxuICBlbmRcblxuICBkZWYgcmVzb2x2ZWQ/XG4gICAgQHJlYWxpemVkID09IDpyZXNvbHZlXG4gIGVuZFxuXG4gIGRlZiByZWplY3RlZD9cbiAgICBAcmVhbGl6ZWQgPT0gOnJlamVjdFxuICBlbmRcblxuICBkZWYgXihwcm9taXNlKVxuICAgIHByb21pc2UgPDwgc2VsZlxuICAgIHNlbGYgPj4gcHJvbWlzZVxuXG4gICAgcHJvbWlzZVxuICBlbmRcblxuICBkZWYgPDwocHJvbWlzZSlcbiAgICBAcHJldiA9IHByb21pc2VcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmID4+KHByb21pc2UpXG4gICAgQG5leHQgPDwgcHJvbWlzZVxuXG4gICAgaWYgZXhjZXB0aW9uP1xuICAgICAgcHJvbWlzZS5yZWplY3QoQGRlbGF5ZWRbMF0pXG4gICAgZWxzaWYgcmVzb2x2ZWQ/XG4gICAgICBwcm9taXNlLnJlc29sdmUoQGRlbGF5ZWQgPyBAZGVsYXllZFswXSA6IHZhbHVlKVxuICAgIGVsc2lmIHJlamVjdGVkP1xuICAgICAgaWYgIUBhY3Rpb24ua2V5Pyg6ZmFpbHVyZSkgfHwgUHJvbWlzZSA9PT0gKEBkZWxheWVkID8gQGRlbGF5ZWRbMF0gOiBAZXJyb3IpXG4gICAgICAgIHByb21pc2UucmVqZWN0KEBkZWxheWVkID8gQGRlbGF5ZWRbMF0gOiBlcnJvcilcbiAgICAgIGVsc2lmIHByb21pc2UuYWN0aW9uLmluY2x1ZGU/KDphbHdheXMpXG4gICAgICAgIHByb21pc2UucmVqZWN0KEBkZWxheWVkID8gQGRlbGF5ZWRbMF0gOiBlcnJvcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzb2x2ZSh2YWx1ZSA9IG5pbClcbiAgICBpZiByZWFsaXplZD9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0aGUgcHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlYWxpemVkJ1xuICAgIGVuZFxuXG4gICAgaWYgUHJvbWlzZSA9PT0gdmFsdWVcbiAgICAgIHJldHVybiAodmFsdWUgPDwgQHByZXYpIF4gc2VsZlxuICAgIGVuZFxuXG4gICAgYmVnaW5cbiAgICAgIGJsb2NrID0gQGFjdGlvbls6c3VjY2Vzc10gfHwgQGFjdGlvbls6YWx3YXlzXVxuICAgICAgaWYgYmxvY2tcbiAgICAgICAgdmFsdWUgPSBibG9jay5jYWxsKHZhbHVlKVxuICAgICAgZW5kXG5cbiAgICAgIHJlc29sdmUhKHZhbHVlKVxuICAgIHJlc2N1ZSBFeGNlcHRpb24gPT4gZVxuICAgICAgZXhjZXB0aW9uIShlKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzb2x2ZSEodmFsdWUpXG4gICAgQHJlYWxpemVkID0gOnJlc29sdmVcbiAgICBAdmFsdWUgICAgPSB2YWx1ZVxuXG4gICAgaWYgQG5leHQuYW55P1xuICAgICAgQG5leHQuZWFjaCB7IHxwfCBwLnJlc29sdmUodmFsdWUpIH1cbiAgICBlbHNlXG4gICAgICBAZGVsYXllZCA9IFt2YWx1ZV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlamVjdCh2YWx1ZSA9IG5pbClcbiAgICBpZiByZWFsaXplZD9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0aGUgcHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlYWxpemVkJ1xuICAgIGVuZFxuXG4gICAgaWYgUHJvbWlzZSA9PT0gdmFsdWVcbiAgICAgIHJldHVybiAodmFsdWUgPDwgQHByZXYpIF4gc2VsZlxuICAgIGVuZFxuXG4gICAgYmVnaW5cbiAgICAgIGJsb2NrID0gQGFjdGlvbls6ZmFpbHVyZV0gfHwgQGFjdGlvbls6YWx3YXlzXVxuICAgICAgaWYgYmxvY2tcbiAgICAgICAgdmFsdWUgPSBibG9jay5jYWxsKHZhbHVlKVxuICAgICAgZW5kXG5cbiAgICAgIGlmIEBhY3Rpb24ua2V5Pyg6YWx3YXlzKVxuICAgICAgICByZXNvbHZlISh2YWx1ZSlcbiAgICAgIGVsc2VcbiAgICAgICAgcmVqZWN0ISh2YWx1ZSlcbiAgICAgIGVuZFxuICAgIHJlc2N1ZSBFeGNlcHRpb24gPT4gZVxuICAgICAgZXhjZXB0aW9uIShlKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVqZWN0ISh2YWx1ZSlcbiAgICBAcmVhbGl6ZWQgPSA6cmVqZWN0XG4gICAgQGVycm9yICAgID0gdmFsdWVcblxuICAgIGlmIEBuZXh0LmFueT9cbiAgICAgIEBuZXh0LmVhY2ggeyB8cHwgcC5yZWplY3QodmFsdWUpIH1cbiAgICBlbHNlXG4gICAgICBAZGVsYXllZCA9IFt2YWx1ZV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbiEoZXJyb3IpXG4gICAgQGV4Y2VwdGlvbiA9IHRydWVcblxuICAgIHJlamVjdCEoZXJyb3IpXG4gIGVuZFxuXG4gIGRlZiB0aGVuKCZibG9jaylcbiAgICBzZWxmIF4gUHJvbWlzZS5uZXcoc3VjY2VzczogYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0aGVuISgmYmxvY2spXG4gICAgdGhlcmVfY2FuX2JlX29ubHlfb25lIVxuICAgIHNlbGYudGhlbigmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBmYWlsKCZibG9jaylcbiAgICBzZWxmIF4gUHJvbWlzZS5uZXcoZmFpbHVyZTogYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBmYWlsISgmYmxvY2spXG4gICAgdGhlcmVfY2FuX2JlX29ubHlfb25lIVxuICAgIGZhaWwoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgYWx3YXlzKCZibG9jaylcbiAgICBzZWxmIF4gUHJvbWlzZS5uZXcoYWx3YXlzOiBibG9jaylcbiAgZW5kXG5cbiAgZGVmIGFsd2F5cyEoJmJsb2NrKVxuICAgIHRoZXJlX2Nhbl9iZV9vbmx5X29uZSFcbiAgICBhbHdheXMoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdHJhY2UoZGVwdGggPSBuaWwsICZibG9jaylcbiAgICBzZWxmIF4gVHJhY2UubmV3KGRlcHRoLCBibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRyYWNlISgqYXJncywgJmJsb2NrKVxuICAgIHRoZXJlX2Nhbl9iZV9vbmx5X29uZSFcbiAgICB0cmFjZSgqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdGhlcmVfY2FuX2JlX29ubHlfb25lIVxuICAgIGlmIEBuZXh0LmFueT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhIHByb21pc2UgaGFzIGFscmVhZHkgYmVlbiBjaGFpbmVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9KCN7b2JqZWN0X2lkfSlcIlxuXG4gICAgaWYgQG5leHQuYW55P1xuICAgICAgcmVzdWx0ICs9IFwiID4+ICN7QG5leHQuaW5zcGVjdH1cIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICs9IGlmIHJlYWxpemVkP1xuICAgICAgICAgICAgICAgIFwiOiAjeyhAdmFsdWUgfHwgQGVycm9yKS5pbnNwZWN0fT5cIlxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgJz4nXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiB0b192MlxuICAgIHYyID0gUHJvbWlzZVYyLm5ld1xuXG4gICAgc2VsZi50aGVuIHsgfGl8IHYyLnJlc29sdmUoaSkgfS5yZXNjdWUgeyB8aXwgdjIucmVqZWN0KGkpIH1cblxuICAgIHYyXG4gIGVuZFxuXG4gICMgUHJvbWlzZVYxIGlzIG5vdCBhIG5hdGl2ZSBjb25zdHJ1Y3QsIHdlIG11c3QgY29udmVydCBpdCB0byBhIHYyIHByb21pc2VcbiAgYWxpYXMgYXdhaXQgdG9fdjJcblxuICBhbGlhcyBjYXRjaCBmYWlsXG4gIGFsaWFzIGNhdGNoISBmYWlsIVxuICBhbGlhcyBkbyB0aGVuXG4gIGFsaWFzIGRvISB0aGVuIVxuICBhbGlhcyBlbnN1cmUgYWx3YXlzXG4gIGFsaWFzIGVuc3VyZSEgYWx3YXlzIVxuICBhbGlhcyBmaW5hbGx5IGFsd2F5c1xuICBhbGlhcyBmaW5hbGx5ISBhbHdheXMhXG4gIGFsaWFzIHJlc2N1ZSBmYWlsXG4gIGFsaWFzIHJlc2N1ZSEgZmFpbCFcbiAgYWxpYXMgdG9fbiB0b192MlxuICBhbGlhcyB0b192MSBpdHNlbGZcblxuICBjbGFzcyBUcmFjZSA8IHNlbGZcbiAgICBkZWYgc2VsZi5pdChwcm9taXNlKVxuICAgICAgY3VycmVudCA9IFtdXG5cbiAgICAgIGlmIHByb21pc2UuYWN0PyB8fCBwcm9taXNlLnByZXYubmlsP1xuICAgICAgICBjdXJyZW50LnB1c2gocHJvbWlzZS52YWx1ZSlcbiAgICAgIGVuZFxuXG4gICAgICBwcmV2ID0gcHJvbWlzZS5wcmV2XG4gICAgICBpZiBwcmV2XG4gICAgICAgIGN1cnJlbnQuY29uY2F0KGl0KHByZXYpKVxuICAgICAgZWxzZVxuICAgICAgICBjdXJyZW50XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKGRlcHRoLCBibG9jaylcbiAgICAgIEBkZXB0aCA9IGRlcHRoXG5cbiAgICAgIHN1cGVyIHN1Y2Nlc3M6IHByb2Mge1xuICAgICAgICB0cmFjZSA9IFRyYWNlLml0KHNlbGYpLnJldmVyc2VcbiAgICAgICAgdHJhY2UucG9wXG5cbiAgICAgICAgaWYgZGVwdGggJiYgZGVwdGggPD0gdHJhY2UubGVuZ3RoXG4gICAgICAgICAgdHJhY2Uuc2hpZnQodHJhY2UubGVuZ3RoIC0gZGVwdGgpXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGJsb2NrLmNhbGwoKnRyYWNlKVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBjbGFzcyBXaGVuIDwgc2VsZlxuICAgIGRlZiBpbml0aWFsaXplKHByb21pc2VzID0gW10pXG4gICAgICBzdXBlcigpXG5cbiAgICAgIEB3YWl0ID0gW11cblxuICAgICAgcHJvbWlzZXMuZWFjaCBkbyB8cHJvbWlzZXxcbiAgICAgICAgd2FpdCBwcm9taXNlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIHNlbGYudGhlbiBkbyB8dmFsdWVzfFxuICAgICAgICB2YWx1ZXMuZWFjaCgmYmxvY2spXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIHNlbGYudGhlbiBkbyB8dmFsdWVzfFxuICAgICAgICBXaGVuLm5ldyh2YWx1ZXMubWFwKCZibG9jaykpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBpbmplY3QoKmFyZ3MsICZibG9jaylcbiAgICAgIHNlbGYudGhlbiBkbyB8dmFsdWVzfFxuICAgICAgICB2YWx1ZXMucmVkdWNlKCphcmdzLCAmYmxvY2spXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB3YWl0KHByb21pc2UpXG4gICAgICB1bmxlc3MgUHJvbWlzZSA9PT0gcHJvbWlzZVxuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS52YWx1ZShwcm9taXNlKVxuICAgICAgZW5kXG5cbiAgICAgIGlmIHByb21pc2UuYWN0P1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuXG4gICAgICBlbmRcblxuICAgICAgQHdhaXQgPDwgcHJvbWlzZVxuXG4gICAgICBwcm9taXNlLmFsd2F5cyBkb1xuICAgICAgICB0cnkgaWYgQG5leHQuYW55P1xuICAgICAgZW5kXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiA+PigqKVxuICAgICAgc3VwZXIudGFwIGRvXG4gICAgICAgIHRyeVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdHJ5XG4gICAgICBpZiBAd2FpdC5hbGw/KCY6cmVhbGl6ZWQ/KVxuICAgICAgICBwcm9taXNlID0gQHdhaXQuZmluZCgmOnJlamVjdGVkPylcbiAgICAgICAgaWYgcHJvbWlzZVxuICAgICAgICAgIHJlamVjdChwcm9taXNlLmVycm9yKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzb2x2ZShAd2FpdC5tYXAoJjp2YWx1ZSkpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyBtYXAgY29sbGVjdFxuICAgIGFsaWFzIHJlZHVjZSBpbmplY3RcbiAgICBhbGlhcyBhbmQgd2FpdFxuICBlbmRcbmVuZFxuXG5Qcm9taXNlVjEgPSBQcm9taXNlXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQcm9taXNlPiIsInZhbHVlIiwic2VsZiIsIm5ldyIsInJlc29sdmUiLCJlcnJvciIsInJlamVjdCIsIndoZW4iLCJXaGVuIiwicHJvbWlzZXMiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJhY3Rpb24iLCJAYWN0aW9uIiwiQHJlYWxpemVkIiwiQGV4Y2VwdGlvbiIsIkB2YWx1ZSIsIkBlcnJvciIsIkBkZWxheWVkIiwiQHByZXYiLCJAbmV4dCIsIlByb21pc2UiLCJhY3Q/IiwiJHJldF9vcl8xIiwia2V5PyIsImtleXMiLCJleGNlcHRpb24/IiwicmVhbGl6ZWQ/IiwiIT0iLCJyZXNvbHZlZD8iLCI9PSIsInJlamVjdGVkPyIsIl4iLCJwcm9taXNlIiwiPDwiLCI+PiIsIltdIiwiMCIsImluY2x1ZGU/IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiYmxvY2siLCJjYWxsIiwicmVzb2x2ZSEiLCJFeGNlcHRpb24iLCJlIiwiZXhjZXB0aW9uISIsImFueT8iLCJlYWNoIiwiYmxvY2sgaW4gcmVzb2x2ZSEiLCJwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXNvbHZlISIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwidGhlbiIsInRoZW4hIiwidGhlcmVfY2FuX2JlX29ubHlfb25lISIsInRvX3Byb2MiLCJmYWlsIiwiZmFpbCEiLCJhbHdheXMiLCJhbHdheXMhIiwidHJhY2UiLCJkZXB0aCIsIlRyYWNlIiwidHJhY2UhIiwiYXJncyIsImluc3BlY3QiLCJyZXN1bHQiLCJjbGFzcyIsIm9iamVjdF9pZCIsIisiLCJ0b192MiIsInYyIiwiUHJvbWlzZVYyIiwicmVzY3VlIiwiYmxvY2sgaW4gdG9fdjIiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b192MiIsIjxjbGFzczpUcmFjZT4iLCJpdCIsImN1cnJlbnQiLCJwcmV2IiwibmlsPyIsInB1c2giLCJjb25jYXQiLCJAZGVwdGgiLCJwcm9jIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsImJsb2NrICgyIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsInJldmVyc2UiLCJwb3AiLCI8PSIsImxlbmd0aCIsInNoaWZ0IiwiLSIsIjxjbGFzczpXaGVuPiIsIkB3YWl0Iiwid2FpdCIsImJsb2NrIGluIGVhY2giLCJ2YWx1ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJjb2xsZWN0IiwiYmxvY2sgaW4gY29sbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsIm1hcCIsImluamVjdCIsImJsb2NrIGluIGluamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gaW5qZWN0IiwicmVkdWNlIiwiYmxvY2sgaW4gd2FpdCIsImJsb2NrICgyIGxldmVscykgaW4gd2FpdCIsInRyeSIsInRhcCIsImJsb2NrIGluID4+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA+PiIsImFsbD8iLCJmaW5kIl0sIm1hcHBpbmdzIjoiQUFBQUEsMEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBbUdBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFQyxNQUFJQyxJQUFKRCxZQUFBQSxpQkFBZUEsS0FBZkE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFDLElBQUFDLEtBQUFBLENBQUFBLENBQUdDLFNBQUFBLENBQVNILEtBQVRHO0lBRExILENBQUFBLEdBQUFBO0lBSUFJLE1BQUlILElBQUpHLFlBQUFBLGlCQUFlSixLQUFmSTtBQUFBQSxNQUFB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QUEsQ0FBTGdELENBQWJ0RztVQUhGO1FBRkY7VUF4Yk42RyxPQUFBO1FBd2JNO01BREZBLENBQUFBLEdBQUFBO01BV0EsYUFBTSxLQUFOLEVBQVUsU0FBVjtNQUNBLGFBQU0sUUFBTixFQUFhLFFBQWI7TUFDQWhCLE9BQUEsYUFBTSxLQUFOLEVBQVUsTUFBVjtJQXRFRkEsR0FBQUEsV0FBQUEsRUFBYS9GLElBQWIrRjtFQTNSRmpHLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBcVdBRCxPQUFBLHFDQUFZc0IsYUFBWjtBQXhjQXRCOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTA4MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vbmF0aXZlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgUHJvdmlkZXMgYSBjb21wbGV0ZSBzZXQgb2YgdG9vbHMgdG8gd3JhcCBuYXRpdmUgSmF2YVNjcmlwdFxuIyBpbnRvIG5pY2UgUnVieSBvYmplY3RzLlxuI1xuIyBAZXhhbXBsZVxuI1xuIyAgICQkLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3AnKS5jbGFzc0xpc3QuYWRkKCdibHVlJylcbiMgICAjID0+IGFkZHMgXCJibHVlXCIgY2xhc3MgdG8gPHA+XG4jXG4jICAgJCQubG9jYXRpb24uaHJlZiA9ICdodHRwczovL2dvb2dsZS5jb20nXG4jICAgIyA9PiBjaGFuZ2VzIHBhZ2UgbG9jYXRpb25cbiNcbiMgICBkb19sYXRlciA9ICQkWzpzZXRUaW1lb3V0XSAjIEFjY2Vzc2luZyB0aGUgXCJzZXRUaW1lb3V0XCIgcHJvcGVydHlcbiMgICBkb19sYXRlci5jYWxsKC0+eyBwdXRzIDpoZWxsb30sIDUwMClcbiNcbiMgYCQkYCBhbmQgYCRnbG9iYWxgIHdyYXAgYE9wYWwuZ2xvYmFsYCwgd2hpY2ggdGhlIE9wYWwgSlMgcnVudGltZVxuIyBzZXRzIHRvIHRoZSBnbG9iYWwgYHRoaXNgIG9iamVjdC5cbiNcbm1vZHVsZSBOYXRpdmVcbiAgZGVmIHNlbGYuaXNfYT8ob2JqZWN0LCBrbGFzcylcbiAgICAleHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAje29iamVjdH0gaW5zdGFuY2VvZiAje3RyeV9jb252ZXJ0KGtsYXNzKX07XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydCh2YWx1ZSwgZGVmYXVsdCA9IG5pbClcbiAgICAleHtcbiAgICAgIGlmICgje25hdGl2ZT8odmFsdWUpfSkge1xuICAgICAgICByZXR1cm4gI3t2YWx1ZX07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/IDp0b19ufSkge1xuICAgICAgICByZXR1cm4gI3t2YWx1ZS50b19ufTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tkZWZhdWx0fTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnZlcnQodmFsdWUpXG4gICAgJXh7XG4gICAgICBpZiAoI3tuYXRpdmU/KHZhbHVlKX0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWV9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fbn0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWUudG9fbn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7dmFsdWUuaW5zcGVjdH0gaXNuJ3QgbmF0aXZlXCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2FsbChvYmosIGtleSwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBwcm9wID0gI3tvYmp9WyN7a2V5fV07XG5cbiAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlZCA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gYXJnc1tpXSxcbiAgICAgICAgICAgICAgY29udiA9ICN7dHJ5X2NvbnZlcnQoYGl0ZW1gKX07XG5cbiAgICAgICAgICBjb252ZXJ0ZWRbaV0gPSBjb252ID09PSBuaWwgPyBpdGVtIDogY29udjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgY29udmVydGVkLnB1c2goYmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBwcm9wLmFwcGx5KCN7b2JqfSwgY29udmVydGVkKWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tOYXRpdmUoYHByb3BgKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5wcm9jKCZibG9jaylcbiAgICByYWlzZSBMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgIDo6S2VybmVsLnByb2MgeyB8KmFyZ3N8XG4gICAgICBhcmdzLm1hcCEgeyB8YXJnfCBOYXRpdmUoYXJnKSB9XG4gICAgICBpbnN0YW5jZSA9IE5hdGl2ZShgdGhpc2ApXG5cbiAgICAgICV4e1xuICAgICAgICAvLyBpZiBnbG9iYWwgaXMgY3VycmVudCBzY29wZSwgcnVuIHRoZSBibG9jayBpbiB0aGUgc2NvcGUgaXQgd2FzIGRlZmluZWRcbiAgICAgICAgaWYgKHRoaXMgPT09IE9wYWwuZ2xvYmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KHNlbGYsICN7YXJnc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGZfID0gYmxvY2suJCRzO1xuICAgICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KCN7aW5zdGFuY2V9LCAje2FyZ3N9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBibG9jay4kJHMgPSBzZWxmXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIEhlbHBlcnNcbiAgICAjIEV4cG9zZXMgYSBuYXRpdmUgSmF2YVNjcmlwdCBtZXRob2QgdG8gUnVieVxuICAgICNcbiAgICAjXG4gICAgIyBAcGFyYW0gbmV3IFtTdHJpbmddXG4gICAgIyAgICAgICBUaGUgbmFtZSBvZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXRob2QuXG4gICAgI1xuICAgICMgQHBhcmFtIG9sZCBbU3RyaW5nXVxuICAgICMgICAgICAgVGhlIG5hbWUgb2YgdGhlIG5hdGl2ZSBKYXZhU2NyaXB0IG1ldGhvZCB0byBiZSBleHBvc2VkLlxuICAgICMgICAgICAgSWYgdGhlIG5hbWUgZW5kcyB3aXRoIFwiPVwiIChlLmcuIGBmb289YCkgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhc1xuICAgICMgICAgICAgYSBwcm9wZXJ0eSBzZXR0ZXIuIChkZWZhdWx0OiB0aGUgdmFsdWUgb2YgXCJuZXdcIilcbiAgICAjXG4gICAgIyBAcGFyYW0gYXMgW0NsYXNzXVxuICAgICMgICAgICAgSWYgcHJvdmlkZWQgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgb3JpZ2luYWwgbWV0aG9kIHdpbGwgYmVcbiAgICAjICAgICAgIHJldHVybmVkIGFzIGluc3RhbmNlcyBvZiB0aGUgcGFzc2VkIGNsYXNzLiBUaGUgY2xhc3MgcGFzc2VkIHRvIFwiYXNcIlxuICAgICMgICAgICAgaXMgZXhwZWN0ZWQgdG8gYWNjZXB0IGEgbmF0aXZlIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgI1xuICAgICMgQGV4YW1wbGVcbiAgICAjXG4gICAgIyAgIGNsYXNzIEVsZW1lbnRcbiAgICAjICAgICBleHRlbmQgTmF0aXZlOjpIZWxwZXJzXG4gICAgI1xuICAgICMgICAgIGFsaWFzX25hdGl2ZSA6YWRkX2NsYXNzLCA6YWRkQ2xhc3NcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOnNob3dcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOmhpZGVcbiAgICAjXG4gICAgIyAgICAgZGVmIGluaXRpYWxpemUoc2VsZWN0b3IpXG4gICAgIyAgICAgICBAbmF0aXZlID0gYCQoI3tzZWxlY3Rvcn0pYFxuICAgICMgICAgIGVuZFxuICAgICMgICBlbmRcbiAgICAjXG4gICAgIyAgIHRpdGxlcyA9IEVsZW1lbnQubmV3KCdoMScpXG4gICAgIyAgIHRpdGxlcy5hZGRfY2xhc3MgOmZvb1xuICAgICMgICB0aXRsZXMuaGlkZVxuICAgICMgICB0aXRsZXMuc2hvd1xuICAgICNcbiAgICBkZWYgYWxpYXNfbmF0aXZlKG5ldywgb2xkID0gbmV3LCBhczogbmlsKVxuICAgICAgaWYgb2xkLmVuZF93aXRoPyAnPSdcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfHZhbHVlfFxuICAgICAgICAgIGAje0BuYXRpdmV9WyN7b2xkWzAuLi0yXX1dID0gI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9YFxuXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBhc1xuICAgICAgICBkZWZpbmVfbWV0aG9kIG5ldyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICAgICB2YWx1ZSA9IE5hdGl2ZS5jYWxsKEBuYXRpdmUsIG9sZCwgKmFyZ3MsICZibG9jaylcbiAgICAgICAgICBpZiB2YWx1ZVxuICAgICAgICAgICAgYXMubmV3KHZhbHVlLnRvX24pXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBkZWZpbmVfbWV0aG9kIG5ldyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICAgICBOYXRpdmUuY2FsbChAbmF0aXZlLCBvbGQsICphcmdzLCAmYmxvY2spXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbmF0aXZlX3JlYWRlcigqbmFtZXMpXG4gICAgICBuYW1lcy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG9cbiAgICAgICAgICBOYXRpdmUoYCN7QG5hdGl2ZX1bbmFtZV1gKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIG5hdGl2ZV93cml0ZXIoKm5hbWVzKVxuICAgICAgbmFtZXMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgICAgIE5hdGl2ZShgI3tAbmF0aXZlfVtuYW1lXSA9IHZhbHVlYClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBuYXRpdmVfYWNjZXNzb3IoKm5hbWVzKVxuICAgICAgbmF0aXZlX3JlYWRlcigqbmFtZXMpXG4gICAgICBuYXRpdmVfd3JpdGVyKCpuYW1lcylcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIFdyYXBwZXJcbiAgICBkZWYgaW5pdGlhbGl6ZShuYXRpdmUpXG4gICAgICB1bmxlc3MgOjpLZXJuZWwubmF0aXZlPyhuYXRpdmUpXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tuYXRpdmUuaW5zcGVjdH0gaXNuJ3QgbmF0aXZlXCJcbiAgICAgIGVuZFxuXG4gICAgICBAbmF0aXZlID0gbmF0aXZlXG4gICAgZW5kXG5cbiAgICAjIFJldHVybnMgdGhlIGludGVybmFsIG5hdGl2ZSBKYXZhU2NyaXB0IHZhbHVlXG4gICAgZGVmIHRvX25cbiAgICAgIEBuYXRpdmVcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmluY2x1ZGVkKGtsYXNzKVxuICAgICAga2xhc3MuZXh0ZW5kIEhlbHBlcnNcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5jbHVkZWQoYmFzZSlcbiAgICB3YXJuICdJbmNsdWRpbmcgOjpOYXRpdmUgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyIGluc3RlYWQuJ1xuICAgIGJhc2UuaW5jbHVkZSBXcmFwcGVyXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIG5hdGl2ZT8odmFsdWUpXG4gICAgYHZhbHVlID09IG51bGwgfHwgIXZhbHVlLiQkY2xhc3NgXG4gIGVuZFxuXG4gICMgV3JhcHMgYSBuYXRpdmUgSmF2YVNjcmlwdCB3aXRoIGBOYXRpdmU6Ok9iamVjdC5uZXdgXG4gICNcbiAgIyBAcmV0dXJuIFtOYXRpdmU6Ok9iamVjdF0gVGhlIHdyYXBwZWQgb2JqZWN0IGlmIGl0IGlzIG5hdGl2ZVxuICAjIEByZXR1cm4gW25pbF0gZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgIyBAcmV0dXJuIFtvYmpdIFRoZSBvYmplY3QgaXRzZWxmIGlmIGl0J3Mgbm90IG5hdGl2ZVxuICBkZWYgTmF0aXZlKG9iailcbiAgICBpZiBgI3tvYmp9ID09IG51bGxgXG4gICAgICBuaWxcbiAgICBlbHNpZiBuYXRpdmU/KG9iailcbiAgICAgIE5hdGl2ZTo6T2JqZWN0Lm5ldyhvYmopXG4gICAgZWxzaWYgb2JqLmlzX2E/KEFycmF5KVxuICAgICAgb2JqLm1hcCBkbyB8b3xcbiAgICAgICAgTmF0aXZlKG8pXG4gICAgICBlbmRcbiAgICBlbHNpZiBvYmouaXNfYT8oUHJvYylcbiAgICAgIHByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgIE5hdGl2ZShvYmouY2FsbCgqYXJncywgJmJsb2NrKSlcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIG9ialxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBfQXJyYXkgQXJyYXlcblxuICAjIFdyYXBzIGFycmF5LWxpa2UgSmF2YVNjcmlwdCBvYmplY3RzIGluIE5hdGl2ZTo6QXJyYXlcbiAgZGVmIEFycmF5KG9iamVjdCwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBuYXRpdmU/KG9iamVjdClcbiAgICAgIHJldHVybiBOYXRpdmU6OkFycmF5Lm5ldyhvYmplY3QsICphcmdzLCAmYmxvY2spLnRvX2FcbiAgICBlbmRcbiAgICBfQXJyYXkob2JqZWN0KVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOYXRpdmU6Ok9iamVjdCA8IEJhc2ljT2JqZWN0XG4gIGluY2x1ZGUgOjpOYXRpdmU6OldyYXBwZXJcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYCN7QG5hdGl2ZX0gPT09ICN7OjpOYXRpdmUudHJ5X2NvbnZlcnQob3RoZXIpfWBcbiAgZW5kXG5cbiAgZGVmIGhhc19rZXk/KG5hbWUpXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbCgje0BuYXRpdmV9LCAje25hbWV9KWBcbiAgZW5kXG5cbiAgZGVmIGVhY2goKmFyZ3MpXG4gICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluICN7QG5hdGl2ZX0pIHtcbiAgICAgICAgICAje3lpZWxkIGBrZXlgLCBgI3tAbmF0aXZlfVtrZXldYH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmXG4gICAgZWxzZVxuICAgICAgbWV0aG9kX21pc3NpbmcoOmVhY2gsICphcmdzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW10oa2V5KVxuICAgICV4e1xuICAgICAgdmFyIHByb3AgPSAje0BuYXRpdmV9W2tleV07XG5cbiAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7OjpOYXRpdmUuY2FsbChAbmF0aXZlLCBrZXkpfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShrZXksIHZhbHVlKVxuICAgIG5hdGl2ZSA9IDo6TmF0aXZlLnRyeV9jb252ZXJ0KHZhbHVlKVxuXG4gICAgaWYgYCN7bmF0aXZlfSA9PT0gbmlsYFxuICAgICAgYCN7QG5hdGl2ZX1ba2V5XSA9ICN7dmFsdWV9YFxuICAgIGVsc2VcbiAgICAgIGAje0BuYXRpdmV9W2tleV0gPSAje25hdGl2ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSEob3RoZXIpXG4gICAgJXh7XG4gICAgICBvdGhlciA9ICN7OjpOYXRpdmUuY29udmVydChvdGhlcil9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICAgICN7QG5hdGl2ZX1bcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvPyhuYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIDo6S2VybmVsLmluc3RhbmNlX21ldGhvZCg6cmVzcG9uZF90bz8pLmJpbmQoc2VsZikuY2FsbChuYW1lLCBpbmNsdWRlX2FsbClcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBgT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKCN7QG5hdGl2ZX0sICN7bmFtZX0pYFxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcobWlkLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKG1pZC5jaGFyQXQobWlkLmxlbmd0aCAtIDEpID09PSAnPScpIHtcbiAgICAgICAgcmV0dXJuICN7c2VsZlttaWQuc2xpY2UoMCwgbWlkLmxlbmd0aCAtIDEpXSA9IGFyZ3NbMF19O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjezo6TmF0aXZlLmNhbGwoQG5hdGl2ZSwgbWlkLCAqYXJncywgJmJsb2NrKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICBgT3BhbC5pc19hKHNlbGYsIGtsYXNzKWBcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICBgc2VsZi4kJGNsYXNzID09PSBrbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIHRvX2Eob3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgOjpOYXRpdmU6OkFycmF5Lm5ldyhAbmF0aXZlLCBvcHRpb25zLCAmYmxvY2spLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8TmF0aXZlOiN7YFN0cmluZygje0BuYXRpdmV9KWB9PlwiXG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGhhc19rZXk/XG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuZW5kXG5cbmNsYXNzIE5hdGl2ZTo6QXJyYXlcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIGluaXRpYWxpemUobmF0aXZlLCBvcHRpb25zID0ge30sICZibG9jaylcbiAgICBzdXBlcihuYXRpdmUpXG5cbiAgICBAZ2V0ICAgID0gb3B0aW9uc1s6Z2V0XSB8fCBvcHRpb25zWzphY2Nlc3NdXG4gICAgQG5hbWVkICA9IG9wdGlvbnNbOm5hbWVkXVxuICAgIEBzZXQgICAgPSBvcHRpb25zWzpzZXRdIHx8IG9wdGlvbnNbOmFjY2Vzc11cbiAgICBAbGVuZ3RoID0gb3B0aW9uc1s6bGVuZ3RoXSB8fCA6bGVuZ3RoXG4gICAgQGJsb2NrICA9IGJsb2NrXG5cbiAgICBpZiBgI3tsZW5ndGh9ID09IG51bGxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gbGVuZ3RoIGZvdW5kIG9uIHRoZSBhcnJheS1saWtlIG9iamVjdCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICN7bGVuZ3RofTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCAje3NlbGZbYGlgXX0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4KVxuICAgIHJlc3VsdCA9IGNhc2UgaW5kZXhcbiAgICAgICAgICAgICB3aGVuIFN0cmluZywgU3ltYm9sXG4gICAgICAgICAgICAgICBAbmFtZWQgPyBgI3tAbmF0aXZlfVsje0BuYW1lZH1dKCN7aW5kZXh9KWAgOiBgI3tAbmF0aXZlfVsje2luZGV4fV1gXG4gICAgICAgICAgICAgd2hlbiBJbnRlZ2VyXG4gICAgICAgICAgICAgICBAZ2V0ID8gYCN7QG5hdGl2ZX1bI3tAZ2V0fV0oI3tpbmRleH0pYCA6IGAje0BuYXRpdmV9WyN7aW5kZXh9XWBcbiAgICAgICAgICAgICBlbmRcblxuICAgIGlmIHJlc3VsdFxuICAgICAgaWYgQGJsb2NrXG4gICAgICAgIEBibG9jay5jYWxsKHJlc3VsdClcbiAgICAgIGVsc2VcbiAgICAgICAgTmF0aXZlKHJlc3VsdClcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSlcbiAgICBpZiBAc2V0XG4gICAgICBgI3tAbmF0aXZlfVsje0BzZXR9XSgje2luZGV4fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVsje2luZGV4fV0gPSAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gbmlsKVxuICAgIGlmIGNvdW50XG4gICAgICBpbmRleCAgPSBsZW5ndGggLSAxXG4gICAgICByZXN1bHQgPSBbXVxuXG4gICAgICB3aGlsZSBpbmRleCA+PSAwXG4gICAgICAgIHJlc3VsdCA8PCBzZWxmW2luZGV4XVxuICAgICAgICBpbmRleCAgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVsc2VcbiAgICAgIHNlbGZbbGVuZ3RoIC0gMV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BuYXRpdmV9WyN7QGxlbmd0aH1dYFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHRvX2EuaW5zcGVjdFxuICBlbmRcblxuICBhbGlhcyB0b19hcnkgdG9fYVxuZW5kXG5cbmNsYXNzIE51bWVyaWNcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBQcm9jXG4gICMgQHJldHVybiBpdHNlbGYgKGFuIGluc3RhbmNlIG9mIGBGdW5jdGlvbmApXG4gIGRlZiB0b19uXG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBSZWdleHBcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgIyBAcmV0dXJuIHRoZSBhcnJheSBvZiBtYXRjaGVzXG4gIGRlZiB0b19uXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RydWN0XG4gICMgQHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhlIG1lbWJlcnMgYXMga2V5cyBhbmQgdGhlaXJcbiAgIyB2YWx1ZXMgYXMgdmFsdWVzLlxuICBkZWYgdG9fblxuICAgIHJlc3VsdCA9IGB7fWBcblxuICAgIGVhY2hfcGFpciBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICBgI3tyZXN1bHR9WyN7bmFtZX1dID0gI3tOYXRpdmUudHJ5X2NvbnZlcnQodmFsdWUsIHZhbHVlKX1gXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgIyBSZXR1bnMgYSBjb3B5IG9mIGl0c2VsZiB0cnlpbmcgdG8gY2FsbCAjdG9fbiBvbiBlYWNoIG1lbWJlci5cbiAgZGVmIHRvX25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHNlbGZbaV07XG5cbiAgICAgICAgcmVzdWx0LnB1c2goI3tOYXRpdmUudHJ5X2NvbnZlcnQoYG9iamAsIGBvYmpgKX0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgQm9vbGVhblxuICAjIEByZXR1cm4gdGhlIGludGVybmFsIEphdmFTY3JpcHQgdmFsdWUgKHdpdGggYHZhbHVlT2ZgKS5cbiAgZGVmIHRvX25cbiAgICBgc2VsZi52YWx1ZU9mKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFRpbWVcbiAgIyBAcmV0dXJuIGl0c2VsZiAoYW4gaW5zdGFuY2Ugb2YgYERhdGVgKS5cbiAgZGVmIHRvX25cbiAgICBzZWxmXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gICMgQHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBKYXZhU2NyaXB0IHZhbHVlIChgbnVsbGApLlxuICBkZWYgdG9fblxuICAgIGBudWxsYFxuICBlbmRcbmVuZFxuXG4jIFJ1bm5pbmcgdGhpcyBjb2RlIHR3aWNlIHJlc3VsdHMgaW4gYW4gaW5maW5pdGUgbG9vcC4gV2hpbGUgaXQncyB0cnVlXG4jIHRoYXQgd2Ugc2hvdWxkbid0IHJ1biB0aGlzIGZpbGUgdHdpY2UsIHRoZXJlIGFyZSBjZXJ0YWluIGNhc2VzLCBsaWtlXG4jIGZvciBleGFtcGxlIGxpdmUgcmVsb2FkLCB3aGVuIHRoaXMgbWF5IGhhcHBlbi5cbnVubGVzcyBIYXNoLm1ldGhvZF9kZWZpbmVkPyA6X2luaXRpYWxpemVcbiAgY2xhc3MgSGFzaFxuICAgIGFsaWFzIF9pbml0aWFsaXplIGluaXRpYWxpemVcblxuICAgIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgICAleHtcbiAgICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwgJiZcbiAgICAgICAgICAgICAoZGVmYXVsdHMuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgZGVmYXVsdHMuY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgc21hcCA9IHNlbGYuJCRzbWFwLFxuICAgICAgICAgICAgICBrZXlzID0gc2VsZi4kJGtleXMsXG4gICAgICAgICAgICAgIGtleSwgdmFsdWU7XG5cbiAgICAgICAgICBmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0c1trZXldO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgKHZhbHVlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICAgICAgICBzbWFwW2tleV0gPSAje0hhc2gubmV3KGB2YWx1ZWApfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgIChpdGVtLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICN7SGFzaC5uZXcoYGl0ZW1gKX07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBpdGVtYCl9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc21hcFtrZXldID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNtYXBba2V5XSA9ICN7TmF0aXZlKGB2YWx1ZWApfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI3tfaW5pdGlhbGl6ZShkZWZhdWx0cywgJmJsb2NrKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICAjIEByZXR1cm4gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYnV0IGNhbGxpbmcgI3RvX24gb25cbiAgICAjIGFsbCB2YWx1ZXMuXG4gICAgZGVmIHRvX25cbiAgICAgICV4e1xuICAgICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICBrZXlzID0gc2VsZi4kJGtleXMsXG4gICAgICAgICAgICBzbWFwID0gc2VsZi4kJHNtYXAsXG4gICAgICAgICAgICBrZXksIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0W2tleV0gPSAje05hdGl2ZS50cnlfY29udmVydChgdmFsdWVgLCBgdmFsdWVgKX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgIyBFeHBvc2VzIHRoZSBjdXJyZW50IG1vZHVsZSBhcyBhIHByb3BlcnR5IG9mXG4gICMgdGhlIGdsb2JhbCBvYmplY3QgKGUuZy4gYHdpbmRvd2ApLlxuICBkZWYgbmF0aXZlX21vZHVsZVxuICAgIGBPcGFsLmdsb2JhbFsje25hbWV9XSA9ICN7c2VsZn1gXG4gIGVuZFxuZW5kXG5cbmNsYXNzIENsYXNzXG4gIGRlZiBuYXRpdmVfYWxpYXMobmV3X2pzaWQsIGV4aXN0aW5nX21pZClcbiAgICAleHtcbiAgICAgIHZhciBhbGlhc2VkID0gI3tzZWxmfS5wcm90b3R5cGVbJyQnICsgI3tleGlzdGluZ19taWR9XTtcbiAgICAgIGlmICghYWxpYXNlZCkge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje2V4aXN0aW5nX21pZH0nIGZvciBjbGFzcyBgI3tpbnNwZWN0fSdcIiwgZXhpc3RpbmdfbWlkKX07XG4gICAgICB9XG4gICAgICAje3NlbGZ9LnByb3RvdHlwZVsje25ld19qc2lkfV0gPSBhbGlhc2VkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hdGl2ZV9jbGFzc1xuICAgIG5hdGl2ZV9tb2R1bGVcbiAgICBgc2VsZltcIm5ld1wiXSA9IHNlbGYuJG5ld2BcbiAgZW5kXG5lbmRcblxuIyBFeHBvc2VzIHRoZSBnbG9iYWwgdmFsdWUgKHdvdWxkIGJlIGB3aW5kb3dgIGluc2lkZSBhIGJyb3dzZXIpXG4kJCA9ICRnbG9iYWwgPSBOYXRpdmUoYE9wYWwuZ2xvYmFsYClcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpOYXRpdmU+IiwiaXNfYT8iLCJzZWxmIiwib2JqZWN0Iiwia2xhc3MiLCJ0cnlfY29udmVydCIsInZhbHVlIiwiZGVmYXVsdCQiLCJuYXRpdmU/IiwicmVzcG9uZF90bz8iLCJ0b19uIiwiY29udmVydCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluc3BlY3QiLCJjYWxsIiwib2JqIiwia2V5IiwiTmF0aXZlIiwicHJvYyIsImJsb2NrIiwiTG9jYWxKdW1wRXJyb3IiLCJLZXJuZWwiLCJibG9jayBpbiBwcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcm9jIiwibWFwISIsImFyZ3MiLCJhcmciLCJibG9jayAoMyBsZXZlbHMpIGluIHByb2MiLCJpbnN0YW5jZSIsIjxtb2R1bGU6SGVscGVycz4iLCJhbGlhc19uYXRpdmUiLCJuZXckIiwib2xkIiwiZW5kX3dpdGg/IiwiZGVmaW5lX21ldGhvZCIsImJsb2NrIGluIGFsaWFzX25hdGl2ZSIsImJsb2NrICgyIGxldmVscykgaW4gYWxpYXNfbmF0aXZlIiwiQG5hdGl2ZSIsIltdIiwiMCIsIi0yIiwiYXMiLCJ0b19wcm9jIiwibmV3IiwibmF0aXZlX3JlYWRlciIsImVhY2giLCJuYW1lcyIsImJsb2NrIGluIG5hdGl2ZV9yZWFkZXIiLCJuYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuYXRpdmVfcmVhZGVyIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuYXRpdmVfcmVhZGVyIiwibmF0aXZlX3dyaXRlciIsImJsb2NrIGluIG5hdGl2ZV93cml0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIG5hdGl2ZV93cml0ZXIiLCJibG9jayAoMyBsZXZlbHMpIGluIG5hdGl2ZV93cml0ZXIiLCJuYXRpdmVfYWNjZXNzb3IiLCI8bW9kdWxlOldyYXBwZXI+IiwiaW5pdGlhbGl6ZSIsIm5hdGl2ZSQiLCJpbmNsdWRlZCIsImV4dGVuZCIsIkhlbHBlcnMiLCJiYXNlIiwid2FybiIsImluY2x1ZGUiLCJXcmFwcGVyIiwiPG1vZHVsZTpLZXJuZWw+IiwiTmF0aXZlOjpPYmplY3QiLCJBcnJheSIsIm1hcCIsImJsb2NrIGluIE5hdGl2ZSIsIm8iLCJibG9jayAoMiBsZXZlbHMpIGluIE5hdGl2ZSIsIlByb2MiLCJOYXRpdmU6OkFycmF5IiwidG9fYSIsIl9BcnJheSIsIjxjbGFzczpOYXRpdmU6Ok9iamVjdD4iLCJOYXRpdmU6OldyYXBwZXIiLCI9PSIsIm90aGVyIiwiaGFzX2tleT8iLCJibG9ja19naXZlbj8iLCJtZXRob2RfbWlzc2luZyIsIltdPSIsIm1lcmdlISIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfbWV0aG9kIiwiYmluZCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtaWQiLCJzbGljZSIsIi0iLCJsZW5ndGgiLCIxIiwibmlsPyIsImluc3RhbmNlX29mPyIsImNsYXNzIiwib3B0aW9ucyIsIkJhc2ljT2JqZWN0IiwiPGNsYXNzOk5hdGl2ZTo6QXJyYXk+IiwiRW51bWVyYWJsZSIsIkBnZXQiLCIkcmV0X29yXzEiLCJAbmFtZWQiLCJAc2V0IiwiQGxlbmd0aCIsIkBibG9jayIsImVudW1fZm9yIiwiaW5kZXgiLCJyZXN1bHQiLCJTdHJpbmciLCJTeW1ib2wiLCJJbnRlZ2VyIiwibGFzdCIsImNvdW50IiwiPj0iLCI8PCIsIjxjbGFzczpOdW1lcmljPiIsIjxjbGFzczpQcm9jPiIsIjxjbGFzczpTdHJpbmc+IiwiPGNsYXNzOlJlZ2V4cD4iLCI8Y2xhc3M6TWF0Y2hEYXRhPiIsIjxjbGFzczpTdHJ1Y3Q+IiwiZWFjaF9wYWlyIiwiYmxvY2sgaW4gdG9fbiIsImJsb2NrICgyIGxldmVscykgaW4gdG9fbiIsIjxjbGFzczpBcnJheT4iLCI8Y2xhc3M6Qm9vbGVhbj4iLCI8Y2xhc3M6VGltZT4iLCI8Y2xhc3M6TmlsQ2xhc3M+IiwiSGFzaCIsIm1ldGhvZF9kZWZpbmVkPyIsIjxjbGFzczpIYXNoPiIsImRlZmF1bHRzIiwiX2luaXRpYWxpemUiLCI8Y2xhc3M6TW9kdWxlPiIsIm5hdGl2ZV9tb2R1bGUiLCI8Y2xhc3M6Q2xhc3M+IiwibmF0aXZlX2FsaWFzIiwibmV3X2pzaWQiLCJleGlzdGluZ19taWQiLCJOYW1lRXJyb3IiLCJuYXRpdmVfY2xhc3MiLCIkJCIsIiRnbG9iYWwiXSwibWFwcGluZ3MiOiJBQUFBQSx5QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFpQkFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDLE1BQUlDLElBQUpELFlBQUFBLDZCQUFlRSxNQUFELEVBQVNDLEtBQXZCSDtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBLGVBQWlCRSxNQUFPRixZQUFjQyxJQUFBRyxhQUFBQSxDQUFZRCxLQUFaQyxDQUFtQko7QUFDekRBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBUkVBLENBQUFBLEdBQUFBO0lBV0FJLE1BQUlILElBQUpHLGtCQUFBQSx1QkFBcUJDLEtBQUQsRUFBUUMsUUFBNUJGO0FBQUFBLE1BQUFBOzs7TUFBNEIsaUNBQVU7O0FBRXhDQSxVQUFZSCxJQUFBTSxZQUFBQSxDQUFRRixLQUFSRSxDQUFlSDtBQUMzQkEsZUFBaUJDLEtBQU1EO0FBQ3ZCQTtBQUNBQSxlQUFpQkMsS0FBS0csZ0JBQUFBLENBQWEsTUFBYkEsQ0FBbUJKO0FBQ3pDQSxlQUFpQkMsS0FBS0ksTUFBQUEsQ0FBQUEsQ0FBTUw7QUFDNUJBO0FBQ0FBO0FBQ0FBLGVBQWlCRSxRQUFRRjtBQUN6QkE7QUFDQUE7SUFYRUEsQ0FBQUEsSUFBQUE7SUFjQU0sTUFBSVQsSUFBSlMsY0FBQUEsbUJBQWlCTCxLQUFqQks7QUFBQUEsTUFBQUE7OztBQUVGQSxVQUFZVCxJQUFBTSxZQUFBQSxDQUFRRixLQUFSRSxDQUFlRztBQUMzQkEsZUFBaUJMLEtBQU1LO0FBQ3ZCQTtBQUNBQSxlQUFpQkwsS0FBS0csZ0JBQUFBLENBQWEsTUFBYkEsQ0FBbUJFO0FBQ3pDQSxlQUFpQkwsS0FBS0ksTUFBQUEsQ0FBQUEsQ0FBTUM7QUFDNUJBO0FBQ0FBO0FBQ0FBLFFBQVVULElBQUFVLE9BQUFBLENBQU1DLG1CQUFOLEVBQXFCLEVBQUEsR0FBQSxDQUFH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QUEsV0FBS0MsQ0FBQUEsZ0JBQVVoSixJQUFBZ0IsUUFBQUEsQ0FBUW5CLFdBQVJtQixDQUFWZ0ksQ0FBTEQ7QUF4bkJBbEo7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1ODc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvYmFzZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvbWluaSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG46Ok9iamVjdC5hdXRvbG9hZCA6TWF0aCwgJ2NvcmVsaWIvbWF0aCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkNvbXBsZXgsICdjb3JlbGliL2NvbXBsZXgnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsL2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmF0aW9uYWwsICdjb3JlbGliL3JhdGlvbmFsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlN0cnVjdCwgJ2NvcmVsaWIvc3RydWN0J1xuOjpPYmplY3QuYXV0b2xvYWQgOkRpciwgJ2NvcmVsaWIvZGlyJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkZpbGUsICdjb3JlbGliL2ZpbGUnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcHJvY2Vzcy9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlByb2Nlc3MsICdjb3JlbGliL3Byb2Nlc3MnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmFuZG9tLCAnY29yZWxpYi9yYW5kb20nXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYmluZGluZydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaXJiJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIiwiYXV0b2xvYWQiXSwibWFwcGluZ3MiOiJBQUFBQSx1QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHlCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLE1BQWxCLEVBQXlCSCxjQUFqQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsU0FBbEIsRUFBNEJILGlCQUFwQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsVUFBbEIsRUFBNkJILGtCQUFyQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxRQUFsQixFQUEyQkgsZ0JBQW5CRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLEtBQWxCLEVBQXdCSCxhQUFoQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxNQUFsQixFQUF5QkgsY0FBakJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHNCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFNBQWxCLEVBQTRCSCxpQkFBcEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsUUFBbEIsRUFBMkJILGdCQUFuQkc7RUFFUkYsT0FBUUMsU0FBQUEsQ0FBU0YscUJBQVRFO0VBRVJELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixhQUFURTtBQXRCUkY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1OTA0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jYW52YXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9jYW52YXMvc3R5bGUnXG5yZXF1aXJlICdicm93c2VyL2NhbnZhcy90ZXh0J1xucmVxdWlyZSAnYnJvd3Nlci9jYW52YXMvZGF0YSdcbnJlcXVpcmUgJ2Jyb3dzZXIvY2FudmFzL2dyYWRpZW50J1xuXG5tb2R1bGUgQnJvd3NlclxuXG5jbGFzcyBDYW52YXNcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICBhdHRyX3JlYWRlciA6ZWxlbWVudCwgOnN0eWxlLCA6dGV4dFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgIGlmIERPTTo6RWxlbWVudCA9PT0gYXJncy5maXJzdFxuICAgICAgZWxlbWVudCA9IGFyZ3Muc2hpZnRcblxuICAgICAgaWYgRE9NOjpFbGVtZW50OjpJbWFnZSA9PT0gZWxlbWVudFxuICAgICAgICBAaW1hZ2UgICA9IGVsZW1lbnRcbiAgICAgIGVsc2VcbiAgICAgICAgQGVsZW1lbnQgPSBlbGVtZW50XG4gICAgICBlbmRcbiAgICBlbHNpZiBDYW52YXMgPT09IGFyZ3MuZmlyc3RcbiAgICAgIEBpbWFnZSA9IGFyZ3MuZmlyc3RcbiAgICBlbmRcblxuICAgIHVubGVzcyBAZWxlbWVudFxuICAgICAgQGVsZW1lbnQgPSAkZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoJ2NhbnZhcycpXG5cbiAgICAgIGlmIEBpbWFnZVxuICAgICAgICBAZWxlbWVudFs6d2lkdGhdICA9IEBpbWFnZS53aWR0aFxuICAgICAgICBAZWxlbWVudFs6aGVpZ2h0XSA9IEBpbWFnZS5oZWlnaHRcbiAgICAgIGVsc2VcbiAgICAgICAgQGVsZW1lbnRbOndpZHRoXSAgPSBhcmdzLnNoaWZ0XG4gICAgICAgIEBlbGVtZW50WzpoZWlnaHRdID0gYXJncy5zaGlmdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBpZiBAZWxlbWVudC5ub2RlX25hbWUgIT0gJ0NBTlZBUydcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidGhlIGVsZW1lbnQgaXNuJ3QgYSA8Y2FudmFzPiBlbGVtZW50XCJcbiAgICBlbmRcblxuICAgIHN1cGVyKGAje0BlbGVtZW50LnRvX259LmdldENvbnRleHQoJzJkJylgKVxuXG4gICAgQHN0eWxlID0gU3R5bGUubmV3KHNlbGYpXG4gICAgQHRleHQgID0gVGV4dC5uZXcoc2VsZilcblxuICAgIGlmIEBpbWFnZVxuICAgICAgZHJhd19pbWFnZShAaW1hZ2UpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB3aWR0aFxuICAgIEBlbGVtZW50Wzp3aWR0aF0udG9faVxuICBlbmRcblxuICBkZWYgaGVpZ2h0XG4gICAgQGVsZW1lbnRbOmhlaWdodF0udG9faVxuICBlbmRcblxuICBkZWYgd2lkdGg9KG5ld193aWR0aClcbiAgICBAZWxlbWVudFs6d2lkdGhdID0gbmV3X3dpZHRoLnRvX2lcbiAgZW5kXG5cbiAgZGVmIGhlaWdodD0obmV3X2hlaWdodClcbiAgICBAZWxlbWVudFs6aGVpZ2h0XSA9IG5ld19oZWlnaHQudG9faVxuICBlbmRcblxuICBkZWYgYXBwZW5kX3RvKHBhcmVudClcbiAgICBAZWxlbWVudC5hcHBlbmRfdG8ocGFyZW50KVxuICBlbmRcblxuICBkZWYgbG9hZChwYXRoKVxuICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuICAgIGltYWdlICAgPSAkZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoJ2ltZycpXG5cbiAgICBpbWFnZS5vbiA6bG9hZCBkb1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKGltYWdlKVxuICAgIGVuZFxuXG4gICAgaW1hZ2VbOnNyY10gPSBwYXRoXG5cbiAgICBwcm9taXNlXG4gIGVuZFxuXG4gIGRlZiBkYXRhKHggPSBuaWwsIHkgPSBuaWwsIHdpZHRoID0gbmlsLCBoZWlnaHQgPSBuaWwpXG4gICAgeCAgICAgIHx8PSAwXG4gICAgeSAgICAgIHx8PSAwXG4gICAgd2lkdGggIHx8PSBzZWxmLndpZHRoXG4gICAgaGVpZ2h0IHx8PSBzZWxmLmhlaWdodFxuXG4gICAgRGF0YS5uZXcoc2VsZiwgeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgZW5kXG5cbiAgZGVmIHBhdHRlcm4oaW1hZ2UsIHR5cGUgPSA6cmVwZWF0KVxuICAgIGAjQG5hdGl2ZS5jcmVhdGVQYXR0ZXJuKCN7RE9NKGltYWdlKS50b19ufSwgdHlwZSlgXG4gIGVuZFxuXG4gIGRlZiBncmFkaWVudCgqYXJncywgJmJsb2NrKVxuICAgIEdyYWRpZW50Lm5ldyhzZWxmLCAqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgY2xlYXIoeCA9IG5pbCwgeSA9IG5pbCwgd2lkdGggPSBuaWwsIGhlaWdodCA9IG5pbClcbiAgICB4ICAgICAgfHw9IDBcbiAgICB5ICAgICAgfHw9IDBcbiAgICB3aWR0aCAgfHw9IHNlbGYud2lkdGhcbiAgICBoZWlnaHQgfHw9IHNlbGYuaGVpZ2h0XG5cbiAgICBgI0BuYXRpdmUuY2xlYXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpYFxuICBlbmRcblxuICBkZWYgYmVnaW5cbiAgICBgI0BuYXRpdmUuYmVnaW5QYXRoKClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9zZVxuICAgIGAjQG5hdGl2ZS5jbG9zZVBhdGgoKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNhdmVcbiAgICBgI0BuYXRpdmUuc2F2ZSgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzdG9yZVxuICAgIGAjQG5hdGl2ZS5yZXN0b3JlKClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBtb3ZlX3RvKHgsIHkpXG4gICAgYCNAbmF0aXZlLm1vdmVUbyh4LCB5KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgbW92ZSBtb3ZlX3RvXG5cbiAgZGVmIGxpbmVfdG8oeCwgeSlcbiAgICBgI0BuYXRpdmUubGluZVRvKHgsIHkpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGluZSh4MSwgeTEsIHgyLCB5MilcbiAgICBtb3ZlX3RvIHgxLCB5MVxuICAgIGxpbmVfdG8geDIsIHkyXG4gIGVuZFxuXG4gIGRlZiByZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAgYCNAbmF0aXZlLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhcmMoeCwgeSwgcmFkaXVzLCBhbmdsZSwgY2xvY2t3aXNlID0gZmFsc2UpXG4gICAgYCNAbmF0aXZlLmFyYyh4LCB5LCByYWRpdXMsICN7YW5nbGVbOnN0YXJ0XX0sICN7YW5nbGVbOmVuZF19LCAhY2xvY2t3aXNlKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHF1YWRyYXRpY19jdXJ2ZV90byhjcDF4LCBjcDF5LCB4LCB5KVxuICAgIGAjQG5hdGl2ZS5xdWFkcmF0aWNDdXJ2ZVRvKGNwMXgsIGNwMXksIHgsIHkpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYmV6aWVyX2N1cnZlX3RvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpXG4gICAgYCNAbmF0aXZlLmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjdXJ2ZV90bygqYXJncylcbiAgICBjYXNlIGFyZ3MubGVuZ3RoXG4gICAgd2hlbiA0IHRoZW4gcXVhZHJhdGljX2N1cnZlX3RvKCphcmdzKVxuICAgIHdoZW4gNiB0aGVuIGJlemllcl9jdXJ2ZV90bygqYXJncylcblxuICAgIGVsc2UgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJkb24ndCBrbm93IHdoZXJlIHRvIGRpc3BhdGNoXCJcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRyYXdfaW1hZ2UoaW1hZ2UsICphcmdzKVxuICAgIGlmIENhbnZhcyA9PT0gaW1hZ2VcbiAgICAgIGltYWdlID0gaW1hZ2UuZWxlbWVudFxuICAgIGVsc2VcbiAgICAgIGltYWdlID0gRE9NKGltYWdlKVxuICAgIGVuZFxuXG4gICAgaWYgYXJncy5maXJzdC5pc19hPyhIYXNoKVxuICAgICAgc291cmNlLCBkZXN0aW5hdGlvbiA9IGFyZ3NcblxuICAgICAgYCNAbmF0aXZlLmRyYXdJbWFnZSgje2ltYWdlLnRvX259LCAje3NvdXJjZVs6eF19LCAje3NvdXJjZVs6eV19LCAje3NvdXJjZVs6d2lkdGhdfSwgI3tzb3VyY2VbOmhlaWdodF19LCAje2Rlc3RpbmF0aW9uWzp4XX0sICN7ZGVzdGluYXRpb25bOnldfSwgI3tkZXN0aW5hdGlvbls6d2lkdGhdfSwgI3tkZXN0aW5hdGlvbls6aGVpZ2h0XX0pYFxuICAgIGVsc2VcbiAgICAgIGNhc2UgYXJncy5sZW5ndGhcbiAgICAgIHdoZW4gMFxuICAgICAgICBgI0BuYXRpdmUuZHJhd0ltYWdlKCN7aW1hZ2UudG9fbn0sIDAsIDApYFxuXG4gICAgICB3aGVuIDJcbiAgICAgICAgYCNAbmF0aXZlLmRyYXdJbWFnZSgje2ltYWdlLnRvX259LCAje2FyZ3NbMF19LCAje2FyZ3NbMV19KWBcblxuICAgICAgd2hlbiA0XG4gICAgICAgIGAjQG5hdGl2ZS5kcmF3SW1hZ2UoI3tpbWFnZS50b19ufSwgI3thcmdzWzBdfSwgI3thcmdzWzFdfSwgI3thcmdzWzJdfSwgI3thcmdzWzNdfSlgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRyYW5zbGF0ZSh4LCB5LCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIHNhdmVcblxuICAgICAgYCNAbmF0aXZlLnRyYW5zbGF0ZSh4LCB5KWBcblxuICAgICAgaW5zdGFuY2VfZXZhbCgmYmxvY2spXG5cbiAgICAgIHJlc3RvcmVcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUudHJhbnNsYXRlKHgsIHkpYFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcm90YXRlKGFuZ2xlLCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIHNhdmVcblxuICAgICAgYCNAbmF0aXZlLnJvdGF0ZShhbmdsZSlgXG5cbiAgICAgIGluc3RhbmNlX2V2YWwoJmJsb2NrKVxuXG4gICAgICByZXN0b3JlXG4gICAgZWxzZVxuICAgICAgYCNAbmF0aXZlLnJvdGF0ZShhbmdsZSlgXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzY2FsZSh4LCB5LCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIHNhdmVcblxuICAgICAgYCNAbmF0aXZlLnNjYWxlKHgsIHkpYFxuXG4gICAgICBpbnN0YW5jZV9ldmFsKCZibG9jaylcblxuICAgICAgcmVzdG9yZVxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS5zY2FsZSh4LCB5KWBcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybShtMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeSwgJmJsb2NrKVxuICAgIGlmIGJsb2NrXG4gICAgICBzYXZlXG5cbiAgICAgIGAjQG5hdGl2ZS50cmFuc2Zvcm0obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpYFxuXG4gICAgICBpbnN0YW5jZV9ldmFsKCZibG9jaylcblxuICAgICAgcmVzdG9yZVxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS50cmFuc2Zvcm0obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpYFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcGF0aCgmYmxvY2spXG4gICAgYCNAbmF0aXZlLmJlZ2luUGF0aCgpYFxuXG4gICAgaW5zdGFuY2VfZXZhbCgmYmxvY2spXG5cbiAgICBgI0BuYXRpdmUuY2xvc2VQYXRoKClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmaWxsKCZibG9jaylcbiAgICBwYXRoKCZibG9jaykgaWYgYmxvY2tcblxuICAgIGAjQG5hdGl2ZS5maWxsKClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzdHJva2UoJmJsb2NrKVxuICAgIHBhdGgoJmJsb2NrKSBpZiBibG9ja1xuXG4gICAgYCNAbmF0aXZlLnN0cm9rZSgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xpcCgmYmxvY2spXG4gICAgcGF0aCgmYmxvY2spIGlmIGJsb2NrXG5cbiAgICBgI0BuYXRpdmUuY2xpcCgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG9pbnRfaW5fcGF0aD8oeCwgeSlcbiAgICBgI0BuYXRpdmUuaXNQb2ludEluUGF0aCh4LCB5KWBcbiAgZW5kXG5cbiAgZGVmIHRvX2RhdGEodHlwZSA9IHVuZGVmaW5lZClcbiAgICBgI3tAZWxlbWVudC50b19ufS50b0RhdGFVcmwodHlwZSlgXG4gIGVuZFxuXG4gIGRlZiB0b19kb20oKilcbiAgICBAZWxlbWVudFxuICBlbmRcblxuICBkZWYgb24oKmFyZ3MsICZibG9jayk7IEBlbGVtZW50Lm9uKCphcmdzLCAmYmxvY2spOyBlbmRcbiAgZGVmIG9uZSgqYXJncywgJmJsb2NrKTsgQGVsZW1lbnQub25lKCphcmdzLCAmYmxvY2spOyBlbmRcbiAgZGVmIG9mZigqYXJncywgJmJsb2NrKTsgQGVsZW1lbnQub2ZmKCphcmdzLCAmYmxvY2spOyBlbmRcbmVuZFxuXG5Ccm93c2VyOjpET006OkJ1aWxkZXIuZm9yIENhbnZhcyBkbyB8YiwgaXRlbXxcbiAgaXRlbS5lbGVtZW50XG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpDYW52YXM+IiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkRPTTo6RWxlbWVudCIsIkRPTSIsImFyZ3MiLCJmaXJzdCIsImVsZW1lbnQiLCJzaGlmdCIsIkRPTTo6RWxlbWVudDo6SW1hZ2UiLCJAaW1hZ2UiLCJAZWxlbWVudCIsIkNhbnZhcyIsIiRkb2N1bWVudCIsImNyZWF0ZV9lbGVtZW50IiwiW109Iiwid2lkdGgiLCJoZWlnaHQiLCJub2RlX25hbWUiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0b19uIiwiQHN0eWxlIiwiU3R5bGUiLCJuZXciLCJAdGV4dCIsIlRleHQiLCJkcmF3X2ltYWdlIiwiW10iLCJ0b19pIiwid2lkdGg9IiwibmV3X3dpZHRoIiwiaGVpZ2h0PSIsIm5ld19oZWlnaHQiLCJhcHBlbmRfdG8iLCJwYXJlbnQiLCJsb2FkIiwicGF0aCIsInByb21pc2UiLCJQcm9taXNlIiwiaW1hZ2UiLCJvbiIsImJsb2NrIGluIGxvYWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGxvYWQiLCJyZXNvbHZlIiwiZGF0YSIsIngiLCJ5IiwiJHJldF9vcl8xIiwiMCIsIkRhdGEiLCJwYXR0ZXJuIiwidHlwZSIsIkBuYXRpdmUiLCJncmFkaWVudCIsIkdyYWRpZW50IiwiYmxvY2siLCJ0b19wcm9jIiwiY2xlYXIiLCJiZWdpbiIsImNsb3NlIiwic2F2ZSIsInJlc3RvcmUiLCJtb3ZlX3RvIiwibGluZV90byIsImxpbmUiLCJ4MSIsInkxIiwieDIiLCJ5MiIsInJlY3QiLCJhcmMiLCJyYWRpdXMiLCJhbmdsZSIsImNsb2Nrd2lzZSIsInF1YWRyYXRpY19jdXJ2ZV90byIsImNwMXgiLCJjcDF5IiwiYmV6aWVyX2N1cnZlX3RvIiwiY3AyeCIsImNwMnkiLCJjdXJ2ZV90byIsImxlbmd0aCIsIjQiLCI2IiwiaXNfYT8iLCJIYXNoIiwic291cmNlIiwiZGVzdGluYXRpb24iLCIyIiwiMSIsIjMiLCJ0cmFuc2xhdGUiLCJpbnN0YW5jZV9ldmFsIiwicm90YXRlIiwic2NhbGUiLCJ0cmFuc2Zvcm0iLCJtMTEiLCJtMTIiLCJtMjEiLCJtMjIiLCJkeCIsImR5IiwiZmlsbCIsInN0cm9rZSIsImNsaXAiLCJwb2ludF9pbl9wYXRoPyIsInRvX2RhdGEiLCJ0b19kb20iLCJvbmUiLCJvZmYiLCJmb3IiLCJCcm93c2VyOjpET006OkJ1aWxkZXIiLCJCcm93c2VyOjpET00iLCJCcm93c2VyIiwiYmxvY2sgaW4gPG1vZHVsZTpCcm93c2VyPiIsImIiLCJpdGVtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8bW9kdWxlOkJyb3dzZXI+Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLHNCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHlCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUVBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFSCxJQUFBSSxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtNQUVBSixJQUFBTyxhQUFBQSxDQUFZLFNBQVosRUFBc0IsT0FBdEIsRUFBOEIsTUFBOUJBOztBQUVBQyxNQUFBQSwwQkFBQUEsc0JBWkYsRUFZRUE7QUFBQUEsUUFBQUE7QUFBQUE7O1FBQUFBOztRQVpGO1FBWWlCO1FBQ2IsSUFBQSxRQUFHQyxJQUFBQyxTQUFBRCxZQUFILEVBQW9CRSxJQUFJQyxPQUFBQSxDQUFBQSxDQUF4QixDQUFBOztVQUNFQyxVQUFVRixJQUFJRyxPQUFBQSxDQUFBQTtVQUVkLElBQUEsUUFBR0MsSUFBQU4sSUFBQUMsU0FBQUQsWUFBQU0sVUFBSCxFQUEyQkYsT0FBM0IsQ0FBQTtZQUNFRyxhQUFXSDtVQURiO1lBR0VJLGVBQVdKO1VBSGI7UUFIRixPQVFBLElBQUEsUUFBTUssWUFBTixFQUFpQlAsSUFBSUMsT0FBQUEsQ0FBQUEsQ0FBckIsQ0FBQTtVQUNFSSxhQUFTTCxJQUFJQyxPQUFBQSxDQUFBQTtRQURmO1FBSUEsS0FBQSxRQUFPSyxZQUFQLENBQUE7O1VBQ0VBLGVBQVdFLGVBQVNDLGdCQUFBQSxDQUFnQlosUUFBaEJZO1VBRXBCLElBQUEsUUFBR0osVUFBSCxDQUFBOztZQUNFQyxZQUFRSSxRQUFBQSxDQUFDLE9BQVQsRUFBb0JMLFVBQU1NLE9BQUFBLENBQUFB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QUFBQTtJQW1VQUQsT0FBcUJtSCxNQUFyQkMsSUFBQUMsSUFBQUMsYUFBQUQsUUFBQUQsWUFBcUJELE9BQUFBLEVBQUFBLENBQUtuRyxZQUFMbUcsQ0FBQUEsRUFBckJJLG9CQUFxQ0MsQ0FBRCxFQUFJQyxJQUF4Q0Y7O01BQXFDO01BQUc7TUFDdENHLE9BQUFELElBQUk5RyxTQUFBQSxDQUFBQSxFQURONEcsQ0FBQUEsR0FBcUJKO0VBclVyQm5ILEdBQUFBLFdBQUFBO0FBTEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjM5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvY3VzdG9tLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgdXNlX3N0cmljdDogdHJ1ZVxuIyBoZWxwZXJzOiB0cnV0aHlcblxubW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbiMgQ3VzdG9tRWxlbWVudHMgaW1wbGVtZW50YXRpb24gZm9yIG9wYWwtYnJvd3Nlci4gU2VlIGV4YW1wbGVzL2N1c3RvbV9lbGVtZW50cy8uXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvV2ViX0NvbXBvbmVudHMvVXNpbmdfY3VzdG9tX2VsZW1lbnRzXG4jIEBhYnN0cmFjdCBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS4gUGxlYXNlIGV4dGVuZCBpdCBhbmQgaW1wbGVtZW50IG5lZWRlZCBtZXRob2RzLlxuY2xhc3MgQ3VzdG9tIDwgRWxlbWVudFxuICAjIFRoZSByZWFzb24gd2h5IHdlIHdyYXAgY2xhc3MgZGVmaW5pdGlvbiB3aXRoIGFuIGV2YWwgaXMga2luZCBvZiBzZWxmaXNoLiBJIHdhbnQgaXQgdG8gd29ya1xuICAjIHdpdGggb3BhbC1vcHRpbWl6ZXIgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHRoZSBuZXcgY2xhc3Mgc3ludGF4LiBJIHdvdWxkIGRvIGl0IHdpdGggcHJvdG90eXBlcyxcbiAgIyBidXQgdGhlIHByb3RvdHlwZXMgc3lzdGVtIGlzIHNvIG1lc3N5IEkgZ2F2ZSB1cC5cbiAgI1xuICAjIFRoZXJlZm9yZSwgZm9yIGl0IHRvIGJlIGNsZWFuZWQgdXAsIG9uZSBvZiB0aG9zZSB0d28gbXVzdCBoYXBwZW46XG4gICMgLSB3ZSByYWlzZSB0aGUgc3VwcG9ydGVkIEVTIHZlcnNpb24gaW4gT3BhbCBhbmQgd2UgaW1wbGVtZW50IHRob3NlIEVTIHN5bnRheCBmZWF0dXJlcyBpblxuICAjICAgcmtlbGx5LXR1cmJvLiBBbmQgdGhlbiB3ZSByZW1vdmUgdGhlIHBvbHlmaWxsLlxuICAjIC0gd2UgcmVpbXBsZW1lbnQgaXQgaW4gdGVybXMgb2YgcHJvdG90eXBlcy5cbiAgJXh7XG4gICAgdmFyIG1ha2VfY3VzdG9tX2NsYXNzID0gRnVuY3Rpb24oJ3NlbGYsYmFzZV9jbGFzcycsXG4gICAgICAnXCJ1c2Ugc3RyaWN0XCI7IFxcXG4gICAgICB2YXIga2xhc3MgPSBjbGFzcyBleHRlbmRzIGJhc2VfY2xhc3MgeyBcXFxuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgXFxcbiAgICAgICAgICBzdXBlcigpOyBcXFxuICAgICAgICAgIHNlbGYuJF9kaXNwYXRjaF9jb25zdHJ1Y3Rvcih0aGlzKTsgXFxcbiAgICAgICAgfSBcXFxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHsgXFxcbiAgICAgICAgICByZXR1cm4gdGhpcy4kJG9wYWxfbmF0aXZlX2NhY2hlZC4kYXR0YWNoZWQoKTsgXFxcbiAgICAgICAgfSBcXFxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHsgXFxcbiAgICAgICAgICByZXR1cm4gdGhpcy4kJG9wYWxfbmF0aXZlX2NhY2hlZC4kZGV0YWNoZWQoKTsgXFxcbiAgICAgICAgfSBcXFxuICAgICAgICBhZG9wdGVkQ2FsbGJhY2soKSB7IFxcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuJCRvcGFsX25hdGl2ZV9jYWNoZWQuJGFkb3B0ZWQoKTsgXFxcbiAgICAgICAgfSBcXFxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgZnJvbSwgdG8pIHsgXFxcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gbnVsbCkgZnJvbSA9IE9wYWwubmlsOyBcXFxuICAgICAgICAgIGlmICh0byA9PT0gbnVsbCkgdG8gPSBPcGFsLm5pbDsgXFxcbiAgICAgICAgICByZXR1cm4gdGhpcy4kJG9wYWxfbmF0aXZlX2NhY2hlZC4kYXR0cmlidXRlX2NoYW5nZWQoYXR0ciwgZnJvbSwgdG8pOyBcXFxuICAgICAgICB9IFxcXG4gICAgICAgIFxcXG4gICAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyBcXFxuICAgICAgICAgIHJldHVybiBzZWxmLiRvYnNlcnZlZF9hdHRyaWJ1dGVzKCk7IFxcXG4gICAgICAgIH0gXFxcbiAgICAgIH07IFxcXG4gICAgICBrbGFzcy4kJG9wYWxfY2xhc3MgPSBzZWxmOyBcXFxuICAgICAgcmV0dXJuIGtsYXNzOydcbiAgICApO1xuICB9IGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdDdXN0b20gRWxlbWVudHMnICMnXG5cbiAgbW9kdWxlIENsYXNzTWV0aG9kc1xuICAgIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdDdXN0b20gRWxlbWVudHMnXG4gICAgICAjIERlZmluZXMgYSBuZXcgY3VzdG9tIGVsZW1lbnQuIFRoaXMgc2hvdWxkIGNvbWUgYXMgdGhlIGxhc3QgY2FsbFxuICAgICAgIyBpbiB0aGUgY2xhc3MgZGVmaW5pdGlvbiwgYmVjYXVzZSBhdCB0aGlzIHBvaW50IHRoZSBtZXRob2RzIG1heVxuICAgICAgIyBiZSBjYWxsZWQhXG4gICAgICAjXG4gICAgICAjIEBvcGFsb3B0IHVzZXM6X2Rpc3BhdGNoX2NvbnN0cnVjdG9yLGF0dGFjaGVkLGRldGFjaGVkLGFkb3B0ZWQsYXR0cmlidXRlX2NoYW5nZWQsb2JzZXJ2ZWRfYXR0cmlidXRlc1xuICAgICAgZGVmIGRlZl9jdXN0b20odGFnX25hbWUsIGJhc2VfY2xhc3M6IG5pbCwgZXh0ZW5kczogbmlsKVxuICAgICAgICBpZiBgYmFzZV9jbGFzcyAhPT0gbmlsYFxuICAgICAgICBlbHNpZiBzZWxmLnN1cGVyY2xhc3MgPT0gQ3VzdG9tXG4gICAgICAgICAgYmFzZV9jbGFzcyA9IGBIVE1MRWxlbWVudGBcbiAgICAgICAgZWxzaWYgc2VsZi5hbmNlc3RvcnMuaW5jbHVkZT8gQ3VzdG9tXG4gICAgICAgICAgYmFzZV9jbGFzcyA9IGAje3NlbGYuc3VwZXJjbGFzc30uY3VzdG9tX2NsYXNzYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJZb3UgbXVzdCBkZWZpbmUgYmFzZV9jbGFzc1wiXG4gICAgICAgIGVuZFxuXG4gICAgICAgIEBjdXN0b21fY2xhc3MgPSBgbWFrZV9jdXN0b21fY2xhc3Moc2VsZiwgI3tiYXNlX2NsYXNzfSlgXG4gICAgICAgIEBvYnNlcnZlZF9hdHRyaWJ1dGVzIHx8PSBbXVxuXG4gICAgICAgIGRlZl9zZWxlY3RvciB0YWdfbmFtZVxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmICgkdHJ1dGh5KCN7ZXh0ZW5kc30pKSBjdXN0b21FbGVtZW50cy5kZWZpbmUoI3t0YWdfbmFtZX0sICN7QGN1c3RvbV9jbGFzc30sIHtleHRlbmRzOiAje2V4dGVuZHN9fSk7XG4gICAgICAgICAgZWxzZSBjdXN0b21FbGVtZW50cy5kZWZpbmUoI3t0YWdfbmFtZX0sICN7QGN1c3RvbV9jbGFzc30pO1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnTXV0YXRpb25PYnNlcnZlcidcbiAgICAgICMgQ2FuIHdlIHBvbHlmaWxsIGl0P1xuICAgICAgQnJvd3Nlcjo6RE9NOjpNdXRhdGlvbk9ic2VydmVyLm5ldyBkbyB8b2JzfFxuICAgICAgICBvYnMuZWFjaCBkbyB8ZXxcbiAgICAgICAgICB0YXJnZXQgPSBlLnRhcmdldFxuXG4gICAgICAgICAgY2FzZSBlLnR5cGVcbiAgICAgICAgICB3aGVuIDphdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmIEN1c3RvbTo6TWl4aW4gPT09IHRhcmdldCAmJiB0YXJnZXQuY2xhc3Mub2JzZXJ2ZWRfYXR0cmlidXRlcy5pbmNsdWRlPyhlLm5hbWUpXG4gICAgICAgICAgICAgIHRhcmdldC5hdHRyaWJ1dGVfY2hhbmdlZChlLm5hbWUsIGUub2xkLCB0YXJnZXRbZS5uYW1lXSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHdoZW4gOnRyZWVcbiAgICAgICAgICAgIGUuYWRkZWQuZWFjaCB7IHxufCBuLmF0dGFjaGVkX29uY2UgaWYgQ3VzdG9tOjpNaXhpbiA9PT0gbiB9XG4gICAgICAgICAgICBlLnJlbW92ZWQuZWFjaCB7IHxufCBuLmRldGFjaGVkX29uY2UgaWYgQ3VzdG9tOjpNaXhpbiA9PT0gbiB9XG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kLm9ic2VydmUoJGRvY3VtZW50LCB0cmVlOiB0cnVlLCBjaGlsZHJlbjogdHJ1ZSwgYXR0cmlidXRlczogOm9sZClcbiAgICBlbmRcblxuICAgIHVubGVzcyBCcm93c2VyLnN1cHBvcnRzPyAnQ3VzdG9tIEVsZW1lbnRzJ1xuICAgICAgIyBUaGUgcG9seWZpbGxlZCBpbXBsZW1lbnRhdGlvbi4gRGVmaW5lIHRoZSBzZWxlY3RvciBhbmQgdGhlblxuICAgICAgIyB0cnkgdG8gdXBncmFkZSB0aGUgZWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICBkZWYgZGVmX2N1c3RvbSh0YWdfbmFtZSwgYmFzZV9jbGFzczogbmlsLCBleHRlbmRzOiBuaWwpXG4gICAgICAgIGRlZl9zZWxlY3RvciB0YWdfbmFtZVxuXG4gICAgICAgICRkb2N1bWVudC5ib2R5LmNzcyh0YWdfbmFtZSkuZWFjaCBkbyB8ZWxlbXxcbiAgICAgICAgICBfZGlzcGF0Y2hfY29uc3RydWN0b3IoZWxlbS50b19uKSYuYXR0YWNoZWRfb25jZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgcHJpdmF0ZSBkZWYgX2Rpc3BhdGNoX2NvbnN0cnVjdG9yKG9iailcbiAgICAgICV4e1xuICAgICAgICBpZiAodHlwZW9mIG9iai4kJG9wYWxfbmF0aXZlX2NhY2hlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZWxldGUgb2JqLiQkb3BhbF9uYXRpdmVfY2FjaGVkO1xuICAgICAgICAgIHJldHVybiBzZWxmLiRuZXcob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWxmLiRuZXcob2JqKTtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICAjIFRoaXMgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBkZWZfY3VzdG9tIGlzIGNhbGxlZCFcbiAgICBhdHRyX2FjY2Vzc29yIDpvYnNlcnZlZF9hdHRyaWJ1dGVzXG5cbiAgICBhdHRyX3JlYWRlciA6Y3VzdG9tX2NsYXNzXG4gIGVuZFxuXG4gIG1vZHVsZSBNaXhpblxuICAgIGRlZiBzZWxmLmluY2x1ZGVkKGtsYXNzKVxuICAgICAga2xhc3MuZXh0ZW5kIENsYXNzTWV0aG9kc1xuICAgIGVuZFxuXG4gICAgIyBAYWJzdHJhY3RcbiAgICBkZWYgYXR0YWNoZWRcbiAgICBlbmRcblxuICAgICMgQGFic3RyYWN0XG4gICAgZGVmIGRldGFjaGVkXG4gICAgZW5kXG5cbiAgICAjIEBhYnN0cmFjdFxuICAgIGRlZiBhZG9wdGVkXG4gICAgZW5kXG5cbiAgICAjIE5vdGU6IGZvciB0aGlzIG1ldGhvZCB0byBmaXJlLCB5b3Ugd2lsbCBuZWVkIHRvIGRlZmluZVxuICAgICMgdGhlIG9ic2VydmVkIGF0dHJpYnV0ZXMuXG4gICAgI1xuICAgICMgQGFic3RyYWN0XG4gICAgZGVmIGF0dHJpYnV0ZV9jaGFuZ2VkKGF0dHIsIGZyb20sIHRvKVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIGN1c3RvbSBlbGVtZW50LlxuICAgIGRlZiBjdXN0b20/XG4gICAgICB0cnVlXG4gICAgZW5kXG5cbiAgICAjIFRob3NlIG1ldGhvZHMga2VlcCB0cmFjayBvZiB0aGUgYXR0YWNobWVudCBzdGF0dXMgb2YgdGhlIGVsZW1lbnRzLFxuICAgICMgc28gdGhhdCAjYXR0YWNoZWQvI2RldGFjaGVkIGlzbid0IGNhbGxlZCB0d2ljZS5cbiAgICB1bmxlc3MgQnJvd3Nlci5zdXBwb3J0cz8gJ0N1c3RvbSBFbGVtZW50cydcbiAgICAgICMgQHByaXZhdGVcbiAgICAgIGRlZiBhdHRhY2hlZF9vbmNlXG4gICAgICAgIGF0dGFjaGVkIHVubGVzcyBAX3BvbHlmaWxsX2F0dGFjaGVkXG4gICAgICAgIEBfcG9seWZpbGxfYXR0YWNoZWQgPSB0cnVlXG4gICAgICBlbmRcblxuICAgICAgIyBAcHJpdmF0ZVxuICAgICAgZGVmIGRldGFjaGVkX29uY2VcbiAgICAgICAgZGV0YWNoZWQgaWYgQF9wb2x5ZmlsbF9hdHRhY2hlZFxuICAgICAgICBAX3BvbHlmaWxsX2F0dGFjaGVkID0gZmFsc2VcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIE1peGluXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkN1c3RvbT4iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPG1vZHVsZTpDbGFzc01ldGhvZHM+IiwiZGVmX2N1c3RvbSIsInRhZ19uYW1lIiwiJGt3YXJncyIsInNlbGYiLCJzdXBlcmNsYXNzIiwiQ3VzdG9tIiwiYmFzZV9jbGFzcyIsImFuY2VzdG9ycyIsImluY2x1ZGU/IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiQGN1c3RvbV9jbGFzcyIsIkBvYnNlcnZlZF9hdHRyaWJ1dGVzIiwiJHJldF9vcl8xIiwiZGVmX3NlbGVjdG9yIiwiZXh0ZW5kcyQiLCJuZXciLCJCcm93c2VyOjpET006Ok11dGF0aW9uT2JzZXJ2ZXIiLCJCcm93c2VyOjpET00iLCJibG9jayBpbiA8bW9kdWxlOkNsYXNzTWV0aG9kcz4iLCJvYnMiLCJibG9jayAoMiBsZXZlbHMpIGluIDxtb2R1bGU6Q2xhc3NNZXRob2RzPiIsImVhY2giLCJlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8bW9kdWxlOkNsYXNzTWV0aG9kcz4iLCJ0YXJnZXQiLCJ0eXBlIiwiQ3VzdG9tOjpNaXhpbiIsImNsYXNzIiwib2JzZXJ2ZWRfYXR0cmlidXRlcyIsIm5hbWUiLCJhdHRyaWJ1dGVfY2hhbmdlZCIsIm9sZCIsIltdIiwiYWRkZWQiLCJuIiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiA8bW9kdWxlOkNsYXNzTWV0aG9kcz4iLCJhdHRhY2hlZF9vbmNlIiwicmVtb3ZlZCIsImRldGFjaGVkX29uY2UiLCJvYnNlcnZlIiwiJGRvY3VtZW50IiwiYm9keSIsImNzcyIsImJsb2NrIGluIGRlZl9jdXN0b20iLCJlbGVtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWZfY3VzdG9tIiwiX2Rpc3BhdGNoX2NvbnN0cnVjdG9yIiwidG9fbiIsInByaXZhdGUiLCJvYmoiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCI8bW9kdWxlOk1peGluPiIsImluY2x1ZGVkIiwia2xhc3MiLCJleHRlbmQiLCJDbGFzc01ldGhvZHMiLCJhdHRhY2hlZCIsImRldGFjaGVkIiwiYWRvcHRlZCIsImN1c3RvbT8iLCJAX3BvbHlmaWxsX2F0dGFjaGVkIiwiaW5jbHVkZSIsIk1peGluIiwiRWxlbWVudCIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUdBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFNNUJBLE9B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R0FBQUE7Y0FNQWdCLE9BQUFkLDZCQUFBQSx5QkFBQUE7QUFBQUEsZ0JBQUFBO0FBQUFBOzs7Z0JBQ0UsSUFBQSxRQUFZdUIsdUJBQVosQ0FBQTtrQkFBQTNELElBQUF3RCxVQUFBQSxDQUFBQTtnQkFBQTtnQkFDQXBCLE9BQUF1QixDQUFBQSwwQkFBc0IsS0FBdEJBO2NBRkZ2QixDQUFBQSxHQUFBQTtZQVJGO1VBL0JGYyxHQUFBQSxXQUFBQTtVQThDQXpELE9BQUFPLElBQUE0RCxTQUFBQSxDQUFRQyxXQUFSRDtRQXBLRm5FLEdBQUFBLFdBQUFBLEVBQWVxRSxhQUFmckU7TUFONEJELEdBQUFBLFdBQUFBLEVBQWdCdUUsVUFBaEJ2RTtJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFIQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NjIxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vbXV0YXRpb25fb2JzZXJ2ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBBIHtNdXRhdGlvbk9ic2VydmVyfSBpcyBhIHBlcmZvcm1hbnQgd2F5IHRvIG9ic2VydmUgY2hhbmdlcyBpbiB0aGUgRE9NLFxuIyBlaXRoZXIgb24gdGhlIHRyZWUsIHRoZSBhdHRyaWJ1dGVzIG9yIGRhdGEuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXJcbmNsYXNzIE11dGF0aW9uT2JzZXJ2ZXJcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/IDpNdXRhdGlvbk9ic2VydmVyXG4gIGVuZFxuXG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgIyBFbmNhcHN1bGF0ZXMgYSByZWNvcmRlZCBjaGFuZ2UuXG4gIGNsYXNzIFJlY29yZFxuICAgIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAgICMgQHJldHVybiBbOmF0dHJpYnV0ZXMsIDp0cmVlLCA6Y2RhdGFdIHRoZSB0eXBlIG9mIHRoZSByZWNvcmRlZCBjaGFuZ2VcbiAgICBkZWYgdHlwZVxuICAgICAgY2FzZSBgI0BuYXRpdmUudHlwZWBcbiAgICAgIHdoZW4gOmF0dHJpYnV0ZXMgICAgdGhlbiA6YXR0cmlidXRlXG4gICAgICB3aGVuIDpjaGlsZExpc3QgICAgIHRoZW4gOnRyZWVcbiAgICAgIHdoZW4gOmNoYXJhY3RlckRhdGEgdGhlbiA6Y2RhdGFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYW5nZSBoYXBwZW5lZCBvbiBhdHRyaWJ1dGVzLlxuICAgIGRlZiBhdHRyaWJ1dGU/XG4gICAgICB0eXBlID09IDphdHRyaWJ1dGVcbiAgICBlbmRcblxuICAgICMgUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFuZ2UgaGFwcGVuZWQgb24gdGhlIHRyZWUuXG4gICAgZGVmIHRyZWU/XG4gICAgICB0eXBlID09IDp0cmVlXG4gICAgZW5kXG5cbiAgICAjIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhbmdlIGhhcHBlbmVkIGluIGEgQ0RBVEEgc2VjdGlvbi5cbiAgICBkZWYgY2RhdGE/XG4gICAgICB0eXBlID09IDpjZGF0YVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gYWRkZWRcbiAgICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSBhZGRlZCBub2Rlc1xuICAgIGRlZiBhZGRlZFxuICAgICAgYXJyYXkgPSBpZiBgI0BuYXRpdmUuYWRkZWROb2RlcyAhPSBudWxsYFxuICAgICAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUuYWRkZWROb2Rlc2ApXG4gICAgICBlbHNlXG4gICAgICAgIFtdXG4gICAgICBlbmRcblxuICAgICAgTm9kZVNldFthcnJheV1cbiAgICBlbmRcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIHJlbW92ZWRcbiAgICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSByZW1vdmVkIG5vZGVzXG4gICAgZGVmIHJlbW92ZWRcbiAgICAgIGFycmF5ID0gaWYgYCNAbmF0aXZlLnJlbW92ZWROb2RlcyAhPSBudWxsYFxuICAgICAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUucmVtb3ZlZE5vZGVzYClcbiAgICAgIGVsc2VcbiAgICAgICAgW11cbiAgICAgIGVuZFxuXG4gICAgICBOb2RlU2V0W2FycmF5XVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdGFyZ2V0XG4gICAgIyBAcmV0dXJuIFtOb2RlXSB0aGUgbm9kZSB0aGUgbXV0YXRpb24gYWZmZWN0ZWRcbiAgICBkZWYgdGFyZ2V0XG4gICAgICBET00oYCNAbmF0aXZlLnRhcmdldGApXG4gICAgZW5kXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBvbGRcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG9sZCB2YWx1ZVxuICAgIGFsaWFzX25hdGl2ZSA6b2xkLCA6b2xkVmFsdWVcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgIGFsaWFzX25hdGl2ZSA6bmFtZSwgOmF0dHJpYnV0ZU5hbWVcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVzcGFjZVxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgbmFtZXNwYWNlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICBhbGlhc19uYXRpdmUgOm5hbWVzcGFjZSwgOmF0dHJpYnV0ZU5hbWVzcGFjZVxuICBlbmRcblxuICAjIENyZWF0ZSBhIG5ldyBNdXRhdGlvbk9ic2VydmVyIHdpdGggdGhlIGdpdmVuIGJsb2NrLlxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVjb3JkcyBbQXJyYXk8UmVjb3JkPl0gdGhlIHJlY29yZGVkIGNoYW5nZXNcbiAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbihyZWNvcmRzKSB7XG4gICAgICAgIHJldHVybiAje2Jsb2NrLmNhbGwoYHJlY29yZHNgLm1hcCB7IHxyfCBCcm93c2VyOjpET006Ok11dGF0aW9uT2JzZXJ2ZXI6OlJlY29yZC5uZXcocikgfSl9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyKGBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIoZnVuYylgKVxuICBlbmRcblxuICAjIE9ic2VydmUgdGhlIGdpdmVuIHRhcmdldCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAjXG4gICMgVGhlIHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgI1xuICAjICsgKipjaGlsZHJlbioqIC0gd2hldGhlciB0byBvYnNlcnZlIGNoYW5nZXMgb24gdGhlIGNoaWxkcmVuXG4gICMgICBvZiB0aGUgdGFyZ2V0IG9yIG5vdFxuICAjICsgKip0cmVlKiogLSB3aGV0aGVyIHRvIG9ic2VydmUgY2hhbmdlcyBvbiB0aGUgd2hvbGUgc3VidHJlZVxuICAjICAgb3Igbm90XG4gICMgKyAqKmF0dHJpYnV0ZXMqKiAtIHdoZXRoZXIgdG8gb2JzZXJ2ZSBjaGFuZ2VzIHRvIGF0dHJpYnV0ZXMgb3Igbm90LFxuICAjICAgaWYgdGhlIHZhbHVlIGlzIGA6b2xkYCB0aGUgb2xkIHZhbHVlIHdpbGwgYmUgc2F2ZWRcbiAgIyArICoqY2RhdGEqKiAtIHdoZXRoZXIgdG8gb2JzZXJ2ZSBjaGFuZ2VzIHRvIENEQVRBIHNlY3Rpb25zIG9yIG5vdCxcbiAgIyAgIGlmIHRoZSB2YWx1ZSBpcyBgOm9sZGAgdGhlIG9sZCB2YWx1ZSB3aWxsIGJlIHNhdmVkXG4gICMgKyAqKmZpbHRlcioqIC0gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIG9ic2VydmVcbiAgI1xuICAjIEBwYXJhbSB0YXJnZXQgW0RPTTo6Tm9kZSwgbmF0aXZlXSB0aGUgbm9kZSB0byBvYnNlcnZlXG4gICMgQHBhcmFtIG9wdGlvbnMgW0hhc2g/XSB0aGUgb3B0aW9uc1xuICBkZWYgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMgPSBuaWwpXG4gICAgdW5sZXNzIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiAgIHRydWUsXG4gICAgICAgIHRyZWU6ICAgICAgIHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IDpvbGQsXG4gICAgICAgIGNkYXRhOiAgICAgIDpvbGRcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5vYnNlcnZlKCN7TmF0aXZlLmNvbnZlcnQodGFyZ2V0KX0sICN7Y29udmVydChvcHRpb25zKX0pYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEVtcHR5IHRoZSBvYnNlcnZlciBxdWV1ZSBhbmQgcmV0dXJuIGl0cyBjb250ZW50cy5cbiAgI1xuICAjIEByZXR1cm4gW0FycmF5PFJlY29yZD5dXG4gIGRlZiB0YWtlXG4gICAgYCNAbmF0aXZlLnRha2VSZWNvcmRzKClgLm1hcCB7IHxyfCBSZWNvcmQubmV3KHIpIH1cbiAgZW5kXG5cbiAgIyBEaXNjb25uZWN0IHRoZSBvYnNlcnZlciwgdGh1cyBzdG9wcGluZyBvYnNlcnZpbmcgYW55IGNoYW5nZXMuXG4gIGRlZiBkaXNjb25uZWN0XG4gICAgYCNAbmF0aXZlLmRpc2Nvbm5lY3QoKWBcbiAgZW5kXG5cbnByaXZhdGVcbiAgZGVmIGNvbnZlcnQoaGFzaClcbiAgICBvcHRpb25zID0gTmF0aXZlKGB7fWApXG5cbiAgICBpZiBoYXNoWzpjaGlsZHJlbl1cbiAgICAgIG9wdGlvbnNbOmNoaWxkTGlzdF0gPSB0cnVlXG4gICAgZW5kXG5cbiAgICBpZiBoYXNoWzp0cmVlXVxuICAgICAgb3B0aW9uc1s6c3VidHJlZV0gPSB0cnVlXG4gICAgZW5kXG5cbiAgICBpZiBhdHRycyA9IGhhc2hbOmF0dHJpYnV0ZXNdXG4gICAgICBvcHRpb25zWzphdHRyaWJ1dGVzXSA9IHRydWVcblxuICAgICAgaWYgYXR0cnMgPT0gOm9sZFxuICAgICAgICBvcHRpb25zWzphdHRyaWJ1dGVPbGRWYWx1ZV0gPSB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGlmIGZpbHRlciA9IGhhc2hbOmZpbHRlcl1cbiAgICAgIG9wdGlvbnNbOmF0dHJpYnV0ZUZpbHRlcl0gPSBmaWx0ZXJcbiAgICBlbmRcblxuICAgIGlmIGNkYXRhID0gaGFzaFs6Y2RhdGFdXG4gICAgICBvcHRpb25zWzpjaGFyYWN0ZXJEYXRhXSA9IHRydWVcblxuICAgICAgaWYgY2RhdGEgPT0gOm9sZFxuICAgICAgICBvcHRpb25zWzpjaGFyYWN0ZXJEYXRhT2xkVmFsdWVdID0gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvcHRpb25zLnRvX25cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpNdXRhdGlvbk9ic2VydmVyPiIsInN1cHBvcnRlZD8iLCJzZWxmIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCI8Y2xhc3M6UmVjb3JkPiIsIkJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXIiLCJ0eXBlIiwiQG5hdGl2ZSIsImF0dHJpYnV0ZT8iLCI9PSIsInRyZWU/IiwiY2RhdGE/IiwiYWRkZWQiLCJhcnJheSIsIk5hdGl2ZTo6QXJyYXkiLCJuZXciLCJOb2RlU2V0IiwiW10iLCJyZW1vdmVkIiwidGFyZ2V0IiwiRE9NIiwiYWxpYXNfbmF0aXZlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiY2FsbCIsIm1hcCIsImJsb2NrIGluIGluaXRpYWxpemUiLCJyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiQnJvd3Nlcjo6RE9NOjpNdXRhdGlvbk9ic2VydmVyOjpSZWNvcmQiLCJCcm93c2VyOjpET006Ok11dGF0aW9uT2JzZXJ2ZXIiLCJCcm93c2VyOjpET00iLCJvYnNlcnZlIiwib3B0aW9ucyIsImNvbnZlcnQiLCJ0YWtlIiwiYmxvY2sgaW4gdGFrZSIsImJsb2NrICgyIGxldmVscykgaW4gdGFrZSIsIlJlY29yZCIsImRpc2Nvbm5lY3QiLCJwcml2YXRlIiwiaGFzaCIsIltdPSIsImF0dHJzIiwiZmlsdGVyIiwiY2RhdGEiLCJ0b19uIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0RBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQU1oQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsTUFBSUMsSUFBSkQsaUJBQUFBLDRDQUFBQTtBQUFBQTtVQUNFQSxPQUFBRSxhQUFPQyxjQUFBQSxDQUFXLGtCQUFYQTtRQURUSCxDQUFBQSxHQUFBQTtRQUlBQyxJQUFBRyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtRQUdBRztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFTixJQUFBRyxTQUFBQSxDQUFRSSxJQUFBTixhQUFBTSx3QkFBUko7O0FBSUFLLFVBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsWUFBQUE7OztZQUVFLFFBRE9DLGNBQU9ELEtBQ2Q7Y0FBQSxLQUFLLFlBQUw7Z0JBQXlCQSxPQUFBO2NBQ3pCLEtBQUssV0FBTDtnQkFBeUJBLE9BQUE7Y0FDekIsS0FBSyxlQUFMO2dCQUF5QkEsT0FBQTtjQUF6QjtnQkFIQUEsT0FBQTtZQUNBO1VBRkZBLENBQUFBLEdBQUFBOztBQVNBRSxVQUFBQSwwQkFBQUEsa0NBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBVixJQUFBUSxNQUFBQSxDQUFBQSxDQUFLRyxPQUFBQSxDQUFHLFdBQUhBO1VBRFBELENBQUFBLEdBQUFBOztBQUtBRSxVQUFBQSxxQkFBQUEsNkJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBWixJQUFBUSxNQUFBQSxDQUFBQSxDQUFLRyxPQUFBQSxDQUFHLE1BQUhB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QUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjc5NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvc2V0dXAvbGFyZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBicm93c2VyL3NldHVwL2xhcmdlIC0gYSBsYXJnZXIgc2V0IG9mIHJlcXVpcmVzIGZvciBtb3JlIGNvbXBsZXggYXBwbGljYXRpb25zXG4jXG4jIE5vdGUgLSBpdCBkb2Vzbid0IGluY2x1ZGUgUGFnZ2lvIChvciBQYWdnaW8gc3VwcG9ydCkgb3IgbWFueSBldmVudHNcblxucmVxdWlyZSAnYnJvd3Nlci9zZXR1cC9taW5pJ1xuXG5yZXF1aXJlICdicm93c2VyL2VmZmVjdHMnXG5yZXF1aXJlICdicm93c2VyL2h0dHAnXG5yZXF1aXJlICdicm93c2VyL2RlbGF5J1xucmVxdWlyZSAnYnJvd3Nlci9pbnRlcnZhbCdcbnJlcXVpcmUgJ2Jyb3dzZXIvaW1tZWRpYXRlJ1xucmVxdWlyZSAnYnJvd3Nlci9zdG9yYWdlJ1xucmVxdWlyZSAnYnJvd3Nlci9ibG9iJ1xucmVxdWlyZSAnYnJvd3Nlci9hbmltYXRpb25fZnJhbWUnXG5yZXF1aXJlICdicm93c2VyL3NvY2tldCdcbnJlcXVpcmUgJ2Jyb3dzZXIvaGlzdG9yeSdcbnJlcXVpcmUgJ2Jyb3dzZXIvbmF2aWdhdG9yJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUlBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGVBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGtCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixtQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLG1CQUFSRTtBQWhCQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2ODE0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jYW52YXMvZGF0YS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgQ2FudmFzXG5cbmNsYXNzIERhdGFcbiAgZGVmIHNlbGYuY3JlYXRlKGNhbnZhcywgd2lkdGgsIGhlaWdodClcbiAgICBkYXRhID0gYWxsb2NhdGVcblxuICAgIGRhdGEuaW5zdGFuY2VfZXZhbCB7XG4gICAgICBAY2FudmFzID0gY2FudmFzLnRvX2FcbiAgICAgIEB4ICAgICAgPSAwXG4gICAgICBAeSAgICAgID0gMFxuICAgICAgQHdpZHRoICA9IHdpZHRoXG4gICAgICBAaGVpZ2h0ID0gaGVpZ2h0XG5cbiAgICAgIEBuYXRpdmUgPSBgI3tjYW52YXMudG9fbn0uY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpYFxuICAgIH1cblxuICAgIGRhdGFcbiAgZW5kXG5cbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICBhdHRyX3JlYWRlciA6eCwgOnksIDp3aWR0aCwgOmhlaWdodFxuXG4gIGRlZiBpbml0aWFsaXplKGNhbnZhcywgeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICBAY2FudmFzID0gY2FudmFzLnRvX25cbiAgICBAeCAgICAgID0geFxuICAgIEB5ICAgICAgPSB5XG4gICAgQHdpZHRoICA9IHdpZHRoXG4gICAgQGhlaWdodCA9IGhlaWdodFxuXG4gICAgc3VwZXIoYCNAY2FudmFzLmdldEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KWApXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgI0BuYXRpdmUuZGF0YS5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiBbXShpbmRleClcbiAgICBgI0BuYXRpdmUuZGF0YVtpbmRleF1gXG4gIGVuZFxuXG4gIGRlZiBbXT0oaW5kZXgsIHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5kYXRhW2luZGV4XSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgc2F2ZSh4ID0gbmlsLCB5ID0gbmlsKVxuICAgIHggfHw9IDBcbiAgICB5IHx8PSAwXG5cbiAgICBgI0BjYW52YXMucHV0SW1hZ2VEYXRhKCNAbmF0aXZlLCB4LCB5KWBcbiAgZW5kXG5cbiAgZGVmIHNhdmVfdG8oY2FudmFzLCB4ID0gbmlsLCB5ID0gbmlsKVxuICAgIHggfHw9IDBcbiAgICB5IHx8PSAwXG5cbiAgICBgI3tjYW52YXMudG9fbn0ucHV0SW1hZ2VEYXRhKCNAbmF0aXZlLCB4LCB5KWBcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkNhbnZhcz4iLCI8Y2xhc3M6RGF0YT4iLCJjcmVhdGUiLCJzZWxmIiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJkYXRhIiwiYWxsb2NhdGUiLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2sgaW4gY3JlYXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjcmVhdGUiLCJAY2FudmFzIiwidG9fYSIsIkB4IiwiMCIsIkB5IiwiQHdpZHRoIiwiQGhlaWdodCIsIkBuYXRpdmUiLCJ0b19uIiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIngiLCJ5IiwibGVuZ3RoIiwiW10i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Ry9CLE1BQU1nQixNQUFBQSxDQUFBQSxDQUFNZSxjQUFlaEIsY0FBT2dCO1FBSnZDQSxDQUFBQSxJQUFBQTtRQU9BbEMsT0FBQSxhQUFNLE1BQU4sRUFBVyxRQUFYO01BekRGQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjkxMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY2FudmFzL3N0eWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBDYW52YXNcblxuY2xhc3MgU3R5bGVPYmplY3RcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICBhdHRyX3JlYWRlciA6Y29udGV4dFxuXG4gIGRlZiBpbml0aWFsaXplKGNvbnRleHQpXG4gICAgQGNvbnRleHQgPSBjb250ZXh0XG5cbiAgICBzdXBlcihAY29udGV4dC50b19uKVxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHlsZSA8IFN0eWxlT2JqZWN0XG4gIGNsYXNzIExpbmUgPCBTdHlsZU9iamVjdFxuICAgIGF0dHJfcmVhZGVyIDp3aWR0aCwgOmNhcCwgOmpvaW4sIDptaXRlcl9saW1pdFxuXG4gICAgZGVmIHdpZHRoPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5saW5lV2lkdGggPSAje0B3aWR0aCA9IHZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBjYXA9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmxpbmVDYXAgPSAje0BjYXAgPSB2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgam9pbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubGluZUpvaW4gPSAje0Bqb2luID0gdmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG1pdGVyX2xpbWl0PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5taXRlckxpbWl0ID0gI3tAbWl0ZXJfbGltaXQgPSB2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIFRleHQgPCBTdHlsZU9iamVjdFxuICAgIGF0dHJfcmVhZGVyIDpmb250LCA6YWxpZ24sIDpiYXNlbGluZVxuXG4gICAgZGVmIGZvbnQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmZvbnQgPSAje0Bmb250ID0gdmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGFsaWduPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS50ZXh0QWxpZ24gPSAje0BhbGlnbiA9IHZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBiYXNlbGluZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudGV4dEJhc2VsaW5lID0gI3tAYmFzZWxpbmUgPSB2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIEltYWdlIDwgU3R5bGVPYmplY3RcbiAgICBhdHRyX3JlYWRlciA6c21vb3RoXG5cbiAgICBhbGlhcyBzbW9vdGg/IHNtb290aFxuXG4gICAgZGVmIHNtb290aCFcbiAgICAgIGAjQG5hdGl2ZS5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSAje0BzbW9vdGggPSB0cnVlfWBcbiAgICAgIGAjQG5hdGl2ZS5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSAje0BzbW9vdGggPSB0cnVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBub19zbW9vdGghXG4gICAgICBgI0BuYXRpdmUubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gI3tAc21vb3RoID0gZmFsc2V9YFxuICAgICAgYCNAbmF0aXZlLmltYWdlU21vb3RoaW5nRW5hYmxlZCA9ICN7QHNtb290aCA9IGZhbHNlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgU2hhZG93IDwgU3R5bGVPYmplY3RcbiAgICBhdHRyX3JlYWRlciA6b2Zmc2V0LCA6Ymx1ciwgOmNvbG9yXG5cbiAgICBkZWYgb2Zmc2V0PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zaGFkb3dPZmZzZXRYID0gI3t2YWx1ZVs6eF19YFxuICAgICAgYCNAbmF0aXZlLnNoYWRvd09mZnNldFkgPSAje3ZhbHVlWzp5XX1gXG5cbiAgICAgIEBvZmZzZXQgPSB2YWx1ZVxuICAgIGVuZFxuXG4gICAgZGVmIGJsdXI9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnNoYWRvd0JsdXIgPSAje0BibHVyID0gdmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbG9yPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zaGFkb3dDb2xvciA9ICN7QGNvbG9yID0gdmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6bGluZSwgOnRleHQsIDppbWFnZSwgOnNoYWRvdywgOmZpbGwsIDpzdHJva2UsIDphbHBoYSwgOmNvbXBvc2l0ZV9vcGVyYXRpb25cblxuICBkZWYgaW5pdGlhbGl6ZShjb250ZXh0KVxuICAgIHN1cGVyKGNvbnRleHQpXG5cbiAgICBAbGluZSAgID0gTGluZS5uZXcoY29udGV4dClcbiAgICBAdGV4dCAgID0gVGV4dC5uZXcoY29udGV4dClcbiAgICBAaW1hZ2UgID0gSW1hZ2UubmV3KGNvbnRleHQpXG4gICAgQHNoYWRvdyA9IFNoYWRvdy5uZXcoY29udGV4dClcbiAgZW5kXG5cbiAgZGVmIGZpbGw9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5maWxsU3R5bGUgPSAjeyhAZmlsbCA9IHZhbHVlKS50b19ufWBcbiAgZW5kXG5cbiAgZGVmIHN0cm9rZT0odmFsdWUpXG4gICAgYCNAbmF0aXZlLnN0cm9rZVN0eWxlID0gI3soQHN0cm9rZSA9IHZhbHVlKS50b19ufWBcbiAgZW5kXG5cbiAgZGVmIGFscGhhPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuZ2xvYmFsQWxwaGEgPSAje0BhbHBoYSA9IHZhbHVlfWBcbiAgZW5kXG5cbiAgZGVmIGNvbXBvc2l0ZV9vcGVyYXRpb249KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAje0Bjb21wb3NpdGVfb3BlcmF0aW9uID0gdmFsdWV9YFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkNhbnZhcz4iLCI8Y2xhc3M6U3R5bGVPYmplY3Q+Iiwic2VsZiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJjb250ZXh0IiwiQGNvbnRleHQiLCJ0b19uIiwiPGNsYXNzOlN0eWxlPiIsIjxjbGFzczpMaW5lPiIsIndpZHRoPSIsInZhbHVlIiwiQG5hdGl2ZSIsIkB3aWR0aCIsImNhcD0iLCJAY2FwIiwiam9pbj0iLCJAam9pbiIsIm1pdGVyX2xpbWl0PSIsIkBtaXRlcl9saW1pdCIsIlN0eWxlT2JqZWN0IiwiPGNsYXNzOlRleHQ+IiwiZm9udD0iLCJAZm9udCIsImFsaWduPSIsIkBhbGlnbiIsImJhc2VsaW5lPSIsIkBiYXNlbGluZSIsIjxjbGFzczpJbWFnZT4iLCJzbW9vdGghIiwiQHNtb290aCIsIm5vX3Ntb290aCEiLCI8Y2xhc3M6U2hhZG93PiIsIm9mZnNldD0iLCJbXSIsIkBvZmZzZXQiLCJibHVyPSIsIkBibHVyIiwiY29sb3I9IiwiQGNvbG9yIiwiQGxpbmUiLCJMaW5lIiwibmV3IiwiQHRleHQiLCJUZXh0IiwiQGltYWdlIiwiSW1hZ2UiLCJAc2hhZG93IiwiU2hhZG93IiwiZmlsbD0iLCJAZmlsbCIsInN0cm9rZT0iLCJAc3Ryb2tlIiwiYWxwaGE9IiwiQGFscGhhIiwiY29tcG9zaXRlX29wZXJhdGlvbj0iLCJAY29tcG9zaXRlX29wZXJhdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7O01BRWhCQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJ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QU9xQyxhQUFnQkMsQ0FBQUEsWUFBUXZDLEtBQVJ1QyxDQUFjM0MsTUFBQUEsQ0FBQUE7UUFEekMwQyxDQUFBQSxHQUFBQTs7QUFJQUUsUUFBQUEsdUJBQUFBLDZCQUFZeEMsS0FBWndDO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFdkMsY0FBT3VDLGVBQWtCQyxDQUFBQSxjQUFVekMsS0FBVnlDLENBQWdCN0MsTUFBQUEsQ0FBQUE7UUFEN0M0QyxDQUFBQSxHQUFBQTs7QUFJQUUsUUFBQUEsc0JBQUFBLDRCQUFXMUMsS0FBWDBDO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFekMsY0FBT3lDLGVBQWlCQyxDQUFBQSxhQUFTM0MsS0FBVDJDO1FBRDVCRCxDQUFBQSxHQUFBQTtRQUlBN0MsT0FBQStDLG9DQUFBQSwwQ0FBeUI1QyxLQUF6QjRDO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFM0MsY0FBTzJDLDRCQUE4QkMsQ0FBQUEsMkJBQXVCN0MsS0FBdkI2QztRQUR6Q0QsQ0FBQUEsR0FBQUE7TUEvRkYvQyxHQUFBQSxXQUFBQSxFQUFjWSxpQkFBZFo7SUFkZ0JYLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjcxMDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9idWlsZGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgVGVtcG9yYXJ5IGZpeCBmb3IgYSBidWcgaW4gU3RyaW5nI3NjYW5cbm1vZHVsZSBQYWdnaW86OlV0aWxzXG4gIGRlZiBzZWxmLmhlcmVkb2Moc3RyaW5nKVxuICAgIHN0cmluZ1xuICBlbmRcbmVuZFxuXG5jbGFzcyBQYWdnaW86OkhUTUw6OkVsZW1lbnQgPCBCYXNpY09iamVjdFxuICBkZWYgb24oKmFyZ3MsICZibG9jaylcbiAgICAoQG9uIHx8PSBbXSkgPDwgW2FyZ3MsIGJsb2NrXVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG5jbGFzcyBCdWlsZGVyXG4gIGRlZiBzZWxmLnRvX2hcbiAgICBAYnVpbGRlcnMgfHw9IHt9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZvcihrbGFzcywgJmJsb2NrKVxuICAgIGlmIGJsb2NrXG4gICAgICB0b19oW2tsYXNzXSA9IGJsb2NrXG4gICAgZWxzZVxuICAgICAgdG9faFtrbGFzc11cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuYnVpbGQoYnVpbGRlciwgaXRlbSlcbiAgICB0b19oLmVhY2gge3xrbGFzcywgYmxvY2t8XG4gICAgICBpZiBrbGFzcyA9PT0gaXRlbVxuICAgICAgICByZXR1cm4gYmxvY2suY2FsbChidWlsZGVyLCBpdGVtKVxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjYW5ub3QgYnVpbGQgdW5rbm93biBpdGVtICN7aXRlbX1cIlxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6ZG9jdW1lbnQsIDplbGVtZW50XG5cbiAgTkVXX1BBR0dJTyA9IChQYWdnaW86OkhUTUwuaW5zdGFuY2VfbWV0aG9kKDpidWlsZCEpIHJlc2N1ZSBmYWxzZSlcblxuICBkZWYgaW5pdGlhbGl6ZShkb2N1bWVudCwgYnVpbGRlcj1uaWwsICZibG9jaylcbiAgICBAZG9jdW1lbnQgPSBkb2N1bWVudFxuXG4gICAgIyBDb21wYXRpYmlsaXR5IGlzc3VlIGR1ZSB0byBhbiB1bnJlbGVhc2VkIFBhZ2dpbyBnZW0uXG4gICAgIyBMZXQncyB0cnkgdG8gc3VwcG9ydCBib3RoIHZlcnNpb25zLiBXaGVuIFBhZ2dpbyBpcyByZWxlYXNlZCxcbiAgICAjIHdlIG1heSByZW1vdmUgaXQuXG5cbiAgICBpZiBORVdfUEFHR0lPXG4gICAgICBAYnVpbGRlciA9IFBhZ2dpbzo6SFRNTC5uZXcoZGVmZXI6IHRydWUsICZibG9jaylcblxuICAgICAgYnVpbGQgPSBwcm9jIGRvXG4gICAgICAgIEBidWlsZGVyLmJ1aWxkIShmb3JjZV9jYWxsOiAhIWJ1aWxkZXIpXG4gICAgICAgIEByb290cyA9IEBidWlsZGVyLmVhY2gubWFwIHsgfGV8IEJ1aWxkZXIuYnVpbGQoc2VsZiwgZSkgfVxuICAgICAgZW5kXG5cbiAgICAgIGlmIGJ1aWxkZXJcbiAgICAgICAgYnVpbGRlci5leHRlbmQhKEBidWlsZGVyLCAmYnVpbGQpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1aWxkLigpXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBAYnVpbGRlciA9IFBhZ2dpbzo6SFRNTC5uZXcoJmJsb2NrKVxuICAgICAgQHJvb3RzID0gQGJ1aWxkZXIuZWFjaC5tYXAgeyB8ZXwgQnVpbGRlci5idWlsZChzZWxmLCBlKSB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgQHJvb3RzXG4gIGVuZFxuZW5kXG5cbkJ1aWxkZXIuZm9yIFN0cmluZyBkbyB8YiwgaXRlbXxcbiAgYi5kb2N1bWVudC5jcmVhdGVfdGV4dChpdGVtKVxuZW5kXG5cbkJ1aWxkZXIuZm9yIFBhZ2dpbzo6SFRNTDo6RWxlbWVudCBkbyB8YiwgaXRlbXxcbiAgb3B0aW9ucyA9IHt9XG5cbiAgb3B0aW9uc1s6YXR0cnNdID0gYGl0ZW0uYXR0cmlidXRlc2AgaWYgSGFzaCA9PT0gYGl0ZW0uYXR0cmlidXRlc2BcbiAgb3B0aW9uc1s6Y2xhc3Nlc10gPSBgaXRlbS5jbGFzc19uYW1lc2BcblxuICBkb20gPSBiLmRvY3VtZW50LmNyZWF0ZV9lbGVtZW50KGBpdGVtLm5hbWVgLCAqKm9wdGlvbnMpXG5cbiAgaWYgb24gPSBgaXRlbS5vbiB8fCBuaWxgXG4gICAgb24uZWFjaCB7fGFyZ3MsIGJsb2NrfFxuICAgICAgZG9tLm9uKCphcmdzLCAmYmxvY2spXG4gICAgfVxuICBlbmRcblxuICBpZiBpbm5lciA9IGBpdGVtLmlubmVyX2h0bWwgfHwgbmlsYFxuICAgIGRvbS5pbm5lcl9odG1sID0gaW5uZXJcbiAgZWxzZVxuICAgIGl0ZW0uZWFjaCB7fGNoaWxkfFxuICAgICAgZG9tIDw8IEJ1aWxkZXIuYnVpbGQoYiwgY2hpbGQpXG4gICAgfVxuICBlbmRcblxuICBkb21cbmVuZFxuXG5CdWlsZGVyLmZvciBET006Ok5vZGUgZG8gfGIsIGl0ZW18XG4gIGl0ZW1cbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOlBhZ2dpbzo6VXRpbHM+IiwiaGVyZWRvYyIsInNlbGYiLCJzdHJpbmciLCJQYWdnaW8iLCI8Y2xhc3M6UGFnZ2lvOjpIVE1MOjpFbGVtZW50PiIsIm9uIiwiQG9uIiwiJHJldF9vcl8xIiwiPDwiLCJhcmdzIiwiYmxvY2siLCJQYWdnaW86OkhUTUwiLCJCYXNpY09iamVjdCIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6QnVpbGRlcj4iLCJ0b19oIiwiQGJ1aWxkZXJzIiwiZm9yIiwia2xhc3MiLCJbXT0iLCJbXSIsImJ1aWxkIiwiYnVpbGRlciIsIml0ZW0iLCJlYWNoIiwiYmxvY2sgaW4gYnVpbGQiLCJjYWxsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBidWlsZCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImF0dHJfcmVhZGVyIiwiaW5zdGFuY2VfbWV0aG9kIiwiU3RhbmRhcmRFcnJvciIsImluaXRpYWxpemUiLCJkb2N1bWVudCIsIkBkb2N1bWVudCIsIk5FV19QQUdHSU8iLCJAYnVpbGRlciIsIm5ldyIsInRvX3Byb2MiLCJwcm9jIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsImJsb2NrICgyIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsImJ1aWxkISIsIiEiLCJAcm9vdHMiLCJtYXAiLCJlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiQnVpbGRlciIsImV4dGVuZCEiLCJ0b19hIiwiU3RyaW5nIiwiYmxvY2sgaW4gPG1vZHVsZTpET00+IiwiYiIsImJsb2NrICgyIGxldmVscykgaW4gPG1vZHVsZTpET00+IiwiY3JlYXRlX3RleHQiLCJQYWdnaW86OkhUTUw6OkVsZW1lbnQiLCJvcHRpb25zIiwiSGFzaCIsImRvbSIsImNyZWF0ZV9lbGVtZW50IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8bW9kdWxlOkRPTT4iLCJpbm5lciIsImlubmVyX2h0bWw9IiwiY2hpbGQiLCJET006Ok5vZGUiLCJET00iXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFDQUM7RUFBQUE7OztJQUNFQSxPQUFBQyxNQUFJQyxJQUFKRCxjQUFBQSxtQkFBaUJFLE1BQWpCRjtBQUFBQTtNQUNFQSxPQUFBRTtJQURGRixDQUFBQSxHQUFBQTtFQURGRCxHQUFPSSxZQUFQSjtFQU1BSztFQUFBQTs7SUFBQUE7O0FBQUFBO0lBQ0VBLE9BQUFDLGtCQUFBQSxjQVJGLEVBUUVBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BUkY7TUFRUztNQUNMQSxPQUFDQyxDQUFBQSxVQVRMLENBQUEsUUFBQUMsQ0FBQUEsWUFTS0QsT0FUTEMsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FTYSxFQVRiLENBQUEsQ0FTS0QsQ0FBWUUsT0FBQUEsQ0FBRyxDQUFDQyxJQUFELEVBQU9DLEtBQVAsQ0FBSEY7SUFEZkgsQ0FBQUEsSUFBQUE7RUFERkQsR0FBTU8sSUFBQVIsWUFBQVEsU0FBTlAsRUFBOEJRLGlCQUE5QlI7RUFNQU4sT0FBQWU7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFFaEJDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLE1BQUlmLElBQUplLFdBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTtBQUFBQTs7VUFDRUEsT0FBQUMsQ0FBQUEsZ0JBakJKLENBQUEsUUFBQVYsQ0FBQUEsWUFpQklVLGFBakJKVixDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQWlCa0IsWUFBQSxFQWpCbEIsQ0FBQSxDQWlCSVU7UUFERkQsQ0FBQUEsR0FBQUE7UUFJQUUsTUFBSWpCLElBQUppQixVQUFBQSx3QkFBYUMsS0FBYkQ7QUFBQUEsVUFB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RUFBRitCLGFBQVUvQyxJQUFELEVBQU9DLEtBQWhCOEM7O1lBQVU7WUFBTTtZQUNkTyxPQUFHMUQsTUFBSHdELEdBQUd4RCxNQUFBQSxFQUFJLE1BQUNJLElBQUQsQ0FBSkosRUFBWUssS0FBRDhCLFNBQUFBLENBQUFBLENBQVhuQyxFQURMbUQsQ0FBQUEsR0FBRS9CO1FBREo7UUFNQSxJQUFBLFFBQUd1QyxDQUFBQSxRQUFTUixzQkFBVFEsQ0FBSCxDQUFBO1VBQ0VILEdBQUdJLGdCQUFBQSxDQUFjRCxLQUFkQztRQURMO1VBR014QyxNQUFKRCxJQUFJQyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFKK0IsYUFBWVUsS0FBWlY7O1lBQVk7WUFDVk8sT0FBQUYsR0FBSXJELE9BQUFBLENBQUcwQyxhQUFPNUIsT0FBQUEsQ0FBT2lDLENBQWQsRUFBaUJXLEtBQVY1QyxDQUFWZCxFQUROZ0QsQ0FBQUEsR0FBSS9CO1FBSE47UUFRQStCLE9BQUFLLElBdEJGUCxDQUFBQSxHQUFPcEM7TUF5QlBKLE9BQU9JLE1BQVBnQyxhQUFPaEMsT0FBQUEsRUFBQUEsQ0FBS2lELElBQUFDLFNBQUFELFNBQUxqRCxDQUFBQSxFQUFQb0MsaUJBQTBCQyxDQUFELEVBQUkvQixJQUE3QjhCOztRQUEwQjtRQUFHO1FBQzNCRSxPQUFBaEMsS0FERjhCLENBQUFBLEdBQU9wQztJQXpGU0osR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBYkFmOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzI4MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvYW5pbWF0aW9uX2ZyYW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbiMgQWxsb3dzIHlvdSB0byB3cmFwIGEgYmxvY2sgdG8gdXNlIGluIGFuIGFuaW1hdGlvbiByZW5kZXJpbmcgY3ljbGUuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbmNsYXNzIEFuaW1hdGlvbkZyYW1lXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBbJ0FuaW1hdGlvbi5yZXF1ZXN0JyxcbiAgICAgJ0FuaW1hdGlvbi5yZXF1ZXN0IChDaHJvbWUpJyxcbiAgICAgJ0FuaW1hdGlvbi5yZXF1ZXN0IChGaXJlZm94KScsXG4gICAgICdBbmltYXRpb24ucmVxdWVzdCAoT3BlcmEpJyxcbiAgICAgJ0FuaW1hdGlvbi5yZXF1ZXN0IChJbnRlcm5ldCBFeHBsb3JlciknXS5hbnk/IHt8ZmVhdHVyZXxcbiAgICAgICBCcm93c2VyLnN1cHBvcnRzPyBmZWF0dXJlXG4gICAgIH1cbiAgZW5kXG5cbiAgIyBFeGVjdXRlIHRoZSBibG9jayB0byB1cGRhdGUgYW4gYW5pbWF0aW9uIGJlZm9yZSB0aGUgbmV4dCByZXBhaW50LlxuICAjXG4gICMgQHBhcmFtIHdpbmRvdyBbV2luZG93XSB0aGUgd2luZG93IHRvIHJlcXVlc3QgdGhlIGZyYW1lIG9uXG4gIGRlZiBpbml0aWFsaXplKHdpbmRvdywgJmJsb2NrKVxuICAgIEB3aW5kb3cgPSB3aW5kb3dcbiAgICBAbmF0aXZlID0gd2luZG93LnRvX25cbiAgICBAaWQgICAgID0gcmVxdWVzdChibG9jaylcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5yZXF1ZXN0J1xuICAgIGRlZiByZXF1ZXN0KGJsb2NrKVxuICAgICAgYCNAbmF0aXZlLnJlcXVlc3RBbmltYXRpb25GcmFtZSgje2Jsb2NrLnRvX259KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5yZXF1ZXN0IChDaHJvbWUpJ1xuICAgIGRlZiByZXF1ZXN0KGJsb2NrKVxuICAgICAgYCNAbmF0aXZlLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSgje2Jsb2NrLnRvX259KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5yZXF1ZXN0IChGaXJlZm94KSdcbiAgICBkZWYgcmVxdWVzdChibG9jaylcbiAgICAgIGAjQG5hdGl2ZS5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoI3tibG9jay50b19ufSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdBbmltYXRpb24ucmVxdWVzdCAoT3BlcmEpJ1xuICAgIGRlZiByZXF1ZXN0KGJsb2NrKVxuICAgICAgYCNAbmF0aXZlLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUoI3tibG9jay50b19ufSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdBbmltYXRpb24ucmVxdWVzdCAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgIGRlZiByZXF1ZXN0KGJsb2NrKVxuICAgICAgYCNAbmF0aXZlLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCN7YmxvY2sudG9fbn0pYFxuICAgIGVuZFxuICBlbHNlXG4gICAgIyBSZXF1ZXN0IHRoZSBhbmltYXRpb24gZnJhbWUuXG4gICAgZGVmIHJlcXVlc3RcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICd3aW5kb3cgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLmNhbmNlbCdcbiAgICBkZWYgY2FuY2VsXG4gICAgICBgI0BuYXRpdmUuY2FuY2VsQW5pbWF0aW9uRnJhbWUoI0BpZClgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdBbmltYXRpb24uY2FuY2VsIChDaHJvbWUpJ1xuICAgIGRlZiBjYW5jZWxcbiAgICAgIGAjQG5hdGl2ZS53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChDaHJvbWUpJ1xuICAgIGRlZiBjYW5jZWxcbiAgICAgIGAjQG5hdGl2ZS53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoI0BpZClgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdBbmltYXRpb24uY2FuY2VsIChGaXJlZm94KSdcbiAgICBkZWYgY2FuY2VsXG4gICAgICBgI0BuYXRpdmUubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUoI0BpZClgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdBbmltYXRpb24uY2FuY2VsUmVxdWVzdCAoRmlyZWZveCknXG4gICAgZGVmIGNhbmNlbFxuICAgICAgYCNAbmF0aXZlLm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5jYW5jZWwgKE9wZXJhKSdcbiAgICBkZWYgY2FuY2VsXG4gICAgICBgI0BuYXRpdmUub0NhbmNlbEFuaW1hdGlvbkZyYW1lKCNAaWQpYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLmNhbmNlbFJlcXVlc3QgKE9wZXJhKSdcbiAgICBkZWYgY2FuY2VsXG4gICAgICBgI0BuYXRpdmUub0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5jYW5jZWwgKEludGVybmV0IEV4cGxvcmVyKSdcbiAgICBkZWYgY2FuY2VsXG4gICAgICBgI0BuYXRpdmUubXNDYW5jZWxBbmltYXRpb25GcmFtZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgZGVmIGNhbmNlbFxuICAgICAgYCNAbmF0aXZlLm1zQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCNAaWQpYFxuICAgIGVuZFxuICBlbHNlXG4gICAgIyBDYW5jZWwgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0LlxuICAgIGRlZiBjYW5jZWxcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICd3aW5kb3cgY2FuY2VsQW5pbWF0aW9uRnJhbWUgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gICMgKHNlZSBCcm93c2VyOjpBbmltYXRpb25GcmFtZS5uZXcpXG4gIGRlZiBhbmltYXRpb25fZnJhbWUoJmJsb2NrKVxuICAgIEJyb3dzZXI6OkFuaW1hdGlvbkZyYW1lLm5ldygkd2luZG93LCAmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFByb2NcbiAgIyAoc2VlIEJyb3dzZXI6OkFuaW1hdGlvbkZyYW1lLm5ldylcbiAgZGVmIGFuaW1hdGlvbl9mcmFtZVxuICAgIEJyb3dzZXI6OkFuaW1hdGlvbkZyYW1lLm5ldygkd2luZG93LCAmc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpBbmltYXRpb25GcmFtZT4iLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsImFueT8iLCJibG9jayBpbiBzdXBwb3J0ZWQ/IiwiZmVhdHVyZSIsImJsb2NrICgyIGxldmVscykgaW4gc3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJpbml0aWFsaXplIiwid2luZG93IiwiQHdpbmRvdyIsIkBuYXRpdmUiLCJ0b19uIiwiQGlkIiwicmVxdWVzdCIsImJsb2NrIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwiY2FuY2VsIiwiPG1vZHVsZTpLZXJuZWw+IiwiYW5pbWF0aW9uX2ZyYW1lIiwibmV3IiwiQnJvd3Nlcjo6QW5pbWF0aW9uRnJhbWUiLCIkd2luZG93IiwidG9fcHJvYyIsIjxjbGFzczpQcm9jPiJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQSxnQkFBQUE7RUFBQUE7O0VB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QSxVQUFBQTs7VUFDRUEsT0FBRVAsY0FBT08sK0JBQWdDTCxPQUFHSztRQUQ5Q0EsQ0FBQUEsR0FBQUE7TUFERjtRQU1FbkIsT0FBQW1CLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFqQixJQUFBZSxPQUFBQSxDQUFNQyx5QkFBTixFQUEyQkMseUNBQTNCRjtRQURGRSxDQUFBQSxHQUFBQTtNQU5GO0lBL0VGbkIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFMQUQsR0FBQUEsV0FBQUE7RUFrR0FxQjtFQUFBQTs7SUFBQUE7O0lBRUVBLE9BQUFDLCtCQUFBQSwyQkFBQUE7QUFBQUEsTUFBQUE7QUFBQUE7O01BQUFBOzs7TUFDRUEsT0FBdUJDLE1BQXZCQyxJQUFBaEIsYUFBQWdCLG1CQUF1QkQsT0FBQUEsRUFBQUEsQ0FBS0UsYUFBTEYsQ0FBQUEsRUFBZU4sS0FBRFMsU0FBQUEsQ0FBQUEsQ0FBZEg7SUFEekJELENBQUFBLEdBQUFBO0VBRkZELEdBQUFBLFdBQUFBO0VBT0F0QixPQUFBNEI7RUFBQUE7O0lBQUFBOztJQUVFQSxPQUFBTCwrQkFBQUEsMkJBQUFBO0FBQUFBLE1BQUFBO0FBQUFBOztNQUNFQSxPQUF1QkMsTUFBdkJDLElBQUFoQixhQUFBZ0IsbUJBQXVCRCxPQUFBQSxFQUFBQSxDQUFLRSxhQUFMRixDQUFBQSxFQUFlcEIsSUFBRHVCLFNBQUFBLENBQUFBLENBQWRIO0lBRHpCRCxDQUFBQSxHQUFBQTtFQUZGSyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQXpHQTVCOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzQ1MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvaW50ZXJ2YWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuIyBBbGxvd3MgeW91IHRvIGNyZWF0ZSBhbiBpbnRlcnZhbCB0aGF0IGV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBldmVyeSBnaXZlblxuIyBzZWNvbmRzLlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuc2V0SW50ZXJ2YWxcbmNsYXNzIEludGVydmFsXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGV2ZXJ5XG4gICMgQHJldHVybiBbRmxvYXRdIHRoZSBzZWNvbmRzIGV2ZXJ5IHdoaWNoIHRoZSBibG9jayBpcyBjYWxsZWRcbiAgYXR0cl9yZWFkZXIgOmV2ZXJ5XG5cbiAgIyBDcmVhdGUgYW5kIHN0YXJ0IGFuIGludGVydmFsLlxuICAjXG4gICMgQHBhcmFtIHdpbmRvdyBbV2luZG93XSB0aGUgd2luZG93IHRvIHN0YXJ0IHRoZSBpbnRlcnZhbCBvblxuICAjIEBwYXJhbSB0aW1lIFtGbG9hdF0gc2Vjb25kcyBldmVyeSB3aGljaCB0byBjYWxsIHRoZSBibG9ja1xuICBkZWYgaW5pdGlhbGl6ZSh3aW5kb3csIHRpbWUsICZibG9jaylcbiAgICBAd2luZG93ID0gTmF0aXZlLmNvbnZlcnQod2luZG93KVxuICAgIEBldmVyeSAgPSB0aW1lXG4gICAgQGJsb2NrICA9IGJsb2NrXG5cbiAgICBAYWJvcnRlZCA9IGZhbHNlXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIGludGVydmFsIGhhcyBiZWVuIHN0b3BwZWQuXG4gIGRlZiBzdG9wcGVkP1xuICAgIEBpZC5uaWw/XG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIGludGVydmFsIGhhcyBiZWVuIGFib3J0ZWQuXG4gIGRlZiBhYm9ydGVkP1xuICAgIEBhYm9ydGVkXG4gIGVuZFxuXG4gICMgQWJvcnQgdGhlIGludGVydmFsLCBpdCB3b24ndCBiZSBwb3NzaWJsZSB0byBzdGFydCBpdCBhZ2Fpbi5cbiAgZGVmIGFib3J0XG4gICAgYCNAd2luZG93LmNsZWFySW50ZXJ2YWwoI0BpZClgXG5cbiAgICBAYWJvcnRlZCA9IHRydWVcbiAgICBAaWQgICAgICA9IG5pbFxuICBlbmRcblxuICAjIFN0b3AgdGhlIGludGVydmFsLCBpdCB3aWxsIGJlIHBvc3NpYmxlIHRvIHN0YXJ0IGl0IGFnYWluLlxuICBkZWYgc3RvcFxuICAgIHJldHVybiBpZiBzdG9wcGVkP1xuXG4gICAgYCNAd2luZG93LmNsZWFySW50ZXJ2YWwoI0BpZClgXG5cbiAgICBAc3RvcHBlZCA9IHRydWVcbiAgICBAaWQgICAgICA9IG5pbFxuICBlbmRcblxuICAjIFN0YXJ0IHRoZSBpbnRlcnZhbCBpZiBpdCBoYXMgYmVlbiBzdG9wcGVkLlxuICBkZWYgc3RhcnRcbiAgICByYWlzZSBcInRoZSBpbnRlcnZhbCBoYXMgYmVlbiBhYm9ydGVkXCIgaWYgYWJvcnRlZD9cbiAgICByZXR1cm4gdW5sZXNzIHN0b3BwZWQ/XG5cbiAgICBAaWQgPSBgI0B3aW5kb3cuc2V0SW50ZXJ2YWwoI0BibG9jaywgI0BldmVyeSAqIDEwMDApYFxuICBlbmRcblxuICAjIENhbGwgdGhlIFtJbnRlcnZhbF0gYmxvY2suXG4gIGRlZiBjYWxsXG4gICAgQGJsb2NrLmNhbGxcbiAgZW5kXG5lbmRcblxuY2xhc3MgV2luZG93XG4gICMgRXhlY3V0ZSB0aGUgYmxvY2sgZXZlcnkgZ2l2ZW4gc2Vjb25kcy5cbiAgI1xuICAjIEBwYXJhbSB0aW1lIFtGbG9hdF0gdGhlIHNlY29uZHMgYmV0d2VlbiBldmVyeSBjYWxsXG4gICNcbiAgIyBAcmV0dXJuIFtJbnRlcnZhbF0gdGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludGVydmFsXG4gIGRlZiBldmVyeSh0aW1lLCAmYmxvY2spXG4gICAgSW50ZXJ2YWwubmV3KEBuYXRpdmUsIHRpbWUsICZibG9jaykudGFwKCY6c3RhcnQpXG4gIGVuZFxuXG4gICMgRXhlY3V0ZSB0aGUgYmxvY2sgZXZlcnkgZ2l2ZW4gc2Vjb25kcywgeW91IGhhdmUgdG8gY2FsbCBbI3N0YXJ0XSBvbiBpdFxuICAjIHlvdXJzZWxmLlxuICAjXG4gICMgQHBhcmFtIHRpbWUgW0Zsb2F0XSB0aGUgc2Vjb25kcyBiZXR3ZWVuIGV2ZXJ5IGNhbGxcbiAgI1xuICAjIEByZXR1cm4gW0ludGVydmFsXSB0aGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW50ZXJ2YWxcbiAgZGVmIGV2ZXJ5ISh0aW1lLCAmYmxvY2spXG4gICAgSW50ZXJ2YWwubmV3KEBuYXRpdmUsIHRpbWUsICZibG9jaylcbiAgZW5kXG5lbmRcblxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNldmVyeSlcbiAgZGVmIGV2ZXJ5KHRpbWUsICZibG9jaylcbiAgICAkd2luZG93LmV2ZXJ5KHRpbWUsICZibG9jaylcbiAgZW5kXG5cbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNldmVyeSEpXG4gIGRlZiBldmVyeSEodGltZSwgJmJsb2NrKVxuICAgICR3aW5kb3cuZXZlcnkhKHRpbWUsICZibG9jaylcbiAgZW5kXG5lbmRcblxuY2xhc3MgUHJvY1xuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I2V2ZXJ5KVxuICBkZWYgZXZlcnkodGltZSlcbiAgICAkd2luZG93LmV2ZXJ5KHRpbWUsICZzZWxmKVxuICBlbmRcblxuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I2V2ZXJ5ISlcbiAgZGVmIGV2ZXJ5ISh0aW1lKVxuICAgICR3aW5kb3cuZXZlcnkhKHRpbWUsICZzZWxmKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkludGVydmFsPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJ3aW5kb3ciLCJ0aW1lIiwiQHdpbmRvdyIsIk5hdGl2ZSIsImNvbnZlcnQiLCJAZXZlcnkiLCJAYmxvY2siLCJibG9jayIsIkBhYm9ydGVkIiwic3RvcHBlZD8iLCJAaWQiLCJuaWw/IiwiYWJvcnRlZD8iLCJhYm9ydCIsInN0b3AiLCJAc3RvcHBlZCIsInN0YXJ0IiwicmFpc2UiLCJjYWxsIiwiPGNsYXNzOldpbmRvdz4iLCJldmVyeSIsInRhcCIsIm5ldyIsIkludGVydmFsIiwiQG5hdGl2ZSIsInRv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bkIsSUFBUG1CLENBQUFBLEVBQWNiLEtBQURrQixTQUFBQSxDQUFBQSxDQUFiTDtJQURUQSxDQUFBQSxHQUFBQTtJQUtBTyxPQUFBRCxzQkFBQUEsOEJBQVd6QixJQUFYeUI7QUFBQUEsTUFBQUE7QUFBQUE7O01BQUFBOzs7TUFDRUEsT0FBT0EsTUFBUEUsYUFBT0YsVUFBQUEsRUFBQUEsQ0FBUXpCLElBQVJ5QixDQUFBQSxFQUFlbkIsS0FBRGtCLFNBQUFBLENBQUFBLENBQWRDO0lBRFRBLENBQUFBLEdBQUFBO0VBUEZDLEdBQUFBLFdBQUFBO0VBWUFqQyxPQUFBbUM7RUFBQUE7Ozs7O0FBRUVULElBQUFBLHFCQUFBQSxpQkFBVW5CLElBQVZtQjtBQUFBQSxNQUFBQTtBQUFBQTs7TUFDRUEsT0FBT0EsTUFBUFEsYUFBT1IsU0FBQUEsRUFBQUEsQ0FBT25CLElBQVBtQixDQUFBQSxFQUFjdkIsSUFBRDRCLFNBQUFBLENBQUFBLENBQWJMO0lBRFRBLENBQUFBLEdBQUFBO0lBS0FTLE9BQUFILHNCQUFBQSw0QkFBV3pCLElBQVh5QjtBQUFBQSxNQUFBQTtBQUFBQTs7TUFDRUEsT0FBT0EsTUFBUEUsYUFBT0YsVUFBQUEsRUFBQUEsQ0FBUXpCLElBQVJ5QixDQUFBQSxFQUFlN0IsSUFBRDRCLFNBQUFBLENBQUFBLENBQWRDO0lBRFRBLENBQUFBLEdBQUFBO0VBUEZHLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBcEdBbkM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NjAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9hbGwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBicm93c2VyL2V2ZW50L2FsbDogTG9hZCBzdXBwb3J0IGZvciBhbGwgZXZlbnRzXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvZm9jdXMnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L3doZWVsJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9kYXRhX3RyYW5zZmVyJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9jb21wb3NpdGlvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvYW5pbWF0aW9uJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9hdWRpb19wcm9jZXNzaW5nJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9iZWZvcmVfdW5sb2FkJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9jb21wb3NpdGlvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvY2xpcGJvYXJkJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9kZXZpY2VfbGlnaHQnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2RldmljZV9tb3Rpb24nXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2RldmljZV9vcmllbnRhdGlvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvZGV2aWNlX3Byb3hpbWl0eSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvZHJhZydcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvZ2FtZXBhZCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvaGFzaF9jaGFuZ2UnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L3Byb2dyZXNzJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9wYWdlX3RyYW5zaXRpb24nXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L3BvcF9zdGF0ZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvc3RvcmFnZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvdG91Y2gnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L3NlbnNvcidcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvbWVzc2FnZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvY2xvc2UnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsNkJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDJCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix5QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0NBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDZCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiwyQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYseUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDRCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw2QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsa0NBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGdDQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDJCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix3QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsK0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix1QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHNCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix1QkFBUkU7RUFDQUYsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0FBekJBRjsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc2MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RlbGF5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbiMgQWxsb3dzIHlvdSB0byBkZWxheSB0aGUgY2FsbCB0byBhIGZ1bmN0aW9uIHdoaWNoIGdldHMgY2FsbGVkIGFmdGVyIHRoZVxuIyBnaXZlbiB0aW1lLlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuc2V0VGltZW91dFxuY2xhc3MgRGVsYXlcbiAgIyBAIWF0dHJpYnV0ZSBbcl0gYWZ0ZXJcbiAgIyBAcmV0dXJuIFtGbG9hdF0gdGhlIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGJsb2NrIGlzIGNhbGxlZFxuICBhdHRyX3JlYWRlciA6YWZ0ZXJcblxuICAjIENyZWF0ZSBhbmQgc3RhcnQgYSB0aW1lb3V0LlxuICAjXG4gICMgQHBhcmFtIHdpbmRvdyBbV2luZG93XSB0aGUgd2luZG93IHRvIHN0YXJ0IHRoZSB0aW1lb3V0IG9uXG4gICMgQHBhcmFtIHRpbWUgW0Zsb2F0XSBzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBibG9jayBpcyBjYWxsZWRcbiAgZGVmIGluaXRpYWxpemUod2luZG93LCB0aW1lLCAmYmxvY2spXG4gICAgQHdpbmRvdyA9IE5hdGl2ZS5jb252ZXJ0KHdpbmRvdylcbiAgICBAYWZ0ZXIgID0gdGltZVxuICAgIEBibG9jayAgPSBibG9ja1xuICBlbmRcblxuICAjIEFib3J0IHRoZSB0aW1lb3V0LlxuICBkZWYgYWJvcnRcbiAgICBgI0B3aW5kb3cuY2xlYXJUaW1lb3V0KCNAaWQpYFxuICBlbmRcblxuICAjIFN0YXJ0IHRoZSBkZWxheS5cbiAgZGVmIHN0YXJ0XG4gICAgQGlkID0gYCNAd2luZG93LnNldFRpbWVvdXQoI3tAYmxvY2sudG9fbn0sICNAYWZ0ZXIgKiAxMDAwKWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgV2luZG93XG4gICMgRXhlY3V0ZSBhIGJsb2NrIGFmdGVyIHRoZSBnaXZlbiBzZWNvbmRzLlxuICAjXG4gICMgQHBhcmFtIHRpbWUgW0Zsb2F0XSB0aGUgc2Vjb25kcyBhZnRlciBpdCBnZXRzIGNhbGxlZFxuICAjXG4gICMgQHJldHVybiBbRGVsYXldIHRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0aW1lb3V0XG4gIGRlZiBhZnRlcih0aW1lLCAmYmxvY2spXG4gICAgRGVsYXkubmV3KEBuYXRpdmUsIHRpbWUsICZibG9jaykudGFwKCY6c3RhcnQpXG4gIGVuZFxuXG4gICMgRXhlY3V0ZSBhIGJsb2NrIGFmdGVyIHRoZSBnaXZlbiBzZWNvbmRzLCB5b3UgaGF2ZSB0byBjYWxsIFsjc3RhcnRdIG9uIGl0XG4gICMgeW91cnNlbGYuXG4gICNcbiAgIyBAcGFyYW0gdGltZSBbRmxvYXRdIHRoZSBzZWNvbmRzIGFmdGVyIGl0IGdldHMgY2FsbGVkXG4gICNcbiAgIyBAcmV0dXJuIFtEZWxheV0gdGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRpbWVvdXRcbiAgZGVmIGFmdGVyISh0aW1lLCAmYmxvY2spXG4gICAgRGVsYXkubmV3KEBuYXRpdmUsIHRpbWUsICZibG9jaylcbiAgZW5kXG5cbiAgIyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBhZnRlciB0aGUgZ2l2ZW4gc2Vjb25kcy5cbiAgI1xuICAjIEBwYXJhbSB0aW1lIFtGbG9hdF0gdGhlIHNlY29uZHMgYWZ0ZXIgaXQgZ2V0cyBjYWxsZWRcbiAgI1xuICAjIEByZXR1cm4gW1Byb21pc2VdIHRoZSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIGFmdGVyIHRpbWVvdXQgaGFwcGVuc1xuICBkZWYgcmVzb2x2ZV9hZnRlcih0aW1lKVxuICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuICAgIERlbGF5Lm5ldyhAbmF0aXZlLCB0aW1lKSB7IHByb21pc2UucmVzb2x2ZSB9LnN0YXJ0XG4gICAgcHJvbWlzZVxuICBlbmRcbmVuZFxuXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I2FmdGVyKVxuICBkZWYgYWZ0ZXIodGltZSwgJmJsb2NrKVxuICAgICR3aW5kb3cuYWZ0ZXIodGltZSwgJmJsb2NrKVxuICBlbmRcblxuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I2FmdGVyISlcbiAgZGVmIGFmdGVyISh0aW1lLCAmYmxvY2spXG4gICAgJHdpbmRvdy5hZnRlciEodGltZSwgJmJsb2NrKVxuICBlbmRcblxuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I3Jlc29sdmVfYWZ0ZXIpXG4gIGRlZiByZXNvbHZlX2FmdGVyKHRpbWUpXG4gICAgJHdpbmRvdy5yZXNvbHZlX2FmdGVyKHRpbWUpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFByb2NcbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNhZnRlcilcbiAgZGVmIGFmdGVyKHRpbWUpXG4gICAgJHdpbmRvdy5hZnRlcih0aW1lLCAmc2VsZilcbiAgZW5kXG5cbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNhZnRlciEpXG4gIGRlZiBhZnRlciEodGltZSlcbiAgICAkd2luZG93LmFmdGVyISh0aW1lLCAmc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpEZWxheT4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwid2luZG93IiwidGltZSIsIkB3aW5kb3ciLCJOYXRpdmUiLCJjb252ZXJ0IiwiQGFmdGVyIiwiQGJsb2NrIiwiYmxvY2siLCJhYm9ydCIsIkBpZCIsInN0YXJ0IiwidG9fbiIsIjxjbGFzczpXaW5kb3c+IiwiYWZ0ZXIiLCJ0YXAiLCJuZXciLCJEZWxheSIsIkBuYXRpdmUiLCJ0b19wcm9jIiwiYWZ0ZXIhIiwicmVzb2x2ZV9hZnRlciIsInByb21pc2UiLCJQcm9taXNlIiwiYmxvY2sgaW4gcmVzb2x2ZV9hZnRlciIsImJsb2NrICgyIGxldmVscykgaW4gcmVzb2x2ZV9hZnRlciIsInJlc29sdmUiLCI8bW9kdWxlOktlcm5lbD4iLCIkd2luZG93IiwiPGNsYXNzOlByb2M+Il0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7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QSxDQUFPWixJQUFQWSxDQUFBQSxFQUFjaEIsSUFBRHFCLFNBQUFBLENBQUFBLENBQWJMO0lBRFRBLENBQUFBLEdBQUFBO0lBS0FlLE9BQUFULHNCQUFBQSw0QkFBV2xCLElBQVhrQjtBQUFBQSxNQUFBQTtBQUFBQTs7TUFDRUEsT0FBT0EsTUFBUFEsYUFBT1IsVUFBQUEsRUFBQUEsQ0FBUWxCLElBQVJrQixDQUFBQSxFQUFldEIsSUFBRHFCLFNBQUFBLENBQUFBLENBQWRDO0lBRFRBLENBQUFBLEdBQUFBO0VBUEZTLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBbkZBbEM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NzYyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9oaXN0b3J5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jyb3dzZXIvbG9jYXRpb24nXG5cbm1vZHVsZSBCcm93c2VyXG5cbiMge0hpc3Rvcnl9IGFsbG93cyBtYW5pcHVsYXRpb24gb2YgdGhlIHNlc3Npb24gaGlzdG9yeS5cbiNcbiMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeVxuY2xhc3MgSGlzdG9yeVxuICAjIENoZWNrIGlmIEhUTUw1IGhpc3RvcnkgaXMgc3VwcG9ydGVkLlxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0hpc3RvcnknXG4gIGVuZFxuXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGxlbmd0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIGhvdyBtYW55IGl0ZW1zIGFyZSBpbiB0aGUgaGlzdG9yeVxuICBhbGlhc19uYXRpdmUgOmxlbmd0aFxuXG4gICMgR28gYmFjayBpbiB0aGUgaGlzdG9yeS5cbiAgI1xuICAjIEBwYXJhbSBudW1iZXIgW0ludGVnZXJdIGhvdyBtYW55IGl0ZW1zIHRvIGdvIGJhY2tcbiAgZGVmIGJhY2sobnVtYmVyID0gMSlcbiAgICBgI0BuYXRpdmUuZ28oLW51bWJlcilgXG4gIGVuZFxuXG4gICMgR28gZm9yd2FyZCBpbiB0aGUgaGlzdG9yeS5cbiAgI1xuICAjIEBwYXJhbSBudW1iZXIgW0ludGVnZXJdIGhvdyBtYW55IGl0ZW1zIHRvIGdvIGZvcndhcmRcbiAgZGVmIGZvcndhcmQobnVtYmVyID0gMSlcbiAgICBgI0BuYXRpdmUuZ28obnVtYmVyKWBcbiAgZW5kXG5cbiAgIyBQdXNoIGFuIGl0ZW0gaW4gdGhlIGhpc3RvcnkuXG4gICNcbiAgIyBAcGFyYW0gaXRlbSBbU3RyaW5nXSB0aGUgaXRlbSB0byBwdXNoIGluIHRoZSBoaXN0b3J5XG4gICMgQHBhcmFtIGRhdGEgW09iamVjdF0gYWRkaXRpb25hbCBzdGF0ZSB0byBwdXNoXG4gIGRlZiBwdXNoKGl0ZW0sIGRhdGEgPSBuaWwpXG4gICAgYCNAbmF0aXZlLnB1c2hTdGF0ZSgje2RhdGEudG9fbn0sIG51bGwsIGl0ZW0pYFxuICBlbmRcblxuICAjIFJlcGxhY2UgdGhlIGN1cnJlbnQgaGlzdG9yeSBpdGVtIHdpdGggYW5vdGhlci5cbiAgI1xuICAjIEBwYXJhbSBpdGVtIFtTdHJpbmddIHRoZSBpdGVtIHRvIHJlcGxhY2Ugd2l0aFxuICAjIEBwYXJhbSBkYXRhIFtPYmplY3RdIGFkZGl0aW9uYWwgc3RhdGUgdG8gcmVwbGFjZVxuICBkZWYgcmVwbGFjZShpdGVtLCBkYXRhID0gbmlsKVxuICAgIGAjQG5hdGl2ZS5yZXBsYWNlU3RhdGUoI3tkYXRhLnRvX259LCBudWxsLCBpdGVtKWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gY3VycmVudFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGN1cnJlbnQgaXRlbVxuICBkZWYgY3VycmVudFxuICAgICR3aW5kb3cubG9jYXRpb24uZnVsbF9wYXRoXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHN0YXRlXG4gICMgQHJldHVybiBbT2JqZWN0XSB0aGUgY3VycmVudCBzdGF0ZVxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnSGlzdG9yeS5zdGF0ZSdcbiAgICBkZWYgc3RhdGVcbiAgICAgICV4e1xuICAgICAgICB2YXIgc3RhdGUgPSAjQG5hdGl2ZS5zdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgc3RhdGVcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdoaXN0b3J5IHN0YXRlIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBXaW5kb3dcbiAgIyBAIWF0dHJpYnV0ZSBbcl0gaGlzdG9yeVxuICAjIEByZXR1cm4gW0hpc3RvcnldIHRoZSBoaXN0b3J5IGZvciB0aGlzIHdpbmRvd1xuICBkZWYgaGlzdG9yeVxuICAgIEhpc3RvcnkubmV3KGAjQG5hdGl2ZS5oaXN0b3J5YCkgaWYgYCNAbmF0aXZlLmhpc3RvcnlgXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6SGlzdG9yeT4iLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImluY2x1ZGUiLCJCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyIiwiYWxpYXNfbmF0aXZlIiwiYmFjayIsIm51bWJlciIsIjEiLCJAbmF0aXZlIiwiZm9yd2FyZCIsInB1c2giLCJpdGVtIiwiZGF0YSIsInRvX24iLCJyZXBsYWNlIiwiY3VycmVudCIsIiR3aW5kb3ciLCJsb2NhdGlvbiIsImZ1bGxfcGF0aCIsInN0YXRlIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwiPGNsYXNzOldpbmRvdz4iLCJoaXN0b3J5IiwiSGlzdG9yeSIsIm5ldyJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixrQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFLQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFFRUMsTUFBSUosSUFBSkksaUJBQUFBLG1DQUFBQTtBQUFBQTtRQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixTQUFYRTtNQURURixDQUFBQSxHQUFBQTtNQUlBSixJQUFBTyxTQUFBQSxDQUFRQyxJQUFBSCxhQUFBRyx3QkFBUkQ7TUFJQVAsSUFBQVMsY0FBQUEsQ0FBYSxRQUFiQTs7QUFLQUMsTUFBQUEsb0JBQUFBLGdCQUFTQyxNQUFURDtBQUFBQSxRQUFBQTs7O1FBQVMsNkJBQVNFO1FBQ2hCRixPQUFFRyxjQUFPSDtNQURYQSxDQUFBQSxJQUFBQTs7QUFPQUksTUFBQUEsdUJBQUFBLG1CQUFZSCxNQUFaRztBQUFBQSxRQUFBQTs7O1FBQVksNkJBQVNGO1FBQ25CRSxPQUFFRCxjQUFPQztNQURYQSxDQUFBQSxJQUFBQTs7QUFRQUMsTUFBQUEsb0JBQUFBLGdCQUFTQyxJQUFELEVBQU9DLElBQWZGO0FBQUFBLFFBQUFBOzs7UUFBZSx5QkFBTztRQUNwQkEsT0FBRUYsY0FBT0UsV0FBYUUsSUFBSUMsTUFBQUEsQ0FBQUEsQ0FBTUg7TUFEbENBLENBQUFBLElBQUFBOztBQVFBSSxNQUFBQSx1QkFBQUEsbUJBQVlILElBQUQsRUFBT0MsSUFBbEJFO0FBQUFBLFFBQUFBOzs7UUFBa0IseUJBQU87UUFDdkJBLE9BQUVOLGNBQU9NLGNBQWdCRixJQUFJQyxNQUFBQSxDQUFBQSxDQUFNQztNQURyQ0EsQ0FBQUEsSUFBQUE7O0FBTUFDLE1BQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLGFBQU9DLFVBQUFBLENBQUFBLENBQVNDLFdBQUFBLENBQUFBO01BRGxCSCxDQUFBQSxHQUFBQTtNQU1BLElBQUEsUUFBR2YsYUFBT0MsY0FBQUEsQ0FBV0gsZUFBWEcsQ0FBVixDQUFBO1FBQ0VILE9BQUFxQixxQkFBQUEsaUJBQUFBO0FBQUFBLFVBQUFBOzs7QUFFSkEsb0JBQXFCWCxjQUFPVzs7QUFFNUJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO1FBVklBLENBQUFBLEdBQUFBO01BREY7UUFjRXJCLE9BQUFxQixxQkFBQUEsaUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBeEIsSUFBQXlCLE9BQUFBLENBQU1DLHlCQUFOLEVBQTJCRiwyQkFBM0JDO1FBREZELENBQUFBLEdBQUFBO01BZEY7SUFsREZyQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQXNFQUQsT0FBQXlCO0lBQUFBOztNQUFBQTs7QUFBQUE7TUFHRUEsT0FBQUMsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRSxJQUFBLFFBQXFDZixjQUFPZSxRQUE1QyxDQUFBO1VBQUFBLE9BQUFDLGFBQU9DLEtBQUFBLENBQU9qQixjQUFPZSxRQUFkRTtRQUFQO1VBakZKRixPQUFBO1FBaUZJO01BREZBLENBQUFBLEdBQUFBO0lBSEZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBM0VBekIsR0FBQUEsV0FBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3ODY3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9zZXR1cC9taW5pLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYnJvd3Nlci9zZXR1cC9taW5pIC0gQSBzbWFsbGVyIHNldCBvZiByZXF1aXJlcywgZGVzaWduZWQgZm9yIHNsaW0gY29kZWJhc2VzXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvc2V0dXAvYmFzZSdcblxucmVxdWlyZSAnYnJvd3Nlci9ldmVudCdcbnJlcXVpcmUgJ2Jyb3dzZXIvd2luZG93J1xucmVxdWlyZSAnYnJvd3Nlci9kb20nXG5yZXF1aXJlICdicm93c2VyL2NzcydcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSxxQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFELElBQUFDLFNBQUFBLENBQVFGLGVBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixhQUFSRTtFQUNBRixPQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixhQUFSRTtBQVBBRjsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc4NzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL3NvY2tldC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlclxuXG4jIEEge1NvY2tldH0gYWxsb3dzIHRoZSBicm93c2VyIGFuZCBhIHNlcnZlciB0byBoYXZlIGEgYmlkaXJlY3Rpb25hbCBkYXRhXG4jIGNvbm5lY3Rpb24uXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldFxuY2xhc3MgU29ja2V0IDwgSU9cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/IDpXZWJTb2NrZXRcbiAgZW5kXG5cbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcbiAgaW5jbHVkZSBJTzo6V3JpdGFibGUgaWYgZGVmaW5lZD8gSU86OldyaXRhYmxlXG4gIGluY2x1ZGUgRXZlbnQ6OlRhcmdldFxuXG4gIHRhcmdldCB7fHZhbHVlfFxuICAgIFNvY2tldC5uZXcodmFsdWUpIGlmIE5hdGl2ZS5pc19hPyh2YWx1ZSwgYHdpbmRvdy5XZWJTb2NrZXRgKVxuICB9XG5cbiAgIyBDcmVhdGUgYSBjb25uZWN0aW9uIHRvIHRoZSBnaXZlbiBVUkwsIG9wdGlvbmFsbHkgdXNpbmcgdGhlIGdpdmVuIHByb3RvY29sLlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgVVJMIHRvIGNvbm5lY3QgdG9cbiAgIyBAcGFyYW0gcHJvdG9jb2wgW1N0cmluZ10gdGhlIHByb3RvY29sIHRvIHVzZVxuICAjXG4gICMgQHlpZWxkIGlmIHRoZSBibG9jayBoYXMgbm8gcGFyYW1ldGVycyBpdCdzIGBpbnN0YW5jZV9leGVjYGQsIG90aGVyd2lzZSBpdCdzXG4gICMgICAgICAgIGNhbGxlZCB3aXRoIGBzZWxmYFxuICBkZWYgaW5pdGlhbGl6ZSh1cmwsIHByb3RvY29sID0gbmlsLCAmYmxvY2spXG4gICAgaWYgbmF0aXZlPyh1cmwpXG4gICAgICBzdXBlcih1cmwpXG4gICAgZWxzaWYgcHJvdG9jb2xcbiAgICAgIHN1cGVyKGBuZXcgd2luZG93LldlYlNvY2tldCgje3VybC50b19zfSwgI3twcm90b2NvbC50b19ufSlgKVxuICAgIGVsc2VcbiAgICAgIHN1cGVyKGBuZXcgd2luZG93LldlYlNvY2tldCgje3VybC50b19zfSlgKVxuICAgIGVuZFxuXG4gICAgaWYgYmxvY2suYXJpdHkgPT0gMFxuICAgICAgaW5zdGFuY2VfZXhlYygmYmxvY2spXG4gICAgZWxzZVxuICAgICAgYmxvY2suY2FsbChzZWxmKVxuICAgIGVuZCBpZiBibG9ja1xuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBwcm90b2NvbFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHByb3RvY29sIG9mIHRoZSBzb2NrZXRcbiAgYWxpYXNfbmF0aXZlIDpwcm90b2NvbFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHVybFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIFVSTCB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCB0b1xuICBhbGlhc19uYXRpdmUgOnVybFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGJ1ZmZlcmVkXG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIGFtb3VudCBvZiBidWZmZXJlZCBkYXRhLlxuICBhbGlhc19uYXRpdmUgOmJ1ZmZlcmVkLCA6YnVmZmVyZWRBbW91bnRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB0eXBlXG4gICMgQHJldHVybiBbOmJsb2IsIDpidWZmZXIsIDpzdHJpbmddIHRoZSB0eXBlIG9mIHRoZSBzb2NrZXRcbiAgZGVmIHR5cGVcbiAgICAleHtcbiAgICAgIHN3aXRjaCAoI0BuYXRpdmUuYmluYXJ5VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICAgIHJldHVybiBcImJsb2JcIjtcblxuICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgICByZXR1cm4gXCJidWZmZXJcIjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gc3RhdGVcbiAgIyBAcmV0dXJuIFs6Y29ubmVjdGluZywgOm9wZW4sIDpjbG9zaW5nLCA6Y2xvc2VkXSB0aGUgc3RhdGUgb2YgdGhlIHNvY2tldFxuICBkZWYgc3RhdGVcbiAgICAleHtcbiAgICAgIHN3aXRjaCAoI0BuYXRpdmUucmVhZHlTdGF0ZSkge1xuICAgICAgICBjYXNlIHdpbmRvdy5XZWJTb2NrZXQuQ09OTkVDVElORzpcbiAgICAgICAgICByZXR1cm4gXCJjb25uZWN0aW5nXCI7XG5cbiAgICAgICAgY2FzZSB3aW5kb3cuV2ViU29ja2V0Lk9QRU46XG4gICAgICAgICAgcmV0dXJuIFwib3BlblwiO1xuXG4gICAgICAgIGNhc2Ugd2luZG93LldlYlNvY2tldC5DTE9TSU5HOlxuICAgICAgICAgIHJldHVybiBcImNsb3NpbmdcIjtcblxuICAgICAgICBjYXNlIHdpbmRvdy5XZWJTb2NrZXQuQ0xPU0VEOlxuICAgICAgICAgIHJldHVybiBcImNsb3NlZFwiO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gZXh0ZW5zaW9uc1xuICAjIEByZXR1cm4gW0FycmF5PFN0cmluZz5dIHRoZSBleHRlbnNpb25zIHVzZWQgYnkgdGhlIHNvY2tldFxuICBkZWYgZXh0ZW5zaW9uc1xuICAgIGAjQG5hdGl2ZS5leHRlbnNpb25zYC5zcGxpdCgvXFxzKixcXHMqLylcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgc29ja2V0IGlzIGFsaXZlLlxuICBkZWYgYWxpdmU/XG4gICAgc3RhdGUgPT0gOm9wZW5cbiAgZW5kXG5cbiAgIyBTZW5kIGRhdGEgdG8gdGhlIHNvY2tldC5cbiAgI1xuICAjIEBwYXJhbSBkYXRhIFsjdG9fbl0gdGhlIGRhdGEgdG8gc2VuZFxuICBkZWYgd3JpdGUoZGF0YSlcbiAgICBgI0BuYXRpdmUuc2VuZCgje2RhdGEudG9fbn0pYFxuICBlbmRcblxuICBhbGlhcyA8PCB3cml0ZVxuXG4gIGFsaWFzIHNlbmQgd3JpdGVcblxuICAjIENsb3NlIHRoZSBzb2NrZXQuXG4gICNcbiAgIyBAcGFyYW0gY29kZSBbSW50ZWdlciwgbmlsXSB0aGUgZXJyb3IgY29kZVxuICAjIEBwYXJhbSByZWFzb24gW1N0cmluZywgbmlsXSB0aGUgcmVhc29uIGZvciBjbG9zaW5nXG4gIGRlZiBjbG9zZShjb2RlID0gbmlsLCByZWFzb24gPSBuaWwpXG4gICAgYCNAbmF0aXZlLmNsb3NlKCN7Y29kZS50b19ufSwgI3tyZWFzb24udG9fbn0pYFxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpTb2NrZXQ+Iiwic3VwcG9ydGVkPyIsInNlbGYiLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsIklPOjpXcml0YWJsZSIsIklPIiwiRXZlbnQ6OlRhcmdldCIsIkV2ZW50IiwidGFyZ2V0IiwiYmxvY2sgaW4gPGNsYXNzOlNvY2tldD4iLCJ2YWx1ZSIsImlzX2E/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6U29ja2V0PiIsIlNvY2tldCIsIm5ldyIsImluaXRpYWxpemUiLCJ1cmwiLCJwcm90b2NvbCIsIm5hdGl2ZT8iLCJ0b19zIiwidG9fbiIsImJsb2NrIiwiYXJpdHkiLCIwIiwiaW5zdGFuY2VfZXhlYyIsInRvX3Byb2MiLCJjYWxsIiwiYWxpYXNfbmF0aXZlIiwidHlwZSIsIkBuYXRpdmUiLCJzdGF0ZSIsImV4dGVuc2lvbnMiLCJzcGxpdCIsImFsaXZlPyIsIj09Iiwid3JpdGUiLCJkYXRhIiwiY2xvc2UiLCJjb2RlIiwicmVhc29uIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQU1BQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxNQUFJQyxJQUFKRCxpQkFBQUEsa0NBQUFBO0FBQUFBO1FBQ0VBLE9BQUFFLGFBQU9DLGNBQUFBLENBQVcsV0FBWEE7TUFEVEgsQ0FBQUEsR0FBQUE7TUFJQUMsSUFBQUcsU0FBQUEsQ0FBUUMsSUFBQUMsWUFBQUQsWUFBUkQ7TUFDQSxJQUFBLFFBQXdCLENBQUEsNkJBQUEsNENBQUEsb0JBQXhCLENBQUE7UUFBQUgsSUFBQUcsU0FBQUEsQ0FBUUcsSUFBQUMsUUFBQUQsYUFBUkg7TUFBQTtNQUNBSCxJQUFBRyxTQUFBQSxDQUFRSyxJQUFBQyxXQUFBRCxXQUFSTDtNQUVBTyxNQUFBVixJQUFBVSxVQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyxtQkFBU0MsS0FBVEQ7O1FBQVM7UUFDUCxJQUFBLFFBQXFCTixZQUFNUSxVQUFBQSxDQUFPRCxLQUFiLEVBQXFCRSxnQkFBZkQsQ0FBM0IsQ0FBQTtVQUFBQyxPQUFBQyxZQUFNQyxLQUFBQSxDQUFLSixLQUFMSTtRQUFOO1VBaEJKRixPQUFBO1FBZ0JJLEVBREZILENBQUFBLEdBQUFEOztBQVdBTyxNQUFBQSwwQkFBQUEsc0JBQWVDLEdBQUQsRUFBTUMsUUFBcEJGO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQW9CLGlDQUFXO1FBQzdCLElBQUEsUUFBR2pCLElBQUFvQixZQUFBQSxDQUFRRixHQUFSRSxDQUFILENBQUE7VUFDRSxPQUFBcEIsSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFNa0IsR0FBTixDQUFBLEVBQUEsSUFBQTtRQURGLE9BRUEsSUFBQSxRQUFNQyxRQUFOLENBQUE7VUFDRSxPQUFBbkIsSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFPaUIscUJBQXVCQyxHQUFHRyxNQUFBQSxDQUFBQSxDQUFNSixFQUFJRSxRQUFRRyxNQUFBQSxDQUFBQSxDQUFNTCxDQUF6RCxDQUFBLEVBQUEsSUFBQTtRQURGO1VBR0UsT0FBQWpCLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBT2lCLHFCQUF1QkMsR0FBR0csTUFBQUEsQ0FBQUEsQ0FBTUosQ0FBdkMsQ0FBQSxFQUFBLElBQUE7UUFIRjtRQU1BLElBQUEsUUFJT00sS0FKUCxDQUFBO1VBQUEsSUFBQSxNQUFHQSxLQUFLQyxPQUFBQSxDQUFBQSxDQUFSLEVBQWtCQyxDQUFsQixDQUFBO1lBQ0VSLE9BQUFTLE1BQUExQixJQUFBMEIsaUJBQUFBLEVBQUFBLEVBQUFBLEVBQWVILEtBQURJLFNBQUFBLENBQUFBLENBQWREO1VBREY7WUFHRVQsT0FBQU0sS0FBS0ssTUFBQUEsQ0FBTTVCLElBQU40QjtVQUhQO1FBQUE7VUFuQ0pYLE9BQUE7UUFtQ0k7TUFURkEsQ0FBQUEsSUFBQUE7TUFrQkFqQixJQUFBNkIsY0FBQUEsQ0FBYSxVQUFiQTtNQUlBN0IsSUFBQTZCLGNBQUFBLENBQWEsS0FBYkE7TUFJQTdCLElBQUE2QixjQUFBQSxDQUFhLFVBQWIsRUFBd0IsZ0JBQXhCQTs7QUFJQUMsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7O0FBRUZBLGNBQWVDLGNBQU9EO0FBQ3RCQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BWkVBLENBQUFBLEdBQUFBOztBQWlCQUUsTUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxRQUFBQTs7O0FBRUZBLGNBQWVELGNBQU9DO0FBQ3RCQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQWZFQSxDQUFBQSxHQUFBQTs7QUFvQkFDLE1BQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFBLENBQUVGLGNBQU9FLFdBQVRBLENBQXFCQyxPQUFBQSxDQUFPLFNBQVBBO01BRHZCRCxDQUFBQSxHQUFBQTs7QUFLQUUsTUFBQUEsc0JBQUFBLDhCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQW5DLElBQUFnQyxPQUFBQSxDQUFBQSxDQUFNSSxPQUFBQSxDQUFHLE1BQUhBO01BRFJELENBQUFBLEdBQUFBOztBQU9BRSxNQUFBQSxxQkFBQUEsaUJBQVVDLElBQVZEO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFFTixjQUFPTSxNQUFRQyxJQUFJaEIsTUFBQUEsQ0FBQUEsQ0FBTWU7TUFEN0JBLENBQUFBLEdBQUFBO01BSUEsYUFBTSxJQUFOLEVBQVMsT0FBVDtNQUVBLGFBQU0sTUFBTixFQUFXLE9BQVg7TUFNQXZDLE9BQUF5QyxxQkFBQUEsaUJBQVVDLElBQUQsRUFBYUMsTUFBdEJGO0FBQUFBLFFBQUFBOzs7UUFBVSx5QkFBTztRQUFLLDZCQUFTO1FBQzdCQSxPQUFFUixjQUFPUSxPQUFTQyxJQUFJbEIsTUFBQUEsQ0FBQUEsQ0FBTWlCLEVBQUlFLE1BQU1uQixNQUFBQSxDQUFBQSxDQUFNaUI7TUFEOUNBLENBQUFBLElBQUFBO0lBL0dGekMsR0FBQUEsV0FBQUEsRUFBZVMsUUFBZlQ7RUFOQUQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4MDA5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC90b3VjaC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgVG91Y2ggPCBFdmVudFxuICBoYW5kbGVzICd0b3VjaGNhbmNlbCcsICd0b3VjaGVuZCcsICd0b3VjaGxlYXZlJywgJ3RvdWNobW92ZScsICd0b3VjaHN0YXJ0J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuVG91Y2gnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGFsdCFcbiAgICAgIGAjQG5hdGl2ZS5hbHRLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGN0cmwhXG4gICAgICBgI0BuYXRpdmUuY3RybEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgbWV0YSFcbiAgICAgIGAjQG5hdGl2ZS5tZXRhS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBzaGlmdCFcbiAgICAgIGAjQG5hdGl2ZS5zaGlmdEtleSA9IHRydWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgVG91Y2hFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFsdD8sIDphbHRLZXlcbiAgYWxpYXNfbmF0aXZlIDpjdHJsPywgOmN0cmxLZXlcbiAgYWxpYXNfbmF0aXZlIDptZXRhPywgOm1ldGFLZXlcbiAgYWxpYXNfbmF0aXZlIDpzaGlmdD8sIDpzaGlmdEtleVxuXG4gICMgVE9ETzogaW1wbGVtZW50IHRvdWNoZXMgYW5kIHRhcmdldFRvdWNoZXNcblxuICBkZWYgY2FuY2VsP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ3RvdWNoY2FuY2VsJ1xuICBlbmRcblxuICBkZWYgZW5kP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ3RvdWNoZW5kJ1xuICBlbmRcblxuICBkZWYgbGVhdmU/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAndG91Y2hsZWF2ZSdcbiAgZW5kXG5cbiAgZGVmIG1vdmU/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAndG91Y2htb3ZlJ1xuICBlbmRcblxuICBkZWYgc3RhcnQ/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAndG91Y2hzdGFydCdcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6VG91Y2g+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImFsdCEiLCJAbmF0aXZlIiwiY3RybCEiLCJtZXRhISIsInNoaWZ0ISIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsImNhbmNlbD8iLCJkb3duY2FzZSIsIj09IiwiZW5kPyIsImxlYXZlPyIsIm1vdmU/Iiwic3RhcnQ/IiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixhQUFSLEVBQXVCQSxVQUF2QixFQUFtQ0EsWUFBbkMsRUFBaURBLFdBQWpELEVBQThEQSxZQUE5REU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLGlDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixhQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsb0JBQUFBLGdDQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUMsY0FBT0Q7VUFEWEEsQ0FBQUEsR0FBQUE7O0FBSUFFLFVBQUFBLHFCQUFBQSxpQ0FBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DO1VBRFhBLENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSxxQkFBQUEsaUNBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRTtVQURYQSxDQUFBQSxHQUFBQTtVQUlBSixPQUFBSyxzQkFBQUEsa0NBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSCxjQUFPRztVQURYQSxDQUFBQSxHQUFBQTtRQWJGTCxHQUFBQSxXQUFBQSxFQUFtQk0sZ0JBQW5CTjtRQWtCQSxJQUFBLFFBSU9MLElBQUFFLGVBQUFBLENBQUFBLENBSlAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFUSxNQUFJWixJQUFKWSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxlQUFpQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEbENBLENBQUFBLEdBQUFBO1VBREY7UUFBQTtRQU1BWixJQUFBZSxjQUFBQSxDQUFhLE1BQWIsRUFBb0IsUUFBcEJBO1FBQ0FmLElBQUFlLGNBQUFBLENBQWEsT0FBYixFQUFxQixTQUFyQkE7UUFDQWYsSUFBQWUsY0FBQUEsQ0FBYSxPQUFiLEVBQXFCLFNBQXJCQTtRQUNBZixJQUFBZSxjQUFBQSxDQUFhLFFBQWIsRUFBc0IsVUFBdEJBOztBQUlBQyxRQUFBQSx1QkFBQUEsOEJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBaEIsSUFBQWEsTUFBQUEsQ0FBQUEsQ0FBSUksVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR0YsYUFBSEU7UUFEaEJGLENBQUFBLEdBQUFBOztBQUlBRyxRQUFBQSxvQkFBQUEsMkJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBbkIsSUFBQWEsTUFBQUEsQ0FBQUEsQ0FBSUksVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR0MsVUFBSEQ7UUFEaEJDLENBQUFBLEdBQUFBOztBQUlBQyxRQUFBQSxzQkFBQUEsNkJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBcEIsSUFBQWEsTUFBQUEsQ0FBQUEsQ0FBSUksVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR0UsWUFBSEY7UUFEaEJFLENBQUFBLEdBQUFBOztBQUlBQyxRQUFBQSxxQkFBQUEsNEJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBckIsSUFBQWEsTUFBQUEsQ0FBQUEsQ0FBSUksVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR0csV0FBSEg7UUFEaEJHLENBQUFBLEdBQUFBO1FBSUF0QixPQUFBdUIsc0JBQUFBLDhCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQXRCLElBQUFhLE1BQUFBLENBQUFBLENBQUlJLFVBQUFBLENBQUFBLENBQVVDLE9BQUFBLENBQUdJLFlBQUhKO1FBRGhCSSxDQUFBQSxHQUFBQTtNQXRERnZCLEdBQUFBLFdBQUFBLEVBQWN3QixXQUFkeEI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjgxMTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2xvY2F0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbiMgQWxsb3dzIG1hbmlwdWxhdGlvbiBvZiBhIGxvY2F0aW9uLCB1c3VhbGx5IGZyb20ge1dpbmRvd30gYW5kIHtET006OkRvY3VtZW50fS5cbiNcbiMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9jYXRpb25cbmNsYXNzIExvY2F0aW9uXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gICMgQ2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZywgI3RvX3NdIHRoZSBVUkwgdG8gZ28gdG9cbiAgZGVmIGFzc2lnbih1cmwpXG4gICAgYCNAbmF0aXZlLmFzc2lnbigje3VybC50b19zfSlgXG4gIGVuZFxuXG4gICMgUmVwbGFjZSB0aGUgY3VycmVudCBVUkwuXG4gICNcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmcsICN0b19zXSB0aGUgVVJMIHRvIGdvIHRvXG4gIGRlZiByZXBsYWNlKHVybClcbiAgICBgI0BuYXRpdmUucmVwbGFjZSgje3VybC50b19zfSlgXG4gIGVuZFxuXG4gICMgUmVsb2FkIHRoZSBwYWdlLlxuICAjXG4gICMgQHBhcmFtIGZvcmNlIFtCb29sZWFuXSB3aGV0aGVyIHRvIGZvcmNlIHRoZSByZWxvYWRcbiAgZGVmIHJlbG9hZChmb3JjZSA9IGZhbHNlKVxuICAgIGAjQG5hdGl2ZS5yZWxvYWQoZm9yY2UpYFxuICBlbmRcblxuICAjIENvbnZlcnQgdGhlIGxvY2F0aW9uIHRvIGEgc3RyaW5nLlxuICBkZWYgdG9fc1xuICAgIGAjQG5hdGl2ZS50b1N0cmluZygpYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIGZyYWdtZW50XG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgaGFzaCBmcmFnbWVudCBvZiB0aGUgbG9jYXRpb24gVVJJXG4gIGFsaWFzX25hdGl2ZSA6ZnJhZ21lbnQsIDpoYXNoXG4gIGFsaWFzX25hdGl2ZSA6ZnJhZ21lbnQ9LCA6aGFzaD1cblxuICAjIEAhYXR0cmlidXRlIGhvc3RcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBob3N0IHBhcnQgb2YgdGhlIGxvY2F0aW9uIFVSSVxuICBhbGlhc19uYXRpdmUgOmhvc3RcbiAgYWxpYXNfbmF0aXZlIDpob3N0PVxuXG4gICMgQCFhdHRyaWJ1dGUgdXJpXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgd2hvbGUgbG9jYXRpb24gVVJJXG4gIGFsaWFzX25hdGl2ZSA6dXJpLCA6aHJlZlxuICBhbGlhc19uYXRpdmUgOnVyaT0sIDpocmVmPVxuXG4gICMgQCFhdHRyaWJ1dGUgcGF0aFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHBhdGggcGFydCBvZiB0aGUgbG9jYXRpb24gVVJJXG4gIGFsaWFzX25hdGl2ZSA6cGF0aCwgOnBhdGhuYW1lXG4gIGFsaWFzX25hdGl2ZSA6cGF0aD0sIDpwYXRobmFtZT1cblxuICAjIEAhYXR0cmlidXRlIHBvcnRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgcG9ydCBwYXJ0IG9mIHRoZSBsb2NhdGlvbiBVUklcbiAgYWxpYXNfbmF0aXZlIDpwb3J0XG4gIGFsaWFzX25hdGl2ZSA6cG9ydD1cblxuICAjIEAhYXR0cmlidXRlIHNjaGVtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHNjaGVtZSBwYXJ0IG9mIHRoZSBsb2NhdGlvbiBVUklcbiAgYWxpYXNfbmF0aXZlIDpzY2hlbWUsIDpwcm90b2NvbFxuICBhbGlhc19uYXRpdmUgOnNjaGVtZT0sIDpwcm90b2NvbD1cblxuICAjIEAhYXR0cmlidXRlIHF1ZXJ5XG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgcXVlcnkgcGFydCBvZiB0aGUgbG9jYXRpb24gVVJJXG4gIGFsaWFzX25hdGl2ZSA6cXVlcnksIDpzZWFyY2hcbiAgYWxpYXNfbmF0aXZlIDpxdWVyeT0sIDpzZWFyY2g9XG5cbiAgIyBSZXR1cm5zIHRoZSBmdWxsIHBhdGggb2YgdGhlIGxvY2F0aW9uIFVSSSwgaW5jbHVkaW5nXG4gICMgdGhlIHF1ZXJ5IHN0cmluZyBhbmQgZnJhZ21lbnQsIGVnLiAvc2l0ZT9hPWIjY1xuICBkZWYgZnVsbF9wYXRoXG4gICAgcGF0aCArIHF1ZXJ5ICsgZnJhZ21lbnRcbiAgZW5kXG5lbmRcblxuY2xhc3MgV2luZG93XG4gICMgQCFhdHRyaWJ1dGUgW3JdIGxvY2F0aW9uXG4gICMgQHJldHVybiBbTG9jYXRpb25dIHRoZSBsb2NhdGlvbiBmb3IgdGhlIHdpbmRvd1xuICBkZWYgbG9jYXRpb25cbiAgICBMb2NhdGlvbi5uZXcoYCNAbmF0aXZlLmxvY2F0aW9uYCkgaWYgYCNAbmF0aXZlLmxvY2F0aW9uYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBET006OkRvY3VtZW50IDwgRE9NOjpFbGVtZW50XG4gICMgQCFhdHRyaWJ1dGUgW3JdIGxvY2F0aW9uXG4gICMgQHJldHVybiBbTG9jYXRpb25dIHRoZSBsb2NhdGlvbiBmb3IgdGhlIGRvY3VtZW50XG4gIGRlZiBsb2NhdGlvblxuICAgIExvY2F0aW9uLm5ldyhgI0BuYXRpdmUubG9jYXRpb25gKSBpZiBgI0BuYXRpdmUubG9jYXRpb25gXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkxvY2F0aW9uPiIsInNlbGYiLCJpbmNsdWRlIiwiQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlciIsIkJyb3dzZXIiLCJhc3NpZ24iLCJ1cmwiLCJAbmF0aXZlIiwidG9fcyIsInJlcGxhY2UiLCJyZWxvYWQiLCJmb3JjZSIsImFsaWFzX25hdGl2ZSIsImZ1bGxfcGF0aCIsIisiLCJwYXRoIiwicXVlcnkiLCJmcmFnbWVudCIsIjxjbGFzczpXaW5kb3c+IiwibG9jYXRpb24iLCJMb2NhdGlvbiIsIm5ldyIsIjxjbGFzczpET006OkRvY3VtZW50PiIsIkRPTSIsIkRPTTo6RWxlbWVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBS0FDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLGFBQUFELHdCQUFSRDs7QUFLQUcsTUFBQUEsc0JBQUFBLGtCQUFXQyxHQUFYRDtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBRUUsY0FBT0YsUUFBVUMsR0FBR0UsTUFBQUEsQ0FBQUEsQ0FBTUg7TUFEOUJBLENBQUFBLEdBQUFBOztBQU9BSSxNQUFBQSx1QkFBQUEsbUJBQVlILEdBQVpHO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFFRixjQUFPRSxTQUFXSCxHQUFHRSxNQUFBQSxDQUFBQSxDQUFNQztNQUQvQkEsQ0FBQUEsR0FBQUE7O0FBT0FDLE1BQUFBLHNCQUFBQSxrQkFBV0MsS0FBWEQ7QUFBQUEsUUFBQUE7OztRQUFXLDJCQUFRO1FBQ2pCQSxPQUFFSCxjQUFPRztNQURYQSxDQUFBQSxJQUFBQTs7QUFLQUYsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBRUQsY0FBT0M7TUFEWEEsQ0FBQUEsR0FBQUE7TUFNQVAsSUFBQVcsY0FBQUEsQ0FBYSxVQUFiLEVBQXdCLE1BQXhCQTtNQUNBWCxJQUFBVyxjQUFBQSxDQUFhLFdBQWIsRUFBeUIsT0FBekJBO01BSUFYLElBQUFXLGNBQUFBLENBQWEsTUFBYkE7TUFDQVgsSUFBQVcsY0FBQUEsQ0FBYSxPQUFiQTtNQUlBWCxJQUFBVyxjQUFBQSxDQUFhLEtBQWIsRUFBbUIsTUFBbkJBO01BQ0FYLElBQUFXLGNBQUFBLENBQWEsTUFBYixFQUFvQixPQUFwQkE7TUFJQVgsSUFBQVcsY0FBQUEsQ0FBYSxNQUFiLEVBQW9CLFVBQXBCQTtNQUNBWCxJQUFBVyxjQUFBQSxDQUFhLE9BQWIsRUFBcUIsV0FBckJBO01BSUFYLElBQUFXLGNBQUFBLENBQWEsTUFBYkE7TUFDQVgsSUFBQVcsY0FBQUEsQ0FBYSxPQUFiQTtNQUlBWCxJQUFBVyxjQUFBQSxDQUFhLFFBQWIsRUFBc0IsVUFBdEJBO01BQ0FYLElBQUFXLGNBQUFBLENBQWEsU0FBYixFQUF1QixXQUF2QkE7TUFJQVgsSUFBQVcsY0FBQUEsQ0FBYSxPQUFiLEVBQXFCLFFBQXJCQTtNQUNBWCxJQUFBVyxjQUFBQSxDQUFhLFFBQWIsRUFBc0IsU0FBdEJBO01BSUFaLE9BQUFhLHlCQUFBQSxxQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQWFDLFNBQVJBLFNBQUxiLElBQUFjLE1BQUFBLENBQUFBLENBQUtELEVBQUViLElBQUFlLE9BQUFBLENBQUFBLENBQUZGLENBQVFBLEVBQUViLElBQUFnQixVQUFBQSxDQUFBQSxDQUFGSDtNQURmRCxDQUFBQSxHQUFBQTtJQWxFRmIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUF1RUFrQjtJQUFBQTs7TUFBQUE7O0FBQUFBO01BR0VBLE9BQUFDLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0UsSUFBQSxRQUF1Q1osY0FBT1ksU0FBOUMsQ0FBQTtVQUFBQSxPQUFBQyxjQUFRQyxLQUFBQSxDQUFPZCxjQUFPWSxTQUFkRTtRQUFSO1VBaEZKRixPQUFBO1FBZ0ZJO01BREZBLENBQUFBLEdBQUFBO0lBSEZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBUUFuQixPQUFBdUI7SUFBQUE7O01BQUFBOztBQUFBQTtNQUdFQSxPQUFBSCx3QkFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBdUNaLGNBQU9ZLFNBQTlDLENBQUE7VUFBQUEsT0FBQUMsY0FBUUMsS0FBQUEsQ0FBT2QsY0FBT1ksU0FBZEU7UUFBUjtVQXhGSkYsT0FBQTtRQXdGSTtNQURGQSxDQUFBQSxHQUFBQTtJQUhGRyxHQUFNQyxTQUFORCxFQUFzQkUsSUFBQUQsU0FBQUMsWUFBdEJGO0VBcEZBdkIsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4MjEwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9zdG9yYWdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2pzb24nXG5yZXF1aXJlICdzdHJpbmdpbydcblxubW9kdWxlIEJyb3dzZXJcblxuIyBBIHtTdG9yYWdlfSBhbGxvd3MgeW91IHRvIHN0b3JlIGRhdGEgYWNyb3NzIHBhZ2UgbG9hZHMgYW5kIGJyb3dzZXJcbiMgcmVzdGFydHMuXG4jXG4jIENvbXBhdGliaWxpdHlcbiMgLS0tLS0tLS0tLS0tLVxuIyBUaGUgY29tcGF0aWJpbGl0eSBsYXllciB3aWxsIHRyeSB2YXJpb3VzIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nXG4jIG9yZGVyLlxuI1xuIyArIFt3aW5kb3cubG9jYWxTdG9yYWdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9BUEkvRE9NL1N0b3JhZ2UjbG9jYWxTdG9yYWdlKVxuIyArIFt3aW5kb3cuZ2xvYmFsU3RvcmFnZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQVBJL0RPTS9TdG9yYWdlI2dsb2JhbFN0b3JhZ2UpXG4jICsgW2RvY3VtZW50LmJvZHkuYWRkQmVoYXZpb3JdKGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTQyNChWUy44NSkuYXNweClcbiMgKyBbZG9jdW1lbnQuY29va2llXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZG9jdW1lbnQuY29va2llKVxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0FQSS9ET00vU3RvcmFnZVxuIyBAdG9kbyByZW1vdmUgbWV0aG9kX2RlZmluZWQ/IGNoZWNrcyB3aGVuIHJlcXVpcmUgb3JkZXIgaXMgZml4ZWRcbmNsYXNzIFN0b3JhZ2VcbiAgZGVmIHNlbGYuanNvbl9jcmVhdGUoZGF0YSlcbiAgICBkYXRhLmRlbGV0ZShKU09OLmNyZWF0ZV9pZClcblxuICAgIEhhc2hbZGF0YS5tYXAge3xrZXksIHZhbHVlfFxuICAgICAgW0pTT04ucGFyc2Uoa2V5KSwgdmFsdWVdXG4gICAgfV1cbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbmFtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIHN0b3JhZ2VcbiAgYXR0cl9yZWFkZXIgOm5hbWVcblxuICAjIENyZWF0ZSBhIG5ldyBzdG9yYWdlIG9uIHRoZSBnaXZlbiB3aW5kb3cgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgI1xuICAjIEBwYXJhbSB3aW5kb3cgW25hdGl2ZV0gdGhlIHdpbmRvdyB0byBzYXZlIHRoZSBzdG9yYWdlIHRvXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIG5hbWUgdG8gdXNlIHRvIGRpc2Nlcm4gZGlmZmVyZW50IHN0b3JhZ2VzXG4gIGRlZiBpbml0aWFsaXplKHdpbmRvdywgbmFtZSlcbiAgICBzdXBlcigpXG5cbiAgICBAd2luZG93ID0gd2luZG93XG4gICAgQG5hbWUgICA9IG5hbWVcbiAgICBAZGF0YSAgID0ge31cblxuICAgIGF1dG9zYXZlIVxuICAgIHJlbG9hZFxuICBlbmRcblxuICAjIENoZWNrIGlmIGF1dG9zYXZpbmcgaXMgZW5hYmxlZC5cbiAgI1xuICAjIFdoZW4gYXV0b3NhdmluZyBpcyBlbmFibGVkIHRoZSB7U3RvcmFnZX0gaXMgc2F2ZWQgZXZlcnkgdGltZSBhIGNoYW5nZSBpc1xuICAjIG1hZGUsIG90aGVyd2lzZSB5b3UnbGwgaGF2ZSB0byBzYXZlIGl0IG1hbnVhbGx5IHlvdXJzZWxmLlxuICBkZWYgYXV0b3NhdmU/XG4gICAgQGF1dG9zYXZlXG4gIGVuZFxuXG4gICMgRW5hYmxlIGF1dG9zYXZpbmcuXG4gIGRlZiBhdXRvc2F2ZSFcbiAgICBAYXV0b3NhdmUgPSB0cnVlXG4gIGVuZFxuXG4gICMgRGlzYWJsZSBhdXRvc2F2aW5nLlxuICBkZWYgbm9fYXV0b3NhdmUhXG4gICAgQGF1dG9zYXZlID0gZmFsc2VcbiAgZW5kXG5cbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgIyBJdGVyYXRlIG92ZXIgdGhlIChrZXksIHZhbHVlKSBwYWlycyBpbiB0aGUgc3RvcmFnZS5cbiAgI1xuICAjIEB5aWVsZCBba2V5LCB2YWx1ZV1cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgIEBkYXRhLmVhY2goJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcoKmFyZ3MsICZibG9jaylcbiAgICBAZGF0YS5fX3NlbmRfXygqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICAjIFNldCBhIHZhbHVlIGluIHRoZSBzdG9yYWdlLlxuICBkZWYgW109KGtleSwgdmFsdWUpXG4gICAgQGRhdGFba2V5XSA9IHZhbHVlXG5cbiAgICBzYXZlIGlmIGF1dG9zYXZlP1xuICBlbmRcblxuICAjIERlbGV0ZSBhIHZhbHVlIGZyb20gdGhlIHN0b3JhZ2UuXG4gIGRlZiBkZWxldGUoa2V5KVxuICAgIEBkYXRhLmRlbGV0ZShrZXkpLnRhcCB7XG4gICAgICBzYXZlIGlmIGF1dG9zYXZlP1xuICAgIH1cbiAgZW5kXG5cbiAgIyBDbGVhciB0aGUgc3RvcmFnZS5cbiAgZGVmIGNsZWFyXG4gICAgQGRhdGEuY2xlYXIudGFwIHtcbiAgICAgIHNhdmUgaWYgYXV0b3NhdmU/XG4gICAgfVxuICBlbmRcblxuICAjIFJlcGxhY2UgdGhlIGN1cnJlbnQgc3RvcmFnZSB3aXRoIHRoZSBnaXZlbiBvbmUuXG4gICNcbiAgIyBAcGFyYW0gbmV3IFtIYXNoLCBTdHJpbmddIGlmIG5ldyBpcyBhIHtTdHJpbmd9IGl0IHdpbGwgYmUgcGFyc2VkIGFzIEpTT05cbiAgZGVmIHJlcGxhY2UobmV3KVxuICAgIGlmIFN0cmluZyA9PT0gbmV3XG4gICAgICBAZGF0YS5yZXBsYWNlKEpTT04ucGFyc2UobmV3KSlcbiAgICBlbHNlXG4gICAgICBAZGF0YS5yZXBsYWNlKG5ldylcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBDYWxsIHRoZSBibG9jayBiZXR3ZWVuIGEgWyNyZWxvYWRdIGFuZCBbI3NhdmVdLlxuICBkZWYgY29tbWl0KCZibG9jaylcbiAgICBhdXRvc2F2ZSAgPSBAYXV0b3NhdmVcbiAgICBAYXV0b3NhdmUgPSBmYWxzZVxuICAgIHJlc3VsdCAgICA9IG5pbFxuXG4gICAgcmVsb2FkXG5cbiAgICBiZWdpblxuICAgICAgcmVzdWx0ID0gYmxvY2suY2FsbFxuICAgICAgc2F2ZVxuICAgIHJlc2N1ZVxuICAgICAgcmVsb2FkXG4gICAgICByYWlzZVxuICAgIGVuc3VyZVxuICAgICAgQGF1dG9zYXZlID0gYXV0b3NhdmVcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIEBkYXRhXG4gIGVuZFxuXG4gICMgQCFtZXRob2QgcmVsb2FkXG4gICMgICBMb2FkIHRoZSBzdG9yYWdlLlxuXG4gICMgQCFtZXRob2Qgc2F2ZVxuICAjICAgUGVyc2lzdCB0aGUgY3VycmVudCBzdGF0ZSB0byB0aGUgc3RvcmFnZS5cblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnU3RvcmFnZS5sb2NhbCdcbiAgICBkZWYgcmVsb2FkXG4gICAgICByZXBsYWNlIGAjQHdpbmRvdy5sb2NhbFN0b3JhZ2VbI0BuYW1lXSB8fCAne30nYFxuICAgIGVuZFxuXG4gICAgZGVmIHNhdmVcbiAgICAgIGAjQHdpbmRvdy5sb2NhbFN0b3JhZ2VbI0BuYW1lXSA9ICN7SlNPTi5kdW1wKHNlbGYpfWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ1N0b3JhZ2UuZ2xvYmFsJ1xuICAgIGRlZiByZWxvYWRcbiAgICAgIHJlcGxhY2UgYCNAd2luZG93Lmdsb2JhbFN0b3JhZ2VbI0B3aW5kb3cubG9jYXRpb24uaG9zdG5hbWVdWyNAbmFtZV0gfHwgJ3t9J2BcbiAgICBlbmRcblxuICAgIGRlZiBzYXZlXG4gICAgICBgI0B3aW5kb3cuZ2xvYmFsU3RvcmFnZVsjQHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZV1bI0BuYW1lXSA9ICN7SlNPTi5kdW1wKHNlbGYpfWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQuYWRkQmVoYXZpb3InXG4gICAgZGVmIHJlbG9hZFxuICAgICAgJXh7XG4gICAgICAgICNAZWxlbWVudCA9ICNAd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgI0BlbGVtZW50LmFkZEJlaGF2aW9yKCcjZGVmYXVsdCN1c2VyRGF0YScpO1xuXG4gICAgICAgICNAd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoI0BlbGVtZW50KTtcblxuICAgICAgICAjQGVsZW1lbnQubG9hZCgjQG5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXBsYWNlIGAjQGVsZW1lbnQuZ2V0QXR0cmlidXRlKCNAbmFtZSkgfHwgJ3t9J2BcbiAgICBlbmRcblxuICAgIGRlZiBzYXZlXG4gICAgICAleHtcbiAgICAgICAgI0BlbGVtZW50LnNldEF0dHJpYnV0ZSgjQG5hbWUsICN7SlNPTi5kdW1wKHNlbGYpfSk7XG4gICAgICAgICNAZWxlbWVudC5zYXZlKCNAbmFtZSk7XG4gICAgICB9XG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgcmVsb2FkXG4gICAgICAkZG9jdW1lbnQuY29va2llcy5vcHRpb25zIGV4cGlyZXM6IDYwICogNjAgKiAyNCAqIDM2NVxuXG4gICAgICByZXBsYWNlICRkb2N1bWVudC5jb29raWVzW0BuYW1lXVxuICAgIGVuZFxuXG4gICAgZGVmIHNhdmVcbiAgICAgICRkb2N1bWVudC5jb29raWVzW0BuYW1lXSA9IEpTT04uZHVtcChzZWxmKVxuICAgIGVuZFxuICBlbmRcblxuICAjIENvbnZlcnQgdGhlIHN0b3JhZ2UgdG8gSlNPTi5cbiAgI1xuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIEpTT04gcmVwcmVzZW50YXRpb25cbiAgZGVmIHRvX2pzb25cbiAgICBpbyA9IFN0cmluZ0lPLm5ldyA8PCBcIntcIlxuXG4gICAgaW8gPDwgSlNPTi5jcmVhdGVfaWQudG9fanNvbiA8PCBcIjpcIiA8PCBzZWxmLmNsYXNzLm5hbWUudG9fanNvbiA8PCBcIixcIlxuXG4gICAgQGRhdGEuZWFjaCB7fGtleSwgdmFsdWV8XG4gICAgICBpbyA8PCBrZXkudG9fanNvbi50b19zIDw8IFwiOlwiIDw8IHZhbHVlLnRvX2pzb24gPDwgXCIsXCJcbiAgICB9XG5cbiAgICBpby5zZWVrKC0xLCBJTzo6U0VFS19DVVIpXG4gICAgaW8gPDwgXCJ9XCJcblxuICAgIGlvLnN0cmluZ1xuICBlbmRcbmVuZFxuXG4jIEEge1Nlc3Npb25TdG9yYWdlfSBhbGxvd3MgeW91IHRvIHN0b3JlIGRhdGEgYWNyb3NzIHBhZ2UgcmVsb2FkcywgYXMgbG9uZyBhcyB0aGUgc2Vzc2lvblxuIyBpcyBhY3RpdmUuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQVBJL0RPTS9TdG9yYWdlI3Nlc3Npb25TdG9yYWdlXG5jbGFzcyBTZXNzaW9uU3RvcmFnZSA8IFN0b3JhZ2VcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdTdG9yYWdlLnNlc3Npb24nXG4gIGVuZFxuXG4gIGRlZiByZWxvYWRcbiAgICByZXBsYWNlIGAjQHdpbmRvdy5zZXNzaW9uU3RvcmFnZVsjQG5hbWVdIHx8ICd7fSdgXG4gIGVuZFxuXG4gIGRlZiBzYXZlXG4gICAgYCNAd2luZG93LnNlc3Npb25TdG9yYWdlWyNAbmFtZV0gPSAje0pTT04uZHVtcChzZWxmKX1gXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFdpbmRvd1xuICAjIEdldCBhIHN0b3JhZ2Ugd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgI1xuICAjIEBwYXJhbSBuYW1lIFtTeW1ib2xdIHRoZSBuYW1lIG9mIHRoZSBzdG9yYWdlXG4gICNcbiAgIyBAcmV0dXJuIFtTdG9yYWdlXVxuICBkZWYgc3RvcmFnZShuYW1lID0gOmRlZmF1bHQpXG4gICAgU3RvcmFnZS5uZXcodG9fbiwgbmFtZSlcbiAgZW5kXG5cbiAgIyBHZXQgYSBzZXNzaW9uIHN0b3JhZ2Ugd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgI1xuICAjIEBwYXJhbSBuYW1lIFtTeW1ib2xdIHRoZSBuYW1lIG9mIHRoZSBzdG9yYWdlXG4gICNcbiAgIyBAcmV0dXJuIFtTZXNzaW9uU3RvcmFnZV1cbiAgZGVmIHNlc3Npb25fc3RvcmFnZShuYW1lID0gOmRlZmF1bHQpXG4gICAgU2Vzc2lvblN0b3JhZ2UubmV3KHRvX24sIG5hbWUpXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6U3RvcmFnZT4iLCJqc29uX2NyZWF0ZSIsImRhdGEiLCJkZWxldGUiLCJKU09OIiwiY3JlYXRlX2lkIiwiSGFzaCIsIltdIiwibWFwIiwiYmxvY2sgaW4ganNvbl9jcmVhdGUiLCJrZXkiLCJ2YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4ganNvbl9jcmVhdGUiLCJwYXJzZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIndpbmRvdyIsIm5hbWUiLCJAd2luZG93IiwiQG5hbWUiLCJAZGF0YSIsImF1dG9zYXZlISIsInJlbG9hZCIsImF1dG9zYXZlPyIsIm5vX2F1dG9zYXZlISIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiZWFjaCIsImJsb2NrIiwiZW51bV9mb3IiLCJ0b19wcm9jIiwibWV0aG9kX21pc3NpbmciLCJfX3NlbmRfXyIsImFyZ3MiLCJbXT0iLCJzYXZlIiwidGFwIiwiYmxvY2sgaW4gZGVsZXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGUiLCJjbGVhciIsImJsb2NrIGluIGNsZWFyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjbGVhciIsInJlcGxhY2UiLCJuZXckIiwiU3RyaW5nIiwiY29tbWl0IiwiYXV0b3NhdmUiLCJAYXV0b3NhdmUiLCJyZXN1bHQiLCJjYWxsIiwiU3RhbmRhcmRFcnJvciIsInJhaXNlIiwidG9faCIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJkdW1wIiwiQGVsZW1lbnQiLCIkZG9jdW1lbnQiLCJjb29raWVzIiwib3B0aW9ucyIsIioiLCI2MCIsIjI0IiwiMzY1IiwidG9fanNvbiIsImlvIiwiU3RyaW5nSU8iLCJuZXciLCI8PCIsImNsYXNzIiwiYmxvY2sgaW4gdG9fanNvbiIsImJsb2NrICgyIGxldmVscykgaW4gdG9fanNvbiIsInRvX3MiLCJzZWVrIiwiLTEiLCJJTzo6U0VFS19DVVIiLCJJTyIsInN0cmluZyIsIjxjbGFzczpTZXNzaW9uU3RvcmFnZT4iLCJzdXBwb3J0ZWQ/IiwiU3RvcmFnZSIsIjxjbGFzczpXaW5kb3c+Iiwic3RvcmFnZSIsInRvX24iLCJzZXNzaW9uX3N0b3JhZ2UiLCJTZXNzaW9uU3RvcmFnZSJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixNQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixVQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQWlCQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDRUMsTUFBSUosSUFBSkksa0JBQUFBLHVCQUFxQkMsSUFBckJEO0FBQUFBOztRQUNFQyxJQUFJQyxRQUFBQSxDQUFRQyxVQUFJQyxXQUFBQSxDQUFBQSxDQUFaRjtRQUVKRixPQUFBSyxVQUFJQyxPQUFBQSxDQUFLQyxNQUFKTixJQUFJTSxPQUFBQSxFQUFBQSxFQUFBQSxFQUFKQyxhQUFXQyxHQUFELEVBQU1DLEtBQWhCRjs7VUFBVztVQUFLO1VBQ25CRyxPQUFBLENBQUNSLFVBQUlTLE9BQUFBLENBQU9ILEdBQVBHLENBQUwsRUFBa0JGLEtBQWxCLEVBREdGLENBQUFBLEdBQUlELENBQUxEO01BSE5OLENBQUFBLEdBQUFBO01BVUFKLElBQUFpQixhQUFBQSxDQUFZLE1BQVpBOztBQU1BQyxNQUFBQSwwQkFBQUEsc0JBQWVDLE1BQUQsRUFBU0MsSUFBdkJGO0FBQUFBLFFBQUFBOztRQUFBQTs7UUFDRSxPQUFBbEIsSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxFQUFBLEVBQUEsSUFBQTtRQUVBcUIsY0FBVUY7UUFDVkcsWUFBVUY7UUFDVkcsWUFBVSxZQUFBO1FBRVZ2QixJQUFBd0IsY0FBQUEsQ0FBQUE7UUFDQU4sT0FBQWxCLElBQUF5QixRQUFBQSxDQUFBQTtNQVJGUCxDQUFBQSxHQUFBQTs7QUFlQVEsTUFBQUEseUJBQUFBLGFBQ0UsVUFERkEsQ0FBQUEsR0FBQUE7O0FBS0FGLE1BQUFBLHlCQUFBQSxpQkFDRSxVQURGQSxFQUNjLElBRGRBLENBQUFBLEdBQUFBOztBQUtBRyxNQUFBQSw0QkFBQUEsaUJBQ0UsVUFERkEsRUFDYyxLQURkQSxDQUFBQSxHQUFBQTtNQUlBM0IsSUFBQTRCLFNBQUFBLENBQVFDLGdCQUFSRDs7QUFLQUUsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNFLEtBQUEsUUFBNkJDLEtBQTdCLENBQUE7VUFBQSxPQUFPL0IsSUFBQWdDLFVBQUFBLENBQVMsTUFBVEE7UUFBUDtRQUVLRixNQUFMUCxTQUFLTyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFPQyxLQUFERSxTQUFBQSxDQUFBQSxDQUFOSDtRQUVMQSxPQUFBOUI7TUFMRjhCLENBQUFBLEdBQUFBOztBQVFBSSxNQUFBQSw4QkFBQUEsMEJBL0VGLEVBK0VFQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQS9FRjtRQStFcUI7UUFDakJBLE9BQUtDLE1BQUxaLFNBQUtZLFlBQUFBLEVBQVUsTUFBQ0MsSUFBRCxDQUFWRCxFQUFrQkosS0FBREUsU0FBQUEsQ0FBQUEsQ0FBakJFO01BRFBELENBQUFBLElBQUFBOztBQUtBRyxNQUFBQSxtQkFBQUEsMEJBQVF4QixHQUFELEVBQU1DLEtBQWJ1QjtBQUFBQSxRQUFBQTs7O1FBQ0VkLFNBQUtjLFFBQUFBLENBQUN4QixHQUFOLEVBQWFDLEtBQVJ1QjtRQUVMLElBQUEsUUFBUXJDLElBQUEwQixjQUFBQSxDQUFBQSxDQUFSLENBQUE7VUFBQVcsT0FBQXJDLElBQUFzQyxNQUFBQSxDQUFBQTtRQUFBO1VBdkZKRCxPQUFBO1FBdUZJO01BSEZBLENBQUFBLEdBQUFBOztBQU9BL0IsTUFBQUEsc0JBQUFBLDJCQUFXTyxHQUFYUDtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBaUJpQyxNQUFqQmhCLFNBQUtqQixRQUFBQSxDQUFRTyxHQUFSUCxDQUFZaUMsT0FBQUEsRUFBQUEsRUFBQUEsRUFBakJDLGFBQUFBLEVBQUFDOztVQUNFLElBQUEsUUFBUXpDLElBQUEwQixjQUFBQSxDQUFBQSxDQUFSLENBQUE7WUFBQWUsT0FBQXpDLElBQUFzQyxNQUFBQSxDQUFBQTtVQUFBO1lBN0ZORyxPQUFBO1VBNkZNLENBREZELENBQUFBLEdBQUFBLHFCQUFBQSxDQUFpQkQ7TUFEbkJqQyxDQUFBQSxHQUFBQTs7QUFPQW9DLE1BQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQVdILE1BQVhoQixTQUFLbUIsT0FBQUEsQ0FBQUEsQ0FBTUgsT0FBQUEsRUFBQUEsRUFBQUEsRUFBWEksYUFBQUEsRUFBQUM7O1VBQ0UsSUFBQSxRQUFRNUMsSUFBQTBCLGNBQUFBLENBQUFBLENBQVIsQ0FBQTtZQUFBa0IsT0FBQTVDLElBQUFzQyxNQUFBQSxDQUFBQTtVQUFBO1lBcEdOTSxPQUFBO1VBb0dNLENBREZELENBQUFBLEdBQUFBLHFCQUFBQSxDQUFXSjtNQURiRyxDQUFBQSxHQUFBQTs7QUFTQUcsTUFBQUEsdUJBQUFBLG1CQUFZQyxJQUFaRDtBQUFBQSxRQUFBQTs7UUFDRSxJQUFBLFFBQUdFLFlBQUgsRUFBY0QsSUFBZCxDQUFBO1VBQ0VELE9BQUF0QixTQUFLc0IsU0FBQUEsQ0FBU3RDLFVBQUlTLE9BQUFBLENBQU84QixJQUFQOUIsQ0FBYjZCO1FBRFA7VUFHRUEsT0FBQXRCLFNBQUtzQixTQUFBQSxDQUFTQyxJQUFURDtRQUhQO01BREZBLENBQUFBLEdBQUFBOztBQVNBRyxNQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0VDLFdBQVlDO1FBQ1pBLGdCQUFZO1FBQ1pDLFNBQVk7UUFFWm5ELElBQUF5QixRQUFBQSxDQUFBQTs7UUFHRTtRQUFBOztVQUFBMEIsU0FBU3BCLEtBQUtxQixNQUFBQSxDQUFBQTtVQUNkcEQsSUFBQXNDLE1BQUFBLENBQUFBO1FBREE7VUFFRixzQkFBQSxDQUFBZSxtQkFBQSxDQUFBO1lBQUE7O2NBQ0VyRCxJQUFBeUIsUUFBQUEsQ0FBQUE7Y0FDQXpCLElBQUFzRCxPQUFBQSxDQUFBQTtZQUZGO1VBQUEsQ0FGRTtRQUFBO1FBQUE7VUFNQUosZ0JBQVlEO1FBTlo7UUFTRkQsT0FBQUc7TUFqQkZILENBQUFBLEdBQUFBOztBQW9CQU8sTUFBQUEsb0JBQUFBLGFBQ0UsTUFERkEsQ0FBQUEsR0FBQUE7TUFVQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVd0RCxlQUFYc0QsQ0FBVixDQUFBOzs7QUFDRWhDLFFBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUF6QixJQUFBNkMsU0FBQUEsQ0FBVXhCLFdBQU9JLGNBQWVILFNBQUtHLFNBQXJDb0I7UUFERnBCLENBQUFBLEdBQUFBOztBQUlBYSxRQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFakIsV0FBT2lCLGNBQWVoQixTQUFLZ0IsSUFBTS9CLFVBQUltRCxNQUFBQSxDQUFNMUQsSUFBTjBEO1FBRHpDcEIsQ0FBQUEsR0FBQUE7TUFMRixPQVFBLElBQUEsUUFBTWtCLGFBQU9DLGNBQUFBLENBQVd0RCxnQkFBWHNELENBQWIsQ0FBQTs7O0FBQ0VoQyxRQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBekIsSUFBQTZDLFNBQUFBLENBQVV4QixXQUFPSSxlQUFnQkosV0FBT0ksb0JBQXFCSCxTQUFLRyxTQUFsRW9CO1FBREZwQixDQUFBQSxHQUFBQTs7QUFJQWEsUUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRWpCLFdBQU9pQixlQUFnQmpCLFdBQU9pQixvQkFBcUJoQixTQUFLZ0IsSUFBTS9CLFVBQUltRCxNQUFBQSxDQUFNMUQsSUFBTjBEO1FBRHRFcEIsQ0FBQUEsR0FBQUE7TUFMRixPQVFBLElBQUEsUUFBTWtCLGFBQU9DLGNBQUFBLENBQVd0RCxxQkFBWHNELENBQWIsQ0FBQTs7O0FBQ0VoQyxRQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOzs7O0FBRUpBLFFBQVNrQyxZQUFRbEMsR0FBSUosV0FBT0k7QUFDNUJBLFFBQVNrQyxZQUFRbEM7O0FBRWpCQSxRQUFTSixXQUFPSSxzREFBdURrQyxZQUFRbEM7O0FBRS9FQSxRQUFTa0MsWUFBUWxDLE1BQU9ILFNBQUtHO0FBQzdCQTtVQUVNQSxPQUFBekIsSUFBQTZDLFNBQUFBLENBQVVjLFlBQVFsQyxjQUFlSCxTQUFLRyxTQUF0Q29CO1FBVkZwQixDQUFBQSxHQUFBQTs7QUFhQWEsUUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7O0FBRUpBLFFBQVNxQixZQUFRckIsY0FBZWhCLFNBQUtnQixFQUFJL0IsVUFBSW1ELE1BQUFBLENBQU0xRCxJQUFOMEQsQ0FBWXBCO0FBQ3pEQSxRQUFTcUIsWUFBUXJCLE1BQU9oQixTQUFLZ0I7QUFDN0JBO1FBSklBLENBQUFBLEdBQUFBO01BZEY7OztBQXFCRWIsUUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxVQUFBQTtBQUFBQTs7O1VBQ0VtQyxlQUFTQyxTQUFBQSxDQUFBQSxDQUFRQyxTQUFBQSxDQUFTLHFCQUFBLFdBQXNCQyxVQUFMQSxVQUFMQSxVQUFIQyxFQUFHRCxFQUFFQyxFQUFGRCxDQUFLQSxFQUFFRSxFQUFGRixDQUFLQSxFQUFFRyxHQUFGSCxDQUF0QixFQUFURDtVQUVqQnJDLE9BQUF6QixJQUFBNkMsU0FBQUEsQ0FBUWUsZUFBU0MsU0FBQUEsQ0FBQUEsQ0FBUW5ELE9BQUFBLENBQUNZLFNBQURaLENBQXpCbUM7UUFIRnBCLENBQUFBLEdBQUFBOztBQU1BYSxRQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFVBQUFBO0FBQUFBOztVQUNFQSxPQUFpQkQsTUFBQUEsQ0FBQ2YsU0FBbEIsRUFBMkJmLFVBQUltRCxNQUFBQSxDQUFNMUQsSUFBTjBELENBQWRyQixDQUFBQSxFQUFBQSxNQUFqQnVCLGVBQVNDLFNBQUFBLENBQUFBLENBQVF4QixPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtRQURuQkMsQ0FBQUEsR0FBQUE7TUEzQkY7TUFtQ0FuQyxPQUFBZ0UsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7O1FBQ0VDLEtBQUtDLGNBQVFDLEtBQUFBLENBQUFBLENBQUtDLE9BQUFBLENBQUdKLEdBQUhJO1FBRWxCSCxFQUFHRyxPQUFBQSxDQUFHaEUsVUFBSUMsV0FBQUEsQ0FBQUEsQ0FBVTJELFNBQUFBLENBQUFBLENBQWpCSSxDQUEwQkEsT0FBQUEsQ0FBR0osR0FBSEksQ0FBT0EsT0FBQUEsQ0FBR3ZFLElBQUl3RSxPQUFBQSxDQUFBQSxDQUFNcEQsTUFBQUEsQ0FBQUEsQ0FBSytDLFNBQUFBLENBQUFBLENBQWxCSSxDQUEyQkEsT0FBQUEsQ0FBR0osR0FBSEk7UUFFMUR6QyxNQUFMUCxTQUFLTyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFMMkMsYUFBYTVELEdBQUQsRUFBTUMsS0FBbEIyRDs7VUFBYTtVQUFLO1VBQ2hCQyxPQUFBTixFQUFHRyxPQUFBQSxDQUFHMUQsR0FBR3NELFNBQUFBLENBQUFBLENBQVFRLE1BQUFBLENBQUFBLENBQWRKLENBQW9CQSxPQUFBQSxDQUFHRyxHQUFISCxDQUFPQSxPQUFBQSxDQUFHekQsS0FBS3FELFNBQUFBLENBQUFBLENBQVJJLENBQWlCQSxPQUFBQSxDQUFHRyxHQUFISCxFQURqREUsQ0FBQUEsR0FBSzNDO1FBSUxzQyxFQUFFUSxNQUFBQSxDQUFNQyxFQUFSLEVBQVlDLElBQUFDLFFBQUFELGFBQVZGO1FBQ0ZSLEVBQUdHLE9BQUFBLENBQUdKLEdBQUhJO1FBRUhKLE9BQUFDLEVBQUVZLFFBQUFBLENBQUFBO01BWkpiLENBQUFBLEdBQUFBO0lBakxGaEUsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFxTUE4RTtJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxNQUFJbEYsSUFBSmtGLGlCQUFBQSwwQ0FBQUE7QUFBQUE7UUFDRUEsT0FBQTFCLGFBQU9DLGNBQUFBLENBQVd5QixpQkFBWHpCO01BRFR5QixDQUFBQSxHQUFBQTs7QUFJQXpELE1BQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUF6QixJQUFBNkMsU0FBQUEsQ0FBVXhCLFdBQU9JLGdCQUFpQkgsU0FBS0csU0FBdkNvQjtNQURGcEIsQ0FBQUEsR0FBQUE7TUFJQXdELE9BQUEzQyxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFFakIsV0FBT2lCLGdCQUFpQmhCLFNBQUtnQixJQUFNL0IsVUFBSW1ELE1BQUFBLENBQU0xRCxJQUFOMEQ7TUFEM0NwQixDQUFBQSxHQUFBQTtJQVRGMkMsR0FBQUEsV0FBQUEsRUFBdUJFLGFBQXZCRjtJQWNBL0UsT0FBQWtGO0lBQUFBOztNQUFBQTs7OztBQU1FQyxNQUFBQSx1QkFBQUEsbUJBQVlqRSxJQUFaaUU7QUFBQUEsUUFBQUE7OztRQUFZLHlCQUFPO1FBQ2pCQSxPQUFBRixhQUFPYixLQUFBQSxDQUFLdEUsSUFBQXNGLE1BQUFBLENBQUFBLENBQVosRUFBa0JsRSxJQUFYa0Q7TUFEVGUsQ0FBQUEsSUFBQUE7TUFTQUQsT0FBQUcsK0JBQUFBLDJCQUFvQm5FLElBQXBCbUU7QUFBQUEsUUFBQUE7OztRQUFvQix5QkFBTztRQUN6QkEsT0FBQUMsb0JBQWNsQixLQUFBQSxDQUFLdEUsSUFBQXNGLE1BQUFBLENBQUFBLENBQW5CLEVBQXlCbEUsSUFBWGtEO01BRGhCaUIsQ0FBQUEsSUFBQUE7SUFmRkgsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFwT0FsRixHQUFBQSxXQUFBQTtBQUhBSDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg1MDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L21lc3NhZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnVmZmVyJ1xuXG5tb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgTWVzc2FnZSA8IEV2ZW50XG4gIGhhbmRsZXMgJ21lc3NhZ2UnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5NZXNzYWdlJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBkYXRhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kYXRhID0gdmFsdWVgXG4gICAgZW5kXG5cbiAgICBkZWYgb3JpZ2luPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5vcmlnaW4gPSB2YWx1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBzb3VyY2U9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnNvdXJjZSA9ICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBNZXNzYWdlRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNZXNzYWdlRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0TWVzc2FnZUV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLmRhdGEsIGRlc2Mub3JpZ2luLCBcIlwiLCBkZXNjLnNvdXJjZSB8fCB3aW5kb3cpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBkZWYgZGF0YVxuICAgICV4e1xuICAgICAgaWYgKHdpbmRvdy5BcnJheUJ1ZmZlciAmJiAjQG5hdGl2ZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuICN7QnVmZmVyLm5ldyhgI0BuYXRpdmUuZGF0YWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHdpbmRvdy5CbG9iICYmICNAbmF0aXZlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiAje0Jsb2IubmV3KGAjQG5hdGl2ZS5kYXRhYCl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjQG5hdGl2ZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDpvcmlnaW5cblxuICBkZWYgc291cmNlXG4gICAgJXh7XG4gICAgICB2YXIgc291cmNlID0gI0BuYXRpdmUuc291cmNlO1xuXG4gICAgICBpZiAod2luZG93LldpbmRvdyAmJiBzb3VyY2UgaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSB7XG4gICAgICAgIHJldHVybiAje1dpbmRvdy5uZXcoYHNvdXJjZWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpNZXNzYWdlPiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImRhdGE9IiwidmFsdWUiLCJAbmF0aXZlIiwib3JpZ2luPSIsInNvdXJjZT0iLCJOYXRpdmUiLCJjb252ZXJ0IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiZGF0YSIsIkJ1ZmZlciIsIm5ldyIsIkJsb2IiLCJhbGlhc19uYXRpdmUiLCJzb3VyY2UiLCJXaW5kb3ciLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixRQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFSixJQUFBSyxTQUFBQSxDQUFRRCxTQUFSQztRQUVBQyxNQUFJTixJQUFKTSxpQkFBQUEsbUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGVBQVhFO1FBRFRGLENBQUFBLEdBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxxQkFBQUEsK0JBQVVDLEtBQVZEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRjtVQURYQSxDQUFBQSxHQUFBQTs7QUFJQUcsVUFBQUEsdUJBQUFBLGlDQUFZRixLQUFaRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0M7VUFEWEEsQ0FBQUEsR0FBQUE7VUFJQUosT0FBQUssdUJBQUFBLGlDQUFZSCxLQUFaRztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUYsY0FBT0UsVUFBWUMsWUFBTUMsU0FBQUEsQ0FBU0wsS0FBVEs7VUFEN0JGLENBQUFBLEdBQUFBO1FBVEZMLEdBQUFBLFdBQUFBLEVBQW1CUSxnQkFBbkJSO1FBY0EsSUFBQSxRQWNPVCxJQUFBTSxlQUFBQSxDQUFBQSxDQWRQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdKLG1CQUFYSSxDQUFWLENBQUE7WUFDRVUsTUFBSWxCLElBQUprQixnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxpQkFBbUJDLElBQUtELEVBQUlFLElBQUtGO1lBRHBDQSxDQUFBQSxHQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNWCxhQUFPQyxjQUFBQSxDQUFXSixjQUFYSSxDQUFiLENBQUE7WUFDRVUsTUFBSWxCLElBQUprQixnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUElBLENBQUFBLEdBQUFBO1VBREY7UUFKQTs7QUFnQkFHLFFBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7OztBQUVGQSxnQ0FBaUNULGNBQU9TO0FBQ3hDQSxlQUFpQkMsWUFBTUMsS0FBQUEsQ0FBT1gsY0FBT1MsS0FBZEUsQ0FBc0JGO0FBQzdDQTtBQUNBQSw4QkFBK0JULGNBQU9TO0FBQ3RDQSxlQUFpQkcsVUFBSUQsS0FBQUEsQ0FBT1gsY0FBT1MsS0FBZEUsQ0FBc0JGO0FBQzNDQTtBQUNBQTtBQUNBQSxlQUFnQlQsY0FBT1M7QUFDdkJBO0FBQ0FBO1FBWEVBLENBQUFBLEdBQUFBO1FBY0FyQixJQUFBeUIsY0FBQUEsQ0FBYSxRQUFiQTtRQUVBckIsT0FBQXNCLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7OztBQUVGQSxtQkFBb0JkLGNBQU9jOztBQUUzQkE7QUFDQUEsZUFBaUJDLFlBQU1KLEtBQUFBLENBQU1HLE1BQU5ILENBQWVHO0FBQ3RDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtRQVZFQSxDQUFBQSxHQUFBQTtNQXJERnRCLEdBQUFBLFdBQUFBLEVBQWdCd0IsV0FBaEJ4QjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODYwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZ2FtZXBhZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgR2FtZXBhZCA8IEV2ZW50XG4gIGhhbmRsZXMgJ2dhbWVwYWRjb25uZWN0ZWQnLCAnZ2FtZXBhZGRpc2Nvbm5lY3RlZCdcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkdhbWVwYWQnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGlkPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5pZCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGluZGV4PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5pbmRleCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGF0PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS50aW1lc3RhbXAgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBheGVzPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5heGVzID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgYnV0dG9ucz0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYnV0dG9ucyA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgcmV0dXJuIG5ldyBHYW1lcGFkRXZlbnQoI3tuYW1lfSwge1xuICAgICAgICBidWJibGVzOiAgICBkZXNjLmJ1YmJsZXMsXG4gICAgICAgIGNhbmNlbGFibGU6IGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgZ2FtZXBhZDogICAgZGVzYyB9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBkZWYgaWRcbiAgICBgI0BuYXRpdmUuZ2FtZXBhZC5pZGBcbiAgZW5kXG5cbiAgZGVmIGluZGV4XG4gICAgYCNAbmF0aXZlLmdhbWVwYWQuaW5kZXhgXG4gIGVuZFxuXG4gIGRlZiBhdFxuICAgIGAjQG5hdGl2ZS5nYW1lcGFkLnRpbWVzdGFtcGBcbiAgZW5kXG5cbiAgZGVmIGF4ZXNcbiAgICBgI0BuYXRpdmUuZ2FtZXBhZC5heGVzYFxuICBlbmRcblxuICBkZWYgYnV0dG9uc1xuICAgIGAjQG5hdGl2ZS5nYW1lcGFkLmJ1dHRvbnNgXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkdhbWVwYWQ+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImlkPSIsInZhbHVlIiwiQG5hdGl2ZSIsImluZGV4PSIsImF0PSIsImF4ZXM9IiwiYnV0dG9ucz0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJpZCIsImluZGV4IiwiYXQiLCJheGVzIiwiYnV0dG9ucyIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsa0JBQVIsRUFBNEJBLHFCQUE1QkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLG1DQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixlQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsbUJBQUFBLDZCQUFRQyxLQUFSRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsTUFBUUM7VUFEbkJELENBQUFBLEdBQUFBOztBQUlBRyxVQUFBQSxzQkFBQUEsZ0NBQVdGLEtBQVhFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxTQUFXRjtVQUR0QkUsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLG1CQUFBQSw2QkFBUUgsS0FBUkc7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FLGFBQWVIO1VBRDFCRyxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEscUJBQUFBLCtCQUFVSixLQUFWSTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0csUUFBVUo7VUFEckJJLENBQUFBLEdBQUFBO1VBSUFOLE9BQUFPLHdCQUFBQSxrQ0FBYUwsS0FBYks7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVKLGNBQU9JLFdBQWFMO1VBRHhCSyxDQUFBQSxHQUFBQTtRQWpCRlAsR0FBQUEsV0FBQUEsRUFBbUJRLGdCQUFuQlI7UUFzQkEsSUFBQSxRQU9PTCxJQUFBRSxlQUFBQSxDQUFBQSxDQVBQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRVUsTUFBSWQsSUFBSmMsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDR0Esd0JBQTBCQyxJQUFLRDtBQUN0Q0E7QUFDQUE7QUFDQUE7WUFKSUEsQ0FBQUEsR0FBQUE7VUFERjtRQUFBOztBQVNBRyxRQUFBQSxrQkFBQUEsY0FBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVULGNBQU9TO1FBRFhBLENBQUFBLEdBQUFBOztBQUlBQyxRQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFVixjQUFPVTtRQURYQSxDQUFBQSxHQUFBQTs7QUFJQUMsUUFBQUEsa0JBQUFBLGNBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFWCxjQUFPVztRQURYQSxDQUFBQSxHQUFBQTs7QUFJQUMsUUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRVosY0FBT1k7UUFEWEEsQ0FBQUEsR0FBQUE7UUFJQXJCLE9BQUFzQix1QkFBQUEsbUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFYixjQUFPYTtRQURYQSxDQUFBQSxHQUFBQTtNQXRERnRCLEdBQUFBLFdBQUFBLEVBQWdCdUIsV0FBaEJ2QjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODcxNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvYmxvYi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlclxuXG5jbGFzcyBCbG9iXG4gIGluY2x1ZGUgTmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gICMgQ3JlYXRlIGEgbmV3IGJsb2IgZnJvbSBhbnl0aGluZyB0aGF0IEJsb2IgQVBJIHN1cHBvcnRzXG4gIGRlZiBzZWxmLmNyZWF0ZShmcm9tLCBvcHRpb25zPXt9KVxuICAgIG5ldyhgbmV3IEJsb2IoI3tOYXRpdmUuY29udmVydChmcm9tKX0sICN7b3B0aW9ucy50b19ufSlgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBzaXplXG4gICMgQHJldHVybiBbSW50ZWdlcl0gYmxvYiBzaXplIGluIGJ5dGVzXG4gIGRlZiBzaXplXG4gICAgYCNAbmF0aXZlLnNpemVgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHR5cGVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIGJsb2IgbWltZSB0eXBlXG4gIGRlZiB0eXBlXG4gICAgYCNAbmF0aXZlLnR5cGVgXG4gIGVuZFxuXG4gICMgQ29udmVydCBhIGJsb2IgdG8gYSBVVEYtOCBlbmNvZGVkIHN0cmluZy5cbiAgI1xuICAjIElmIGJsb2NrIGlzIGdpdmVuIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJhbWV0ZXIgb25jZSB3ZSByZWNlaXZlXG4gICMgdGhlIHRleHQuIE90aGVyd2lzZSByZXR1cm4gYSB7UHJvbWlzZX0gd2hpY2ggd2lsbCByZXNvbHZlIG9uY2Ugd2VcbiAgIyByZWNlaXZlIGl0LlxuICBkZWYgdGV4dCgmYmxvY2spXG4gICAgcHJvbWlzZSA9IG5pbFxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuICAgICAgYmxvY2sgPSBwcm9jIHsgfGl8IHByb21pc2UucmVzb2x2ZShpKSB9XG4gICAgZW5kXG4gICAgYCNAbmF0aXZlLnRleHQoKS50aGVuKCN7YmxvY2sudG9fbn0pYFxuICAgIHByb21pc2VcbiAgZW5kXG5cbiAgIyB7QnVmZmVyfSB2aWV3IGludG8gdGhlIGJsb2JcbiAgI1xuICAjIElmIGJsb2NrIGlzIGdpdmVuIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJhbWV0ZXIgb25jZSB3ZSByZWNlaXZlXG4gICMgdGhlIGJ1ZmZlci4gT3RoZXJ3aXNlIHJldHVybiBhIHtQcm9taXNlfSB3aGljaCB3aWxsIHJlc29sdmUgb25jZSB3ZVxuICAjIHJlY2VpdmUgaXQuXG4gIGRlZiBidWZmZXJcbiAgICBwcm9taXNlID0gbmlsXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4gICAgICBibG9jayA9IHByb2MgeyB8aXwgcHJvbWlzZS5yZXNvbHZlKGkpIH1cbiAgICBlbmRcbiAgICByZXNibG9jayA9IHByb2MgeyB8aXwgYmxvY2suY2FsbChCdWZmZXIubmV3KGkpKSB9XG4gICAgYCNAbmF0aXZlLmFycmF5QnVmZmVyKCkudGhlbigje3Jlc2Jsb2NrLnRvX259KWBcbiAgICBwcm9taXNlXG4gIGVuZFxuXG4gICMgQ3JlYXRlIGEgbmV3IGJsb2IgYnkgc2xpY2luZyB0aGlzIGJsb2JcbiAgZGVmIHNsaWNlKHN0YXJ0LCBmaW5pc2g9bmlsKVxuICAgIEJsb2IubmV3KGAjQG5hdGl2ZS5zbGljZSgje3N0YXJ0fSwgI3tmaW5pc2h9KWApXG4gIGVuZFxuXG4gICMgQ29udmVydCBhIGJsb2IgdG8gYW4gVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgYmxvYiBpbiBET01cbiAgIyBlZy4gZGlzcGxheSBzb21lIG11bHRpbWVkaWFcbiAgZGVmIHRvX3VybCh3aW5kb3c9JHdpbmRvdylcbiAgICBgI3t3aW5kb3cudG9fbn0uVVJMLmNyZWF0ZU9iamVjdFVSTCgjQG5hdGl2ZSlgXG4gIGVuZFxuXG4gICMgUmVuYW1lIGEgYmxvYiBhbmQgcmV0dXJuIGEge0ZpbGV9IHdpdGggYSBuZXcgbmFtZS5cbiAgI1xuICAjIEByZXR1cm4gW0ZpbGVdIGEgcmVuYW1lZCBibG9iXG4gIGRlZiByZW5hbWUobmV3X2ZpbGVuYW1lKVxuICAgIEZpbGUuY3JlYXRlKFtzZWxmXSwgbmV3X2ZpbGVuYW1lLCB0eXBlOiB0eXBlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiByZXNwb25kX3RvPyg6bGFzdF9tb2RpZmllZCkgPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbW9kaWZpZWQgOiBUaW1lLm5vdylcbiAgZW5kXG5lbmRcblxuY2xhc3MgRmlsZSA8IEJsb2JcbiAgIyBDcmVhdGUgYSBuZXcgZmlsZSBmcm9tIGFueXRoaW5nIHRoYXQgRmlsZSBBUEkgc3VwcG9ydHNcbiAgZGVmIHNlbGYuY3JlYXRlKGZyb20sIG5hbWUsIG9wdGlvbnM9e30pXG4gICAgbmV3KGBuZXcgRmlsZSgje05hdGl2ZS5jb252ZXJ0KGZyb20pfSwgI3tuYW1lfSwgI3tvcHRpb25zLnRvX259KWApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGxhc3RfbW9kaWZpZWRcbiAgIyBAcmV0dXJuIFtUaW1lXSBsYXN0IG1vZGlmaWVkIGRhdGUgb2YgdGhpcyBmaWxlXG4gIGRlZiBsYXN0X21vZGlmaWVkXG4gICAgVGltZS5hdChgI0BuYXRpdmUubGFzdE1vZGlmaWVkYC8xMDAwLjApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIGZpbGVuYW1lIFxuICBkZWYgbmFtZVxuICAgIGAjQG5hdGl2ZS5uYW1lYFxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpCbG9iPiIsInNlbGYiLCJpbmNsdWRlIiwiTmF0aXZlQ2FjaGVkV3JhcHBlciIsImNyZWF0ZSIsImZyb20iLCJvcHRpb25zIiwibmV3IiwiTmF0aXZlIiwiY29udmVydCIsInRvX24iLCJzaXplIiwiQG5hdGl2ZSIsInR5cGUiLCJ0ZXh0IiwicHJvbWlzZSIsImJsb2NrX2dpdmVuPyIsIlByb21pc2UiLCJibG9jayIsInByb2MiLCJibG9jayBpbiB0ZXh0IiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gdGV4dCIsInJlc29sdmUiLCJidWZmZXIiLCJibG9jayBpbiBidWZmZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGJ1ZmZlciIsInJlc2Jsb2NrIiwiY2FsbCIsIkJ1ZmZlciIsInNsaWNlIiwic3RhcnQiLCJmaW5pc2giLCJCbG9iIiwidG9fdXJsIiwid2luZG93IiwiJHdpbmRvdyIsInJlbmFtZSIsIm5ld19maWxlbmFtZSIsIkZpbGUiLCJyZXNwb25kX3RvPyIsImxhc3RfbW9kaWZpZWQiLCJUaW1lIiwibm93IiwiPGNsYXNzOkZpbGU+IiwibmFtZSIsImF0IiwiLyJdLCJtYXBwaW5ncyI6IkFBQUFBLCtCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBRUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLHlCQUFSRDtNQUdBRSxNQUFJSCxJQUFKRyxhQUFBQSxrQkFBZ0JDLElBQUQsRUFBT0MsT0FBdEJGO0FBQUFBLFFBQUFBOzs7UUFBc0IsK0JBQVEsWUFBQTtRQUM1QkEsT0FBQUgsSUFBQU0sS0FBQUEsQ0FBS0gsU0FBV0ksWUFBTUMsU0FBQUEsQ0FBU0osSUFBVEksQ0FBZUwsRUFBSUUsT0FBT0ksTUFBQUEsQ0FBQUEsQ0FBTU4sQ0FBdERHO01BREZILENBQUFBLElBQUFBOztBQU1BTyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFFQyxjQUFPRDtNQURYQSxDQUFB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QUFBQTs7UUFDRUEsT0FBQUMsVUFBSUksSUFBQUEsQ0FBMkJDLFdBQXJCbkMsY0FBTzZCLGFBQWNNLEVBQUMsTUFBREEsQ0FBM0JEO01BRE5MLENBQUFBLEdBQUFBO01BTUFHLE9BQUFDLG9CQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUVqQyxjQUFPaUM7TUFEWEEsQ0FBQUEsR0FBQUE7SUFkRkQsR0FBQUEsV0FBQUEsRUFBYVgsVUFBYlc7RUExRUE3QyxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg4NDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2Nsb3NlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBDbG9zZSA8IEV2ZW50XG4gIGhhbmRsZXMgJ2Nsb3NlJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuQ2xvc2UnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGNvZGU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmNvZGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiByZWFzb249KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnJlYXNvbiA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGNsZWFuISh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS53YXNDbGVhbiA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgbm90X2NsZWFuISh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS53YXNDbGVhbiA9IGZhbHNlYFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IENsb3NlRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDbG9zZUV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdENsb3NlRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2Mud2FzQ2xlYW4sIGRlc2MuY29kZSwgZGVzYy5yZWFzb24pO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmNvZGVcbiAgYWxpYXNfbmF0aXZlIDpyZWFzb25cbiAgYWxpYXNfbmF0aXZlIDpjbGVhbj8sIDp3YXNDbGVhblxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkNsb3NlPiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJjb2RlPSIsInZhbHVlIiwiQG5hdGl2ZSIsInJlYXNvbj0iLCJjbGVhbiEiLCJub3RfY2xlYW4hIiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixPQUFSRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsaUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGFBQVhFO1FBRFRGLENBQUFBLEdBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxxQkFBQUEsK0JBQVVDLEtBQVZEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixRQUFVQztVQURyQkQsQ0FBQUEsR0FBQUE7O0FBSUFHLFVBQUFBLHVCQUFBQSxpQ0FBWUYsS0FBWkU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLFVBQVlGO1VBRHZCRSxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEsc0JBQUFBLGtDQUFXSCxLQUFYRztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUYsY0FBT0U7VUFEWEEsQ0FBQUEsR0FBQUE7VUFJQUwsT0FBQU0sMEJBQUFBLHNDQUFlSixLQUFmSTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0c7VUFEWEEsQ0FBQUEsR0FBQUE7UUFiRk4sR0FBQUEsV0FBQUEsRUFBbUJPLGdCQUFuQlA7UUFrQkEsSUFBQSxRQWNPTCxJQUFBRSxlQUFBQSxDQUFBQSxDQWRQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRVMsTUFBSWIsSUFBSmEsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0EsZUFBaUJDLElBQUtELEVBQUlFLElBQUtGO1lBRGxDQSxDQUFBQSxHQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNVixhQUFPQyxjQUFBQSxDQUFXTCxjQUFYSyxDQUFiLENBQUE7WUFDRVMsTUFBSWIsSUFBSmEsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtZQVBJQSxDQUFBQSxHQUFBQTtVQURGO1FBSkE7UUFnQkFiLElBQUFnQixjQUFBQSxDQUFhLE1BQWJBO1FBQ0FoQixJQUFBZ0IsY0FBQUEsQ0FBYSxRQUFiQTtRQUNBakIsT0FBQUMsSUFBQWdCLGNBQUFBLENBQWEsUUFBYixFQUFzQixVQUF0QkE7TUEzQ0ZqQixHQUFBQSxXQUFBQSxFQUFja0IsV0FBZGxCO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4OTMwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9wYWdnaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5yZXF1aXJlICdwYWdnaW8vdXRpbHMnXG5yZXF1aXJlICdwYWdnaW8vaHRtbCdcbnJlcXVpcmUgJ3BhZ2dpby9jc3MnXG5yZXF1aXJlICdwYWdnaW8vZm9ybWF0dGVyJ1xuXG5jbGFzcyBQYWdnaW9cbiAgZGVmIHNlbGYub3B0aW9ucyhvcHRpb25zLCAmYmxvY2spXG4gICAgRm9ybWF0dGVyLm9wdGlvbnMob3B0aW9ucywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmRlbnQob3B0aW9ucywgJmJsb2NrKVxuICAgIG9wdGlvbnMoaW5kZW50OiBvcHRpb25zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNzcygqYXJncywgJmJsb2NrKVxuICAgIEZvcm1hdHRlci5uZXcuZm9ybWF0KENTUy5uZXcoKmFyZ3MsICZibG9jaykpLnRvX3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaHRtbCgqYXJncywgJmJsb2NrKVxuICAgIEZvcm1hdHRlci5uZXcuZm9ybWF0KEhUTUwubmV3KCphcmdzLCAmYmxvY2spKS50b19zXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmh0bWwhKCZibG9jaylcbiAgICBGb3JtYXR0ZXIubmV3LnRhcCB7fGZ8XG4gICAgICBIVE1MLm5ldygmYmxvY2spLmVhY2gge3xyb290fFxuICAgICAgICBmLmZvcm1hdCByb290XG4gICAgICB9XG4gICAgfS50b19zXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlBhZ2dpbz4iLCJvcHRpb25zIiwiRm9ybWF0dGVyIiwiYmxvY2siLCJ0b19wcm9jIiwiaW5kZW50IiwiY3NzIiwibmV3IiwiZm9ybWF0IiwiQ1NTIiwiYXJncyIsInRvX3MiLCJodG1sIiwiSFRNTCIsImh0bWwhIiwidGFwIiwiYmxvY2sgaW4gaHRtbCEiLCJmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBodG1sISIsImVhY2giLCJyb290IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBodG1sISJdLCJtYXBwaW5ncyI6IkFBQUFBLHlCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQVVBQyxJQUFBQyxTQUFBQSxDQUFRRixjQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixhQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixZQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixrQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUMsTUFBSUgsSUFBSkcsY0FBQUEsbUJBQWlCQSxPQUFqQkE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRUEsT0FBU0EsTUFBVEMsZUFBU0QsV0FBQUEsRUFBQUEsQ0FBU0EsT0FBVEEsQ0FBQUEsRUFBbUJFLEtBQURDLFNBQUFBLENBQUFBLENBQWxCSDtJQURYQSxDQUFBQSxHQUFBQTtJQUlBSSxNQUFJUCxJQUFKTyxhQUFBQSxrQkFBZ0JKLE9BQWhCSTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFQSxPQUFBSixNQUFBSCxJQUFBRyxXQUFBQSxFQUFBQSxDQUFRLG9CQUFBLFVBQVFBLE9BQVIsRUFBUkEsQ0FBQUEsRUFBMEJFLEtBQURDLFNBQUFBLENBQUFBLENBQXpCSDtJQURGSSxDQUFBQSxHQUFBQTtJQUlBQyxNQUFJUixJQUFKUSxVQUFBQSxlQXhCRixFQXdCRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUF4QkY7TUF3QmU7TUFDWEEsT0FBQUosZUFBU0ssS0FBQUEsQ0FBQUEsQ0FBSUMsUUFBQUEsQ0FBV0QsTUFBSEUsU0FBR0YsT0FBQUEsRUFBSyxNQUFDRyxJQUFELENBQUxILEVBQWFKLEtBQURDLFNBQUFBLENBQUFBLENBQVpHLENBQVhDLENBQStCRyxNQUFBQSxDQUFBQTtJQUQ5Q0wsQ0FBQUEsSUFBQUE7SUFJQU0sTUFBSWQsSUFBSmMsV0FBQUEsZ0JBNUJGLEVBNEJFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQTVCRjtNQTRCZ0I7TUFDWkEsT0FBQVYsZUFBU0ssS0FBQUEsQ0FBQUEsQ0FBSUMsUUFBQUEsQ0FBWUQsTUFBSk0sVUFBSU4sT0FBQUEsRUFBSyxNQUFDRyxJQUFELENBQUxILEVBQWFKLEtBQURDLFNBQUFBLENBQUFBLENBQVpHLENBQVpDLENBQWdDRyxNQUFBQSxDQUFBQTtJQUQvQ0MsQ0FBQUEsSUFBQUE7SUFJQVosT0FBQWMsTUFBSWhCLElBQUpnQixZQUFBQSw2QkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRUEsT0FBYUMsTUFBYmIsZUFBU0ssS0FBQUEsQ0FBQUEsQ0FBSVEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBYkMsYUFBb0JDLENBQXBCRDs7UUFBb0I7UUFDbEJFLE9BQWdCQyxNQUFaWixNQUFKTSxVQUFJTixPQUFBQSxFQUFBQSxFQUFBQSxFQUFNSixLQUFEQyxTQUFBQSxDQUFBQSxDQUFMRyxDQUFZWSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFoQkQsYUFBd0JFLElBQXhCRjs7VUFBd0I7VUFDdEJHLE9BQUFKLENBQUNULFFBQUFBLENBQVFZLElBQVJaLEVBREhVLENBQUFBLEdBQWdCQyxFQURsQkgsQ0FBQUEsR0FBYUQsQ0FJWkosTUFBQUEsQ0FBQUE7SUFMSEcsQ0FBQUEsR0FBQUE7RUFqQkZkLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBZkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODk5OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvaHR0cC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdicm93c2VyL2h0dHAvYmluYXJ5J1xucmVxdWlyZSAnYnJvd3Nlci9odHRwL2hlYWRlcnMnXG5yZXF1aXJlICdicm93c2VyL2h0dHAvcmVxdWVzdCdcbnJlcXVpcmUgJ2Jyb3dzZXIvaHR0cC9yZXNwb25zZSdcblxubW9kdWxlIEJyb3dzZXJcblxubW9kdWxlIEhUVFBcbiAgIyBDaGVjayBpZiBIVFRQIHJlcXVlc3RzIGFyZSBzdXBwb3J0ZWQuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPygnWEhSJykgfHwgQnJvd3Nlci5zdXBwb3J0cz8oJ0FjdGl2ZVhPYmplY3QnKVxuICBlbmRcblxuICAjIFNlbmQgYW4gYXN5bmNocm9ub3VzIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gbWV0aG9kIFtTeW1ib2xdIHRoZSBIVFRQIG1ldGhvZCB0byB1c2VcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmddIHRoZSBVUkwgdG8gcmVxdWVzdFxuICAjIEBwYXJhbSBkYXRhIFtTdHJpbmcsIEhhc2hdIHRoZSBkYXRhIHRvIHNlbmRcbiAgI1xuICAjIEB5aWVsZHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNvbmZpZ3VyZVxuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXNwb25zZVxuICBkZWYgc2VsZi5zZW5kKG1ldGhvZCwgdXJsLCBkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgUHJvbWlzZS5uZXcudGFwIHt8cHJvbWlzZXxcbiAgICAgIFJlcXVlc3QubmV3KCZibG9jaykudGFwIHt8cmVxfFxuICAgICAgICByZXEub24gOnN1Y2Nlc3MgZG8gfHJlc3xcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUocmVzKVxuICAgICAgICBlbmRcblxuICAgICAgICByZXEub24gOmZhaWx1cmUgZG8gfHJlc3xcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChyZXMpXG4gICAgICAgIGVuZFxuICAgICAgfS5vcGVuKG1ldGhvZCwgdXJsKS5zZW5kKGRhdGEpXG4gICAgfVxuICBlbmRcblxuICAjIFNlbmQgYW4gYXN5bmNocm9ub3VzIEdFVCByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgVVJMIHRvIHJlcXVlc3RcbiAgI1xuICAjIEB5aWVsZHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNvbmZpZ3VyZVxuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXNwb25zZVxuICBkZWYgc2VsZi5nZXQodXJsLCAmYmxvY2spXG4gICAgc2VuZCg6Z2V0LCB1cmwsICZibG9jaylcbiAgZW5kXG5cbiAgIyBTZW5kIGFuIGFzeW5jaHJvbm91cyBIRUFEIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmddIHRoZSBVUkwgdG8gcmVxdWVzdFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtQcm9taXNlXSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLmhlYWQodXJsLCAmYmxvY2spXG4gICAgc2VuZCg6aGVhZCwgdXJsLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgU2VuZCBhbiBhc3luY2hybm91cyBQT1NUIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmddIHRoZSBVUkwgdG8gcmVxdWVzdFxuICAjIEBwYXJhbSBkYXRhIFtTdHJpbmcsIEhhc2hdIHRoZSBkYXRhIHRvIHNlbmRcbiAgI1xuICAjIEB5aWVsZHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNvbmZpZ3VyZVxuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXNwb25zZVxuICBkZWYgc2VsZi5wb3N0KHVybCwgZGF0YSA9IG5pbCwgJmJsb2NrKVxuICAgIHNlbmQoOnBvc3QsIHVybCwgZGF0YSwgJmJsb2NrKVxuICBlbmRcblxuICAjIFNlbmQgYW4gYXN5bmNocm9ub3VzIFBVVCByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgVVJMIHRvIHJlcXVlc3RcbiAgIyBAcGFyYW0gZGF0YSBbU3RyaW5nLCBIYXNoXSB0aGUgZGF0YSB0byBzZW5kXG4gICNcbiAgIyBAeWllbGRwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCB0byBjb25maWd1cmVcbiAgI1xuICAjIEByZXR1cm4gW1Byb21pc2VdIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzcG9uc2VcbiAgZGVmIHNlbGYucHV0KHVybCwgZGF0YSA9IG5pbCwgJmJsb2NrKVxuICAgIHNlbmQoOnB1dCwgdXJsLCBkYXRhLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgU2VuZCBhbiBhc3luY2hyb25vdXMgREVMRVRFIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmddIHRoZSBVUkwgdG8gcmVxdWVzdFxuICAjIEBwYXJhbSBkYXRhIFtTdHJpbmcsIEhhc2hdIHRoZSBkYXRhIHRvIHNlbmRcbiAgI1xuICAjIEB5aWVsZHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNvbmZpZ3VyZVxuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXNwb25zZVxuICBkZWYgc2VsZi5kZWxldGUodXJsLCBkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgc2VuZCg6ZGVsZXRlLCB1cmwsIGRhdGEsICZibG9jaylcbiAgZW5kXG5cbiAgIyBTZW5kIGEgc3luY2hyb25vdXMgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSBtZXRob2QgW1N5bWJvbF0gdGhlIEhUVFAgbWV0aG9kIHRvIHVzZVxuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICMgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIGRhdGEgdG8gc2VuZFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtSZXNwb25zZV0gdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLnNlbmQhKG1ldGhvZCwgdXJsLCBkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgUmVxdWVzdC5uZXcoJmJsb2NrKS5vcGVuKG1ldGhvZCwgdXJsLCBmYWxzZSkuc2VuZChkYXRhKVxuICBlbmRcblxuICAjIFNlbmQgYSBzeW5jaHJvbm91cyBHRVQgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICNcbiAgIyBAeWllbGRwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCB0byBjb25maWd1cmVcbiAgI1xuICAjIEByZXR1cm4gW1Jlc3BvbnNlXSB0aGUgcmVzcG9uc2VcbiAgZGVmIHNlbGYuZ2V0ISh1cmwsICZibG9jaylcbiAgICBzZW5kISg6Z2V0LCB1cmwsICZibG9jaylcbiAgZW5kXG5cbiAgIyBTZW5kIGEgc3luY2hyb25vdXMgSEVBRCByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgVVJMIHRvIHJlcXVlc3RcbiAgI1xuICAjIEB5aWVsZHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNvbmZpZ3VyZVxuICAjXG4gICMgQHJldHVybiBbUmVzcG9uc2VdIHRoZSByZXNwb25zZVxuICBkZWYgc2VsZi5oZWFkISh1cmwsICZibG9jaylcbiAgICBzZW5kISg6aGVhZCwgdXJsLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgU2VuZCBhIHN5bmNocm9ub3VzIFBPU1QgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICMgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIGRhdGEgdG8gc2VuZFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtSZXNwb25zZV0gdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLnBvc3QhKHVybCwgZGF0YSA9IG5pbCwgJmJsb2NrKVxuICAgIHNlbmQhKDpwb3N0LCB1cmwsIGRhdGEsICZibG9jaylcbiAgZW5kXG5cbiAgIyBTZW5kIGEgc3luY2hyb25vdXMgUFVUIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmddIHRoZSBVUkwgdG8gcmVxdWVzdFxuICAjIEBwYXJhbSBkYXRhIFtTdHJpbmcsIEhhc2hdIHRoZSBkYXRhIHRvIHNlbmRcbiAgI1xuICAjIEB5aWVsZHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNvbmZpZ3VyZVxuICAjXG4gICMgQHJldHVybiBbUmVzcG9uc2VdIHRoZSByZXNwb25zZVxuICBkZWYgc2VsZi5wdXQhKHVybCwgZGF0YSA9IG5pbCwgJmJsb2NrKVxuICAgIHNlbmQhKDpwdXQsIHVybCwgZGF0YSwgJmJsb2NrKVxuICBlbmRcblxuICAjIFNlbmQgYSBzeW5jaHJvbm91cyBERUxFVEUgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICMgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIGRhdGEgdG8gc2VuZFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtSZXNwb25zZV0gdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLmRlbGV0ZSEodXJsLCBkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgc2VuZCEoOmRlbGV0ZSwgdXJsLCBkYXRhLCAmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkhUVFA+Iiwic3VwcG9ydGVkPyIsIiRyZXRfb3JfMSIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJzZW5kIiwibWV0aG9kIiwidXJsIiwiZGF0YSIsInRhcCIsIlByb21pc2UiLCJuZXciLCJibG9jayBpbiBzZW5kIiwicHJvbWlzZSIsImJsb2NrICgyIGxldmVscykgaW4gc2VuZCIsIlJlcXVlc3QiLCJibG9jayIsInRvX3Byb2MiLCJyZXEiLCJvbiIsImJsb2NrICgzIGxldmVscykgaW4gc2VuZCIsInJlcyIsImJsb2NrICg0IGxldmVscykgaW4gc2VuZCIsInJlc29sdmUiLCJyZWplY3QiLCJvcGVuIiwiZ2V0IiwiaGVhZCIsInBvc3QiLCJwdXQiLCJkZWxldGUiLCJzZW5kISIsImdldCEiLCJoZWFkISIsInBvc3Qh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eEIsR0FBYndCLENBQUFBLEVBQW1CZixLQUFEQyxTQUFBQSxDQUFBQSxDQUFsQmM7TUFERkUsQ0FBQUEsR0FBQUE7TUFZQUMsTUFBSXJDLElBQUpxQyxZQUFBQSw0QkFBZTNCLEdBQUQsRUFBTUMsSUFBcEIwQjtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFvQix5QkFBTztRQUN6QkEsT0FBQUgsTUFBQWxDLElBQUFrQyxTQUFBQSxFQUFBQSxDQUFNLE1BQU4sRUFBYXhCLEdBQWIsRUFBa0JDLElBQWxCdUIsQ0FBQUEsRUFBeUJmLEtBQURDLFNBQUFBLENBQUFBLENBQXhCYztNQURGRyxDQUFBQSxJQUFBQTtNQVlBQyxNQUFJdEMsSUFBSnNDLFdBQUFBLDJCQUFjNUIsR0FBRCxFQUFNQyxJQUFuQjJCO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQW1CLHlCQUFPO1FBQ3hCQSxPQUFBSixNQUFBbEMsSUFBQWtDLFNBQUFBLEVBQUFBLENBQU0sS0FBTixFQUFZeEIsR0FBWixFQUFpQkMsSUFBakJ1QixDQUFBQSxFQUF3QmYsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBdkJjO01BREZJLENBQUFBLElBQUFBO01BWUFuQyxPQUFBb0MsTUFBSXZDLElBQUp1QyxjQUFBQSw4QkFBaUI3QixHQUFELEVBQU1DLElBQXRCNEI7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFBc0IseUJBQU87UUFDM0JBLE9BQUFMLE1BQUFsQyxJQUFBa0MsU0FBQUEsRUFBQUEsQ0FBTSxRQUFOLEVBQWV4QixHQUFmLEVBQW9CQyxJQUFwQnVCLENBQUFBLEVBQTJCZixLQUFEQyxTQUFBQSxDQUFBQSxDQUExQmM7TUFERkssQ0FBQUEsSUFBQUE7SUExSkZwQyxHQUFBQSxXQUFBQTtFQUZBRCxHQUFBQSxXQUFBQTtBQUxBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjkxNDgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RldmljZV9vcmllbnRhdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgRGV2aWNlT3JpZW50YXRpb24gPCBFdmVudFxuICBoYW5kbGVzICdkZXZpY2VvcmllbnRhdGlvbidcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRldmljZU9yaWVudGF0aW9uJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBhYnNvbHV0ZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYWJzb2x1dGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBhbHBoYT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYWxwaGEgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBiZXRhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5iZXRhID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgZ2FtbWE9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmdhbW1hID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRGV2aWNlT3JpZW50YXRpb25FdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkRldmljZU9yaWVudGF0aW9uRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0RGV2aWNlT3JpZW50YXRpb25FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy5hbHBoYSwgZGVzYy5iZXRhLCBkZXNjLmdhbW1hLCBkZXNjLmFic29sdXRlKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDphYnNvbHV0ZVxuICBhbGlhc19uYXRpdmUgOmFscGhhXG4gIGFsaWFzX25hdGl2ZSA6YmV0YVxuICBhbGlhc19uYXRpdmUgOmdhbW1hXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6RGV2aWNlT3JpZW50YXRpb24+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImFic29sdXRlPSIsInZhbHVlIiwiQG5hdGl2ZSIsImFscGhhPSIsImJldGE9IiwiZ2FtbWE9IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSxtREFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixtQkFBUkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLDZDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRix5QkFBWEU7UUFEVEYsQ0FBQUEsR0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLHlCQUFBQSxtQ0FBY0MsS0FBZEQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLFlBQWNDO1VBRHpCRCxDQUFBQSxHQUFBQTs7QUFJQUcsVUFBQUEsc0JBQUFBLGdDQUFXRixLQUFYRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsU0FBV0Y7VUFEdEJFLENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSxxQkFBQUEsK0JBQVVILEtBQVZHO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRSxRQUFVSDtVQURyQkcsQ0FBQUEsR0FBQUE7VUFJQUwsT0FBQU0sc0JBQUFBLGdDQUFXSixLQUFYSTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0csU0FBV0o7VUFEdEJJLENBQUFBLEdBQUFBO1FBYkZOLEdBQUFBLFdBQUFBLEVBQW1CTyxnQkFBbkJQO1FBa0JBLElBQUEsUUFjT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VTLE1BQUliLElBQUphLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLDJCQUE2QkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEOUNBLENBQUFBLEdBQUFBO1VBREYsT0FJQSxJQUFBLFFBQU1WLGFBQU9DLGNBQUFBLENBQVdMLGNBQVhLLENBQWIsQ0FBQTtZQUNFUyxNQUFJYixJQUFKYSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUElBLENBQUFBLEdBQUFBO1VBREY7UUFKQTtRQWdCQWIsSUFBQWdCLGNBQUFBLENBQWEsVUFBYkE7UUFDQWhCLElBQUFnQixjQUFBQSxDQUFhLE9BQWJBO1FBQ0FoQixJQUFBZ0IsY0FBQUEsQ0FBYSxNQUFiQTtRQUNBakIsT0FBQUMsSUFBQWdCLGNBQUFBLENBQWEsT0FBYkE7TUE1Q0ZqQixHQUFBQSxXQUFBQSxFQUEwQmtCLFdBQTFCbEI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjkyMzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2F1ZGlvX3Byb2Nlc3NpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEF1ZGlvUHJvY2Vzc2luZyA8IEV2ZW50XG4gIGhhbmRsZXMgJ2F1ZGlvcHJvY2VzcydcbiAgXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuQXVkaW9Qcm9jZXNzaW5nJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiB0aW1lPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5wbGF5YmFja1RpbWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBpbnB1dD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuaW5wdXRCdWZmZXIgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBvdXRwdXQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLm91dHB1dEJ1ZmZlciA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IEF1ZGlvUHJvY2Vzc2luZ0V2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6dGltZSwgOnBsYXliYWNrVGltZVxuICBhbGlhc19uYXRpdmUgOmlucHV0LCA6aW5wdXRCdWZmZXJcbiAgYWxpYXNfbmF0aXZlIDpvdXRwdXQsIDpvdXRwdXRCdWZmZXJcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpBdWRpb1Byb2Nlc3Npbmc+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsInRpbWU9IiwidmFsdWUiLCJAbmF0aXZlIiwiaW5wdXQ9Iiwib3V0cHV0PSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsaURBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLDJDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRix1QkFBWEU7UUFEVEYsQ0FBQUEsR0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLHFCQUFBQSwrQkFBVUMsS0FBVkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLGdCQUFrQkM7VUFEN0JELENBQUFBLEdBQUFBOztBQUlBRyxVQUFBQSxzQkFBQUEsZ0NBQVdGLEtBQVhFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxlQUFpQkY7VUFENUJFLENBQUFBLEdBQUFBO1VBSUFKLE9BQUFLLHVCQUFBQSxpQ0FBWUgsS0FBWkc7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FLGdCQUFrQkg7VUFEN0JHLENBQUFBLEdBQUFBO1FBVEZMLEdBQUFBLFdBQUFBLEVBQW1CTSxnQkFBbkJOO1FBY0EsSUFBQSxRQUlPTCxJQUFBRSxlQUFBQSxDQUFBQSxDQUpQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRVEsTUFBSVosSUFBSlksZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0EseUJBQTJCQyxJQUFLRCxFQUFJRSxJQUFLRjtZQUQ1Q0EsQ0FBQUEsR0FBQUE7VUFERjtRQUFBO1FBTUFaLElBQUFlLGNBQUFBLENBQWEsTUFBYixFQUFvQixjQUFwQkE7UUFDQWYsSUFBQWUsY0FBQUEsQ0FBYSxPQUFiLEVBQXFCLGFBQXJCQTtRQUNBaEIsT0FBQUMsSUFBQWUsY0FBQUEsQ0FBYSxRQUFiLEVBQXNCLGNBQXRCQTtNQTdCRmhCLEdBQUFBLFdBQUFBLEVBQXdCaUIsV0FBeEJqQjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTI5OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvaGFzaF9jaGFuZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEhhc2hDaGFuZ2UgPCBFdmVudFxuICBoYW5kbGVzICdoYXNoY2hhbmdlJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuSGFzaENoYW5nZSdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgb2xkPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5vbGRVUkwgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBuZXc9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLm5ld1VSTCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IEhhc2hDaGFuZ2VFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOm9sZCwgOm9sZFVSTFxuICBhbGlhc19uYXRpdmUgOm5ldywgOm5ld1VSTFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkhhc2hDaGFuZ2U+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsIm9sZD0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJuZXc9IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSw0Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixZQUFSRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsc0NBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGtCQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsb0JBQUFBLDhCQUFTQyxLQUFURDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsVUFBWUM7VUFEdkJELENBQUFBLEdBQUFBO1VBSUFELE9BQUFJLG9CQUFBQSw4QkFBU0YsS0FBVEU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLFVBQVlGO1VBRHZCRSxDQUFBQSxHQUFBQTtRQUxGSixHQUFBQSxXQUFBQSxFQUFtQkssZ0JBQW5CTDtRQVVBLElBQUEsUUFJT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VPLE1BQUlYLElBQUpXLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLG9CQUFzQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEdkNBLENBQUFBLEdBQUFBO1VBREY7UUFBQTtRQU1BWCxJQUFBYyxjQUFBQSxDQUFhLEtBQWIsRUFBbUIsUUFBbkJBO1FBQ0FmLE9BQUFDLElBQUFjLGNBQUFBLENBQWEsS0FBYixFQUFtQixRQUFuQkE7TUF4QkZmLEdBQUFBLFdBQUFBLEVBQW1CZ0IsV0FBbkJoQjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTM1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvc2Vuc29yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBTZW5zb3IgPCBFdmVudFxuICBoYW5kbGVzICdjb21wYXNzbmVlZHNjYWxpYnJhdGlvbicsICd1c2VycHJveGltaXR5J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuU2Vuc29yJ1xuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFNlbnNvckV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOlNlbnNvcj4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLHlCQUFSLEVBQW1DQSxlQUFuQ0U7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLGtDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixjQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBLElBQUEsUUFJT0YsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VMLE9BQUFNLE1BQUlMLElBQUpLLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLGdCQUFrQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEbkNBLENBQUFBLEdBQUFBO1VBREY7WUFURk4sT0FBQTtVQVNFO1FBQUE7VUFURkEsT0FBQTtRQVNFO01BUEZBLEdBQUFBLFdBQUFBLEVBQWVTLFdBQWZUO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5Mzk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jYW52YXMvZ3JhZGllbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIENhbnZhc1xuXG5jbGFzcyBHcmFkaWVudFxuICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gIGF0dHJfcmVhZGVyIDpjb250ZXh0XG5cbiAgZGVmIGluaXRpYWxpemUoY29udGV4dCwgKmFyZ3MsICZibG9jaylcbiAgICBAY29udGV4dCA9IGNvbnRleHRcblxuICAgIHN1cGVyKGNhc2UgYXJncy5sZW5ndGhcbiAgICAgIHdoZW4gNCB0aGVuIGAje0Bjb250ZXh0LnRvX259LmNyZWF0ZUxpbmVhckdyYWRpZW50LmFwcGx5KHNlbGYsIGFyZ3MpYFxuICAgICAgd2hlbiA2IHRoZW4gYCN7QGNvbnRleHQudG9fbn0uY3JlYXRlUmFkaWFsR3JhZGllbnQuYXBwbHkoc2VsZiwgYXJncylgXG4gICAgICBlbHNlIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiZG9uJ3Qga25vdyB3aGVyZSB0byBkaXNwYXRjaFwiXG4gICAgZW5kKVxuXG4gICAgaW5zdGFuY2VfZXZhbCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBhZGQocG9zaXRpb24sIGNvbG9yKVxuICAgIGAje0Bjb250ZXh0LnRvX259LmFkZENvbG9yU3RvcChwb3NpdGlvbiwgY29sb3IpYFxuXG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkNhbnZhcz4iLCI8Y2xhc3M6R3JhZGllbnQ+Iiwic2VsZiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJjb250ZXh0IiwiQGNvbnRleHQiLCI0IiwiJHJldF9vcl8xIiwiYXJncyIsImxlbmd0aCIsInRvX24iLCI2IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImFkZCIsInBvc2l0aW9uIiwiY29sb3IiXSwibWFwcGluZ3MiOiJBQUFBQSwwQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtRQUVBRCxJQUFBSSxhQUFBQSxDQUFZLFNBQVpBOztBQUVBQyxRQUFBQSwwQkFBQUEsc0JBQWVDLE9BQUQsRUFQaEIsRUFPRUQ7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFQRjtVQU8wQjtVQUN0QkUsZUFBV0Q7VUFFWCxPQUFBTixJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFBLENBQ0UsQ0FBQSxRQUFLUSxDQUFMLEVBRElDLENBQUFBLFlBQUtDLElBQUlDLFFBQUFBLENBQUFBLENBQVRGLENBQ0osQ0FBQSxHQUFBLENBQWVGLFlBQVFLLE1BQUFBLENBQUFBLENBQU1QLHVDQUE3QixJQUNBLENBQUEsUUFBS1EsQ0FBTCxFQVpOLFNBWU0sQ0FBQSxHQUFBLENBQWVOLFlBQVFLLE1BQUFBLENBQUFBLENBQU1QLHVDQUE3QixJQUFBLENBQ0tMLElBQUFjLE9BQUFBLENBQU1DLG1CQUFOLEVBQXFCViw4QkFBckJTLENBREwsQ0FBQSxDQURBLENBREYsQ0FBQSxFQUFBLElBQUE7VUFNQVQsT0FBQVcsTUFBQWhCLElBQUFnQixpQkFBQUEsRUFBQUEsRUFBQUEsRUFBZUMsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBZEY7UUFURlgsQ0FBQUEsSUFBQUE7UUFZQU4sT0FBQW9CLG1CQUFBQSxlQUFRQyxRQUFELEVBQVdDLEtBQWxCRjtBQUFBQSxVQUFBQTs7O1VBQ0taLFlBQVFLLE1BQUFBLENBQUFBLENBQU1PO1VBRWpCQSxPQUFBbkI7UUFIRm1CLENBQUFBLEdBQUFBO01BakJGcEIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk0NDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2VmZmVjdHMucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9hbmltYXRpb25fZnJhbWUnXG5cbm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbmNsYXNzIERvY3VtZW50IDwgRWxlbWVudFxuICAjIEAhYXR0cmlidXRlIFtyXSBhY3RpdmVfZWxlbWVudFxuICAjIEByZXR1cm4gW0VsZW1lbnRdIHRoZSBlbGVtZW50IHdpdGggZm9jdXNcbiAgZGVmIGFjdGl2ZV9lbGVtZW50XG4gICAgRE9NKGAjQG5hdGl2ZS5hY3RpdmVFbGVtZW50YClcbiAgZW5kXG5lbmRcblxuY2xhc3MgRWxlbWVudFxuICAjIFNob3cgdGhlIGVsZW1lbnQuXG4gICNcbiAgIyBAcGFyYW0gd2hhdCBbU3ltYm9sXSBob3cgdG8gZGlzcGxheSBpdFxuICBkZWYgc2hvdyh3aGF0ID0gOmJsb2NrKVxuICAgIHN0eWxlWzpkaXNwbGF5XSA9IHdoYXRcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgSGlkZSB0aGUgZWxlbWVudC5cbiAgZGVmIGhpZGVcbiAgICBzdHlsZVs6ZGlzcGxheV0gPSA6bm9uZVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHZpc2libGU/XG4gICAgIyBMZXQncyBjaGVjayBpZiB3ZSB3YW50IHRvIGxpZSBhYm91dCB0aGUgcmVhbCB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQuXG4gICAgIyBJdCBjb3VsZCBiZSB3aXNlIHRvIGxpZSBhYm91dCBpdCB3aGVuIGl0J3MgaW4gYSBwcm9jZXNzIG9mIGFuaW1hdGlvbi4uLlxuICAgIGlmICFAdmlydHVhbGx5X3Zpc2libGUubmlsP1xuICAgICAgQHZpcnR1YWxseV92aXNpYmxlXG4gICAgZWxzZVxuICAgICAgc3R5bGUhWzpkaXNwbGF5XSAhPSA6bm9uZVxuICAgIGVuZFxuICBlbmRcblxuICAjIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZWxlbWVudCwgaGlkZSBpdCBpZiBpdCdzIHNob3duLCBzaG93IGl0IGlmXG4gICMgaXQncyBoaWRkZW4uXG4gIGRlZiB0b2dnbGUod2hhdCA9IDpibG9jaylcbiAgICBpZiB2aXNpYmxlP1xuICAgICAgaGlkZVxuICAgIGVsc2VcbiAgICAgIHNob3cod2hhdClcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgU2V0IHRoZSBmb2N1cyBvbiB0aGUgZWxlbWVudC5cbiAgZGVmIGZvY3VzXG4gICAgYCNAbmF0aXZlLmZvY3VzKClgXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEJsdXIgdGhlIGZvY3VzIGZyb20gdGhlIGVsZW1lbnQuXG4gIGRlZiBibHVyXG4gICAgYCNAbmF0aXZlLmJsdXIoKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgZm9jdXNlZC5cbiAgZGVmIGZvY3VzZWQ/XG4gICAgYCNAbmF0aXZlLmhhc0ZvY3VzYFxuICBlbmRcblxuICAjIFF1ZXVlIHRoZSBibG9jayB0byBoYXBwZW4gd2hlbiBjdXJyZW50bHkgcXVldWVkIGFuaW1hdGlvbnMgZmluaXNoIG9yIGR1cmluZ1xuICAjIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgZGVmIGFuaW1hdGlvbl9xdWV1ZSAmYmxvY2tcbiAgICBwcm9taXNlID0gUHJvbWlzZS5uZXdcblxuICAgIHByb21pc2VfcmVzb2x2ZSA9IHByb2MgZG9cbiAgICAgIEBhbmltYXRpb25fcHJvbWlzZSA9IG5pbCBpZiBAYW5pbWF0aW9uX3Byb21pc2UgPT0gcHJvbWlzZVxuICAgICAgcHJvbWlzZS5yZXNvbHZlXG4gICAgZW5kXG5cbiAgICBAYW5pbWF0aW9uX3Byb21pc2UgPSAoQGFuaW1hdGlvbl9wcm9taXNlIHx8IFByb21pc2UudmFsdWUodHJ1ZSkpLnRoZW4gZG9cbiAgICAgIGFuaW1hdGlvbl9mcmFtZSBkb1xuICAgICAgICB5aWVsZCBwcm9taXNlX3Jlc29sdmVcbiAgICAgIGVuZFxuICAgICAgcHJvbWlzZVxuICAgIGVuZFxuICBlbmRcblxuICAjIFRyYW5zZm9ybSBhbiBlbGVtZW50IHNtb290aGx5IHVzaW5nIENTUyB0cmFuc2l0aW9ucywgalF1ZXJ5IHN0eWxlLiBZaWVsZFxuICAjIGEgYmxvY2sgYWZ0ZXJ3YXJkcyBpZiBpdCdzIHByb3ZpZGVkLlxuICBkZWYgYW5pbWF0ZShwcm9wZXJ0aWVzLCBkdXJhdGlvbjogMC40LnMsIGVhc2luZzogOmVhc2UsIHJlc29sdmU6IGZhbHNlLCAmYmxvY2spXG4gICAgYW5pbWF0aW9uX3F1ZXVlKHJlc29sdmUpIGRvIHxyZXN8XG4gICAgICBkdXJhdGlvbiA9IDAuNi5zIGlmIGR1cmF0aW9uID09IDpzbG93XG4gICAgICBkdXJhdGlvbiA9IDAuMi5zIGlmIGR1cmF0aW9uID09IDpmYXN0XG5cbiAgICAgIG9yaWdpbmFsX3ZhbHVlID0gc3R5bGVbJ3RyYW5zaXRpb24nXVxuXG4gICAgICBzdHlsZVsndHJhbnNpdGlvbiddID0gW29yaWdpbmFsX3ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICpwcm9wZXJ0aWVzLmtleXMubWFwIGRvIHxrZXl8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiN7a2V5fSAje2R1cmF0aW9ufSAje2Vhc2luZ31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZF0uY29tcGFjdC5qb2luKFwiLCBcIilcblxuICAgICAgcHJvcGVydGllcy5lYWNoIGRvIHxrZXksIHZhbHVlfFxuICAgICAgICBzdHlsZVtrZXldID0gdmFsdWVcbiAgICAgIGVuZFxuXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5uZXdcblxuICAgICAgb25lIDp0cmFuc2l0aW9uZW5kIGRvIHwqYXJnc3xcbiAgICAgICAgc3R5bGVbJ3RyYW5zaXRpb24nXSA9IG9yaWdpbmFsX3ZhbHVlXG5cbiAgICAgICAgeWllbGQoKmFyZ3MpIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgICAgIHJlcy5jYWxsXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgU2hvdyBhIGhpZGRlbiBlbGVtZW50IHdpdGggYSBcImZhZGUgaW5cIiBhbmltYXRpb24uIFlpZWxkIGEgYmxvY2sgYWZ0ZXJ3YXJkcy5cbiAgZGVmIGZhZGVfaW4oKiprd2FyZ3MsICZibG9jaylcbiAgICBhbmltYXRpb25fcXVldWUgZG8gfHJlc29sdmV8XG4gICAgICBpZiAhdmlzaWJsZT9cbiAgICAgICAgQHZpcnR1YWxseV92aXNpYmxlID0gdHJ1ZVxuICAgICAgICBzaG93XG5cbiAgICAgICAgc3R5bGVbOm9wYWNpdHldID0gMC4wXG4gICAgICAgIGFuaW1hdGUgb3BhY2l0eTogMS4wLCAqKmt3YXJncyBkbyB8KmFyZ3N8XG4gICAgICAgICAgQHZpcnR1YWxseV92aXNpYmxlID0gbmlsXG4gICAgICAgICAgc3R5bGVbOm9wYWNpdHldID0gbmlsXG4gICAgICAgICAgeWllbGQoKmFyZ3MpIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmVzb2x2ZS5jYWxsXG4gICAgZW5kXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEhpZGUgYSB2aXNpYmxlIGVsZW1lbnQgd2l0aCBhIFwiZmFkZSBvdXRcIiBhbmltYXRpb24uIFlpZWxkIGEgYmxvY2sgYWZ0ZXJ3YXJkcy5cbiAgZGVmIGZhZGVfb3V0KCoqa3dhcmdzLCAmYmxvY2spXG4gICAgYW5pbWF0aW9uX3F1ZXVlIGRvIHxyZXNvbHZlfFxuICAgICAgaWYgdmlzaWJsZT9cbiAgICAgICAgQHZpcnR1YWxseV92aXNpYmxlID0gZmFsc2VcblxuICAgICAgICBzdHlsZVs6b3BhY2l0eV0gPSAxLjBcbiAgICAgICAgYW5pbWF0ZSBvcGFjaXR5OiAwLjAsICoqa3dhcmdzIGRvIHwqYXJnc3xcbiAgICAgICAgICBAdmlydHVhbGx5X3Zpc2libGUgPSBuaWxcbiAgICAgICAgICBzdHlsZVs6b3BhY2l0eV0gPSBuaWxcbiAgICAgICAgICBoaWRlXG4gICAgICAgICAgeWllbGQoKmFyZ3MpIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmVzb2x2ZS5jYWxsXG4gICAgZW5kXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFRvZ2dsZSBhIHZpc2liaWxpdHkgb2YgYW4gZWxlbWVudCB3aXRoIGEgXCJmYWRlIGluXCIvXCJmYWRlIG91dFwiIGFuaW1hdGlvbi4gWWllbGRcbiAgIyBhIGJsb2NrIGFmdGVyd2FyZHMuXG4gIGRlZiBmYWRlX3RvZ2dsZSgqKmt3YXJncywgJmJsb2NrKVxuICAgIGlmIHZpc2libGU/XG4gICAgICBmYWRlX291dCgqKmt3YXJncywgJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIGZhZGVfaW4oKiprd2FyZ3MsICZibG9jaylcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgU2hvdyBhIGhpZGRlbiBlbGVtZW50IHdpdGggYSBcInNsaWRlIGRvd25cIiBhbmltYXRpb24uIFlpZWxkIGEgYmxvY2sgYWZ0ZXJ3YXJkcy5cbiAgZGVmIHNsaWRlX2Rvd24oKiprd2FyZ3MsICZibG9jaylcbiAgICBhbmltYXRpb25fcXVldWUgZG8gfHJlc29sdmV8XG4gICAgICBpZiAhdmlzaWJsZT9cbiAgICAgICAgQHZpcnR1YWxseV92aXNpYmxlID0gdHJ1ZVxuICAgICAgICBzaG93XG4gICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0XG4gICAgICAgIG9yaWdfaGVpZ2h0ID0gc3R5bGVbOmhlaWdodF1cbiAgICAgICAgc3R5bGVbOmhlaWdodF0gPSAwLnB4XG5cbiAgICAgICAgYW5pbWF0ZSBoZWlnaHQ6IGhlaWdodC5weCwgKiprd2FyZ3MgZG8gfCphcmdzfFxuICAgICAgICAgIEB2aXJ0dWFsbHlfdmlzaWJsZSA9IG5pbFxuICAgICAgICAgIHN0eWxlWzpoZWlnaHRdID0gb3JpZ19oZWlnaHRcbiAgICAgICAgICB5aWVsZCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXNvbHZlLmNhbGxcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgSGlkZSBhIHZpc2libGUgZWxlbWVudCB3aXRoIGEgXCJzbGlkZSB1cFwiIGFuaW1hdGlvbi4gWWllbGQgYSBibG9jayBhZnRlcndhcmRzLlxuICBkZWYgc2xpZGVfdXAoKiprd2FyZ3MsICZibG9jaylcbiAgICBhbmltYXRpb25fcXVldWUgZG8gfHJlc29sdmV8XG4gICAgICBpZiB2aXNpYmxlP1xuICAgICAgICBAdmlydHVhbGx5X3Zpc2libGUgPSBmYWxzZVxuICAgICAgICBvcmlnX2hlaWdodCA9IHN0eWxlWzpoZWlnaHRdXG5cbiAgICAgICAgYW5pbWF0ZSBoZWlnaHQ6IDAucHgsICoqa3dhcmdzIGRvIHwqYXJnc3xcbiAgICAgICAgICBAdmlydHVhbGx5X3Zpc2libGUgPSBuaWxcbiAgICAgICAgICBzdHlsZVs6aGVpZ2h0XSA9IG9yaWdfaGVpZ2h0XG4gICAgICAgICAgaGlkZVxuICAgICAgICAgIHlpZWxkKCphcmdzKSBpZiBibG9ja19naXZlbj9cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJlc29sdmUuY2FsbFxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBUb2dnbGUgYSB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQgd2l0aCBhIFwic2xpZGUgdXBcIi9cInNsaWRlIGRvd25cIiBhbmltYXRpb24uXG4gICMgWWllbGQgYSBibG9jayBhZnRlcndhcmRzLlxuICBkZWYgc2xpZGVfdG9nZ2xlKCoqa3dhcmdzLCAmYmxvY2spXG4gICAgaWYgdmlzaWJsZT9cbiAgICAgIHNsaWRlX3VwKCoqa3dhcmdzLCAmYmxvY2spXG4gICAgZWxzZVxuICAgICAgc2xpZGVfZG93bigqKmt3YXJncywgJmJsb2NrKVxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkRvY3VtZW50PiIsImFjdGl2ZV9lbGVtZW50IiwiRE9NIiwiQG5hdGl2ZSIsIkVsZW1lbnQiLCI8Y2xhc3M6RWxlbWVudD4iLCJzaG93Iiwid2hhdCIsInN0eWxlIiwiW109IiwiaGlkZSIsInZpc2libGU/IiwiQHZpcnR1YWxseV92aXNpYmxlIiwibmlsPyIsInN0eWxlISIsIltdIiwiIT0iLCJ0b2dnbGUiLCJmb2N1cyIsImJsdXIiLCJmb2N1c2VkPyIsImFuaW1hdGlvbl9xdWV1ZSIsInByb21pc2UiLCJQcm9taXNlIiwibmV3IiwicHJvbWlzZV9yZXNvbHZlIiwicHJvYyIsImJsb2NrIGluIGFuaW1hdGlvbl9xdWV1ZSIsImJsb2NrICgyIGxldmVscykgaW4gYW5pbWF0aW9uX3F1ZXVlIiwiQGFuaW1hdGlvbl9wcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCIkcmV0X29yXzEiLCJ2YWx1ZSIsImFuaW1hdGlvbl9mcmFtZSIsImFuaW1hdGUiLCJwcm9wZXJ0aWVzIiwiJGt3YXJncyIsInMiLCJibG9jayBpbiBhbmltYXRlIiwicmVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbmltYXRlIiwiZHVyYXRpb24iLCJvcmlnaW5hbF92YWx1ZSIsIm1hcCIsImtleXMiLCJrZXkiLCJibG9jayAoMyBsZXZlbHMpIGluIGFuaW1hdGUiLCJlYXNpbmciLCJjb21wYWN0Iiwiam9pbiIsImVhY2giLCJvbmUiLCJibG9ja19naXZlbj8iLCJhcmdzIiwiY2FsbCIsImZhZGVfaW4iLCJibG9jayBpbiBmYWRlX2luIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmYWRlX2luIiwia3dhcmdzIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBmYWRlX2luIiwiZmFkZV9vdXQiLCJibG9jayBpbiBmYWRlX291dCIsImJsb2NrICgyIGxldmVscykgaW4gZmFkZV9vdXQiLCJibG9jayAoMyBsZXZlbHMpIGluIGZhZGVfb3V0IiwiZmFkZV90b2dnbGUiLCJibG9jayIsInRvX3Byb2MiLCJzbGlkZV9kb3duIiwiYmxvY2sgaW4gc2xpZGVfZG93biIsImJsb2NrICgyIGxldmVscykgaW4gc2xpZGVfZG93biIsImhlaWdodCIsInNpemUiLCJvcmlnX2hlaWdodCIsIjAiLCJweCIsImJsb2NrICgzIGxldmVscykgaW4gc2xpZGVfZG93biIsInNsaWRlX3VwIiwiYmxvY2sgaW4gc2xpZGVfdXAiLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWRlX3VwIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBzbGlkZV91cCIsInNsaWRlX3RvZ2dsZSJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRix5QkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFFaEJDO01BQUFBOztRQUFBQTs7QUFBQUE7UUFHRUEsT0FBQUMsOEJBQUFBLDBCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUwsSUFBQU0sS0FBQUEsQ0FBTUMsY0FBT0YsY0FBYkM7UUFERkQsQ0FBQUEsR0FBQUE7TUFIRkQsR0FBQUEsV0FBQUEsRUFBaUJJLGFBQWpCSjtNQVFBRCxPQUFBTTtNQUFBQTs7UUFBQUE7O0FBQUFBOzs7QUFJRUMsUUFBQUEsb0JBQUFBLGdCQUFTQyxJQUFURDtBQUFBQSxVQUFBQTs7O1VBQVMseUJBQU87VUFDZFYsSUFBQVksT0FBQUEsQ0FBQUEsQ0FBS0MsUUFBQUEsQ0FBQyxTQUFOLEVBQWtCRixJQUFiRTtVQUNMSCxPQUFBVjtRQUZGVSxDQUFBQSxJQUFBQTs7QUFNQUksUUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7O1VBQ0VkLElBQUFZLE9BQUFBLENBQUFBLENBQUtDLFFBQUFBLENBQUMsU0FBTixFQUFrQixNQUFiQTtVQUNMQyxPQUFBZDtRQUZGYyxDQUFBQSxHQUFBQTs7QUFLQUMsUUFB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bEIsTUFBRixDQUFUa0IsQ0FBQUEsRUFBb0JYLEtBQURDLFNBQUFBLENBQUFBLENBQW5CVTtVQURGO1lBR0VULE1BQUF4RSxJQUFBd0UsY0FBQUEsRUFBQUEsQ0FBVyxhQUFFVCxNQUFGLENBQVhTLENBQUFBLEVBQXNCRixLQUFEQyxTQUFBQSxDQUFBQSxDQUFyQkM7VUFIRjtVQUtBYSxPQUFBckY7UUFORnFGLENBQUFBLElBQUFBO01Bak1GNUUsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFWZ0JOLEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUZBSDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk3OTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2NsaXBib2FyZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQ2xpcGJvYXJkIDwgRXZlbnRcbiAgaGFuZGxlcyAnY29weScsICdjdXQnLCAncGFzdGUnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5DbGlwYm9hcmQnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGRhdGE9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmRhdGEgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiB0eXBlPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kYXRhVHlwZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IENsaXBib2FyZEV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6ZGF0YVxuICBhbGlhc19uYXRpdmUgOnR5cGUsIDpkYXRhVHlwZVxuXG4gICMgUmV0dXJucyBhIHtEYXRhVHJhbnNmZXJ9IHJlbGF0ZWQgdG8gdGhpcyBldmVudFxuICAjXG4gICMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRGF0YVRyYW5zZmVyXG4gIGRlZiB0cmFuc2ZlclxuICAgIERhdGFUcmFuc2Zlci5uZXcoYCNAbmF0aXZlLmNsaXBib2FyZERhdGFgKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpDbGlwYm9hcmQ+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImRhdGE9IiwidmFsdWUiLCJAbmF0aXZlIiwidHlwZT0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJ0cmFuc2ZlciIsIkRhdGFUcmFuc2ZlciIsIm5ldyIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsTUFBUixFQUFnQkEsS0FBaEIsRUFBdUJBLE9BQXZCRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEscUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGlCQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEscUJBQUFBLCtCQUFVQyxLQUFWRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsUUFBVUM7VUFEckJELENBQUFBLEdBQUFBO1VBSUFELE9BQUFJLHFCQUFBQSwrQkFBVUYsS0FBVkU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLFlBQWNGO1VBRHpCRSxDQUFBQSxHQUFBQTtRQUxGSixHQUFBQSxXQUFBQSxFQUFtQkssZ0JBQW5CTDtRQVVBLElBQUEsUUFJT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VPLE1BQUlYLElBQUpXLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLG1CQUFxQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEdENBLENBQUFBLEdBQUFBO1VBREY7UUFBQTtRQU1BWCxJQUFBYyxjQUFBQSxDQUFhLE1BQWJBO1FBQ0FkLElBQUFjLGNBQUFBLENBQWEsTUFBYixFQUFvQixVQUFwQkE7UUFLQWYsT0FBQWdCLHdCQUFBQSxvQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFDLGtCQUFZQyxLQUFBQSxDQUFPVCxjQUFPTyxjQUFkRTtRQURkRixDQUFBQSxHQUFBQTtNQTdCRmhCLEdBQUFBLFdBQUFBLEVBQWtCbUIsV0FBbEJuQjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTg1NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY2FudmFzL3RleHQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIENhbnZhc1xuXG5jbGFzcyBUZXh0XG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgYXR0cl9yZWFkZXIgOmNvbnRleHRcblxuICBkZWYgaW5pdGlhbGl6ZShjb250ZXh0KVxuICAgIEBjb250ZXh0ID0gY29udGV4dFxuXG4gICAgc3VwZXIoQGNvbnRleHQudG9fbilcbiAgZW5kXG5cbiAgZGVmIG1lYXN1cmUodGV4dClcbiAgICBgI0BuYXRpdmUubWVhc3VyZVRleHQodGV4dClgXG4gIGVuZFxuXG4gIGRlZiBmaWxsKHRleHQsIHggPSBuaWwsIHkgPSBuaWwsIG1heF93aWR0aCA9IG5pbClcbiAgICB4IHx8PSAwXG4gICAgeSB8fD0gMFxuXG4gICAgaWYgbWF4X3dpZHRoXG4gICAgICBgI0BuYXRpdmUuZmlsbFRleHQodGV4dCwgeCwgeSwgbWF4X3dpZHRoKWBcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUuZmlsbFRleHQodGV4dCwgeCwgeSlgXG4gICAgZW5kXG5cbiAgICBAY29udGV4dFxuICBlbmRcblxuICBkZWYgc3Ryb2tlKHRleHQsIHggPSBuaWwsIHkgPSBuaWwsIG1heF93aWR0aCA9IG5pbClcbiAgICB4IHx8PSAwXG4gICAgeSB8fD0gMFxuXG4gICAgaWYgbWF4X3dpZHRoXG4gICAgICBgI0BuYXRpdmUuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5LCBtYXhfd2lkdGgpYFxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS5zdHJva2VUZXh0KHRleHQsIHgsIHkpYFxuICAgIGVuZFxuXG4gICAgQGNvbnRleHRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpDYW52YXM+IiwiPGNsYXNzOlRleHQ+Iiwic2VsZiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJjb250ZXh0IiwiQGNvbnRleHQiLCJ0b19uIiwibWVhc3VyZSIsInRleHQiLCJAbmF0aXZlIiwiZmlsbCIsIngiLCJ5IiwibWF4X3dpZHRoIiwiJHJldF9vcl8xIiwiMCIsInN0cm9rZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEO1FBRUFELElBQUFJLGFBQUFBLENBQVksU0FBWkE7O0FBRUFDLFFBQUFBLDBCQUFBQSxzQkFBZUMsT0FBZkQ7QUFBQUEsVUFBQUE7O1VBQUFBOztVQUNFRSxlQUFXRDtVQUVYRCxPQUFBLE9BQUFMLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTU8sWUFBUUMsTUFBQUEsQ0FBQUEsQ0FBZCxDQUFBLEVBQUEsSUFBQTtRQUhGSCxDQUFBQSxHQUFBQTs7QUFNQUksUUFBQUEsdUJBQUFBLG1CQUFZQyxJQUFaRDtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRUUsY0FBT0Y7UUFEWEEsQ0FBQUEsR0FBQUE7O0FBSUFHLFFBQUFBLG9CQUFBQSxnQkFBU0YsSUFBRCxFQUFPRyxDQUFQLEVBQWdCQyxDQUFoQixFQUF5QkMsU0FBakNIO0FBQUFBLFVBQUFBOzs7VUFBZSxtQkFBSTtVQUFLLG1CQUFJO1VBQUssbUNBQVk7VUFDM0NDLElBbEJKLENBQUEsUUFBQUcsQ0FBQUEsWUFrQklILENBbEJKRyxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQWtCVUMsQ0FsQlYsQ0FBQTtVQW1CSUgsSUFuQkosQ0FBQSxRQUFBRSxDQUFBQSxZQW1CSUYsQ0FuQkpFLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBbUJVQyxDQW5CVixDQUFBO1VBcUJJLElBQUEsUUFBR0YsU0FBSCxDQUFBO1lBQ0lKLGNBQU9DO1VBRFg7WUFHSUQsY0FBT0M7VUFIWDtVQU1BQSxPQUFBTDtRQVZGSyxDQUFBQSxJQUFBQTtRQWFBYixPQUFBbUIsc0JBQUFBLGtCQUFXUixJQUFELEVBQU9HLENBQVAsRUFBZ0JDLENBQWhCLEVBQXlCQyxTQUFuQ0c7QUFBQUEsVUFBQUE7OztVQUFpQixtQkFBSTtVQUFLLG1CQUFJO1VBQUssbUNBQVk7VUFDN0NMLElBL0JKLENBQUEsUUFBQUcsQ0FBQUEsWUErQklILENBL0JKRyxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQStCVUMsQ0EvQlYsQ0FBQTtVQWdDSUgsSUFoQ0osQ0FBQSxRQUFBRSxDQUFBQSxZQWdDSUYsQ0FoQ0pFLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBZ0NVQyxDQWhDVixDQUFBO1VBa0NJLElBQUEsUUFBR0YsU0FBSCxDQUFBO1lBQ0lKLGNBQU9PO1VBRFg7WUFHSVAsY0FBT087VUFIWDtVQU1BQSxPQUFBWDtRQVZGVyxDQUFBQSxJQUFBQTtNQTVCRm5CLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5OTMxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC93aGVlbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgV2hlZWwgPCBVSVxuICBoYW5kbGVzICd3aGVlbCcsICdtb3VzZXdoZWVsJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBub3QgJCRbOldoZWVsRXZlbnRdLm5pbD9cbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgeD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGVsdGFYID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgeT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGVsdGFZID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgej0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGVsdGFaID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgbW9kZT0odmFsdWUpXG4gICAgICB2YWx1ZSA9IGNhc2UgdmFsdWVcbiAgICAgICAgd2hlbiA6cGl4ZWwgdGhlbiBgV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUxgXG4gICAgICAgIHdoZW4gOmxpbmUgIHRoZW4gYFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkVgXG4gICAgICAgIHdoZW4gOnBhZ2UgIHRoZW4gYFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0VgXG4gICAgICBlbmRcblxuICAgICAgYCNAbmF0aXZlLmRlbHRhTW9kZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICBgbmV3IFdoZWVsRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gIGVuZFxuXG4gIGFsaWFzX25hdGl2ZSA6eCwgOmRlbHRhWFxuICBhbGlhc19uYXRpdmUgOnksIDpkZWx0YVlcbiAgYWxpYXNfbmF0aXZlIDp6LCA6ZGVsdGFaXG5cbiAgZGVmIG1vZGVcbiAgICBjYXNlIGAjQG5hdGl2ZS5kZWx0YU1vZGVgXG4gICAgICB3aGVuIGBXaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTGAgdGhlbiA6cGl4ZWxcbiAgICAgIHdoZW4gYFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkVgICB0aGVuIDpsaW5lXG4gICAgICB3aGVuIGBXaGVlbEV2ZW50LkRPTV9ERUxUQV9QQUdFYCAgdGhlbiA6cGFnZVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpXaGVlbD4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCIkJCIsIltdIiwibmlsPyIsIiEiLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJ4PSIsInZhbHVlIiwiQG5hdGl2ZSIsInk9Iiwiej0iLCJtb2RlPSIsIiRyZXRfb3JfMSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIm1vZGUiLCJVSSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLE9BQVIsRUFBaUJBLFlBQWpCRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsaUNBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFJQyxRQUFFQyxPQUFBQSxDQUFDLFlBQURBLENBQWFDLFNBQUFBLENBQUFBLENBQW5CQyxNQUFBQSxDQUFBQTtRQURGSixDQUFBQSxHQUFBQTtRQUlBSztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsa0JBQUFBLDRCQUFPQyxLQUFQRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsVUFBWUM7VUFEdkJELENBQUFBLEdBQUFBOztBQUlBRyxVQUFBQSxrQkFBQUEsNEJBQU9GLEtBQVBFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxVQUFZRjtVQUR2QkUsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLGtCQUFBQSw0QkFBT0gsS0FBUEc7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FLFVBQVlIO1VBRHZCRyxDQUFBQSxHQUFBQTtVQUlBTCxPQUFBTSxxQkFBQUEsK0JBQVVKLEtBQVZJO0FBQUFBLFlBQUFBOzs7WUFDRUosUUFDRSxDQUFBLFFBQUssT0FBTCxFQURNSyxDQUFBQSxZQUFLTCxLQUFMSyxDQUNOLENBQUEsR0FBQSxDQUFrQkQsMEJBQWxCLElBQ0EsQ0FBQSxRQUFLLE1BQUwsRUF6QlIsU0F5QlEsQ0FBQSxHQUFBLENBQWtCQSx5QkFBbEIsSUFDQSxDQUFBLFFBQUssTUFBTCxFQTFCUixTQTBCUSxDQUFBLEdBQUEsQ0FBa0JBLHlCQUFsQixJQUFBLENBSE0sR0FHTixDQUFBLENBREEsQ0FEQTtZQUtGQSxPQUFFSCxjQUFPRyxhQUFlSjtVQVAxQkksQ0FBQUEsR0FBQUE7UUFiRk4sR0FBQUEsV0FBQUEsRUFBbUJRLGdCQUFuQlI7UUF3QkFTLE1BQUloQixJQUFKZ0IsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7VUFDRUEsT0FBQ0EsZUFBaUJDLElBQUtELEVBQUlFLElBQUtGO1FBRGxDQSxDQUFBQSxHQUFBQTtRQUlBaEIsSUFBQW1CLGNBQUFBLENBQWEsR0FBYixFQUFpQixRQUFqQkE7UUFDQW5CLElBQUFtQixjQUFBQSxDQUFhLEdBQWIsRUFBaUIsUUFBakJBO1FBQ0FuQixJQUFBbUIsY0FBQUEsQ0FBYSxHQUFiLEVBQWlCLFFBQWpCQTtRQUVBcEIsT0FBQXFCLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O1VBRUksSUFBQSxRQUFNQSwwQkFBTixFQURGTixDQUFBQSxZQUFPSixjQUFPVSxVQUFkTixDQUNFLENBQUE7WUFBdUNNLE9BQUE7VUFBdkMsT0FDQSxJQUFBLFFBQU1BLHlCQUFOLEVBNUNOLFNBNENNLENBQUE7WUFBdUNBLE9BQUE7VUFBdkMsT0FDQSxJQUFBLFFBQU1BLHlCQUFOLEVBN0NOLFNBNkNNLENBQUE7WUFBdUNBLE9BQUE7VUFBdkM7WUFIRkEsT0FBQTtVQUdFO1FBSkpBLENBQUFBLEdBQUFBO01BdkNGckIsR0FBQUEsV0FBQUEsRUFBY3NCLFFBQWR0QjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDAxNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvc3RvcmFnZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgU3RvcmFnZSA8IEV2ZW50XG4gIGhhbmRsZXMgJ3N0b3JhZ2UnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5TdG9yYWdlJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBrZXk9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmtleSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG5ldz0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubmV3VmFsdWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBvbGQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLm9sZFZhbHVlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgYXJlYT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuc3RvcmFnZUFyZWEgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiB1cmw9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnVybCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFN0b3JhZ2VFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmtleVxuICBhbGlhc19uYXRpdmUgOm5ldywgOm5ld1ZhbHVlXG4gIGFsaWFzX25hdGl2ZSA6b2xkLCA6b2xkVmFsdWVcbiAgYWxpYXNfbmF0aXZlIDphcmVhLCA6c3RvcmFnZUFyZWFcbiAgYWxpYXNfbmF0aXZlIDp1cmxcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpTdG9yYWdlPiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJrZXk9IiwidmFsdWUiLCJAbmF0aXZlIiwibmV3PSIsIm9sZD0iLCJhcmVhPSIsInVybD0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLFNBQVJFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSxtQ0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0YsZUFBWEU7UUFEVEYsQ0FBQUEsR0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLG9CQUFBQSw4QkFBU0MsS0FBVEQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLE9BQVNDO1VBRHBCRCxDQUFBQSxHQUFBQTs7QUFJQUcsVUFBQUEsb0JBQUFBLDhCQUFTRixLQUFURTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsWUFBY0Y7VUFEekJFLENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSxvQkFBQUEsOEJBQVNILEtBQVRHO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRSxZQUFjSDtVQUR6QkcsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLHFCQUFBQSwrQkFBVUosS0FBVkk7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVILGNBQU9HLGVBQWlCSjtVQUQ1QkksQ0FBQUEsR0FBQUE7VUFJQU4sT0FBQU8sb0JBQUFBLDhCQUFTTCxLQUFUSztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUosY0FBT0ksT0FBU0w7VUFEcEJLLENBQUFBLEdBQUFBO1FBakJGUCxHQUFBQSxXQUFBQSxFQUFtQlEsZ0JBQW5CUjtRQXNCQSxJQUFBLFFBSU9MLElBQUFFLGVBQUFBLENBQUFBLENBSlAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFVSxNQUFJZCxJQUFKYyxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxpQkFBbUJDLElBQUtELEVBQUlFLElBQUtGO1lBRHBDQSxDQUFBQSxHQUFBQTtVQURGO1FBQUE7UUFNQWQsSUFBQWlCLGNBQUFBLENBQWEsS0FBYkE7UUFDQWpCLElBQUFpQixjQUFBQSxDQUFhLEtBQWIsRUFBbUIsVUFBbkJBO1FBQ0FqQixJQUFBaUIsY0FBQUEsQ0FBYSxLQUFiLEVBQW1CLFVBQW5CQTtRQUNBakIsSUFBQWlCLGNBQUFBLENBQWEsTUFBYixFQUFvQixhQUFwQkE7UUFDQWxCLE9BQUFDLElBQUFpQixjQUFBQSxDQUFhLEtBQWJBO01BdkNGbEIsR0FBQUEsV0FBQUEsRUFBZ0JtQixXQUFoQm5CO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwMDk2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9kcmFnLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBEcmFnIDwgRXZlbnRcbiAgaGFuZGxlcyAnZHJhZycsICdkcmFnZW5kJywgJ2RyYWdlbnRlcicsICdkcmFnZXhpdCcsICdkcmFnbGVhdmUnLCAnZHJhZ292ZXInLFxuICAgICAgICAgICdkcmFnc3RhcnQnLCAnZHJvcCdcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRyYWcnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgY2xhc3MgQ2xpZW50XG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5jbGllbnRYID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUuY2xpZW50WSA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjbGFzcyBTY3JlZW5cbiAgICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnNjcmVlblggPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgeT0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5zY3JlZW5ZID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBhbHQhXG4gICAgICBgI0BuYXRpdmUuYWx0S2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBjdHJsIVxuICAgICAgYCNAbmF0aXZlLmN0cmxLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIG1ldGEhXG4gICAgICBgI0BuYXRpdmUubWV0YUtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgYnV0dG9uPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5idXR0b24gPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBjbGllbnRcbiAgICAgIENsaWVudC5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiBzY3JlZW5cbiAgICAgIFNjcmVlbi5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiByZWxhdGVkPShlbGVtKVxuICAgICAgYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXQgPSAje05hdGl2ZS5jb252ZXJ0KGVsZW0pfWBcbiAgICBlbmRcblxuICAgIGRlZiB0cmFuc2Zlcj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGF0YVRyYW5zZmVyID0gI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IERyYWdFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkRyYWdFdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXREcmFnRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2MudmlldyB8fCB3aW5kb3csIDAsXG4gICAgICAgICAgICAgIGRlc2Muc2NyZWVuWCB8fCAwLCBkZXNjLnNjcmVlblkgfHwgMCxcbiAgICAgICAgICAgICAgZGVzYy5jbGllbnRYIHx8IDAsIGRlc2MuY2xpZW50WSB8fCAwLFxuICAgICAgICAgICAgICBkZXNjLmN0cmxLZXksIGRlc2MuYWx0S2V5LCBkZXNjLnNoaWZ0S2V5LCBkZXNjLm1ldGFLZXksXG4gICAgICAgICAgICAgIGRlc2MuYnV0dG9uIHx8IDAsIGRlc2MucmVsYXRlZFRhcmdldCwgZGVzYy5kYXRhVHJhbnNmZXIpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFsdD8sIDphbHRLZXlcbiAgYWxpYXNfbmF0aXZlIDpjdHJsPywgOmN0cmxLZXlcbiAgYWxpYXNfbmF0aXZlIDptZXRhPywgOm1ldGFLZXlcbiAgYWxpYXNfbmF0aXZlIDpzaGlmdD8sIDpzaGlmdEtleVxuICBhbGlhc19uYXRpdmUgOmJ1dHRvblxuXG4gIGRlZiBjbGllbnRcbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLmNsaWVudFhgLCBgI0BuYXRpdmUuY2xpZW50WWApXG4gIGVuZFxuXG4gIGRlZiBzY3JlZW5cbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLnNjcmVlblhgLCBgI0BuYXRpdmUuc2NyZWVuWWApIGlmIGRlZmluZWQ/KGAjQG5hdGl2ZS5zY3JlZW5YYClcbiAgZW5kXG5cbiAgZGVmIHhcbiAgICBzY3JlZW4ueFxuICBlbmRcblxuICBkZWYgeVxuICAgIHNjcmVlbi55XG4gIGVuZFxuXG4gIGRlZiByZWxhdGVkXG4gICAgRE9NKGAjQG5hdGl2ZS5yZWxhdGVkVGFyZ2V0YClcbiAgZW5kXG5cbiAgIyBSZXR1cm5zIGEge0RhdGFUcmFuc2Zlcn0gcmVsYXRlZCB0byB0aGlzIGV2ZW50XG4gICNcbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9EYXRhVHJhbnNmZXJcbiAgZGVmIHRyYW5zZmVyXG4gICAgRGF0YVRyYW5zZmVyLm5ldyhgI0BuYXRpdmUuZGF0YVRyYW5zZmVyYClcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6RHJhZz4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwiPGNsYXNzOkNsaWVudD4iLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwieD0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJ5PSIsIjxjbGFzczpTY3JlZW4+IiwiYWx0ISIsImN0cmwhIiwibWV0YSEiLCJidXR0b249IiwiY2xpZW50IiwiQ2xpZW50IiwibmV3Iiwic2NyZWVuIiwiU2NyZWVuIiwicmVsYXRlZD0iLCJlbGVtIiwiY29udmVydCIsInRyYW5zZmVyPSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIlBvc2l0aW9uIiwieCIsInkiLCJyZWxhdGVkIiwiRE9NIiwidHJhbnNmZXIiLCJEYXRhVHJhbnNmZXIiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLE1BQVIsRUFBZ0JBLFNBQWhCLEVBQTJCQSxXQUEzQixFQUF3Q0EsVUFBeEMsRUFBb0RBLFdBQXBELEVBQWlFQSxVQUFqRSxFQUNRQSxXQURSLEVBQ3FCQSxNQURyQkU7UUFHQUMsTUFBSUYsSUFBSkUsaUJBQUFBLGdDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixZQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQztVQUFBQTs7WUFBQUE7O0FBQUFBOztZQUNFTixJQUFBTyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDs7QUFFQUcsWUFBQUEsa0JBQUFBLHdCQUFPQyxLQUFQRDtBQUFBQSxjQUFBQTs7Y0FDRUEsT0FBRUUsY0FBT0YsV0FBYUM7WUFEeEJELENBQUFBLEdBQUFBO1lBSUFKLE9BQUFPLGtCQUFBQSx3QkFBT0YsS0FBUEU7QUFBQUEsY0FBQUE7O2NBQ0VBLE9BQUVELGNBQU9DLFdBQWFGO1lBRHhCRSxDQUFBQSxHQUFBQTtVQVBGUCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtVQVlBUTtVQUFBQTs7WUFBQUE7O0FBQUFBOztZQUNFZCxJQUFBTyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZ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QixrQkFBeEQsQ0FBQTtZQUFBQSxPQUFBVyxjQUFRWixLQUFBQSxDQUFPVCxjQUFPVSxRQUF0QixFQUFtQ1YsY0FBT1UsUUFBbENEO1VBQVI7WUFuR0pDLE9BQUE7VUFtR0k7UUFERkEsQ0FBQUEsR0FBQUE7O0FBSUFZLFFBQUFBLGlCQUFBQSxhQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQWxDLElBQUFzQixRQUFBQSxDQUFBQSxDQUFNWSxHQUFBQSxDQUFBQTtRQURSQSxDQUFBQSxHQUFBQTs7QUFJQUMsUUFBQUEsaUJBQUFBLGFBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBbkMsSUFBQXNCLFFBQUFBLENBQUFBLENBQU1hLEdBQUFBLENBQUFBO1FBRFJBLENBQUFBLEdBQUFBOztBQUlBQyxRQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBcEMsSUFBQXFDLEtBQUFBLENBQU16QixjQUFPd0IsY0FBYkM7UUFERkQsQ0FBQUEsR0FBQUE7UUFPQXJDLE9BQUF1Qyx3QkFBQUEsb0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBQyxrQkFBWWxCLEtBQUFBLENBQU9ULGNBQU8wQixhQUFkakI7UUFEZGlCLENBQUFBLEdBQUFBO01BbkhGdkMsR0FBQUEsV0FBQUEsRUFBYXlDLFdBQWJ6QztJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDI4OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvd2luZG93LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jyb3dzZXIvd2luZG93L3ZpZXcnXG5yZXF1aXJlICdicm93c2VyL3dpbmRvdy9zaXplJ1xuXG5tb2R1bGUgQnJvd3NlclxuXG4jIFdyYXBwZXIgY2xhc3MgZm9yIHRoZSBgd2luZG93YCBvYmplY3QsIGFuIGluc3RhbmNlIG9mIGl0IGdldHNcbiMgc2V0IHRvIGAkd2luZG93YC5cbmNsYXNzIFdpbmRvd1xuICBkZWYgc2VsZi5vcGVuKHVybCwgb3B0aW9ucylcbiAgICBuYW1lICAgICA9IG9wdGlvbnMuZGVsZXRlKDpuYW1lKVxuICAgIGZlYXR1cmVzID0gb3B0aW9ucy5tYXAge3xrZXksIHZhbHVlfFxuICAgICAgdmFsdWUgPSBjYXNlIHZhbHVlXG4gICAgICAgICAgICAgIHdoZW4gdHJ1ZSAgdGhlbiA6eWVzXG4gICAgICAgICAgICAgIHdoZW4gZmFsc2UgdGhlbiA6bm9cbiAgICAgICAgICAgICAgZWxzZSAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgICBcIiN7a2V5fT0je3ZhbHVlfVwiXG4gICAgfS5qb2luKD8sKVxuXG4gICAgJXh7XG4gICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4oI3t1cmx9LCAje25hbWV9LCAje2ZlYXR1cmVzfSk7XG5cbiAgICAgIGlmICh3aW4gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tuZXcoYHdpbmApfTtcbiAgICB9XG4gIGVuZFxuXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuICBpbmNsdWRlIEV2ZW50OjpUYXJnZXRcblxuICB0YXJnZXQge3x2YWx1ZXxcbiAgICAkd2luZG93IGlmIGAje3ZhbHVlfSA9PSB3aW5kb3dgXG4gIH1cblxuICAjIEFsZXJ0IHRoZSBwYXNzZWQgc3RyaW5nLlxuICBkZWYgYWxlcnQodmFsdWUpXG4gICAgYCNAbmF0aXZlLmFsZXJ0KHZhbHVlKWBcblxuICAgIHZhbHVlXG4gIGVuZFxuXG4gICMgRGlzcGxheSBhIHByb21wdCBkaWFsb2cgd2l0aCB0aGUgcGFzc2VkIHN0cmluZyBhcyB0ZXh0LlxuICBkZWYgcHJvbXB0KHZhbHVlLCBkZWZhdWx0PW5pbClcbiAgICBgI0BuYXRpdmUucHJvbXB0KHZhbHVlLCAje2RlZmF1bHQgfHwgXCJcIn0pIHx8IG5pbGBcbiAgZW5kXG5cbiAgIyBEaXNwbGF5IGEgY29uZmlybWF0aW9uIGRpYWxvZyB3aXRoIHRoZSBwYXNzZWQgc3RyaW5nIGFzIHRleHQuXG4gIGRlZiBjb25maXJtKHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5jb25maXJtKHZhbHVlKSB8fCBmYWxzZWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcGFyZW50XG4gICMgQHJldHVybiBbV2luZG93XSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgd2luZG93IG9yIHN1YmZyYW1lXG4gIGRlZiBwYXJlbnRcbiAgICBAcGFyZW50IHx8PSBCcm93c2VyOjpXaW5kb3cubmV3KGAjQG5hdGl2ZS5wYXJlbnRgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB0b3BcbiAgIyBAcmV0dXJuIFtXaW5kb3ddIHJlZmVyZW5jZSB0byB0aGUgdG9wbW9zdCB3aW5kb3cgaW4gdGhlIHdpbmRvdyBoaWVyYXJjaHlcbiAgZGVmIHRvcFxuICAgIEB0b3AgfHw9IEJyb3dzZXI6OldpbmRvdy5uZXcoYCNAbmF0aXZlLnRvcGApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG9wZW5lclxuICAjIEByZXR1cm4gW1dpbmRvd10gcmVmZXJlbmNlIHRvIHRoZSB3aW5kb3cgdGhhdCBvcGVuZWQgdGhlIHdpbmRvdyB1c2luZyBgb3BlbmBcbiAgZGVmIG9wZW5lclxuICAgIEBvcGVuZXIgfHw9IEJyb3dzZXI6OldpbmRvdy5uZXcoYCNAbmF0aXZlLm9wZW5lcmApXG4gIGVuZFxuXG4gICMgR2V0IHRoZSB7Vmlld30gZm9yIHRoZSB3aW5kb3cuXG4gICNcbiAgIyBAcmV0dXJuIFtWaWV3XVxuICBkZWYgdmlld1xuICAgIEB2aWV3IHx8PSBWaWV3Lm5ldyhzZWxmKVxuICBlbmRcblxuICAjIEdldCB0aGUge1NpemV9IGZvciB0aGlzIHdpbmRvdy5cbiAgI1xuICAjIEByZXR1cm4gW1NpemVdXG4gIGRlZiBzaXplXG4gICAgQHNpemUgfHw9IFNpemUubmV3KHNlbGYpXG4gIGVuZFxuXG4gICMgR2V0IHRoZSB7RE9NOjpFbGVtZW50OjpTY3JvbGx9IGZvciB0aGlzIHdpbmRvdy5cbiAgI1xuICAjIEByZXR1cm4gW0RPTTo6RWxlbWVudDo6U2Nyb2xsXVxuICBkZWYgc2Nyb2xsXG4gICAgQHNjcm9sbCB8fD0gRE9NOjpFbGVtZW50OjpTY3JvbGwubmV3KHNlbGYpXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdXaW5kb3cuc2VuZCdcbiAgICBkZWYgc2VuZChtZXNzYWdlLCBvcHRpb25zID0ge30pXG4gICAgICBgI0BuYXRpdmUucG9zdE1lc3NhZ2UoI3ttZXNzYWdlfSwgI3tvcHRpb25zWzp0b10gfHwgJyonfSlgXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSB3aW5kb3cuXG4gICAgI1xuICAgICMgQHBhcmFtIG1lc3NhZ2UgW1N0cmluZ10gdGhlIG1lc3NhZ2VcbiAgICAjIEBwYXJhbSBvcHRpb25zIFtIYXNoXSBvcHRpb25hbCBgdG86IHRhcmdldGBcbiAgICBkZWYgc2VuZChtZXNzYWdlLCBvcHRpb25zID0ge30pXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnbWVzc2FnZSBzZW5kaW5nIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2VcbiAgICBgI3tAbmF0aXZlfS5jbG9zZSgpYFxuICBlbmRcbmVuZFxuXG5lbmRcblxuJHdpbmRvdyA9IEJyb3dzZXI6OldpbmRvdy5uZXcoYHdpbmRvd2ApXG5cbm1vZHVsZSBLZXJuZWxcbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNhbGVydClcbiAgZGVmIGFsZXJ0KHZhbHVlKVxuICAgICR3aW5kb3cuYWxlcnQodmFsdWUpXG4gIGVuZFxuXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjcHJvbXB0KVxuICBkZWYgcHJvbXB0KHZhbHVlLCBkZWZhdWx0PW5pbClcbiAgICAkd2luZG93LnByb21wdCh2YWx1ZSwgZGVmYXVsdClcbiAgZW5kXG5cbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNjb25maXJtKVxuICBkZWYgY29uZmlybSh2YWx1ZSlcbiAgICAkd2luZG93LmNvbmZpcm0odmFsdWUpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpXaW5kb3c+Iiwib3BlbiIsInVybCIsIm9wdGlvbnMiLCJuYW1lIiwiZGVsZXRlIiwiZmVhdHVyZXMiLCJtYXAiLCJibG9jayBpbiBvcGVuIiwia2V5IiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIG9wZW4iLCIkcmV0X29yXzEiLCJqb2luIiwibmV3IiwiaW5jbHVkZSIsIkJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXIiLCJCcm93c2VyIiwiRXZlbnQ6OlRhcmdldCIsIkV2ZW50IiwidGFyZ2V0IiwiYmxvY2sgaW4gPGNsYXNzOldpbmRvdz4iLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpXaW5kb3c+IiwiJHdpbmRvdyIsImFsZXJ0IiwiQG5hdGl2ZSIsInByb21wdCIsImRlZmF1bHQkIiwiY29uZmlybSIsInBhcmVudCIsIkBwYXJlbnQiLCJCcm93c2VyOjpXaW5kb3ciLCJ0b3AiLCJAdG9wIiwib3BlbmVyIiwiQG9wZW5lciIsInZpZXciLCJAdmlldyIsIlZpZXciLCJzaXplIiwiQHNpemUiLCJTaXplIiwic2Nyb2xsIiwiQHNjcm9sbCIsIkRPTTo6RWxlbWVudDo6U2Nyb2xsIiwiRE9NOjpFbGVtZW50IiwiRE9NIiwic3VwcG9ydHM/Iiwic2VuZCIsIm1lc3NhZ2UiLCJbXSIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsImNsb3NlIiwiPG1vZHVsZTpLZXJuZWw+Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFR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ZmZzZXQiOnsibGluZSI6MzA0NTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2h0dHAvYmluYXJ5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgSFRUUFxuXG4jIFJlcHJlc2VudHMgYSBiaW5hcnkgcmVzdWx0IGZyb20gYSBIVFRQIHJlc3BvbnNlLlxuY2xhc3MgQmluYXJ5XG4gICMgQCFhdHRyaWJ1dGUgW3JdIHR5cGVcbiAgIyBAcmV0dXJuIFs6c3RyaW5nLCA6YnVmZmVyXSB0aGUgdHlwZSBvZiBiaW5hcnlcbiAgYXR0cl9yZWFkZXIgOnR5cGVcblxuICAjIENyZWF0ZSBhIGJpbmFyeSBmcm9tIGEgdmFsdWUuXG4gICNcbiAgIyBAcGFyYW0gdmFsdWUgW1N0cmluZywgQnVmZmVyXSB0aGUgYmluYXJ5XG4gIGRlZiBpbml0aWFsaXplKHZhbHVlKVxuICAgIGlmIFN0cmluZyA9PT0gdmFsdWVcbiAgICAgIEB0eXBlID0gOnN0cmluZ1xuICAgICAgQGRhdGEgPSB2YWx1ZVxuICAgIGVsc2VcbiAgICAgIEB0eXBlID0gOmJ1ZmZlclxuICAgICAgQGRhdGEgPSB2YWx1ZS50b19hXG4gICAgZW5kXG4gIGVuZFxuXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICMgSXRlcmF0ZSBvdmVyIGVhY2ggYnl0ZSBpbiB0aGUgYmluYXJ5LlxuICAjXG4gICMgQHlpZWxkIFtieXRlXSB0aGUgYnl0ZVxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgIGluZGV4ICA9IDBcbiAgICBsZW5ndGggPSBzZWxmLmxlbmd0aFxuXG4gICAgd2hpbGUgaW5kZXggPCBsZW5ndGhcbiAgICAgIGJsb2NrLmNhbGwoc2VsZltpbmRleF0pXG5cbiAgICAgIGluZGV4ICs9IDFcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBBY2Nlc3MgYSBieXRlIGZyb20gdGhlIGJpbmFyeS5cbiAgI1xuICAjIEByZXR1cm4gW0ludGVnZXJdIGEgYnl0ZVxuICBkZWYgW10oaW5kZXgpXG4gICAgQHR5cGUgPT0gOnN0cmluZyA/IGAjQGRhdGEuY2hhckNvZGVBdChpbmRleCkgJiAweGZmYCA6IEBkYXRhW2luZGV4XVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBsZW5ndGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbGVuZ3RoIG9mIHRoZSBiaW5hcnlcbiAgZGVmIGxlbmd0aFxuICAgIEBkYXRhLmxlbmd0aFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpIVFRQPiIsIjxjbGFzczpCaW5hcnk+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsInZhbHVlIiwiU3RyaW5nIiwiQHR5cGUiLCJAZGF0YSIsInRvX2EiLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImVhY2giLCJibG9jayIsImVudW1fZm9yIiwiaW5kZXgiLCIwIiwibGVuZ3RoIiwiPCIsImNhbGwiLCJbXSIsIisiLCIxIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUdoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFHRUMsSUFBQUMsYUFBQUEsQ0FBWSxNQUFaQTs7QUFLQUMsUUFBQUEsMEJBQUFBLHNCQUFlQyxLQUFmRDtBQUFBQSxVQUFBQTs7VUFDRSxJQUFBLFFBQUdFLFlBQUgsRUFBY0QsS0FBZCxDQUFBOztZQUNFRSxZQUFRO1lBQ1JILE9BQUFJLENBQUFBLFlBQVFILEtBQVJHO1VBRkY7O1lBSUVELFlBQVE7WUFDUkgsT0FBQUksQ0FBQUEsWUFBUUgsS0FBS0ksTUFBQUEsQ0FBQUEsQ0FBYkQ7VUFMRjtRQURGSixDQUFBQSxHQUFBQTtRQVVBRixJQUFBUSxTQUFBQSxDQUFRQyxnQkFBUkQ7O0FBT0FFLFFBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFDRSxLQUFBLFFBQTZCQyxLQUE3QixDQUFBO1lBQUEsT0FBT1gsSUFBQVksVUFBQUEsQ0FBUyxNQUFUQTtVQUFQO1VBRUFDLFFBQVNDO1VBQ1RDLFNBQVNmLElBQUllLFFBQUFBLENBQUFBO1VBRWIsT0FBQSxRQUFZQyxPQUFOSCxLQUFNRyxFQUFFRCxNQUFGQyxDQUFaLENBQUE7O1lBQ0VMLEtBQUtNLE1BQUFBLENBQU1qQixJQUFJa0IsT0FBQUEsQ0FBQ0wsS0FBREssQ0FBVkQ7WUFFTEosUUFBTU0sU0FBTk4sS0FBTU0sRUFBR0MsQ0FBSEQ7VUFIUjtVQU1BVCxPQUFBVjtRQVpGVSxDQUFBQSxHQUFBQTs7QUFrQkFRLFFBQUFBLGtCQUFBQSxzQkFBT0wsS0FBUEs7QUFBQUEsVUFBQUE7O1VBQ0UsSUFBQSxNQUFBYixTQUFBLEVBQVMsUUFBVCxDQUFBO1lBQW1CYSxPQUFFWixTQUFLWTtVQUExQjtZQUF1REEsT0FBQVosU0FBS1ksT0FBQUEsQ0FBQ0wsS0FBREs7VUFBNUQ7UUFERkEsQ0FBQUEsR0FBQUE7UUFNQW5CLE9BQUFnQixzQkFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBVCxTQUFLUyxRQUFBQSxDQUFBQTtRQURQQSxDQUFBQSxHQUFBQTtNQWpERmhCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBSGdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwNTI5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL3V0aWxzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvXG5cbm1vZHVsZSBVdGlsc1xuICBkZWYgc2VsZi5oZXJlZG9jKHN0cmluZylcbiAgICBpbmRlbnQgPSBzdHJpbmcuc2NhbigvXlsgXFx0XSooPz1cXFMpLykubWluLnNpemUgcmVzY3VlIDBcblxuICAgIHN0cmluZy5nc3ViKC9eWyBcXHRdeyN7aW5kZW50fX0vLCAnJylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVlcF9tZXJnZShhLCBiKVxuICAgIG1lcmdlciA9IHByb2Mge3xrZXksIHYxLCB2MnxcbiAgICAgIGlmIEhhc2ggPT09IHYxICYmIEhhc2ggPT09IHYyXG4gICAgICAgIHYxLm1lcmdlKHYyLCAmbWVyZ2VyKVxuICAgICAgZWxzZVxuICAgICAgICB2MlxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgYS5tZXJnZShiLCAmbWVyZ2VyKVxuICBlbmRcblxuICBkZWYgc2VsZi5kZWVwX21lcmdlIShhLCBiKVxuICAgIG1lcmdlciA9IHByb2Mge3xrZXksIHYxLCB2MnxcbiAgICAgIGlmIEhhc2ggPT09IHYxICYmIEhhc2ggPT09IHYyXG4gICAgICAgIHYxLm1lcmdlISh2MiwgJm1lcmdlcilcbiAgICAgICAgdjFcbiAgICAgIGVsc2VcbiAgICAgICAgdjJcbiAgICAgIGVuZFxuICAgIH1cblxuICAgIGEubWVyZ2UhKGIsICZtZXJnZXIpXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxtb2R1bGU6VXRpbHM+IiwiaGVyZWRvYyIsInNlbGYiLCJzdHJpbmciLCJpbmRlbnQiLCJzY2FuIiwibWluIiwic2l6ZSIsIlN0YW5kYXJkRXJyb3IiLCIwIiwiZ3N1YiIsImRlZXBfbWVyZ2UiLCJhIiwiYiIsIm1lcmdlciIsInByb2MiLCJibG9jayBpbiBkZWVwX21lcmdlIiwia2V5IiwidjEiLCJ2MiIsIkhhc2giLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZXBfbWVyZ2UiLCJtZXJnZSIsInRvX3Byb2MiLCJkZWVwX21lcmdlISIsImJsb2NrIGluIGRlZXBfbWVyZ2UhIiwibWVyZ2UhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWVwX21lcmdlISJdLCJtYXBwaW5ncyI6IkFBQUFBLCtCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFFQUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRUMsTUFBSUMsSUFBSkQsY0FBQUEsbUJBQWlCRSxNQUFqQkY7QUFBQUEsUUFBQUE7OztRQUNFRyxTQUFTLGNBQUE7VUFBQUgsT0FBQUUsTUFBTUUsTUFBQUEsQ0FBTSxlQUFOQSxDQUFzQkMsS0FBQUEsQ0FBQUEsQ0FBSUMsTUFBQUEsQ0FBQUE7UUFBaEM7VUFBc0Msc0JBQUEsQ0FBQUMsbUJBQUEsQ0FBQTtZQUFBO2NBQU9QLE9BQUFRO1lBQVA7VUFBQSxDQUF0QztRQUFBLENBQUE7UUFFVFIsT0FBQUUsTUFBTU8sTUFBQUEsQ0FBTSxTQUFDVCxVQUFELEVBQVVHLE1BQVYsRUFBaUJILEdBQWpCLENBQUEsQ0FBWixFQUFpQ0EsRUFBM0JTO01BSFJULENBQUFBLEdBQUFBO01BTUFVLE1BQUlULElBQUpTLGlCQUFBQSxzQkFBb0JDLENBQUQsRUFBSUMsQ0FBdkJGO0FBQUFBLFFBQUFBOzs7UUFDRUcsU0FBU0MsTUFBQWIsSUFBQWEsUUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsYUFBT0MsR0FBRCxFQUFNQyxFQUFOLEVBQVVDLEVBQWhCSDs7VUFBTztVQUFLO1VBQUk7VUFDdkIsSUFBRyxDQUFBLFFBQUFJLFVBQUEsRUFBU0YsRUFBVCxDQUFBLElBQUEsQ0FBQSxRQUFlRSxVQUFmLEVBQXdCRCxFQUF4QixDQUFBLENBQUEsQ0FBSDtZQUNFRSxPQUFFQyxNQUFGSixFQUFFSSxTQUFBQSxFQUFBQSxDQUFPSCxFQUFQRyxDQUFBQSxFQUFZUixNQUFEUyxTQUFBQSxDQUFBQSxDQUFYRDtVQURKO1lBR0VELE9BQUFGO1VBSEYsRUFET0gsQ0FBQUEsR0FBQUQ7UUFRVEosT0FBQ1csTUFBRFYsQ0FBQ1UsU0FBQUEsRUFBQUEsQ0FBT1QsQ0FBUFMsQ0FBQUEsRUFBV1IsTUFBRFMsU0FBQUEsQ0FBQUEsQ0FBVkQ7TUFUSFgsQ0FBQUEsR0FBQUE7TUFZQVgsT0FBQXdCLE1BQUl0QixJQUFKc0Isa0JBQUFBLGtDQUFxQlosQ0FBRCxFQUFJQyxDQUF4Qlc7QUFBQUEsUUFBQUE7OztRQUNFVixTQUFTQyxNQUFBYixJQUFBYSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFBVSxhQUFPUixHQUFELEVBQU1DLEVBQU4sRUFBVUMsRUFBaEJNOztVQUFPO1VBQUs7VUFBSTtVQUN2QixJQUFHLENBQUEsUUFBQUwsVUFBQSxFQUFTRixFQUFULENBQUEsSUFBQSxDQUFBLFFBQWVFLFVBQWYsRUFBd0JELEVBQXhCLENBQUEsQ0FBQSxDQUFIOztZQUNJTyxNQUFGUixFQUFFUSxVQUFBQSxFQUFBQSxDQUFRUCxFQUFSTyxDQUFBQSxFQUFhWixNQUFEUyxTQUFBQSxDQUFBQSxDQUFaRztZQUNGQyxPQUFBVDtVQUZGO1lBSUVTLE9BQUFSO1VBSkYsRUFET00sQ0FBQUEsR0FBQVY7UUFTVFMsT0FBQ0UsTUFBRGQsQ0FBQ2MsVUFBQUEsRUFBQUEsQ0FBUWIsQ0FBUmEsQ0FBQUEsRUFBWVosTUFBRFMsU0FBQUEsQ0FBQUEsQ0FBWEc7TUFWSEYsQ0FBQUEsR0FBQUE7SUFuQkZ4QixHQUFBQSxXQUFBQTtFQUZBRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzA1OTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL25hdmlnYXRvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlclxuXG4jIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBuYXZpZ2F0b3IgYXBwbGljYXRpb24uXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvclxuY2xhc3MgTmF2aWdhdG9yXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gIFZlcnNpb24gPSBTdHJ1Y3QubmV3KDptYWpvciwgOm1pbm9yLCA6YnVpbGQpXG4gIFByb2R1Y3QgPSBTdHJ1Y3QubmV3KDpuYW1lLCA6dmVyc2lvbilcbiAgVmVuZG9yICA9IFN0cnVjdC5uZXcoOm5hbWUsIDp2ZXJzaW9uKVxuXG4gICMgUmVwcmVzZW50YXRpb24gb2YgYSBNSU1FIHR5cGUuXG4gIGNsYXNzIE1pbWVUeXBlXG4gICAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBwbHVnaW5cbiAgICAjIEByZXR1cm4gW1BsdWdpbl0gdGhlIHBsdWdpbiBmb3IgdGhlIE1JTUUgdHlwZVxuICAgIGRlZiBwbHVnaW5cbiAgICAgIFBsdWdpbi5uZXcoYCNAbmF0aXZlLmVuYWJsZWRQbHVnaW5gKVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gZGVzY3JpcHRpb25cbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgTUlNRSB0eXBlXG4gICAgYWxpYXNfbmF0aXZlIDpkZXNjcmlwdGlvblxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gZXh0ZW5zaW9uc1xuICAgICMgQHJldHVybiBbQXJyYXk8U3RyaW5nPl0gdGhlIGV4dGVuc2lvbnMgZm9yIHRoaXMgTUlNRSB0eXBlXG4gICAgZGVmIGV4dGVuc2lvbnNcbiAgICAgIGAjQG5hdGl2ZS5zdWZmaXhlc2Auc3BsaXQoL1xccyovKVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgTUlNRSB0eXBlXG4gICAgYWxpYXNfbmF0aXZlIDp0eXBlXG4gIGVuZFxuXG4gICMgUmVwcmVzZW50YXRpb24gb2YgYSBuYXZpZ2F0b3IgcGx1Z2luLlxuICAjXG4gICMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGx1Z2luXG4gIGNsYXNzIFBsdWdpbiA8IE5hdGl2ZTo6QXJyYXlcbiAgICBkZWYgaW5pdGlhbGl6ZShwbHVnaW4pXG4gICAgICBzdXBlciBwbHVnaW4gZG8gfG18XG4gICAgICAgIE1pbWVUeXBlLm5ldyhtKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBkZXNjcmlwdGlvblxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgcGx1Z2luIGRlc2NyaXB0aW9uXG4gICAgYWxpYXNfbmF0aXZlIDpkZXNjcmlwdGlvblxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gZmlsZVxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgZmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIHBsdWdpblxuICAgIGFsaWFzX25hdGl2ZSA6ZmlsZSwgOmZpbGVuYW1lXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBuYW1lXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBwbHVnaW4gbmFtZVxuICAgIGFsaWFzX25hdGl2ZSA6bmFtZVxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdmVyc2lvblxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgcGx1Z2luIHZlcnNpb25cbiAgICBhbGlhc19uYXRpdmUgOnZlcnNpb25cbiAgZW5kXG5cbiAgIyBSZXByZXNlbnRhdGlvbiBmb3IgdGhlIGFycmF5IG9mIHBsdWdpbnMuXG4gICNcbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3JQbHVnaW5zXG4gIGNsYXNzIFBsdWdpbnMgPCBOYXRpdmU6OkFycmF5XG4gICAgZGVmIGluaXRpYWxpemUocGx1Z2lucylcbiAgICAgIHN1cGVyIHBsdWdpbnMgZG8gfHB8XG4gICAgICAgIFBsdWdpbi5uZXcocClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBSZWxvYWQgYWxsIGJyb3dzZXIgcGx1Z2lucy5cbiAgICBkZWYgcmVmcmVzaFxuICAgICAgYCNAbmF0aXZlLnJlZnJlc2goZmFsc2UpYFxuICAgIGVuZFxuXG4gICAgIyBSZWxvYWQgYWxsIGJyb3dzZXIgcGx1Z2lucyByZWxvYWRpbmcgcGFnZXMgdGhhdCBjb250YWluIGA8ZW1iZWQ+YHMuXG4gICAgZGVmIHJlZnJlc2ghXG4gICAgICBgI0BuYXRpdmUucmVmcmVzaCh0cnVlKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gY29kZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGJyb3dzZXIgY29kZSBuYW1lXG4gIGFsaWFzX25hdGl2ZSA6Y29kZSwgOmFwcENvZGVOYW1lXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbmFtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGJyb3dzZXIgbmFtZVxuICBhbGlhc19uYXRpdmUgOm5hbWUsIDphcHBOYW1lXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdmVyc2lvblxuICAjIEByZXR1cm4gW1ZlcnNpb25dIHRoZSBicm93c2VyIHZlcnNpb25cbiAgZGVmIHZlcnNpb25cbiAgICBWZXJzaW9uLm5ldyhgI0BuYXRpdmUuYXBwVmVyc2lvbmAsIGAjQG5hdGl2ZS5hcHBNaW5vclZlcnNpb25gLCBgI0BuYXRpdmUuYnVpbGRJRGApXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgY29va2llcyBhcmUgZW5hYmxlZC5cbiAgYWxpYXNfbmF0aXZlIDpjb29raWVzPywgOmNvb2tpZUVuYWJsZWRcblxuICAjIENoZWNrIGlmIEROVCBpcyBkaXNhYmxlZC5cbiAgZGVmIHRyYWNrP1xuICAgIGAhI0BuYXRpdmUuZG9Ob3RUcmFja2BcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbGFuZ3VhZ2VcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBicm93c2VyIGxhbmd1YWdlXG4gIGFsaWFzX25hdGl2ZSA6bGFuZ3VhZ2VcblxuICAjIEAhYXR0cmlidXRlIFtyXSBtaW1lX3R5cGVzXG4gICMgQHJldHVybiBbTmF0aXZlOjpBcnJheTxNaW1lVHlwZT5dIHRoZSBzdXBwb3J0ZWQgTUlNRSB0eXBlc1xuICBkZWYgbWltZV90eXBlc1xuICAgIE5hdGl2ZTo6QXJyYXkubmV3IGAjQG5hdGl2ZS5taW1lVHlwZXNgLCBnZXQ6IDppdGVtLCBuYW1lZDogOm5hbWVkSXRlbSBkbyB8bXxcbiAgICAgIE1pbWVUeXBlLm5ldyhtKVxuICAgIGVuZFxuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSBicm93c2VyIGlzIGluIG9mZmxpbmUgbW9kZS5cbiAgZGVmIG9mZmxpbmU/XG4gICAgYCEjQG5hdGl2ZS5vbkxpbmVgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG9wZXJhdGluZ19zeXN0ZW1cbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBvcGVyYXRpbmcgc3lzdGVtIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgb25cbiAgYWxpYXNfbmF0aXZlIDpvcGVyYXRpbmdfc3lzdGVtLCA6b3NjcHVcblxuICBhbGlhcyBvcyBvcGVyYXRpbmdfc3lzdGVtXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcGxhdGZvcm1cbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBwbGF0Zm9ybSB0aGUgYnJvd3NlciBpcyBydW5uaW5nIG9uXG4gIGFsaWFzX25hdGl2ZSA6cGxhdGZvcm1cblxuICAjIEAhYXR0cmlidXRlIFtyXSBwbHVnaW5zXG4gICMgQHJldHVybiBbUGx1Z2luc10gdGhlIGVuYWJsZWQgcGx1Z2luc1xuICBkZWYgcGx1Z2luc1xuICAgIFBsdWdpbnMubmV3KGAjQG5hdGl2ZS5wbHVnaW5zYClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcHJvZHVjdFxuICAjIEByZXR1cm4gW1Byb2R1Y3RdIHRoZSBwcm9kdWN0IG5hbWUgYW5kIHZlcnNpb25cbiAgZGVmIHByb2R1Y3RcbiAgICBQcm9kdWN0Lm5ldyhgI0BuYXRpdmUucHJvZHVjdGAsIGAjQG5hdGl2ZS5wcm9kdWN0U3ViYClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdXNlcl9hZ2VudFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGJyb3dzZXIncyB1c2VyIGFnZW50XG4gIGFsaWFzX25hdGl2ZSA6dXNlcl9hZ2VudCwgOnVzZXJBZ2VudFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHZlbmRvclxuICAjIEByZXR1cm4gW1ZlbmRvcl0gdGhlIHZlbmRvciBuYW1lIGFuZCB2ZXJzaW9uXG4gIGRlZiB2ZW5kb3JcbiAgICBWZW5kb3IubmV3KGAjQG5hdGl2ZS52ZW5kb3JgLCBgI0BuYXRpdmUudmVuZG9yU3ViYClcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiBKYXZhIGlzIGVuYWJsZWQuXG4gIGRlZiBqYXZhP1xuICAgIGAjQG5hdGl2ZS5qYXZhRW5hYmxlZCgpYFxuICByZXNjdWVcbiAgICBmYWxzZVxuICBlbmRcblxuICAjIFJlcHJlc2VudGF0aW9uIG9mIHVzZXIgbG9jYXRpb24gYmFzZWQgb24gR2VvbG9jYXRpb24gQVBJXG4gICNcbiAgIyBFeGFtcGxlIHVzYWdlOlxuICAjIGBgYFxuICAjICR3aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0ZS50aGVuIGRvIHxwb3N8XG4gICMgICBwdXRzIFwiI3twb3MuY29vcmRzLmxhdGl0dWRlfSwgI3twb3MuY29vcmRzLmxvbmdpdHVkZX0sICN7cG9zLmNvb3Jkcy5hY2N1cmFjeX1cIlxuICAjIGVuZFxuICAjIGBgYFxuICAjXG4gICMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9zaXRpb25cbiAgY2xhc3MgUG9zaXRpb25cbiAgICBpbmNsdWRlIEJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXJcblxuICAgIGNsYXNzIENvb3Jkc1xuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgIyBAIWF0dHJpYnV0ZSBbcl0gbGF0aXR1ZGVcbiAgICAgIGFsaWFzX25hdGl2ZSA6bGF0aXR1ZGVcbiAgICAgICMgQCFhdHRyaWJ1dGUgW3JdIGxvbmdpdHVkZVxuICAgICAgYWxpYXNfbmF0aXZlIDpsb25naXR1ZGVcbiAgICAgICMgQCFhdHRyaWJ1dGUgW3JdIGFsdGl0dWRlXG4gICAgICBhbGlhc19uYXRpdmUgOmFsdGl0dWRlXG4gICAgICAjIEAhYXR0cmlidXRlIFtyXSBhY2N1cmFjeVxuICAgICAgYWxpYXNfbmF0aXZlIDphY2N1cmFjeVxuICAgICAgIyBAIWF0dHJpYnV0ZSBbcl0gYWx0aXR1ZGVfYWNjdXJhY3lcbiAgICAgIGFsaWFzX25hdGl2ZSA6YWx0aXR1ZGVfYWNjdXJhY3ksIDphbHRpdHVkZUFjY3VyYWN5XG4gICAgICAjIEAhYXR0cmlidXRlIFtyXSBoZWFkaW5nXG4gICAgICBhbGlhc19uYXRpdmUgOmhlYWRpbmdcbiAgICAgICMgQCFhdHRyaWJ1dGUgW3JdIHNwZWVkXG4gICAgICBhbGlhc19uYXRpdmUgOnNwZWVkXG4gICAgZW5kXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSB0aW1lc3RhbXBcbiAgICBhbGlhc19uYXRpdmUgOnRpbWVzdGFtcFxuXG4gICAgZGVmIGNvb3Jkc1xuICAgICAgQGNvb3JkcyB8fD0gQ29vcmRzLm5ldyhgI0BuYXRpdmUuY29vcmRzYClcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBHZW9sb2NhdGVzIHRoZSB1c2VyIG9uY2VcbiAgI1xuICAjIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUge1Bvc2l0aW9ufSBvYmplY3RcbiAgZGVmIGdlb2xvY2F0ZShtYXhfYWdlOiAwLCB0aW1lb3V0OiBGbG9hdDo6SU5GSU5JVFksIGhpZ2hfYWNjdXJhY3k6IGZhbHNlKVxuICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuICAgIHN1Y2MgPSBwcm9jIHsgfGl8IHByb21pc2UucmVzb2x2ZShQb3NpdGlvbi5uZXcoaSkpIH1cbiAgICBmYWlsID0gcHJvYyB7IHxpfCBwcm9taXNlLnJlamVjdChOYXRpdmUoaSkpIH1cbiAgICBvcHRzID0ge21heEFnZTogbWF4X2FnZSwgdGltZW91dDogdGltZW91dCwgZW5hYmxlSGlnaEFjY3VyYWN5OiBoaWdoX2FjY3VyYWN5fVxuICAgIGAjQG5hdGl2ZS5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oI3tzdWNjLnRvX259LCAje2ZhaWwudG9fbn0sICN7b3B0cy50b19ufSlgXG4gICAgcHJvbWlzZVxuICBlbmRcblxuICAjIEdlb2xvY2F0ZXMgdGhlIHVzZXIgbXVsdGlwbGUgdGltZXMgYW5kIGNhbGxzIGEgYmxvY2sgd2l0aCBoaXMgbG9jYXRpb25cbiAgIyB1bnRpbCAjc3RvcF90cmFja2luZyBpcyBjYWxsZWQgd2l0aCBhIHJldHVybmVkIGlkLiBDYWxscyBhIHByb2MgbmFtZWQgZXJyb3JcbiAgIyBpZiBlcnJvciBoYXBwZW5zLlxuICAjXG4gICMgQHJldHVybiBbSW50ZWdlcl0gYW4gSUQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhcmd1bWVudCB0byAjc3RvcF90cmFja2luZ1xuICBkZWYgdHJhY2sobWF4X2FnZTogMCwgdGltZW91dDogRmxvYXQ6OklORklOSVRZLCBoaWdoX2FjY3VyYWN5OiBmYWxzZSwgZXJyb3I6IHByb2N7fGl8fSwgJmJsb2NrKVxuICAgIG9wdHMgPSB7bWF4QWdlOiBtYXhfYWdlLCB0aW1lb3V0OiB0aW1lb3V0LCBlbmFibGVIaWdoQWNjdXJhY3k6IGhpZ2hfYWNjdXJhY3l9XG4gICAgc3VjYyA9IHByb2MgeyB8aXwgYmxvY2suY2FsbChQb3NpdGlvbi5uZXcoaSkpIH1cbiAgICBmYWlsID0gcHJvYyB7IHxpfCBlcnJvci5jYWxsKE5hdGl2ZShpKSkgfVxuICAgIGAjQG5hdGl2ZS5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKCN7c3VjYy50b19ufSwgI3tmYWlsLnRvX259LCAje29wdHMudG9fbn0pYFxuICBlbmRcblxuICBkZWYgc3RvcF90cmFja2luZyhpZClcbiAgICBgI0BuYXRpdmUuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCgje2lkfSlgXG4gIGVuZFxuXG4gICMgVHJpZ2dlcnMgYSB2aWJyYXRpb24gb24gYSBkZXZpY2UuIEEgcGF0dGVybiBjYW4gYmUgZWl0aGVyIGEgbnVtYmVyIG9mXG4gICMgbWlsaXNlY29uZHMgZm9yIGEgdmlicmF0aW9uIGxlbmd0aCwgb3IgYW4gYXJyYXkgb2YgbGVuZ3RocyAoaW5cbiAgIyBtaWxpc2Vjb25kcykgd2hpY2ggZGVzY3JpYmVzIGEgdmlicmF0aW9uIHBhdHRlcm4gLSBmaXJzdCBlbGVtZW50IG9mIHNhaWRcbiAgIyBhcnJheSBkZXNjcmliZXMgaG93IGxvbmcgdGhlIGRldmljZSBzaG91bGQgdmlicmF0ZSwgc2Vjb25kIC0gaG93IGxvbmcgdG9cbiAgIyBzdG9wIGZvciBhbmQgc28gb24uXG4gIGRlZiB2aWJyYXRlKHBhdHRlcm4pXG4gICAgYCNAbmF0aXZlLnZpYnJhdGUoI3twYXR0ZXJuLnRvX259KWBcbiAgZW5kXG5cbiAgIyBDaGVjayBhIGJhdHRlcnkgc3RhdHVzIG9mIHVzZXIgZGV2aWNlLiBUaGlzIEFQSSBpcyBkZXByZWNhdGVkIGluIHRoZSBicm93c2VyXG4gICMgY29udGV4dCBhbmQgdXNhYmxlIG1haW5seSBpbiBwcml2aWxlZ2VkIGNvbnRleHRzLlxuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIGJhdHRlcnkgc3RhdHVzXG4gICNcbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvZ2V0QmF0dGVyeVxuICBkZWYgZ2V0X2JhdHRlcnlcbiAgICBwcm9taXNlID0gUHJvbWlzZS5uZXdcbiAgICB5ZXMgPSBwcm9jIHsgfHJ8IHByb21pc2UucmVzb2x2ZShOYXRpdmUocikpIH1cbiAgICBubyA9IHByb2MgeyB8cnwgcHJvbWlzZS5yZWplY3QoTmF0aXZlKHIpKSB9XG4gICAgYCNAbmF0aXZlLmdldEJhdHRlcnkoKS50aGVuKCN7eWVzLnRvX259KS5jYXRjaCgje25vLnRvX259KWBcbiAgICBwcm9taXNlXG4gIGVuZFxuXG4gICMgUXVldWUgdG8gc2VuZCBhIHNtYWxsIGFtb3VudCBvZiBkYXRhIHRvIGEgc2VydmVyLlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB1cmwgdG8gdHJpZ2dlclxuICAjIEBwYXJhbSBwYXlsb2FkIFtTdHJpbmcsIEJsb2IsIEZvcm1EYXRhLCBIYXNoXSBkYXRhIHRvIHNlbmRcbiAgI1xuICAjIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvci9zZW5kQmVhY29uXG4gIGRlZiBzZW5kX2JlYWNvbih1cmwsIHBheWxvYWQ9bmlsKVxuICAgIGAjQG5hdGl2ZS5zZW5kQmVhY29uKCN7dXJsfSwgI3twYXlsb2FkLnRvX259KWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgV2luZG93XG4gICMgQCFhdHRyaWJ1dGUgW3JdIG5hdmlnYXRvclxuICAjIEByZXR1cm4gW05hdmlnYXRvcl0gdGhlIG5hdmlnYXRvclxuICBkZWYgbmF2aWdhdG9yXG4gICAgQG5hdmlnYXRvciB8fD0gTmF2aWdhdG9yLm5ldyhgI0BuYXRpdmUubmF2aWdhdG9yYCkgaWYgYCNAbmF0aXZlLm5hdmlnYXRvcmBcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6TmF2aWdhdG9yPiIsInNlbGYiLCJpbmNsdWRlIiwiQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlciIsIkJyb3dzZXIiLCJTdHJ1Y3QiLCJuZXciLCI8Y2xhc3M6TWltZVR5cGU+IiwicGx1Z2luIiwiUGx1Z2luIiwiQG5hdGl2ZSIsImFsaWFzX25hdGl2ZSIsImV4dGVuc2lvbnMiLCJzcGxpdCIsIjxjbGFzczpQbHVnaW4+IiwiaW5pdGlhbGl6ZSIsImJsb2NrIGluIGluaXRpYWxpemUiLCJtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiTWltZVR5cGUiLCJOYXRpdmU6OkFycmF5IiwiTmF0aXZlIiwiPGNsYXNzOlBsdWdpbnM+IiwicGx1Z2lucyIsInAiLCJyZWZyZXNoIiwicmVmcmVzaCEiLCJ2ZXJzaW9uIiwiVmVyc2lvbiIsInRyYWNrPyIsIm1pbWVfdHlwZXMiLCJibG9jayBpbiBtaW1lX3R5cGVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW1lX3R5cGVzIiwib2ZmbGluZT8iLCJQbHVnaW5zIiwicHJvZHVjdCIsIlByb2R1Y3QiLCJ2ZW5kb3IiLCJWZW5kb3IiLCJqYXZhPyIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6UG9zaXRpb24+IiwiPGNsYXNzOkNvb3Jkcz4iLCJOYXRpdmU6OldyYXBwZXIiLCJjb29yZHMiLCJAY29vcmRzIiwiJHJldF9vcl8xIiwiQ29vcmRzIiwiZ2VvbG9jYXRlIiwiJGt3YXJncyIsIjAiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsInByb21pc2UiLCJQcm9taXNlIiwic3VjYyIsInByb2MiLCJibG9jayBpbiBnZW9sb2NhdGUiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBnZW9sb2NhdGUiLCJyZXNvbHZlIiwiUG9zaXRpb24iLCJmYWlsIiwicmVqZWN0Iiwib3B0cyIsIm1heF9hZ2UiLCJ0aW1lb3V0IiwiaGlnaF9hY2N1cmFjeSIsInRvX24iLCJ0cmFjayIsImJsb2NrIGluIHRyYWNrIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFjayIsImJsb2NrIiwiY2FsbCIsImVycm9yIiwic3RvcF90cmFja2luZyIsImlkIiwidmlicmF0ZSIsInBhdHRlcm4iLCJnZXRfYmF0dGVyeSIsInllcyIsImJsb2NrIGluIGdldF9iYXR0ZXJ5IiwiciIsImJsb2NrICgyIGxldmVscykgaW4gZ2V0X2JhdHRlcnkiLCJubyIsInNlbmRfYmVhY29uIiwidXJsIiwicGF5bG9hZCIsIjxjbGFzczpXaW5kb3c+IiwibmF2aWdhdG9yIiwiQG5hdmlnYXRvciIsIk5hdmlnYXRvciJdLCJtYXBwaW5ncyI6IkFBQUFBLG9DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBS0FDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLGFBQUFELHdCQUFSRDtNQUVBLG1DQUFVRyxZQUFNQyxLQUFBQSxDQUFLLE9BQVgsRUFBbUIsT0FBbkIsRUFBMkIsT0FBckJBLENBQWhCO01BQ0EsbUNBQVVELFlBQU1DLEtBQUFBLENBQUssTUFBWCxFQUFrQixTQUFaQSxDQUFoQjtNQUNBLGtDQUFVRCxZQUFNQyxLQUFBQSxDQUFLLE1BQVgsRUFBa0IsU0FBWkEsQ0FBaEI7TUFHQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRU4sSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsd0JBQVJEOztBQUlBTSxRQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBQyxZQUFNSCxLQUFBQSxDQUFPSSxjQUFPRixjQUFkRjtRQURSRSxDQUFBQSxHQUFBQTtRQU1BUCxJQUFBVSxjQUFBQSxDQUFhLGFBQWJBOztBQUlBQyxRQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBQSxDQUFFRixjQUFPRSxTQUFUQSxDQUFtQkMsT0FBQUEsQ0FBTyxLQUFQQTtRQURyQkQsQ0FBQUEsR0FBQUE7UUFNQUwsT0FBQU4sSUFBQVUsY0FBQUEsQ0FBYSxNQUFi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QUE7O1FBQ0UsSUFBQSxRQUF3RC9FLGNBQU8rRSxVQUEvRCxDQUFBO1VBQUFBLE9BQUFDLENBQUFBLGlCQTdRSixDQUFBLFFBQUE1QyxDQUFBQSxZQTZRSTRDLGNBN1FKNUMsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0E2UW1CNkMsZUFBU3JGLEtBQUFBLENBQU9JLGNBQU8rRSxVQUFkbkYsQ0E3UTVCLENBQUEsQ0E2UUlvRjtRQUFBO1VBN1FKRCxPQUFBO1FBNlFJO01BREZBLENBQUFBLEdBQUFBO0lBSEZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBelFBekYsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwOTAzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9kZXZpY2VfbGlnaHQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIERldmljZUxpZ2h0IDwgRXZlbnRcbiAgaGFuZGxlcyAnZGV2aWNlbGlnaHQnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5EZXZpY2VMaWdodCdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgdmFsdWU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnZhbHVlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRGV2aWNlTGlnaHRFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOnZhbHVlXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6RGV2aWNlTGlnaHQ+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsInZhbHVlPSIsInZhbHVlIiwiQG5hdGl2ZSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsYUFBUkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLHVDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixtQkFBWEU7UUFEVEYsQ0FBQUEsR0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTtVQUNFQSxPQUFBQyxzQkFBQUEsZ0NBQVdDLEtBQVhEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixTQUFXQztVQUR0QkQsQ0FBQUEsR0FBQUE7UUFERkQsR0FBQUEsV0FBQUEsRUFBbUJJLGdCQUFuQko7UUFNQSxJQUFBLFFBSU9MLElBQUFFLGVBQUFBLENBQUFBLENBSlAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFTSxNQUFJVixJQUFKVSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxxQkFBdUJDLElBQUtELEVBQUlFLElBQUtGO1lBRHhDQSxDQUFBQSxHQUFBQTtVQURGO1FBQUE7UUFNQVgsT0FBQUMsSUFBQWEsY0FBQUEsQ0FBYSxPQUFiQTtNQW5CRmQsR0FBQUEsV0FBQUEsRUFBb0JlLFdBQXBCZjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDk1NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZGV2aWNlX3Byb3hpbWl0eS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgRGV2aWNlUHJveGltaXR5IDwgRXZlbnRcbiAgaGFuZGxlcyAnZGV2aWNlcHJveGltaXR5J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuRGV2aWNlUHJveGltaXR5J1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiB2YWx1ZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudmFsdWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBtaW49KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLm1pbiA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG1heD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubWF4ID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRGV2aWNlUHJveGltaXR5RXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDp2YWx1ZVxuICBhbGlhc19uYXRpdmUgOm1pblxuICBhbGlhc19uYXRpdmUgOm1heFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkRldmljZVByb3hpbWl0eT4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwidmFsdWU9IiwidmFsdWUiLCJAbmF0aXZlIiwibWluPSIsIm1heD0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLGlEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsMkNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLHVCQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsc0JBQUFBLGdDQUFXQyxLQUFYRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsU0FBV0M7VUFEdEJELENBQUFBLEdBQUFBOztBQUlBRyxVQUFBQSxvQkFBQUEsOEJBQVNGLEtBQVRFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxPQUFTRjtVQURwQkUsQ0FBQUEsR0FBQUE7VUFJQUosT0FBQUssb0JBQUFBLDhCQUFTSCxLQUFURztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUYsY0FBT0UsT0FBU0g7VUFEcEJHLENBQUFBLEdBQUFBO1FBVEZMLEdBQUFBLFdBQUFBLEVBQW1CTSxnQkFBbkJOO1FBY0EsSUFBQSxRQUlPTCxJQUFBRSxlQUFBQSxDQUFBQSxDQUpQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRVEsTUFBSVosSUFBSlksZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0EseUJBQTJCQyxJQUFLRCxFQUFJRSxJQUFLRjtZQUQ1Q0EsQ0FBQUEsR0FBQUE7VUFERjtRQUFBO1FBTUFaLElBQUFlLGNBQUFBLENBQWEsT0FBYkE7UUFDQWYsSUFBQWUsY0FBQUEsQ0FBYSxLQUFiQTtRQUNBaEIsT0FBQUMsSUFBQWUsY0FBQUEsQ0FBYSxLQUFiQTtNQTdCRmhCLEdBQUFBLFdBQUFBLEVBQXdCaUIsV0FBeEJqQjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMTAyMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY3NzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jyb3dzZXIvY3NzL2RlY2xhcmF0aW9uJ1xucmVxdWlyZSAnYnJvd3Nlci9jc3Mvc3R5bGVfc2hlZXQnXG5yZXF1aXJlICdicm93c2VyL2Nzcy9ydWxlJ1xucmVxdWlyZSAnYnJvd3Nlci9jc3MvcnVsZS9zdHlsZSdcblxubW9kdWxlIEtlcm5lbFxuICAjIEBvdmVybG9hZCBDU1MoZG9jdW1lbnQgPSAkZG9jdW1lbnQsICZibG9jaylcbiAgI1xuICAjICAgQ3JlYXRlIGEgYDxzdHlsZT5gIGVsZW1lbnQgZnJvbSBhIHtQYWdnaW86OkNTU30gRFNMLlxuICAjXG4gICMgICBAcGFyYW0gZG9jdW1lbnQgW0Jyb3dzZXI6OkRPTTo6RG9jdW1lbnRdIHRoZSBkb2N1bWVudCBpbnN0YW5jZVxuICAjICAgICB3ZSBpbnRlbmQgdG8gdXNlXG4gICNcbiAgIyAgIEByZXR1cm4gW0Jyb3dzZXI6OkRPTTo6RWxlbWVudF0gdGhlIGNyZWF0ZWQgYDxzdHlsZT5gIGVsZW1lbnRcbiAgI1xuICAjIEBvdmVybG9hZCBDU1Moc3RyaW5nLCBkb2N1bWVudCA9ICRkb2N1bWVudClcbiAgI1xuICAjICAgQ3JlYXRlIGEgYDxzdHlsZT5gIGVsZW1lbnQgZnJvbSBhIHN0cmluZy5cbiAgI1xuICAjICAgQHBhcmFtIGRvY3VtZW50IFtCcm93c2VyOjpET006OkRvY3VtZW50XSB0aGUgZG9jdW1lbnQgaW5zdGFuY2VcbiAgIyAgICAgd2UgaW50ZW5kIHRvIHVzZVxuICAjXG4gICMgICBAcmV0dXJuIFtCcm93c2VyOjpET006OkVsZW1lbnRdIHRoZSBjcmVhdGVkIGA8c3R5bGU+YCBlbGVtZW50XG4gIGRlZiBDU1MoKmFyZ3MsICZibG9jaylcbiAgICBkb2N1bWVudCA9IGlmIGFyZ3MubGVuZ3RoID4gMSB8fCBibG9ja19naXZlbj9cbiAgICAgIGFyZ3MucG9wXG4gICAgZW5kIHx8ICRkb2N1bWVudFxuXG4gICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVfZWxlbWVudCg6c3R5bGUpXG4gICAgc3R5bGVbOnR5cGVdID0gJ3RleHQvY3NzJ1xuXG4gICAgaWYgYmxvY2tcbiAgICAgIHN0eWxlLmlubmVyX3RleHQgPSBQYWdnaW8uY3NzKCZibG9jaylcbiAgICBlbHNlXG4gICAgICBzdHlsZS5pbm5lcl90ZXh0ID0gYXJncy5qb2luKFwiXCIpXG4gICAgZW5kXG5cbiAgICBzdHlsZVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxtb2R1bGU6S2VybmVsPiIsIkNTUyIsImRvY3VtZW50IiwiJHJldF9vcl8xIiwiPiIsImFyZ3MiLCJsZW5ndGgiLCIxIiwiYmxvY2tfZ2l2ZW4/IiwicG9wIiwiJGRvY3VtZW50Iiwic3R5bGUiLCJjcmVhdGVfZWxlbWVudCIsIltdPSIsImJsb2NrIiwiaW5uZXJfdGV4dD0iLCJjc3MiLCJQYWdnaW8iLCJ0b19wcm9jIiwiam9pbiJdLCJtYXBwaW5ncyI6IkFBQUFBLDhCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRix5QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYseUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGtCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix3QkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztJQWtCRUEsT0FBQUMsbUJBQUFBLGVBdkJGLEVBdUJFQTtBQUFBQSxNQUFBQTtBQUFBQTs7TUFBQUE7OztNQXZCRjtNQXVCVTtNQUNOQyxXQUFXLENBQUEsUUFBQUMsQ0FBQUEsWUFBQSxDQUFHLENBQUEsUUFBWUMsT0FBWkMsSUFBSUMsUUFBQUEsQ0FBQUEsQ0FBUUYsRUFBRUcsQ0FBRkgsQ0FBWixDQUFBLElBQUEsQ0FBbUJJLGVBQW5CLENBQUEsQ0FBSCxHQUFBLENBQ1RILElBQUlJLEtBQUFBLENBQUFBLENBREssSUFBQSxHQUFBLENBQUFOLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBRUpPLGVBRkksQ0FBQTtNQUlYQyxRQUFRVCxRQUFRVSxnQkFBQUEsQ0FBZ0IsT0FBaEJBO01BQ2hCRCxLQUFLRSxRQUFBQSxDQUFDLE1BQU4sRUFBZVosVUFBVlk7TUFFTCxJQUFBLFFBQUdDLEtBQUgsQ0FBQTtRQUNFSCxLQUFLSSxnQkFBQUEsQ0FBb0JDLE1BQU5DLFlBQU1ELE9BQUFBLEVBQUFBLEVBQUFBLEVBQU1GLEtBQURJLFNBQUFBLENBQUFBLENBQUxGLENBQXBCRDtNQURQO1FBR0VKLEtBQUtJLGdCQUFBQSxDQUFjVixJQUFJYyxNQUFBQSxDQUFNbEIsRUFBTmtCLENBQWxCSjtNQUhQO01BTUFkLE9BQUFVO0lBZEZWLENBQUFBLElBQUFBO0VBbEJGRCxHQUFBQSxXQUFBQTtBQUxBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MzEwNTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL3NldHVwL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBicm93c2VyL3NldHVwL2Jhc2U6IFNldHVwIG9ubHkgdGhlIGJhc2UgcmVxdWlyZXNcblxucmVxdWlyZSAnYnJvd3Nlci92ZXJzaW9uJ1xucmVxdWlyZSAnYnJvd3Nlci91dGlscydcbnJlcXVpcmUgJ2Jyb3dzZXIvZm9ybV9kYXRhJ1xucmVxdWlyZSAnYnJvd3Nlci9zdXBwb3J0J1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZUFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsbUJBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtBQUxBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MzEwNjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L3Byb2dyZXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBQcm9ncmVzcyA8IEV2ZW50XG4gIGhhbmRsZXMgJ3Byb2dyZXNzJywgJ2xvYWQnLCAnbG9hZGVuZCcsICdsb2Fkc3RhcnQnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5Qcm9ncmVzcydcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgY29tcHV0YWJsZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuY29tcHV0YWJsZUxlbmd0aCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGxvYWRlZD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubG9hZGVkID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgdG90YWw9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnRvdGFsID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgUHJvZ3Jlc3NFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIlByb2dyZXNzRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0UHJvZ3Jlc3NFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy5jb21wdXRhYmxlLCBkZXNjLmxvYWRlZCwgZGVzYy50b3RhbCk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6Y29tcHV0YWJsZT8sIDpjb21wdXRhYmxlTGVuZ3RoXG4gIGFsaWFzX25hdGl2ZSA6bG9hZGVkXG4gIGFsaWFzX25hdGl2ZSA6dG90YWxcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpQcm9ncmVzcz4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwiY29tcHV0YWJsZT0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJsb2FkZWQ9IiwidG90YWw9IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSx5Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixVQUFSLEVBQW9CQSxNQUFwQixFQUE0QkEsU0FBNUIsRUFBdUNBLFdBQXZDRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsb0NBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGdCQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsMkJBQUFBLHFDQUFnQkMsS0FBaEJEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixvQkFBc0JDO1VBRGpDRCxDQUFBQSxHQUFBQTs7QUFJQUcsVUFBQUEsdUJBQUFBLGlDQUFZRixLQUFaRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsVUFBWUY7VUFEdkJFLENBQUFBLEdBQUFBO1VBSUFKLE9BQUFLLHNCQUFBQSxnQ0FBV0gsS0FBWEc7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FLFNBQVdIO1VBRHRCRyxDQUFBQSxHQUFBQTtRQVRGTCxHQUFBQSxXQUFBQSxFQUFtQk0sZ0JBQW5CTjtRQWNBLElBQUEsUUFjT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VRLE1BQUlaLElBQUpZLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLGtCQUFvQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEckNBLENBQUFBLEdBQUFBO1VBREYsT0FJQSxJQUFBLFFBQU1ULGFBQU9DLGNBQUFBLENBQVdMLGNBQVhLLENBQWIsQ0FBQTtZQUNFUSxNQUFJWixJQUFKWSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUElBLENBQUFBLEdBQUFBO1VBREY7UUFKQTtRQWdCQVosSUFBQWUsY0FBQUEsQ0FBYSxhQUFiLEVBQTJCLGtCQUEzQkE7UUFDQWYsSUFBQWUsY0FBQUEsQ0FBYSxRQUFiQTtRQUNBaEIsT0FBQUMsSUFBQWUsY0FBQUEsQ0FBYSxPQUFiQTtNQXZDRmhCLEdBQUFBLFdBQUFBLEVBQWlCaUIsV0FBakJqQjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMTE0NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvaW1tZWRpYXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbiMgQ2xhc3MgdG8gZWFzaWx5IGNyZWF0ZSBhbmQgZGlzcGF0Y2ggYW4gaW1tZWRpYXRlIGNhbGwuXG4jXG4jIEltbWVkaWF0ZSBjYWxscyBhcmUgZGVmZXJyZWQgZnVuY3Rpb24gY2FsbHMgdGhhdCBoYXBwZW4gYXMgc29vbiBhcyB0aGV5IGNhblxuIyBiZSBzY2hlZHVsZWQuXG4jXG4jIENvbXBhdGliaWxpdHlcbiMgLS0tLS0tLS0tLS0tLVxuIyBUaGUgY29tcGF0aWJpbGl0eSBsYXllciB3aWxsIHRyeSB2YXJpb3VzIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nXG4jIG9yZGVyLlxuI1xuIyArIFtzZXRJbW1lZGlhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuc2V0SW1tZWRpYXRlKVxuIyArIFtwb3N0TWVzc2FnZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy5wb3N0TWVzc2FnZSlcbiMgKyBbcmVhZHlzdGF0ZWNoYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvUmVmZXJlbmNlL0V2ZW50cy9yZWFkeXN0YXRlY2hhbmdlKVxuIyArIFtzZXRUaW1lb3V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvd2luZG93LnNldFRpbWVvdXQpXG4jXG4jIFRoZSBvcmRlciBoYXMgYmVlbiBjaG9zZW4gZnJvbSBiZXN0IHRvIHdvcnN0IGZvciBib3RoIHBlcmZvcm1hbmNlIGFuZFxuIyBwcmVlbXB0aXZlbmVzcy5cbmNsYXNzIEltbWVkaWF0ZVxuICAjIENyZWF0ZSBhbiBpbW1lZGlhdGUgZm9yIHRoZSBnaXZlbiBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAjIGFyZ3VtZW50cyBhbmQgYmxvY2suXG4gICNcbiAgIyBAcGFyYW0gZnVuYyBbUHJvY10gdGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAgIyBAcGFyYW0gYXJncyBbQXJyYXldIHRoZSBhcmd1bWVudHMgdG8gY2FsbCBpdCB3aXRoXG4gIGRlZiBpbml0aWFsaXplKGZ1bmMsIGFyZ3MsICZibG9jaylcbiAgICBAYWJvcnRlZCAgID0gZmFsc2VcbiAgICBAZnVuY3Rpb24gID0gZnVuY1xuICAgIEBhcmd1bWVudHMgPSBhcmdzXG4gICAgQGJsb2NrICAgICA9IGJsb2NrXG4gIGVuZFxuXG4gICMgQCFtZXRob2QgZGlzcGF0Y2hcbiAgIyAgIERpc3BhdGNoIHRoZSBpbW1lZGlhdGUuXG5cbiAgIyBAIW1ldGhvZCBwcmV2ZW50XG4gICMgICBQcmV2ZW50IHRoZSBpbW1lZGlhdGUgZnJvbSBiZWluZyBjYWxsZWQgb25jZSBzY2hlZHVsZWQuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdJbW1lZGlhdGUnXG4gICAgZGVmIGRpc3BhdGNoXG4gICAgICBAaWQgPSBgd2luZG93LnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgI3tAZnVuY3Rpb24uY2FsbCgqQGFyZ3VtZW50cywgJkBibG9jayl9O1xuICAgICAgfSlgXG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudFxuICAgICAgYHdpbmRvdy5jbGVhckltbWVkaWF0ZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0ltbWVkaWF0ZSAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgIGRlZiBkaXNwYXRjaFxuICAgICAgQGlkID0gYHdpbmRvdy5tc1NldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgI3tAZnVuY3Rpb24uY2FsbCgqQGFyZ3VtZW50cywgJkBibG9jayl9O1xuICAgICAgfSlgXG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudFxuICAgICAgYHdpbmRvdy5tc0NsZWFySW1tZWRpYXRlKCNAaWQpYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnV2luZG93LnNlbmQgKEFzeW5jaHJvbm91cyknXG4gICAgIyBAcHJpdmF0ZVxuICAgIEBAdGFza3MgID0ge31cblxuICAgICMgQHByaXZhdGVcbiAgICBAQHByZWZpeCA9IFwib3BhbC5icm93c2VyLmltbWVkaWF0ZS4je3JhbmQoMV8wMDBfMDAwKX0uXCJcblxuICAgICR3aW5kb3cub24gOm1lc3NhZ2UgZG8gfGV8XG4gICAgICBpZiBTdHJpbmcgPT09IGUuZGF0YSAmJiBlLmRhdGEuc3RhcnRfd2l0aD8oQEBwcmVmaXgpXG4gICAgICAgIGlmIHRhc2sgPSBAQHRhc2tzLmRlbGV0ZShlLmRhdGFbQEBwcmVmaXgubGVuZ3RoIC4uIC0xXSlcbiAgICAgICAgICB0YXNrWzBdLmNhbGwoKnRhc2tbMV0sICZ0YXNrWzJdKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRpc3BhdGNoXG4gICAgICBAaWQgICAgICAgICAgPSByYW5kKDFfMDAwXzAwMCkudG9fc1xuICAgICAgQEB0YXNrc1tAaWRdID0gW0BmdW5jdGlvbiwgQGFyZ3VtZW50cywgQGJsb2NrXVxuXG4gICAgICAkd2luZG93LnNlbmQgXCIje0BAcHJlZml4fSN7QGlkfVwiXG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudFxuICAgICAgQEB0YXNrcy5kZWxldGUoQGlkKVxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQucmVhZHlzdGF0ZWNoYW5nZSdcbiAgICBkZWYgZGlzcGF0Y2hcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblxuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCEje2Fib3J0ZWQ/fSkge1xuICAgICAgICAgICAgI3tAZnVuY3Rpb24uY2FsbCgqQGFyZ3VtZW50cywgJkBibG9jayl9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudDsgZW5kXG4gIGVsc2VcbiAgICBkZWYgZGlzcGF0Y2hcbiAgICAgIEBpZCA9IGB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgI3tAZnVuY3Rpb24uY2FsbCgqQGFyZ3VtZW50cywgJkBibG9jayl9O1xuICAgICAgfSwgMClgXG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudFxuICAgICAgYHdpbmRvdy5jbGVhclRpbWVvdXQoI0BpZClgXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQWJvcnQgdGhlIGltbWVkaWF0ZS5cbiAgZGVmIGFib3J0XG4gICAgcmV0dXJuIGlmIGFib3J0ZWQ/XG5cbiAgICBAYWJvcnRlZCA9IHRydWVcbiAgICBwcmV2ZW50XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIGltbWVkaWF0ZSBoYXMgYmVlbiBhYm9ydGVkLlxuICBkZWYgYWJvcnRlZD9cbiAgICBAYWJvcnRlZFxuICBlbmRcbmVuZFxuXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICAjIChzZWUgSW1tZWRpYXRlLm5ldylcbiAgZGVmIGRlZmVyKCphcmdzLCAmYmxvY2spXG4gICAgQnJvd3Nlcjo6SW1tZWRpYXRlLm5ldyhibG9jaywgYXJncykudGFwKCY6ZGlzcGF0Y2gpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFByb2NcbiAgIyAoc2VlIEltbWVkaWF0ZS5uZXcpXG4gIGRlZiBkZWZlcigqYXJncywgJmJsb2NrKVxuICAgIEJyb3dzZXI6OkltbWVkaWF0ZS5uZXcoc2VsZiwgYXJncywgJmJsb2NrKS50YXAoJjpkaXNwYXRjaClcbiAgZW5kXG5lbmRcblxuY2xhc3MgUHJvbWlzZVxuICAjIENyZWF0ZSBhIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGltbWVkaWF0ZS5cbiAgI1xuICAjIEBwYXJhbSBhcmdzIFtBcnJheV0gdGhlIGFyZ3VtZW50cyB0aGUgYmxvY2sgd2lsbCBiZSBjYWxsZWQgd2l0aFxuICBkZWYgc2VsZi5kZWZlcigqYXJncywgJmJsb2NrKVxuICAgIG5ldy50YXAge3xwcm9taXNlfFxuICAgICAgcHJvYyB7XG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGJsb2NrLmNhbGwoKmFyZ3MpKVxuICAgICAgICByZXNjdWUgRXhjZXB0aW9uID0+IGVcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChlKVxuICAgICAgICBlbmRcbiAgICAgIH0uZGVmZXJcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6SW1tZWRpYXRlPiIsImluaXRpYWxpemUiLCJmdW5jIiwiYXJncyIsIkBhYm9ydGVkIiwiQGZ1bmN0aW9uIiwiQGFyZ3VtZW50cyIsIkBibG9jayIsImJsb2NrIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImRpc3BhdGNoIiwiQGlkIiwiY2FsbCIsInRvX3Byb2MiLCJwcmV2ZW50IiwiQEB0YXNrcyIsIkBAcHJlZml4Iiwic2VsZiIsInJhbmQiLCIxMDAwMDAwIiwib24iLCIkd2luZG93IiwiYmxvY2sgaW4gPGNsYXNzOkltbWVkaWF0ZT4iLCJlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6SW1tZWRpYXRlPiIsIlN0cmluZyIsImRhdGEiLCJzdGFydF93aXRoPyIsInRhc2siLCJkZWxldGUiLCJbXSIsImxlbmd0aCIsIi0xIiwiMCIsIjEiLCIyIiwidG9fcyIsIltdPSIsInNlbmQiLCJhYm9ydGVkPyIsImFib3J0IiwiPG1vZHVsZTpLZXJuZWw+IiwiZGVmZXIiLCJ0YXAiLCJCcm93c2VyOjpJbW1lZGlhdGUiLCJuZXciLCI8Y2xhc3M6UHJvYz4iLCI8Y2xhc3M6UHJvbWlzZT4iLCJibG9jayBpbiBkZWZlciIsInByb21pc2UiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmVyIiwicHJvYyIsImJsb2NrICgzIGxldmVscykgaW4gZGVmZXIiLCJyZXNvbHZlIiwiRXhjZXB0aW9uIiwicmVqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7SUFtQkFBLE9BQUFDO0lBQUFBOztNQUFBQTtBQUFBQTs7QUFBQUE7OztBQU1FQyxNQUFBQSwwQkFBQUEsc0JBQWVDLElBQUQsRUFBT0MsSUFBckJGO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0VHLGVBQWE7UUFDYkMsbUJBQWFIO1FBQ2JJLG9CQUFhSDtRQUNiRixPQUFBTSxDQUFBQSxhQUFh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U0FBQUEsQ0FBY3pDLE1BQUxMLEtBQUtLLFFBQUFBLEVBQU0sTUFBQ1YsSUFBRCxDQUFOVSxDQUFkeUM7VUFBUDtZQUNGLHNCQUFPLENBQUFDLGVBQUEsQ0FBUCxJQUFvQi9CLENBQUFBLElBQXBCLElBQW9CQTtjQUFwQjtnQkFDRTZCLE9BQUFILE9BQU9NLFFBQUFBLENBQVFoQyxDQUFSZ0M7Y0FEVDtZQUFBLENBREU7VUFBQSxDQUZKTCxDQUFBQSxHQUFBQyxDQU1DVCxPQUFBQSxDQUFBQSxFQVBITSxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBR0w7SUFETEQsQ0FBQUEsSUFBQUE7RUFKRkssR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFqSkFsRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzEzNTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2NvbXBvc2l0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBDb21wb3NpdGlvbiA8IFVJXG4gIGhhbmRsZXMgJ2NvbXBvc2l0aW9uZW5kJywgJ2NvbXBvc2l0aW9uc3RhcnQnLCAnY29tcG9zaXRpb251cGRhdGUnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5Db21wb3NpdGlvbidcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IFVJOjpEZWZpbml0aW9uXG4gICAgZGVmIGRhdGE9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmRhdGEgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBsb2NhbGU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmxvY2FsZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IENvbXBvc2l0aW9uRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDb21wb3NpdGlvbkV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdENvbXBvc2l0aW9uRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2MudmlldyB8fCB3aW5kb3csIGRlc2MuZGF0YSwgZGVzYy5sb2NhbGUpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmRhdGFcbiAgYWxpYXNfbmF0aXZlIDpsb2NhbGVcblxuICBkZWYgc3RhcnQ/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnY29tcG9zaXRpb25zdGFydCdcbiAgZW5kXG5cbiAgZGVmIHVwZGF0ZT9cbiAgICBuYW1lLmRvd25jYXNlID09ICdjb21wb3NpdGlvbnVwZGF0ZSdcbiAgZW5kXG5cbiAgZGVmIGVuZD9cbiAgICBuYW1lLmRvd25jYXNlID09ICdjb21wb3NpdGlvbmVuZCdcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6Q29tcG9zaXRpb24+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImRhdGE9IiwidmFsdWUiLCJAbmF0aXZlIiwibG9jYWxlPSIsIlVJOjpEZWZpbml0aW9uIiwiVUkiLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsInN0YXJ0PyIsImRvd25jYXNlIiwiPT0iLCJ1cGRhdGU/IiwiZW5kPyJdLCJtYXBwaW5ncyI6IkFBQUFBLDRDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLGdCQUFSLEVBQTBCQSxrQkFBMUIsRUFBOENBLG1CQUE5Q0U7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLHVDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixtQkFBWEU7UUFEVEYsQ0FBQUEsR0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLHFCQUFBQSwrQkFBVUMsS0FBVkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLFFBQVVDO1VBRHJCRCxDQUFBQSxHQUFBQTtVQUlBRCxPQUFBSSx1QkFBQUEsaUNBQVlGLEtBQVpFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxVQUFZRjtVQUR2QkUsQ0FBQUEsR0FBQUE7UUFMRkosR0FBQUEsV0FBQUEsRUFBbUJLLElBQUFDLFFBQUFELGVBQW5CTDtRQVVBLElBQUEsUUFjT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VRLE1BQUlaLElBQUpZLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLHFCQUF1QkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEeENBLENBQUFBLEdBQUFBO1VBREYsT0FJQSxJQUFBLFFBQU1ULGFBQU9DLGNBQUFBLENBQVdMLGNBQVhLLENBQWIsQ0FBQTtZQUNFUSxNQUFJWixJQUFKWSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUElBLENBQUFBLEdBQUFBO1VBREY7UUFKQTtRQWdCQVosSUFBQWUsY0FBQUEsQ0FBYSxNQUFiQTtRQUNBZixJQUFBZSxjQUFBQSxDQUFhLFFBQWJBOztBQUVBQyxRQUFBQSxzQkFBQUEsbUNBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBaEIsSUFBQWEsTUFBQUEsQ0FBQUEsQ0FBSUksVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR0Ysa0JBQUhFO1FBRGhCRixDQUFBQSxHQUFBQTs7QUFJQUcsUUFBQUEsdUJBQUFBLG9DQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQW5CLElBQUFhLE1BQUFBLENBQUFBLENBQUlJLFVBQUFBLENBQUFBLENBQVVDLE9BQUFBLENBQUdDLG1CQUFIRDtRQURoQkMsQ0FBQUEsR0FBQUE7UUFJQXBCLE9BQUFxQixvQkFBQUEsaUNBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBcEIsSUFBQWEsTUFBQUEsQ0FBQUEsQ0FBSUksVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR0UsZ0JBQUhGO1FBRGhCRSxDQUFBQSxHQUFBQTtNQTVDRnJCLEdBQUFBLFdBQUFBLEVBQW9CWSxRQUFwQlo7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzE0NDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2Nzcy9zdHlsZV9zaGVldC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIENTU1xuXG5jbGFzcyBTdHlsZVNoZWV0XG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gIGRlZiBpbml0aWFsaXplKHdoYXQpXG4gICAgaWYgRE9NOjpFbGVtZW50ID09PSB3aGF0XG4gICAgICBzdXBlcihgI3t3aGF0LnRvX259LnNoZWV0YClcbiAgICBlbHNlXG4gICAgICBzdXBlcih3aGF0KVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhc19uYXRpdmUgOmRpc2FibGVkPywgOmRpc2FibGVkXG4gIGFsaWFzX25hdGl2ZSA6aHJlZlxuICBhbGlhc19uYXRpdmUgOnRpdGxlXG4gIGFsaWFzX25hdGl2ZSA6dHlwZVxuXG4gIGRlZiBtZWRpYVxuICAgIE1lZGlhLm5ldyhgI0BuYXRpdmUubWVkaWFgKSBpZiBgI0BuYXRpdmUubWVkaWEgIT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIG93bmVyXG4gICAgRE9NKGAjQG5hdGl2ZS5vd25lck5vZGVgKVxuICBlbmRcblxuICBkZWYgcGFyZW50XG4gICAgU2hlZXQubmV3KGAjQG5hdGl2ZS5wYXJlbnRTdHlsZVNoZWV0YCkgaWYgYCNAbmF0aXZlLnBhcmVudFN0eWxlU2hlZXQgIT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIHJ1bGVzXG4gICAgTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLmNzc1J1bGVzYCkgeyB8ZXxcbiAgICAgIFJ1bGUubmV3KGUpXG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlKGluZGV4KVxuICAgIGAjQG5hdGl2ZS5kZWxldGVSdWxlKGluZGV4KWBcbiAgZW5kXG5cbiAgZGVmIGluc2VydChpbmRleCwgcnVsZSlcbiAgICBgI0BuYXRpdmUuaW5zZXJ0UnVsZSgje3J1bGV9LCAje2luZGV4fSlgXG4gIGVuZFxuXG4gIGRlZiBydWxlKHNlbGVjdG9yLCBib2R5KVxuICAgIHVubGVzcyBTdHJpbmcgPT09IHNlbGVjdG9yXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLmpvaW4gJywgJ1xuICAgIGVuZFxuXG4gICAgdW5sZXNzIFN0cmluZyA9PT0gYm9keVxuICAgICAgYm9keSA9IGJvZHkubWFwIHt8bmFtZSwgdmFsdWV8XG4gICAgICAgIFwiI3tuYW1lfTogI3t2YWx1ZX07XCJcbiAgICAgIH0uam9pbiBcIlxcblwiXG4gICAgZW5kXG5cbiAgICBpbnNlcnQobGVuZ3RoLCBcIiN7c2VsZWN0b3J9IHsgI3tib2R5fSB9XCIpXG4gIGVuZFxuXG4gIGRlZiBbXShpZClcbiAgICBydWxlcy5maW5kIHsgfHJ8IGxvZyByOyByLmlkID09IGlkIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKCphcmdzLCAmYmxvY2spXG4gICAgcnVsZXMuX19zZW5kX18oKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgY2xhc3MgTWVkaWEgPCBOYXRpdmU6OkFycmF5XG4gICAgYWxpYXNfbmF0aXZlIDp0ZXh0LCA6bWVkaWFUZXh0XG4gICAgYWxpYXNfbmF0aXZlIDp0b19zLCA6bWVkaWFUZXh0XG5cbiAgICBkZWYgcHVzaChtZWRpdW0pXG4gICAgICBgI0BuYXRpdmUuYXBwZW5kTWVkaXVtKCN7bWVkaXVtfSlgXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBkZWxldGUobWVkaXVtKVxuICAgICAgYCNAbmF0aXZlLmRlbGV0ZU1lZGl1bSgje21lZGl1bX0pYFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpDU1M+IiwiPGNsYXNzOlN0eWxlU2hlZXQ+Iiwic2VsZiIsImluY2x1ZGUiLCJCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyIiwiQnJvd3NlciIsImluaXRpYWxpemUiLCJ3aGF0IiwiRE9NOjpFbGVtZW50IiwiRE9NIiwidG9fbiIsImFsaWFzX25hdGl2ZSIsIm1lZGlhIiwiQG5hdGl2ZSIsIk1lZGlhIiwibmV3Iiwib3duZXIiLCJwYXJlbnQiLCJTaGVldCIsInJ1bGVzIiwiTmF0aXZlOjpBcnJheSIsIk5hdGl2ZSIsImJsb2NrIGluIHJ1bGVzIiwiZSIsImJsb2NrICgyIGxldmVscykgaW4gcnVsZXMiLCJSdWxlIiwiZGVsZXRlIiwiaW5kZXgiLCJpbnNlcnQiLCJydWxlIiwic2VsZWN0b3IiLCJib2R5IiwiU3RyaW5nIiwiam9pbiIsIm1hcCIsImJsb2NrIGluIHJ1bGUiLCJuYW1lIiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIHJ1bGUiLCJsZW5ndGgiLCJbXSIsImlkIiwiZmluZCIsImJsb2NrIGluIFtdIiwiciIsImJsb2NrICgyIGxldmVscykgaW4gW10iLCJsb2ciLCI9PSIsIm1ldGhvZF9taXNzaW5nIiwiX19zZW5kX18iLCJhcmdzIiwiYmxvY2siLCJ0b19wcm9jIiwiPGNsYXNzOk1lZGlhPiIsInB1c2giLCJtZWRpdW0iXSwibWFwcGluZ3MiOiJBQUFBQSwwQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCx3QkFBUkQ7O0FBRUFHLFFBQUFBLDBCQUFBQSxzQkFBZUMsSUFBZkQ7QUFBQUEsVUFBQUE7O1VBQUFBO1VBQ0UsSUFBQSxRQUFHRSxJQUFBQyxTQUFBRCxZQUFILEVBQW9CRCxJQUFwQixDQUFBO1lBQ0VELE9BQUEsT0FBQUosSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFTSyxJQUFJRyxNQUFBQSxDQUFBQSxDQUFNSixNQUFuQixDQUFBLEVBQUEsSUFBQTtVQURGO1lBR0VBLE9BQUEsT0FBQUosSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFNSyxJQUFOLENBQUEsRUFBQSxJQUFBO1VBSEY7UUFERkQsQ0FBQUEsR0FBQUE7UUFRQUosSUFBQVMsY0FBQUEsQ0FBYSxXQUFiLEVBQXlCLFVBQXpCQTtRQUNBVCxJQUFBUyxjQUFBQSxDQUFhLE1BQWJBO1FBQ0FULElBQUFTLGNBQUFBLENBQWEsT0FBYkE7UUFDQVQsSUFBQVMsY0FBQUEsQ0FBYSxNQUFiQTs7QUFFQUMsUUFBQUEscUJBQUFBLGlCQUFBQTtB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QUEsSUFBQUE7UUFJQS9DLE9BQUFvRDtRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFbkQsSUFBQVMsY0FBQUEsQ0FBYSxNQUFiLEVBQW9CLFdBQXBCQTtVQUNBVCxJQUFBUyxjQUFBQSxDQUFhLE1BQWIsRUFBb0IsV0FBcEJBOztBQUVBMkMsVUFBQUEsb0JBQUFBLGdCQUFTQyxNQUFURDtBQUFBQSxZQUFBQTs7O1lBQ0l6QyxjQUFPeUMsY0FBZ0JDLE1BQU9EO1lBRWhDQSxPQUFBcEQ7VUFIRm9ELENBQUFBLEdBQUFBO1VBTUFELE9BQUEzQixzQkFBQUEseUJBQVc2QixNQUFYN0I7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUViLGNBQU9hLGNBQWdCNkIsTUFBTzdCO1VBRGxDQSxDQUFBQSxHQUFBQTtRQVZGMkIsR0FBQUEsV0FBQUEsRUFBY2pDLElBQUFDLFlBQUFELFVBQWRpQztNQWhFRnBELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBRmdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxNTk2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9zdHJpbmdpby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTdHJpbmdJTyA8IElPXG4gIGRlZiBzZWxmLm9wZW4oc3RyaW5nID0gXCJcIiwgbW9kZSA9IG5pbCwgJmJsb2NrKVxuICAgIGlvICA9IG5ldyhzdHJpbmcsIG1vZGUpXG4gICAgcmVzID0gYmxvY2suY2FsbChpbylcbiAgICBpby5jbG9zZVxuXG4gICAgcmVzXG4gIGVuZFxuXG4gIGF0dHJfYWNjZXNzb3IgOnN0cmluZ1xuXG4gIGRlZiBpbml0aWFsaXplKHN0cmluZyA9IFwiXCIsIG1vZGUgPSAncncnKVxuICAgIEBzdHJpbmcgICA9IHN0cmluZ1xuICAgIEBwb3NpdGlvbiA9IDBcblxuICAgIHN1cGVyKG5pbCwgbW9kZSlcbiAgZW5kXG5cbiAgZGVmIGVvZj9cbiAgICBjaGVja19yZWFkYWJsZVxuXG4gICAgQHBvc2l0aW9uID09IEBzdHJpbmcubGVuZ3RoXG4gIGVuZFxuXG4gIGRlZiBzZWVrKHBvcywgd2hlbmNlID0gSU86OlNFRUtfU0VUKVxuICAgICMgTGV0J3MgcmVzZXQgdGhlIHJlYWQgYnVmZmVyLCBiZWNhdXNlIGl0IHdpbGwgYmUgbW9zdCBsaWtlbHkgd3JvbmdcbiAgICBAcmVhZF9idWZmZXIgPSAnJ1xuXG4gICAgY2FzZSB3aGVuY2VcbiAgICB3aGVuIElPOjpTRUVLX1NFVFxuICAgICAgcmFpc2UgRXJybm86OkVJTlZBTCB1bmxlc3MgcG9zID49IDBcblxuICAgICAgQHBvc2l0aW9uID0gcG9zXG5cbiAgICB3aGVuIElPOjpTRUVLX0NVUlxuICAgICAgaWYgQHBvc2l0aW9uICsgcG9zID4gQHN0cmluZy5sZW5ndGhcbiAgICAgICAgQHBvc2l0aW9uID0gQHN0cmluZy5sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgQHBvc2l0aW9uICs9IHBvc1xuICAgICAgZW5kXG5cbiAgICB3aGVuIElPOjpTRUVLX0VORFxuICAgICAgaWYgcG9zID4gQHN0cmluZy5sZW5ndGhcbiAgICAgICAgQHBvc2l0aW9uID0gMFxuICAgICAgZWxzZVxuICAgICAgICBAcG9zaXRpb24gLT0gcG9zXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIDBcbiAgZW5kXG5cbiAgZGVmIHRlbGxcbiAgICBAcG9zaXRpb25cbiAgZW5kXG5cbiAgZGVmIHJld2luZFxuICAgIHNlZWsgMFxuICBlbmRcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGNoZWNrX3dyaXRhYmxlXG5cbiAgICAjIExldCdzIHJlc2V0IHRoZSByZWFkIGJ1ZmZlciwgYmVjYXVzZSBpdCB3aWxsIGJlIG1vc3QgbGlrZWx5IHdyb25nXG4gICAgQHJlYWRfYnVmZmVyID0gJydcblxuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpXG5cbiAgICBpZiBAc3RyaW5nLmxlbmd0aCA9PSBAcG9zaXRpb25cbiAgICAgIEBzdHJpbmcgICArPSBzdHJpbmdcbiAgICAgIEBwb3NpdGlvbiArPSBzdHJpbmcubGVuZ3RoXG4gICAgZWxzZVxuICAgICAgYmVmb3JlID0gQHN0cmluZ1swIC4uIEBwb3NpdGlvbiAtIDFdXG4gICAgICBhZnRlciAgPSBAc3RyaW5nW0Bwb3NpdGlvbiArIHN0cmluZy5sZW5ndGggLi4gLTFdXG5cbiAgICAgIEBzdHJpbmcgICA9IGJlZm9yZSArIHN0cmluZyArIGFmdGVyXG4gICAgICBAcG9zaXRpb24gKz0gc3RyaW5nLmxlbmd0aFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVhZChsZW5ndGggPSBuaWwsIG91dGJ1ZiA9IG5pbClcbiAgICBjaGVja19yZWFkYWJsZVxuXG4gICAgcmV0dXJuIGlmIGVvZj9cblxuICAgIHN0cmluZyA9IGlmIGxlbmd0aFxuICAgICAgc3RyID0gQHN0cmluZ1tAcG9zaXRpb24sIGxlbmd0aF1cbiAgICAgIEBwb3NpdGlvbiArPSBsZW5ndGhcbiAgICAgIEBwb3NpdGlvbiA9IEBzdHJpbmcubGVuZ3RoIGlmIEBwb3NpdGlvbiA+IEBzdHJpbmcubGVuZ3RoXG4gICAgICBzdHJcbiAgICBlbHNlXG4gICAgICBzdHIgPSBAc3RyaW5nW0Bwb3NpdGlvbiAuLiAtMV1cbiAgICAgIEBwb3NpdGlvbiA9IEBzdHJpbmcubGVuZ3RoXG4gICAgICBzdHJcbiAgICBlbmRcblxuICAgIGlmIG91dGJ1ZlxuICAgICAgb3V0YnVmLndyaXRlKHN0cmluZylcbiAgICBlbHNlXG4gICAgICBzdHJpbmdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHN5c3JlYWQobGVuZ3RoKVxuICAgIGNoZWNrX3JlYWRhYmxlXG5cbiAgICByZWFkKGxlbmd0aClcbiAgZW5kXG5cbiAgYWxpYXMgZW9mIGVvZj9cbiAgYWxpYXMgcG9zIHRlbGxcbiAgYWxpYXMgcG9zPSBzZWVrXG4gIGFsaWFzIHJlYWRwYXJ0aWFsIHJlYWRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6U3RyaW5nSU8+Iiwib3BlbiIsInNlbGYiLCJzdHJpbmciLCJtb2RlIiwiaW8iLCJuZXciLCJyZXMiLCJibG9jayIsImNhbGwiLCJjbG9zZSIsImF0dHJfYWNjZXNzb3IiLCJpbml0aWFsaXplIiwiQHN0cmluZyIsIkBwb3NpdGlvbiIsIjAiLCJlb2Y/IiwiY2hlY2tfcmVhZGFibGUiLCI9PSIsImxlbmd0aCIsInNlZWsiLCJwb3MiLCJ3aGVuY2UiLCJJTzo6U0VFS19TRVQiLCJJTyIsIkByZWFkX2J1ZmZlciIsIiRyZXRfb3JfMSIsIj49IiwicmFpc2UiLCJFcnJubzo6RUlOVkFMIiwiRXJybm8iLCJJTzo6U0VFS19DVVIiLCI+IiwiKyIsIklPOjpTRUVLX0VORCIsIi0iLCJ0ZWxsIiwicmV3aW5kIiwid3JpdGUiLCJjaGVja193cml0YWJsZSIsIlN0cmluZyIsImJlZm9yZSIsIltdIiwiMSIsImFmdGVyIiwiLTEiLCJyZWFkIiwib3V0YnVmIiwic3RyIiwic3lzcmVhZCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlDLElBQUpELFdBQUFBLGdCQUFjRSxNQUFELEVBQWNDLElBQTNCSDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFjLDZCQUFTQTtNQUFJLHlCQUFPO01BQ2hDSSxLQUFNSCxJQUFBSSxLQUFBQSxDQUFJSCxNQUFKLEVBQVlDLElBQVpFO01BQ05DLE1BQU1DLEtBQUtDLE1BQUFBLENBQU1KLEVBQU5JO01BQ1hKLEVBQUVLLE9BQUFBLENBQUFBO01BRUZULE9BQUFNO0lBTEZOLENBQUFBLElBQUFBO0lBUUFDLElBQUFTLGVBQUFBLENBQWMsUUFBZEE7O0FBRUFDLElBQUFBLDBCQUFBQSxzQkFBZVQsTUFBRCxFQUFjQyxJQUE1QlE7QUFBQUEsTUFBQUE7O01BQUFBOztNQUFlLDZCQUFTQTtNQUFJLHlCQUFPQTtNQUNqQ0MsY0FBWVY7TUFDWlcsZ0JBQVlDO01BRVpILE9B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RUFBVSxNQUFWO0lBQ0EsYUFBTSxLQUFOLEVBQVUsTUFBVjtJQUNBLGFBQU0sTUFBTixFQUFXLE1BQVg7SUFDQWpELE9BQUEsYUFBTSxhQUFOLEVBQWtCLE1BQWxCO0VBaEhGQSxHQUFBQSxXQUFBQSxFQUFpQndCLFFBQWpCeEI7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxNzMyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9wb3Bfc3RhdGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIFBvcFN0YXRlIDwgRXZlbnRcbiAgaGFuZGxlcyAncG9wc3RhdGUnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5Qb3BTdGF0ZSdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgc3RhdGU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnN0YXRlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgUG9wU3RhdGVFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnUG9wU3RhdGVFdmVudCcpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdFBvcFN0YXRlRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2Muc3RhdGUpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOnN0YXRlXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6UG9wU3RhdGU+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsInN0YXRlPSIsInZhbHVlIiwiQG5hdGl2ZSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsVUFBUkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLG9DQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixnQkFBWEU7UUFEVEYsQ0FBQUEsR0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTtVQUNFQSxPQUFBQyxzQkFBQUEsZ0NBQVdDLEtBQVhEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixTQUFXQztVQUR0QkQsQ0FBQUEsR0FBQUE7UUFERkQsR0FBQUEsV0FBQUEsRUFBbUJJLGdCQUFuQko7UUFNQSxJQUFBLFFBY09MLElBQUFFLGVBQUFBLENBQUFBLENBZFAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFTSxNQUFJVixJQUFKVSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxrQkFBb0JDLElBQUtELEVBQUlFLElBQUtGO1lBRHJDQSxDQUFBQSxHQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNUCxhQUFPQyxjQUFBQSxDQUFXTCxjQUFYSyxDQUFiLENBQUE7WUFDRU0sTUFBSVYsSUFBSlUsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtZQVBJQSxDQUFBQSxHQUFBQTtVQURGO1FBSkE7UUFnQkFYLE9BQUFDLElBQUFhLGNBQUFBLENBQWEsT0FBYkE7TUE3QkZkLEdBQUFBLFdBQUFBLEVBQWlCZSxXQUFqQmY7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzE3OTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RhdGFfdHJhbnNmZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9ibG9iJ1xuXG5tb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuIyB7RGF0YVRyYW5zZmVyfSBpcyBhbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBpbmNsdWRlZCBkYXRhIHRvXG4jIGFuIGV2ZW50IG9mIHR5cGUge0V2ZW50OjpEcmFnfSBvciB7RXZlbnQ6OkNsaXBib2FyZH0uXG5jbGFzcyBEYXRhVHJhbnNmZXJcbiAgaW5jbHVkZSBOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcnddIGVmZmVjdFxuICAjIEByZXR1cm4gW1N5bWJvbF0gRWZmZWN0IG9mIHRoaXMgZHJvcCBvcGVyYXRpb24uXG4gICMgICBNdXN0IGJlIG9uZSBvZjogOm5vbmUsIDpjb3B5LCA6bGluayBvciA6bW92ZS5cbiAgZGVmIGVmZmVjdFxuICAgIGAjQG5hdGl2ZS5kcm9wRWZmZWN0YFxuICBlbmRcblxuICBkZWYgZWZmZWN0PSAoZWZmZWN0KVxuICAgIGAjQG5hdGl2ZS5kcm9wRWZmZWN0ID0gI3tlZmZlY3R9YFxuICBlbmRcblxuICAjIEV4dHJhY3Qgc29tZSB0ZXh0IGRhdGEgZnJvbSB0aGlzIHtEYXRhVHJhbnNmZXJ9IGluc3RhbmNlLlxuICBkZWYgW10gKHR5cGUpXG4gICAgYCNAbmF0aXZlLmdldERhdGEoI3t0eXBlfSlgXG4gIGVuZFxuXG4gICMgRW1iZWQgc29tZSB0ZXh0IGRhdGEgaW4gdGhpcyB7RGF0YVRyYW5zZmVyfSBpbnN0YW5jZS5cbiAgZGVmIFtdPSAodHlwZSwgdmFsdWUpXG4gICAgYCNAbmF0aXZlLnNldERhdGEoI3t0eXBlfSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgZW5kXG5cbiAgIyBDbGVhciBzb21lIChvciBhbGwsIGlmIHR5cGUgaXMgbm90IHNwZWNpZmllZCkgdGV4dCBkYXRhIGZyb21cbiAgIyB0aGlzIHtEYXRhVHJhbnNmZXJ9IGluc3RhbmNlLlxuICBkZWYgY2xlYXIgKHR5cGU9bmlsKVxuICAgIGAjQG5hdGl2ZS5jbGVhckRhdGEoI3t0eXBlLnRvX259KWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbd10gZHJhZ19pbWFnZVxuICAjIFNldHMgYSBkcmFnIGltYWdlIGZvciB0aGlzIHtEYXRhVHJhbnNmZXJ9LiBVc2Ugc29tZVxuICAjIHtET006OkVsZW1lbnQ6OkltYWdlfSBvciB7Q2FudmFzfSBhcyBhIHZhbHVlLlxuICBkZWYgZHJhZ19pbWFnZT0gKGltYWdlKVxuICAgIGAjQG5hdGl2ZS5zZXREcmFnSW1hZ2UoI3tOYXRpdmUuY29udmVydChpbWFnZSl9KWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gZmlsZXNcbiAgIyBAcmV0dXJuIFtBcnJheTxGaWxlPl0gbGlzdCBvZiBmaWxlcyBhdHRhY2hlZCB0byB0aGlzIHtEYXRhVHJhbnNmZXJ9XG4gIGRlZiBmaWxlc1xuICAgIE5hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5maWxlc2ApLm1hcCB7IHxmfCBGaWxlLm5ldyhmLnRvX24pIH1cbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gaXRlbXNcbiAgIyBAcmV0dXJuIFtBcnJheTxJdGVtPl0gbGlzdCBvZiBpdGVtcyBhdHRhY2hlZCB0byB0aGlzIHtEYXRhVHJhbnNmZXJ9XG4gIGRlZiBpdGVtc1xuICAgIE5hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5pdGVtc2ApLm1hcCB7IHxpfCBJdGVtLm5ldyhpLnRvX24pIH1cbiAgZW5kXG5cbiAgIyBBbiBpbnN0YW5jZSBvZiBgRGF0YVRyYW5zZmVySXRlbWBcbiAgY2xhc3MgSXRlbVxuICAgIGluY2x1ZGUgTmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0ga2luZFxuICAgICMgQHJldHVybiBbU3ltYm9sXSBraW5kIG9mIGFuIGl0ZW06IDpzdHJpbmcgb3IgOmZpbGVcbiAgICBkZWYga2luZFxuICAgICAgYCNAbmF0aXZlLmtpbmRgXG4gICAgZW5kXG5cbiAgICBkZWYgc3RyaW5nPzsga2luZCA9PSAnc3RyaW5nJzsgICAgICAgICAgIGVuZFxuICAgIGRlZiBmaWxlPzsgICBraW5kID09ICdmaWxlJyAmJiB0b19maWxlOyAgZW5kICMgU29tZSBmaWxlcyBjYW4ndCBiZSByZXNvbHZlZC4uLlxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAgICMgQHJldHVybiBbU3RyaW5nXSBtaW1lIHR5cGUgb2YgYW4gaXRlbVxuICAgIGRlZiB0eXBlXG4gICAgICBgI0BuYXRpdmUudHlwZWBcbiAgICBlbmRcblxuICAgICMgQ29udmVydCB0byBzdHJpbmcgYW5kIGNhbGwgYmFjayBvbmNlIHJlYWR5LCBvciByZXR1cm4gYVxuICAgICMgcHJvbWlzZSBpZiBhIGJsb2NrIGlzbid0IGdpdmVuLlxuICAgIGRlZiB0b19zdHJpbmcoJmJsb2NrKVxuICAgICAgcHJvbWlzZSA9IG5pbFxuICAgICAgaWYgIWJsb2NrXG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuICAgICAgICBibG9jayA9IHByb2MgeyB8aXwgcHJvbWlzZS5yZXNvbHZlKGkpIH1cbiAgICAgIGVuZFxuICAgICAgYCNAbmF0aXZlLmdldEFzU3RyaW5nKCN7YmxvY2sudG9fbn0pYFxuICAgICAgcmV0dXJuIHByb21pc2VcbiAgICBlbmRcblxuICAgICMgQ29udmVydCB0byBmaWxlIG9yIHJldHVybiBuaWwgaWYgaW1wb3NzaWJsZVxuICAgIGRlZiB0b19maWxlXG4gICAgICBhc19maWxlID0gYCNAbmF0aXZlLmdldEFzRmlsZSgpYFxuICAgICAgRmlsZS5uZXcoYXNfZmlsZSkgaWYgYXNfZmlsZVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkRhdGFUcmFuc2Zlcj4iLCJpbmNsdWRlIiwiTmF0aXZlQ2FjaGVkV3JhcHBlciIsImVmZmVjdCIsIkBuYXRpdmUiLCJlZmZlY3Q9IiwiW10iLCJ0eXBlIiwiW109IiwidmFsdWUiLCJOYXRpdmUiLCJjb252ZXJ0IiwiY2xlYXIiLCJ0b19uIiwiZHJhZ19pbWFnZT0iLCJpbWFnZSIsImZpbGVzIiwibWFwIiwiTmF0aXZlOjpBcnJheSIsIm5ldyIsImJsb2NrIGluIGZpbGVzIiwiZiIsImJsb2NrICgyIGxldmVscykgaW4gZmlsZXMiLCJGaWxlIiwiaXRlbXMiLCJibG9jayBpbiBpdGVtcyIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIGl0ZW1zIiwiSXRlbSIsIjxjbGFzczpJdGVtPiIsImtpbmQiLCJzdHJpbmc/IiwiPT0iLCJmaWxlPyIsIiRyZXRfb3JfMSIsInRvX2ZpbGUiLCJ0b19zdHJpbmciLCJwcm9taXNlIiwiYmxvY2siLCJQcm9taXNlIiwicHJvYyIsImJsb2NrIGluIHRvX3N0cmluZyIsImJsb2NrICgy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QUEsQ0FBQUE7WUFBbEI7Y0FBQUYsT0FBQTtZQUFBO1VBQWJBLENBQUFBLEdBQUFBOztBQUlBMUIsVUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0c7VUFEWEEsQ0FBQUEsR0FBQUE7O0FBTUE2QixVQUFBQSx5QkFBQUEscUJBQUFBO0FBQUFBLFlBQUFBOztZQUFBQTs7O1lBQ0VDLFVBQVU7WUFDVixJQUFBLEtBQUlDLEtBQUosQ0FBQTs7Y0FDRUQsVUFBVUUsYUFBT3BCLEtBQUFBLENBQUFBO2NBQ2pCbUIsUUFBUUUsTUFBQTVDLElBQUE0QyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyxhQUFRZixDQUFSZTs7Z0JBQVE7Z0JBQUdDLE9BQUFMLE9BQU9NLFNBQUFBLENBQVNqQixDQUFUaUIsRUFBbEJGLENBQUFBLEdBQUFEO1lBRlY7WUFJRXBDLGNBQU9nQyxhQUFlRSxLQUFLekIsTUFBQUEsQ0FBQUEsQ0FBTXVCO1lBQ25DLE9BQU9DO1VBUFRELENBQUFBLEdBQUFBO1VBV0FQLE9BQUFNLHVCQUFBQSxtQkFBQUE7QUFBQUEsWUFBQUE7OztZQUNFUyxVQUFZeEMsY0FBTytCO1lBQ25CLElBQUEsUUFBcUJTLE9BQXJCLENBQUE7Y0FBQVQsT0FBQVosVUFBSUosS0FBQUEsQ0FBS3lCLE9BQUx6QjtZQUFKO2NBekZOZ0IsT0FBQTtZQXlGTTtVQUZGQSxDQUFBQSxHQUFBQTtRQS9CRk4sR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7TUFsREY3QixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUpnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMTk0NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvYmVmb3JlX3VubG9hZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQmVmb3JlVW5sb2FkIDwgRXZlbnRcbiAgaGFuZGxlcyAnYmVmb3JldW5sb2FkJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuQmVmb3JlVW5sb2FkJ1xuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IEJlZm9yZVVubG9hZEV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkJlZm9yZVVubG9hZD4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLDhDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSx3Q0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0Ysb0JBQVhFO1FBRFRGLENBQUFBLEdBQUFBO1FBSUEsSUFBQSxRQUlPRixJQUFBRSxlQUFBQSxDQUFBQSxDQUpQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRUwsT0FBQU0sTUFBSUwsSUFBSkssZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0Esc0JBQXdCQyxJQUFLRCxFQUFJRSxJQUFLRjtZQUR6Q0EsQ0FBQUEsR0FBQUE7VUFERjtZQVRGTixPQUFBO1VBU0U7UUFBQTtVQVRGQSxPQUFBO1FBU0U7TUFQRkEsR0FBQUEsV0FBQUEsRUFBcUJTLFdBQXJCVDtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMTk4OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9ldmVudC9iYXNlJ1xuXG5tb2R1bGUgQnJvd3NlclxuXG5jbGFzcyBFdmVudFxuICBkZWYgc2VsZi5hbGlhc2VzXG4gICAgQGFsaWFzZXMgfHw9IHtcbiAgICAgICdkb206bG9hZCcgPT4gJ0RPTUNvbnRlbnRMb2FkZWQnLFxuICAgICAgJ2hvdmVyJyAgICA9PiAnbW91c2U6b3ZlcidcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5hbWVfZm9yKG5hbWUpXG4gICAgKGFsaWFzZXNbbmFtZV0gfHwgbmFtZSkuZ3N1Yig/OiwgJycpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmhhbmRsZXJzXG4gICAgQGhhbmRsZXJzIHx8PSB7fVxuICBlbmRcblxuICBkZWYgc2VsZi5oYW5kbGVzKCpldmVudHMpXG4gICAgZXZlbnRzLmVhY2ggeyB8ZXZlbnR8IEV2ZW50LmhhbmRsZXJzW2V2ZW50XSA9IHNlbGYgfVxuICBlbmRcblxuICAjIFRob3NlIGV2ZW50cyBkb24ndCBoYXZlIGludGVyZXN0aW5nIHByb3BlcnRpZXMgdG8gd2FycmFudCBhIGN1c3RvbSBjbGFzc1xuICAjIG9yIGFyZSBub3QgY3VycmVudGx5IGltcGxlbWVudGVkLlxuICBoYW5kbGVzICdhYm9ydCcsICdhZnRlcnByaW50JywgJ2JlZm9yZXByaW50JywgJ2NhY2hlZCcsICdjYW5wbGF5JyxcbiAgICAgICAgICAnY2FucGxheXRocm91Z2gnLCAnY2hhbmdlJywgJ2NoYXJnaW5nY2hhbmdlJywgJ2NoYXJnaW5ndGltZWNoYW5nZScsXG4gICAgICAgICAgJ2NoZWNraW5nJywgJ2Nsb3NlJywgJ2Rpc2NoYXJnaW5ndGltZWNoYW5nZScsICdET01Db250ZW50TG9hZGVkJyxcbiAgICAgICAgICAnZG93bmxvYWRpbmcnLCAnZHVyYXRpb25jaGFuZ2UnLCAnZW1wdGllZCcsICdlbmRlZCcsICdlcnJvcicsXG4gICAgICAgICAgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCAnZnVsbHNjcmVlbmVycm9yJywgJ2lucHV0JywgJ2ludmFsaWQnLFxuICAgICAgICAgICdsZXZlbGNoYW5nZScsICdsb2FkZWRkYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ25vdXBkYXRlJywgJ29ic29sZXRlJyxcbiAgICAgICAgICAnb2ZmbGluZScsICdvbmxpbmUnLCAnb3BlbicsICdvcmllbnRhdGlvbmNoYW5nZScsICdwYXVzZScsXG4gICAgICAgICAgJ3BvaW50ZXJsb2NrY2hhbmdlJywgJ3BvaW50ZXJsb2NrZXJyb3InLCAncGxheScsICdwbGF5aW5nJyxcbiAgICAgICAgICAncmF0ZWNoYW5nZScsICdyZWFkeXN0YXRlY2hhbmdlJywgJ3Jlc2V0JywgJ3NlZWtlZCcsICdzZWVraW5nJyxcbiAgICAgICAgICAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VjY2VzcycsICdzdXNwZW5kJywgJ3RpbWV1cGRhdGUnLCAndXBkYXRlcmVhZHknLFxuICAgICAgICAgICd2aXNpYmlsaXR5Y2hhbmdlJywgJ3ZvbHVtZWNoYW5nZScsICd3YWl0aW5nJ1xuXG4gIGRlZiBzZWxmLmNsYXNzX2ZvcihuYW1lKVxuICAgIEBoYW5kbGVyc1tuYW1lX2ZvcihuYW1lKV0gfHwgQ3VzdG9tXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNyZWF0ZShuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIG5hbWUgID0gbmFtZV9mb3IobmFtZSlcbiAgICBrbGFzcyA9IGNsYXNzX2ZvcihuYW1lKVxuXG4gICAgZXZlbnQgPSBrbGFzcy5uZXcoa2xhc3MuY29uc3RydWN0KG5hbWUsIGtsYXNzLmNvbnN0X2dldCg6RGVmaW5pdGlvbikubmV3KCZibG9jaykpKVxuICAgIGV2ZW50LmFyZ3VtZW50cyA9IGFyZ3NcblxuICAgIGV2ZW50XG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlKTtcblxuICAgICAgICAje3JldHVybiBOYXRpdmUoYGV2ZW50YCkubWVyZ2UhKGRlc2MpfTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZU9iamVjdCdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIE5hdGl2ZShgZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKWApIFxcXG4gICAgICAgIC5tZXJnZSEoZGVzYykgXFxcbiAgICAgICAgLm1lcmdlIShgeyB0eXBlOiBuYW1lIH1gKSBcXFxuICAgICAgICAudG9fblxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBOYXRpdmUoZGVzYykubWVyZ2UhKGB7IHR5cGU6IG5hbWUgfWApLnRvX25cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYubmV3KHZhbHVlLCBjYWxsYmFjayA9IG5pbClcbiAgICByZXR1cm4gc3VwZXIgdW5sZXNzIHNlbGYgPT0gRXZlbnRcblxuICAgIGtsYXNzID0gY2xhc3NfZm9yKGNhbGxiYWNrID8gY2FsbGJhY2submFtZSA6IGB2YWx1ZS50eXBlYClcblxuICAgIGlmIGtsYXNzID09IEV2ZW50XG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIGtsYXNzLm5ldyh2YWx1ZSwgY2FsbGJhY2spXG4gICAgZW5kXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpjYWxsYmFja1xuICBhdHRyX3dyaXRlciA6b25cblxuICBkZWYgaW5pdGlhbGl6ZShldmVudCwgY2FsbGJhY2sgPSBuaWwpXG4gICAgc3VwZXIoZXZlbnQpXG5cbiAgICBAY2FsbGJhY2sgPSBjYWxsYmFja1xuICBlbmRcblxuICBkZWYgbmFtZVxuICAgIGAjQG5hdGl2ZS50eXBlYFxuICBlbmRcblxuICBkZWYgb25cbiAgICBAb24gfHwgVGFyZ2V0LmNvbnZlcnQoYCNAbmF0aXZlLmN1cnJlbnRUYXJnZXRgKVxuICBlbmRcblxuICBkZWYgdGFyZ2V0XG4gICAgVGFyZ2V0LmNvbnZlcnQoYCNAbmF0aXZlLnNyY0VsZW1lbnQgfHwgI0BuYXRpdmUudGFyZ2V0YClcbiAgZW5kXG5cbiAgZGVmIGFyZ3VtZW50c1xuICAgIGAjQG5hdGl2ZS5hcmd1bWVudHMgfHwgW11gXG4gIGVuZFxuXG4gIGRlZiBhcmd1bWVudHM9KGFyZ3MpXG4gICAgYCNAbmF0aXZlLmFyZ3VtZW50cyA9ICN7YXJnc31gXG4gIGVuZFxuXG4gIGFsaWFzX25hdGl2ZSA6YnViYmxlcz8sIDpidWJibGVzXG4gIGFsaWFzX25hdGl2ZSA6Y2FuY2VsYWJsZT8sIDpjYW5jZWxhYmxlXG4gIGFsaWFzX25hdGl2ZSA6ZGF0YVxuICBhbGlhc19uYXRpdmUgOnBoYXNlLCA6ZXZlbnRQaGFzZVxuICBhbGlhc19uYXRpdmUgOmF0LCA6dGltZVN0YW1wXG5cbiAgZGVmIG9mZlxuICAgIEBjYWxsYmFjay5vZmYgaWYgQGNhbGxiYWNrXG4gIGVuZFxuXG4gIGRlZiBzdG9wcGVkP1xuICAgIGAhISNAbmF0aXZlLnN0b3BwZWRgXG4gIGVuZFxuXG4gIGRlZiBzdG9wXG4gICAgYCNAbmF0aXZlLnN0b3BQcm9wYWdhdGlvbigpYCBpZiBkZWZpbmVkPyhgI0BuYXRpdmUuc3RvcFByb3BhZ2F0aW9uYClcbiAgICBgI0BuYXRpdmUuc3RvcHBlZCA9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBwcmV2ZW50XG4gICAgYCNAbmF0aXZlLnByZXZlbnREZWZhdWx0KClgIGlmIGRlZmluZWQ/KGAjQG5hdGl2ZS5wcmV2ZW50RGVmYXVsdGApXG4gICAgYCNAbmF0aXZlLnByZXZlbnRlZCA9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBwcmV2ZW50ZWQ/XG4gICAgYCEhI0BuYXRpdmUucHJldmVudGVkYFxuICBlbmRcblxuICBkZWYgc3RvcCFcbiAgICBwcmV2ZW50XG4gICAgc3RvcFxuICBlbmRcbmVuZFxuXG5lbmRcblxucmVxdWlyZSAnYnJvd3Nlci9ldmVudC91aSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvbW91c2UnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2tleWJvYXJkJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9jdXN0b20nXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCJhbGlhc2VzIiwiQGFsaWFzZXMiLCIkcmV0X29yXzEiLCJuYW1lX2ZvciIsIm5hbWUiLCJbXSIsImdzdWIiLCJoYW5kbGVycyIsIkBoYW5kbGVycyIsImhhbmRsZXMiLCJlYWNoIiwiZXZlbnRzIiwiYmxvY2sgaW4gaGFuZGxlcyIsImV2ZW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBoYW5kbGVzIiwiW109IiwiRXZlbnQiLCJjbGFzc19mb3IiLCJDdXN0b20iLCJzdXBwb3J0ZWQ/IiwiY3JlYXRlIiwia2xhc3MiLCJuZXciLCJjb25zdHJ1Y3QiLCJjb25zdF9nZXQiLCJibG9jayIsInRvX3Byb2MiLCJhcmd1bWVudHM9IiwiYXJncyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJkZXNjIiwiTmF0aXZlIiwibWVyZ2UhIiwidG9fbiIsInZhbHVlIiwiY2FsbGJhY2siLCJhdHRyX3JlYWRlciIsImF0dHJfd3JpdGVyIiwiaW5pdGlhbGl6ZSIsIkBjYWxsYmFjayIsIkBuYXRpdmUiLCJvbiIsIkBvbiIsIlRhcmdldCIsImNvbnZlcnQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJhbGlhc19uYXRpdmUiLCJvZmYiLCJzdG9wcGVkPyIsInN0b3AiLCJwcmV2ZW50IiwicHJldmVudGVkPyIsInN0b3AhIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBQztFQUFBQTs7SUFBQUE7O0lBRUFBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLE1BQUlKLElBQUpJLGNBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTs7UUFDRUEsT0FBQUMsQ0FBQUEsZUFOSixDQUFBLFFBQUFDLENBQUFBLFlBTUlELFlBTkpDLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBTWlCLCtCQUFBLFlBQ0dGLGtCQURILEVBQUEsU0FFR0EsWUFGSCxFQU5qQixDQUFBLENBTUlDO01BREZELENBQUFBLEdBQUFBO01BT0FHLE1BQUlQLElBQUpPLGVBQUFBLG9CQUFrQkMsSUFBbEJEO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFDLENBQUEsUUFBQUQsQ0FBQUEsWUFBQU4sSUFBQUksU0FBQUEsQ0FBQUEsQ0FBT0ssT0FBQUEsQ0FBQ0QsSUFBREMsQ0FBUEgsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBaUJFLElBQWpCLENBQUEs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QUFoQyxDQUFBO1VBQUVWLGNBQU9VO1FBQVQ7UUFDQUEsT0FBRVYsY0FBT1U7TUFGWEEsQ0FBQUEsR0FBQUE7O0FBS0FDLE1BQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7OztRQUNFLElBQUEsUUFBK0IsUUFBV1gsY0FBT1csZUFBbEIsa0JBQS9CLENBQUE7VUFBRVgsY0FBT1c7UUFBVDtRQUNBQSxPQUFFWCxjQUFPVztNQUZYQSxDQUFBQSxHQUFBQTs7QUFLQUMsTUFBQUEsMEJBQUFBLGlDQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQ0EsRUFBR1osY0FBT1k7TUFEYkEsQ0FBQUEsR0FBQUE7TUFJQXRELE9BQUF1RCxxQkFBQUEsNEJBQUFBO0FBQUFBLFFBQUFBOzs7UUFDRTFELElBQUF3RCxTQUFBQSxDQUFBQTtRQUNBRSxPQUFBMUQsSUFBQXVELE1BQUFBLENBQUFBO01BRkZHLENBQUFBLEdBQUFBO0lBbkpGdkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFGQUQsR0FBQUEsV0FBQUE7RUE2SkFGLElBQUFDLFNBQUFBLENBQVFGLGtCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsd0JBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLHNCQUFSRTtBQWxLQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyMjE0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9odHRwL2hlYWRlcnMucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBIVFRQXG5cbiMgUmVwcmVzZW50cyBhIHNpbmdsZSBIVFRQIGhlYWRlci5cbkhlYWRlciA9IFN0cnVjdC5uZXcoOm5hbWUsIDp2YWx1ZSlcblxuIyBSZXByZXNlbnRzIEhUVFAgaGVhZGVycy5cbmNsYXNzIEhlYWRlcnNcbiAgIyBQYXJzZSBIVFRQIGhlYWRlcnMgZnJvbSBhIHN0cmluZy5cbiAgI1xuICAjIEBwYXJhbSBzdHJpbmcgW1N0cmluZ10gdGhlIHdob2xlIEhUVFAgaGVhZGVycyByZXNwb25zZVxuICAjIEByZXR1cm4gW0hlYWRlcnNdIHRoZSBwYXJzZWQgaGVhZGVyc1xuICBkZWYgc2VsZi5wYXJzZShzdHJpbmcpXG4gICAgc2VsZltzdHJpbmcubGluZXMubWFwIHsgfGx8IGwuY2hvbXAuc3BsaXQoL1xccyo6XFxzKi8pIH1dXG4gIGVuZFxuXG4gICMgQ3JlYXRlIHtIZWFkZXJzfSBmcm9tIGEgaGFzaC5cbiAgI1xuICAjIEBwYXJhbSBoYXNoIFtIYXNoXVxuICBkZWYgc2VsZi5bXShoYXNoKVxuICAgIHJlc3VsdCA9IG5ld1xuXG4gICAgaGFzaC5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZVxuICAgIH1cblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIENyZWF0ZSBhbiBlbXB0eSB7SGVhZGVyc30uXG4gIGRlZiBpbml0aWFsaXplXG4gICAgQGhhc2ggPSBIYXNoLm5ld1xuICBlbmRcblxuICAjIENsZWFyIHRoZSB7SGVhZGVyc30uXG4gIGRlZiBjbGVhclxuICAgIEBoYXNoLmNsZWFyXG4gIGVuZFxuXG4gICMgRW51bWVyYXRlIG92ZXIgdGhlIGhlYWRlcnMuXG4gICNcbiAgIyBAeWllbGRwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBoZWFkZXJcbiAgIyBAeWllbGRwYXJhbSB2YWx1ZSBbU3RyaW5nXSB0aGUgdmFsdWUgb2YgdGhlIGhlYWRlclxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgIEBoYXNoLmVhY2gge3xfLCBoZWFkZXJ8XG4gICAgICBibG9jay5jYWxsIFtoZWFkZXIubmFtZSwgaGVhZGVyLnZhbHVlXVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBHZXQgdGhlIHZhbHVlIG9mIGEgaGVhZGVyLlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIGhlYWRlclxuICAjXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgdmFsdWUgb2YgdGhlIGhlYWRlclxuICBkZWYgW10obmFtZSlcbiAgICBAaGFzaFtuYW1lLmRvd25jYXNlXVxuICBlbmRcblxuICAjIFNldCBhIHZhbHVlIGZvciB0aGUgaGVhZGVyLlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIGhlYWRlclxuICAjIEBwYXJhbSB2YWx1ZSBbU3RyaW5nXSB0aGUgdmFsdWUgb2YgdGhlIGhlYWRlclxuICBkZWYgW109KG5hbWUsIHZhbHVlKVxuICAgIGhlYWRlciA9IEhlYWRlci5uZXcobmFtZSwgdmFsdWUpXG5cbiAgICBAaGFzaFtuYW1lLmRvd25jYXNlXSA9IGhlYWRlclxuICBlbmRcblxuICAjIFB1c2ggYSBoZWFkZXIuXG4gICNcbiAgIyBAcGFyYW0gaGVhZGVyIFtIZWFkZXJdIHRoZSBoZWFkZXIgdG8gcHVzaFxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIDw8KGhlYWRlcilcbiAgICBAaGFzaFtoZWFkZXIubmFtZS5kb3duY2FzZV0gPSBoZWFkZXJcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgcHVzaCA8PFxuXG4gICMgTWVyZ2UgaW4gcGxhY2Ugb3RoZXIgaGVhZGVycy5cbiAgI1xuICAjIEBwYXJhbSBvdGhlciBbSGVhZGVycywgSGFzaCwgI2VhY2hdIHRoZSBoZWFkZXJzIHRvIG1lcmdlXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgbWVyZ2UhKG90aGVyKVxuICAgIG90aGVyLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgIHNlbGZbbmFtZV0gPSB2YWx1ZVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbGVuZ3RoXG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIG51bWJlciBvZiBoZWFkZXJzXG4gIGRlZiBsZW5ndGhcbiAgICBAaGFzaC5sZW5ndGhcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6SFRUUD4iLCJTdHJ1Y3QiLCJuZXciLCI8Y2xhc3M6SGVhZGVycz4iLCJwYXJzZSIsInNlbGYiLCJzdHJpbmciLCJbXSIsIm1hcCIsImxpbmVzIiwiYmxvY2sgaW4gcGFyc2UiLCJsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwYXJzZSIsImNob21wIiwic3BsaXQiLCJoYXNoIiwicmVzdWx0IiwiZWFjaCIsImJsb2NrIGluIFtdIiwibmFtZSIsInZhbHVlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBbXSIsIltdPSIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiaW5pdGlhbGl6ZSIsIkBoYXNoIiwiSGFzaCIsImNsZWFyIiwiYmxvY2siLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2giLCJfIiwiaGVhZGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiY2FsbCIsImRvd25jYXNlIiwiSGVhZGVyIiwiPDwiLCJtZXJnZSEiLCJvdGhlciIsImJsb2NrIGluIG1lcmdlISIsImJsb2NrICgyIGxldmVscykgaW4gbWVyZ2UhIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFHaEIsa0NBQVNDLFlBQU1DLEtBQUFBLENBQUssTUFBWCxFQUFrQixPQUFaQSxDQUFmO01BR0FGLE9BQUFHO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBS0VDLE1BQUlDLElBQUpELFlBQUFBLGlCQUFlRSxNQUFmRjtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUMsSUFBSUUsT0FBQUEsQ0FB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SUFBSWlCLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURObUIsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUt4QjtVQUlMc0IsT0FBQWxDO1FBTEZrQyxDQUFBQSxHQUFBQTtRQVVBcEMsT0FBQXdDLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFqQixTQUFLaUIsUUFBQUEsQ0FBQUE7UUFEUEEsQ0FBQUEsR0FBQUE7TUFqR0Z4QyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQU5nQkgsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMjMzNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvcGFnZV90cmFuc2l0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBQYWdlVHJhbnNpdGlvbiA8IEV2ZW50XG4gIGhhbmRsZXMgJ3BhZ2VoaWRlJywgJ3BhZ2VzaG93J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuUGFnZVRyYW5zaXRpb24nXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIHBlcnNpc3RlZD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUucGVyc2lzdGVkID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5QYWdlVHJhbnNpdGlvbidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgUGFnZVRyYW5zaXRpb25FdmVudChuYW1lLCBkZXNjKWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOnBlcnNpc3RlZD8sIDpwZXJzaXN0ZWRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpQYWdlVHJhbnNpdGlvbj4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwicGVyc2lzdGVkPSIsInZhbHVlIiwiQG5hdGl2ZSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsZ0RBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsVUFBUixFQUFvQkEsVUFBcEJFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSwwQ0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0Ysc0JBQVhFO1FBRFRGLENBQUFBLEdBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7VUFDRUEsT0FBQUMsMEJBQUFBLG9DQUFlQyxLQUFmRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsYUFBZUM7VUFEMUJELENBQUFBLEdBQUFBO1FBREZELEdBQUFBLFdBQUFBLEVBQW1CSSxnQkFBbkJKO1FBTUEsSUFBQSxRQUlPTCxJQUFBRSxlQUFBQSxDQUFBQSxDQUpQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLHNCQUFYSyxDQUFWLENBQUE7WUFDRU0sTUFBSVYsSUFBSlUsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0EsbUNBQURBO1lBREZBLENBQUFBLEdBQUFBO1VBREY7UUFBQTtRQU1BWCxPQUFBQyxJQUFBYSxjQUFBQSxDQUFhLFlBQWIsRUFBMEIsV0FBMUJBO01BbkJGZCxHQUFBQSxXQUFBQSxFQUF1QmUsV0FBdkJmO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyMzg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9odHRwL3JlcXVlc3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBIVFRQXG5cbmNsYXNzIFJlcXVlc3RcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcbiAgaW5jbHVkZSBFdmVudDo6VGFyZ2V0XG5cbiAgIyBEZWZhdWx0IGhlYWRlcnMuXG4gIEhFQURFUlMgPSB7XG4gICAgJ1gtUmVxdWVzdGVkLVdpdGgnID0+ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgJ1gtT3BhbC1WZXJzaW9uJyAgID0+IFJVQllfRU5HSU5FX1ZFUlNJT04sXG4gICAgJ0FjY2VwdCcgICAgICAgICAgID0+ICd0ZXh0L2phdmFzY3JpcHQsIHRleHQvaHRtbCwgYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCwgKi8qJ1xuICB9XG5cbiAgU1RBVEVTID0gJXdbdW5pbml0aWFsaXplZCBsb2FkaW5nIGxvYWRlZCBpbnRlcmFjdGl2ZSBjb21wbGV0ZV1cblxuICAjIEAhYXR0cmlidXRlIFtyXSBoZWFkZXJzXG4gICMgQHJldHVybiBbSGVhZGVyc10gdGhlIHJlcXVlc3QgaGVhZGVyc1xuICBhdHRyX3JlYWRlciA6aGVhZGVyc1xuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHJlc3BvbnNlXG4gICMgQHJldHVybiBbUmVzcG9uc2VdIHRoZSByZXNwb25zZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXF1ZXN0XG4gIGF0dHJfcmVhZGVyIDpyZXNwb25zZVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG1ldGhvZFxuICAjIEByZXR1cm4gW1N5bWJvbF0gdGhlIEhUVFAgbWV0aG9kIGZvciB0aGlzIHJlcXVlc3RcbiAgYXR0cl9yZWFkZXIgOm1ldGhvZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHVybFxuICAjIEByZXR1cm4gW1N0cmluZywgI3RvX3NdIHRoZSBVUkwgZm9yIHRoaXMgcmVxdWVzdFxuICBhdHRyX3JlYWRlciA6dXJsXG5cbiAgIyBDcmVhdGUgYSByZXF1ZXN0IHdpdGggdGhlIG9wdGlvbmFsbHkgZ2l2ZW4gY29uZmlndXJhdGlvbiBibG9jay5cbiAgI1xuICAjIEB5aWVsZCBbcmVxdWVzdF0gaWYgdGhlIGJsb2NrIGhhcyBhIHBhcmFtZXRlciB0aGUgcmVxdWVzdCBpcyBwYXNzZWRcbiAgIyAgICAgICAgICAgICAgICAgIG90aGVyd2lzZSBpdCdzIGluc3RhbmNlX2V4ZWMnZFxuICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgc3VwZXIodHJhbnNwb3J0KVxuXG4gICAgQHBhcmFtZXRlcnMgICA9IHt9XG4gICAgQHF1ZXJ5ICAgICAgICA9IHt9XG4gICAgQGhlYWRlcnMgICAgICA9IEhlYWRlcnNbSEVBREVSU11cbiAgICBAbWV0aG9kICAgICAgID0gOmdldFxuICAgIEBhc3luY2hyb25vdXMgPSB0cnVlXG4gICAgQGJpbmFyeSAgICAgICA9IGZhbHNlXG4gICAgQGNhY2hlYWJsZSAgICA9IHRydWVcbiAgICBAb3BlbmVkICAgICAgID0gZmFsc2VcbiAgICBAc2VudCAgICAgICAgID0gZmFsc2VcbiAgICBAY29tcGxldGVkICAgID0gZmFsc2VcbiAgICBAY2FsbGJhY2tzICAgID0gSGFzaC5uZXcgeyB8aCwga3wgaFtrXSA9IFtdIH1cblxuICAgIGlmIGJsb2NrLmFyaXR5ID09IDBcbiAgICAgIGluc3RhbmNlX2V4ZWMoJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIGJsb2NrLmNhbGwoc2VsZilcbiAgICBlbmQgaWYgYmxvY2tcbiAgZW5kXG5cbiAgIyBAIW1ldGhvZCB0cmFuc3BvcnRcbiAgIyAgIEBwcml2YXRlXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/IDpYSFJcbiAgICBkZWYgdHJhbnNwb3J0XG4gICAgICBgbmV3IFhNTEh0dHBSZXF1ZXN0KClgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/IDpBY3RpdmVYXG4gICAgZGVmIHRyYW5zcG9ydFxuICAgICAgYG5ldyBBY3RpdmVYT2JqZWN0KFwiTVNYTUwyLlhNTEhUVFAuMy4wXCIpYFxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIHRyYW5zcG9ydFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgIGVuZFxuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSByZXF1ZXN0IGhhcyBiZWVuIG9wZW5lZC5cbiAgZGVmIG9wZW5lZD9cbiAgICBAb3BlbmVkXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gc2VudC5cbiAgZGVmIHNlbnQ/XG4gICAgQHNlbnRcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgcmVxdWVzdCBoYXMgY29tcGxldGVkLlxuICBkZWYgY29tcGxldGVkP1xuICAgIEBjb21wbGV0ZWRcbiAgZW5kXG5cbiAgIyBDaGVjayB0aGUgcmVxdWVzdCBpcyBhc3luY2hyb25vdXMuXG4gIGRlZiBhc3luY2hyb25vdXM/XG4gICAgQGFzeW5jaHJvbm91c1xuICBlbmRcblxuICAjIENoZWNrIHRoZSByZXF1ZXN0IGlzIHN5bmNocm9ub3VzLlxuICBkZWYgc3luY2hyb25vdXM/XG4gICAgIUBhc3luY2hyb25vdXNcbiAgZW5kXG5cbiAgIyBNYWtlIHRoZSByZXF1ZXN0IGFzeW5jaHJvbm91cy5cbiAgZGVmIGFzeW5jaHJvbm91cyFcbiAgICBAYXN5bmNocm9ub3VzID0gdHJ1ZVxuICBlbmRcblxuICAjIE1ha2UgdGhlIHJlcXVlc3Qgc3luY2hyb25vdXMuXG4gIGRlZiBzeW5jaHJvbm91cyFcbiAgICBAYXN5bmNocm9ub3VzID0gZmFsc2VcbiAgZW5kXG5cbiAgIyBDaGVjayB0aGUgcmVxdWVzdCBpcyBiaW5hcnkuXG4gIGRlZiBiaW5hcnk/XG4gICAgQGJpbmFyeVxuICBlbmRcblxuICAjIE1ha2UgdGhlIHJlcXVlc3QgYmluYXJ5LlxuICBkZWYgYmluYXJ5IVxuICAgIEBiaW5hcnkgPSB0cnVlXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIHJlcXVlc3QgaXMgY2FjaGVhYmxlLlxuICBkZWYgY2FjaGVhYmxlP1xuICAgIEBjYWNoZWFibGVcbiAgZW5kXG5cbiAgIyBEaXNhYmxlIGNhY2hpbmcgZm9yIHRoaXMgcmVxdWVzdC5cbiAgZGVmIG5vX2NhY2hlIVxuICAgIEBjYWNoZWFibGUgPSBmYWxzZVxuICBlbmRcblxuICAjIEdldCBvciBzZXQgdGhlIHVzZXIgdXNlZCBmb3IgYXV0aGVudGljYXRpb24uXG4gICNcbiAgIyBAcGFyYW0gdmFsdWUgW1N0cmluZ10gd2hlbiBwYXNzZWQgaXQgc2V0cywgd2hlbiBvbWl0dGVkIGl0IGdldHNcbiAgI1xuICAjIEByZXR1cm4gW1N0cmluZ11cbiAgZGVmIHVzZXIodmFsdWUgPSBuaWwpXG4gICAgdmFsdWUgPyBAdXNlciA9IHZhbHVlIDogQHVzZXJcbiAgZW5kXG5cbiAgIyBHZXQgb3Igc2V0IHRoZSBwYXNzd29yZCB1c2VkIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgI1xuICAjIEBwYXJhbSB2YWx1ZSBbU3RyaW5nXSB3aGVuIHBhc3NlZCBpdCBzZXRzLCB3aGVuIG9taXR0ZWQgaXQgZ2V0c1xuICAjXG4gICMgQHJldHVybiBbU3RyaW5nXVxuICBkZWYgcGFzc3dvcmQodmFsdWUgPSBuaWwpXG4gICAgdmFsdWUgPyBAcGFzc3dvcmQgPSB2YWx1ZSA6IEBwYXNzd29yZFxuICBlbmRcblxuICAjIEdldCBvciBzZXQgdGhlIE1JTUUgdHlwZSBvZiB0aGUgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB2YWx1ZSBbU3RyaW5nXSB3aGVuIHBhc3NlZCBpdCBzZXRzLCB3aGVuIG9taXR0ZWQgaXQgZ2V0c1xuICAjXG4gICMgQHJldHVybiBbU3RyaW5nXVxuICBkZWYgbWltZV90eXBlKHZhbHVlID0gbmlsKVxuICAgIHZhbHVlID8gQG1pbWVfdHlwZSA9IHZhbHVlIDogQG1pbWVfdHlwZVxuICBlbmRcblxuICAjIEdldCBvciBzZXQgdGhlIENvbnRlbnQtVHlwZSBvZiB0aGUgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB2YWx1ZSBbU3RyaW5nXSB3aGVuIHBhc3NlZCBpdCBzZXRzLCB3aGVuIG9taXR0ZWQgaXQgZ2V0c1xuICAjXG4gICMgQHJldHVybiBbU3RyaW5nXVxuICBkZWYgY29udGVudF90eXBlKHZhbHVlID0gbmlsKVxuICAgIHZhbHVlID8gQGNvbnRlbnRfdHlwZSA9IHZhbHVlIDogQGNvbnRlbnRfdHlwZVxuICBlbmRcblxuICAjIEdldCBvciBzZXQgdGhlIGVuY29kaW5nIG9mIHRoZSByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHZhbHVlIFtTdHJpbmddIHdoZW4gcGFzc2VkIGl0IHNldHMsIHdoZW4gb21pdHRlZCBpdCBnZXRzXG4gICNcbiAgIyBAcmV0dXJuIFtTdHJpbmddXG4gIGRlZiBlbmNvZGluZyh2YWx1ZSA9IG5pbClcbiAgICB2YWx1ZSA/IEBlbmNvZGluZyA9IHZhbHVlIDogQGVuY29kaW5nXG4gIGVuZFxuXG4gICMgU2V0IHRoZSByZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICNcbiAgIyBAcGFyYW0gaGFzaCBbSGFzaF0gdGhlIHBhcmFtZXRlcnNcbiAgI1xuICAjIEByZXR1cm4gW0hhc2hdXG4gIGRlZiBwYXJhbWV0ZXJzKGhhc2ggPSBuaWwpXG4gICAgaGFzaCA/IEBwYXJhbWV0ZXJzID0gaGFzaCA6IEBwYXJhbWV0ZXJzXG4gIGVuZFxuXG4gICMgU2V0IHRoZSBVUkkgcXVlcnkuXG4gICNcbiAgIyBAcGFyYW0gaGFzaCBbSGFzaF0gdGhlIHF1ZXJ5XG4gICNcbiAgIyBAcmV0dXJuIFtIYXNoXVxuICBkZWYgcXVlcnkoaGFzaCA9IG5pbClcbiAgICBoYXNoID8gQHF1ZXJ5ID0gaGFzaCA6IEBxdWVyeVxuICBlbmRcblxuICAjIFJlZ2lzdGVyIGFuIGV2ZW50IG9uIHRoZSByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHdoYXQgW1N5bWJvbCwgU3RyaW5nXSB0aGUgZXZlbnQgbmFtZVxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVzcG9uc2UgW1Jlc3BvbnNlXSB0aGUgcmVzcG9uc2UgZm9yIHRoZSBldmVudFxuICBkZWYgb24od2hhdCwgKiwgJmJsb2NrKVxuICAgIGlmIFNUQVRFUy5pbmNsdWRlPyh3aGF0KSB8fCAld1tzdWNjZXNzIGZhaWx1cmVdLmluY2x1ZGU/KHdoYXQpIHx8IEludGVnZXIgPT09IHdoYXRcbiAgICAgIEBjYWxsYmFja3Nbd2hhdF0gPDwgYmxvY2tcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICAjIE9wZW4gdGhlIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gbWV0aG9kIFtTeW1ib2xdIHRoZSBIVFRQIG1ldGhvZCB0byB1c2VcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmcsICN0b19zXSB0aGUgVVJMIHRvIHNlbmQgdGhlIHJlcXVlc3QgdG9cbiAgIyBAcGFyYW0gYXN5bmNocm9ub3VzIFtCb29sZWFuXSB3aGV0aGVyIHRoZSByZXF1ZXN0IGlzIGFzeW5jaHJvbm91cyBvciBub3RcbiAgIyBAcGFyYW0gdXNlciBbU3RyaW5nXSB0aGUgdXNlciB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICMgQHBhcmFtIHBhc3N3b3JkIFtTdHJpbmddIHRoZSBwYXNzd29yZCB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgb3BlbihtZXRob2QgPSBuaWwsIHVybCA9IG5pbCwgYXN5bmNocm9ub3VzID0gbmlsLCB1c2VyID0gbmlsLCBwYXNzd29yZCA9IG5pbClcbiAgICByYWlzZSAndGhlIHJlcXVlc3QgaGFzIGFscmVhZHkgYmVlbiBvcGVuZWQnIGlmIG9wZW5lZD9cblxuICAgIEBtZXRob2QgICAgICAgPSBtZXRob2QgICAgICAgdW5sZXNzIG1ldGhvZC5uaWw/XG4gICAgQHVybCAgICAgICAgICA9IHVybCAgICAgICAgICB1bmxlc3MgdXJsLm5pbD9cbiAgICBAYXN5bmNocm9ub3VzID0gYXN5bmNocm9ub3VzIHVubGVzcyBhc3luY2hyb25vdXMubmlsP1xuICAgIEB1c2VyICAgICAgICAgPSB1c2VyICAgICAgICAgdW5sZXNzIHVzZXIubmlsP1xuICAgIEBwYXNzd29yZCAgICAgPSBwYXNzd29yZCAgICAgdW5sZXNzIHBhc3N3b3JkLm5pbD9cblxuICAgIHVybCA9IEB1cmxcblxuICAgICMgYWRkIGEgZHVtbXkgcmFuZG9tIHBhcmFtZXRlciB0byB0aGUgcXVlcnkgdG8gdHJ5IGNpcmN1bXZlbnQgY2FjaGluZ1xuICAgIHVubGVzcyBjYWNoZWFibGU/XG4gICAgICBAcXVlcnlbOl9dID0gcmFuZFxuICAgIGVuZFxuXG4gICAgIyBhZGQgdGhlIGVuY29kZWQgcXVlcnkgdG8gdGhlIEB1cmwsIHByZXBlbmRpbmcgdGhlIHJpZ2h0IGNoYXJhY3RlciBpZlxuICAgICMgdGhlcmUgd2FzIGFscmVhZHkgYSBxdWVyeSBpbiB0aGUgZGVmaW5lZCBAdXJsIG9yIG5vdFxuICAgIHVubGVzcyBAcXVlcnkuZW1wdHk/XG4gICAgICBpZiB1cmwuaW5jbHVkZT8gPz9cbiAgICAgICAgdXJsICs9ID8mXG4gICAgICBlbHNlXG4gICAgICAgIHVybCArPSA/P1xuICAgICAgZW5kXG5cbiAgICAgIHVybCArPSBGb3JtRGF0YS5idWlsZF9xdWVyeShAcXVlcnkpXG4gICAgZW5kXG5cbiAgICBgI0BuYXRpdmUub3Blbigje0BtZXRob2QudG9fcy51cGNhc2V9LCAje3VybC50b19zfSwgI3tAYXN5bmNocm9ub3VzfSwgI3tAdXNlci50b19ufSwgI3tAcGFzc3dvcmQudG9fbn0pYFxuXG4gICAgIyBpZiB0aGVyZSBhcmUgbm8gcmVnaXN0ZXJlZCBjYWxsYmFja3Mgbm8gcG9pbnQgaW4gc2V0dGluZyB0aGUgZXZlbnRcbiAgICAjIGhhbmRsZXJcbiAgICB1bmxlc3MgQGNhbGxiYWNrcy5lbXB0eT9cbiAgICAgIGAjQG5hdGl2ZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAje2NhbGxiYWNrfWBcbiAgICBlbmRcblxuICAgIEBvcGVuZWQgPSB0cnVlXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgU2VuZCB0aGUgcmVxdWVzdCB3aXRoIG9wdGlvbmFsIHBhcmFtZXRlcnMuXG4gICNcbiAgIyBAcGFyYW0gcGFyYW1ldGVycyBbU3RyaW5nLCBIYXNoXSB0aGUgZGF0YSB0byBzZW5kXG4gICNcbiAgIyBAcmV0dXJuIFtSZXNwb25zZV0gdGhlIHJlc3BvbnNlXG4gIGRlZiBzZW5kKHBhcmFtZXRlcnMgPSBAcGFyYW1ldGVycylcbiAgICByYWlzZSAndGhlIHJlcXVlc3QgaGFzIG5vdCBiZWVuIG9wZW5lZCcgdW5sZXNzIG9wZW5lZD9cblxuICAgIHJhaXNlICd0aGUgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHNlbnQnIGlmIHNlbnQ/XG5cbiAgICAjIHRyeSB0byBjaXJjdW12ZW50IGNhY2hpbmcgc2V0dGluZyBhbiBJZi1Nb2RpZmllZC1TaW5jZSBoZWFkZXIgd2l0aCBhIHZlcnlcbiAgICAjIG9sZCBkYXRlXG4gICAgdW5sZXNzIGNhY2hlYWJsZT9cbiAgICAgIGAjQG5hdGl2ZS5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgXCJUdWUsIDExIFNlcCAyMDAxIDEyOjQ2OjAwIEdNVFwiKWBcbiAgICBlbmRcblxuICAgIEBoZWFkZXJzLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgIGAjQG5hdGl2ZS5zZXRSZXF1ZXN0SGVhZGVyKCN7bmFtZS50b19zfSwgI3t2YWx1ZS50b19zfSlgXG4gICAgfVxuXG4gICAgaWYgQGNvbnRlbnRfdHlwZVxuICAgICAgaGVhZGVyICA9IEBjb250ZW50X3R5cGVcbiAgICAgIGhlYWRlciArPSBcIjsgY2hhcnNldD0je0BlbmNvZGluZ31cIiBpZiBAZW5jb2RpbmdcblxuICAgICAgYCNAbmF0aXZlLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGhlYWRlcilgXG4gICAgZW5kXG5cbiAgICBpZiBiaW5hcnk/XG4gICAgICBpZiBCdWZmZXIuc3VwcG9ydGVkP1xuICAgICAgICBgI0BuYXRpdmUucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ2BcbiAgICAgIGVsc2VcbiAgICAgICAgYCNAbmF0aXZlLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaWYgbWltZV90eXBlICYmICFiaW5hcnk/XG4gICAgICBgI0BuYXRpdmUub3ZlcnJpZGVNaW1lVHlwZSgjQG1pbWVfdHlwZSlgXG4gICAgZW5kXG5cbiAgICBAc2VudCAgICAgPSB0cnVlXG4gICAgQHJlc3BvbnNlID0gUmVzcG9uc2UubmV3KHNlbGYpXG5cbiAgICBpZiBTdHJpbmcgPT09IHBhcmFtZXRlcnNcbiAgICAgIGRhdGEgPSBwYXJhbWV0ZXJzXG4gICAgZWxzaWYgKEhhc2ggPT09IHBhcmFtZXRlcnMgJiYgIXBhcmFtZXRlcnMuZW1wdHk/KSB8fCBGb3JtRGF0YSA9PT0gcGFyYW1ldGVyc1xuICAgICAgZGF0YSA9IGlmIEhhc2ggPT09IHBhcmFtZXRlcnNcbiAgICAgICAgaWYgRm9ybURhdGEuY29udGFpbl9maWxlcz8ocGFyYW1ldGVycylcbiAgICAgICAgICBGb3JtRGF0YS5idWlsZF9mb3JtX2RhdGEocGFyYW1ldGVycylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIEZvcm1EYXRhLmJ1aWxkX3F1ZXJ5KHBhcmFtZXRlcnMpXG4gICAgICAgIGVuZFxuICAgICAgZWxzZSAjaWYgRm9ybURhdGEgPT09IHBhcmFtZXRlcnNcbiAgICAgICAgcGFyYW1ldGVyc1xuICAgICAgZW5kXG5cbiAgICAgIHVubGVzcyBAY29udGVudF90eXBlXG4gICAgICAgIGlmIEZvcm1EYXRhID09PSBkYXRhXG4gICAgICAgICAgIyBJIHRob3VnaHQgaXQncyBkb25lIHRoaXMgd2F5LCBidXQgaXQgaXNuJ3QuIEl0IGFjdHVhbGx5IGlzXG4gICAgICAgICAgIyBcIm11bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PS0tLS0tLS0tLS0tLi4uLi4uLlwiLiBMZXQncyBtaXNzIGl0XG4gICAgICAgICAgIyBwdXJwb3NlZnVsbHksIGJlY2F1c2UgaXQncyBmaWxsZWQgaW4gYXV0b21hdGljYWxseSBpbiB0aGlzIGV4YW1wbGUuXG4gICAgICAgICAgIyBgI0BuYXRpdmUuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ211bHRpcGFydC9mb3JtLWRhdGEnKWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGAjQG5hdGl2ZS5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJylgXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIGRhdGEgPSBkYXRhLnRvX25cbiAgICBlbHNlXG4gICAgICBkYXRhID0gYG51bGxgXG4gICAgZW5kXG5cbiAgICBgI0BuYXRpdmUuc2VuZCgje2RhdGF9KWBcblxuICAgIEByZXNwb25zZVxuICBlbmRcblxuICAjIEFib3J0IHRoZSByZXF1ZXN0LlxuICBkZWYgYWJvcnRcbiAgICBgI0BuYXRpdmUuYWJvcnQoKWBcbiAgZW5kXG5cbnByaXZhdGVcbiAgZGVmIGNhbGxiYWNrXG4gICAgLT4gZXZlbnQge1xuICAgICAgc3RhdGUgPSBTVEFURVNbYCNAbmF0aXZlLnJlYWR5U3RhdGVgXVxuICAgICAgcmVzICAgPSByZXNwb25zZVxuXG4gICAgICBAY2FsbGJhY2tzW3N0YXRlXS5lYWNoIHsgfGJ8IGIuKHJlcykgfVxuXG4gICAgICBpZiBzdGF0ZSA9PSA6Y29tcGxldGVcbiAgICAgICAgQGNvbXBsZXRlZCA9IHRydWVcblxuICAgICAgICBAY2FsbGJhY2tzW3Jlcy5zdGF0dXMuY29kZV0uZWFjaCB7IHxifCBiLihyZXMpIH1cblxuICAgICAgICBpZiByZXMuc3VjY2Vzcz9cbiAgICAgICAgICBAY2FsbGJhY2tzWzpzdWNjZXNzXS5lYWNoIHsgfGJ8IGIuKHJlcykgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgQGNhbGxiYWNrc1s6ZmFpbHVyZV0uZWFjaCB7IHxifCBiLihyZXMpIH1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICB9XG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkhUVFA+IiwiPGNsYXNzOlJlcXVlc3Q+Iiwic2VsZiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJFdmVudDo6VGFyZ2V0IiwiRXZlbnQiLCJSVUJZX0VOR0lORV9WRVJTSU9OIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwidHJhbnNwb3J0IiwiQHBhcmFtZXRlcnMiLCJAcXVlcnkiLCJAaGVhZGVycyIsIkhlYWRlcnMiLCJbXSIsIkhFQURFUlMiLCJAbWV0aG9kIiwiQGFzeW5jaHJvbm91cyIsIkBiaW5hcnkiLCJAY2FjaGVhYmxlIiwiQG9wZW5lZCIsIkBzZW50IiwiQGNvbXBsZXRlZCIsIkBjYWxsYmFja3MiLCJuZXciLCJIYXNoIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsImgiLCJrIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiW109IiwiYmxvY2siLCJhcml0eSIsIjAiLCJpbnN0YW5jZV9leGVjIiwidG9fcHJvYyIsImNhbGwiLCJCcm93c2VyIiwic3VwcG9ydHM/IiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwib3BlbmVkPyIsInNlbnQ/IiwiY29tcGxldGVkPyIsImFzeW5jaHJvbm91cz8iLCJzeW5jaHJvbm91cz8iLCIhIiwiYXN5bmNocm9ub3VzISIsInN5bmNocm9ub3VzISIsImJpbmFyeT8iLCJiaW5hcnkhIiwiY2FjaGVhYmxlPyIsIm5vX2NhY2hlISIsInVzZXIiLCJ2YWx1ZSIsIkB1c2VyIiwicGFzc3dvcmQiLCJAcGFzc3dvcmQiLCJtaW1lX3R5cGUiLCJAbWltZV90eXBlIiwiY29udGVudF90eXBlIiwiQGNvbnRlbnRfdHlwZSIsImVuY29kaW5nIiwiQGVuY29kaW5nIiwicGFyYW1ldGVycyIsImhhc2giLCJxdWVyeSIsIm9uIiwid2hhdCIsIlNUQVRFUyIsImluY2x1ZGU/IiwiSW50ZWdlciIsIjw8Iiwib3BlbiIsIm1ldGhvZCIsInVybCIsImFzeW5jaHJvbm91cyIsIm5pbD8iLCJAdXJsIiwicmFuZCIsImVtcHR5PyIsIisiLCJGb3JtRGF0YSIsImJ1aWxkX3F1ZXJ5IiwiQG5hdGl2ZSIsInRvX3MiLCJ1cGNhc2UiLCJ0b19uIiwiY2FsbGJhY2siLCJzZW5kIiwiZWFjaCIsImJsb2NrIGluIHNlbmQiLCJuYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZW5kIiwiaGVhZGVyIiwiQnVmZmVyIiwic3VwcG9ydGVkPyIsIkByZXNwb25zZSIsIlJlc3BvbnNlIiwiU3RyaW5nIiwiZGF0YSIsImNvbnRhaW5fZmlsZXM/IiwiYnVpbGRfZm9ybV9kYXRhIiwiYWJvcnQiLCJwcml2YXRlIiwiYmxvY2sgaW4gY2FsbGJhY2siLCJldmVudCIsImJsb2NrICgyIGxldmVscykgaW4gY2FsbGJhY2siLCJzdGF0ZSIsInJlcyIsInJlc3BvbnNlIiwiYiIsImJsb2NrICgzIGxldmVscykgaW4gY2FsbGJhY2siLCJzdGF0dXMiLCJjb2RlIiwic3VjY2Vzcz8iXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtRQUNBRCxJQUFBQyxTQUFBQSxDQUFRRyxJQUFBQyxXQUFBRCxXQUFSSDtRQUdBLG1DQUFVLDBEQUFBLG9C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QUFVNEUsUUFBQUEsRUFBQUEsRUFBQUEsRUFBcEJpQixhQUE2QkksQ0FBN0JKOztrQkFBNkI7a0JBQUdLLE9BQUFELENBQUMzRSxNQUFBQSxDQUFFeUUsR0FBRnpFLEVBQWpDdUUsQ0FBQUEsR0FBb0JqQjtjQUR0QjtnQkFHRWlCLE9BQW9CakIsTUFBcEJuRSxjQUFVVCxPQUFBQSxDQUFDLFNBQURBLENBQVU0RSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFwQmlCLGFBQTZCSSxDQUE3Qko7O2tCQUE2QjtrQkFBR0ssT0FBQUQsQ0FBQzNFLE1BQUFBLENBQUV5RSxHQUFGekUsRUFBakN1RSxDQUFBQSxHQUFvQmpCO2NBSHRCO1lBTEY7Y0F2Vk5pQixPQUFBO1lBdVZNLEVBTkZGLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBO1FBREZqQixDQUFBQSxHQUFBQTtNQTlVRnpGLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBRmdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyNzQ5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9kb20vbm9kZV9zZXQnXG5yZXF1aXJlICdicm93c2VyL2RvbS9ub2RlJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vYXR0cmlidXRlJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vY2hhcmFjdGVyX2RhdGEnXG5yZXF1aXJlICdicm93c2VyL2RvbS90ZXh0J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vY2RhdGEnXG5yZXF1aXJlICdicm93c2VyL2RvbS9jb21tZW50J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2RvY3VtZW50X29yX3NoYWRvd19yb290J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZG9jdW1lbnQnXG5yZXF1aXJlICdicm93c2VyL2RvbS9kb2N1bWVudF9mcmFnbWVudCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL3NoYWRvd19yb290J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vbXV0YXRpb25fb2JzZXJ2ZXInXG5cbm1vZHVsZSBLZXJuZWxcbiAgIyBQYXJzZSBhbiBYTUwgc3RyaW5nIGludG8gYSBET00gdXNhYmxlIHtCcm93c2VyOjpET006OkRvY3VtZW50fVxuICAjXG4gICMgQHBhcmFtIHdoYXQgW1N0cmluZ10gdGhlIHN0cmluZyB0byBwYXJzZVxuICAjIEByZXR1cm4gW0Jyb3dzZXI6OkRPTTo6RG9jdW1lbnRdIHRoZSBkb2N1bWVudFxuICBkZWYgWE1MKHdoYXQpXG4gICAgJXh7XG4gICAgICB2YXIgZG9jO1xuXG4gICAgICBpZiAod2luZG93LkRPTVBhcnNlcikge1xuICAgICAgICBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdoYXQsICd0ZXh0L3htbCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRvYyAgICAgICA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XG4gICAgICAgIGRvYy5hc3luYyA9ICdmYWxzZSc7XG4gICAgICAgIGRvYy5sb2FkWE1MKHdoYXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIERPTShgZG9jYClcbiAgZW5kXG5cbiAgIyBAb3ZlcmxvYWQgRE9NKGRvY3VtZW50ID0gJGRvY3VtZW50LCAmYmxvY2spXG4gICNcbiAgIyAgIENyZWF0ZSBhIERPTSB0cmVlIHVzaW5nIHRoZSB7UGFnZ2lvOjpIVE1MfSBEU0wuXG4gICNcbiAgIyAgIEBwYXJhbSBkb2N1bWVudCBbQnJvd3Nlcjo6RE9NOjpEb2N1bWVudF0gdGhlIGRvY3VtZW50IGluc3RhbmNlXG4gICMgICAgIHdlIGludGVuZCB0byB1c2VcbiAgI1xuICAjICAgQHJldHVybiBbQnJvd3Nlcjo6RE9NOjpOb2RlLCBCcm93c2VyOjpET006Ok5vZGVTZXRdXG4gICNcbiAgIyBAb3ZlcmxvYWQgRE9NKHN0cmluZywgZG9jdW1lbnQgPSAkZG9jdW1lbnQpXG4gICNcbiAgIyAgIENyZWF0ZSBhIERPTSB0cmVlIGZyb20gYSBIVE1MIHN0cmluZy5cbiAgI1xuICAjICAgQHBhcmFtIHN0cmluZyBbU3RyaW5nXSB0aGUgSFRNTCBzdHJpbmdcbiAgIyAgIEBwYXJhbSBkb2N1bWVudCBbQnJvd3Nlcjo6RE9NOjpEb2N1bWVudF0gdGhlIGRvY3VtZW50IGluc3RhbmNlXG4gICMgICAgIHdlIGludGVuZCB0byB1c2VcbiAgI1xuICAjICAgQHJldHVybiBbQnJvd3Nlcjo6RE9NOjpOb2RlXVxuICAjXG4gICMgQG92ZXJsb2FkIERPTShuYXRpdmUpXG4gICNcbiAgIyAgIFdyYXAgYSBuYXRpdmUgZWxlbWVudCB0byBjcmVhdGUgYSBET00gdHJlZS5cbiAgI1xuICAjICAgQHBhcmFtIG5hdGl2ZSBbTmF0aXZlXSB0aGUgTmF0aXZlIG5vZGVcbiAgI1xuICAjICAgQHJldHVybiBbQnJvd3Nlcjo6RE9NOjpOb2RlXVxuICAjXG4gIGRlZiBET00oKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgZG9jdW1lbnQgPSBhcmdzLnNoaWZ0IHx8ICRkb2N1bWVudFxuICAgICAgcm9vdHMgICAgPSBCcm93c2VyOjpET006OkJ1aWxkZXIubmV3KGRvY3VtZW50LCAmYmxvY2spLnRvX2FcblxuICAgICAgaWYgcm9vdHMubGVuZ3RoID09IDFcbiAgICAgICAgcm9vdHMuZmlyc3RcbiAgICAgIGVsc2VcbiAgICAgICAgQnJvd3Nlcjo6RE9NOjpOb2RlU2V0Lm5ldyhyb290cylcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHdoYXQgICAgID0gYXJncy5zaGlmdFxuICAgICAgZG9jdW1lbnQgPSBhcmdzLnNoaWZ0IHx8ICRkb2N1bWVudFxuXG4gICAgICB3aGF0ID0gd2hhdC50b19kb20oZG9jdW1lbnQpIGlmIE9wYWwucmVzcG9uZF90bz8gd2hhdCwgOnRvX2RvbVxuXG4gICAgICBpZiBgdHlwZW9mKCN7d2hhdH0pID09PSAndW5kZWZpbmVkJyB8fCAje3doYXR9ID09PSBudWxsYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXJndW1lbnQgaXMgbnVsbCdcbiAgICAgIGVsc2lmIG5hdGl2ZT8od2hhdClcbiAgICAgICAgQnJvd3Nlcjo6RE9NOjpOb2RlLm5ldyh3aGF0KVxuICAgICAgZWxzaWYgQnJvd3Nlcjo6RE9NOjpOb2RlID09PSB3aGF0XG4gICAgICAgIHdoYXRcbiAgICAgIGVsc2lmIE9wYWwucmVzcG9uZF90bz8gd2hhdCwgOmVhY2ggIyBlZy4gTm9kZVNldCwgQXJyYXlcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoXCJESVZcIikudGFwIGRvIHxkaXZ8XG4gICAgICAgICAgZGl2IDw8IHdoYXRcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBTdHJpbmcgPT09IHdoYXRcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIGRvYyA9ICN7TmF0aXZlLnRyeV9jb252ZXJ0KGRvY3VtZW50KX0uY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgZG9jLmlubmVySFRNTCA9IHdoYXQ7XG5cbiAgICAgICAgICByZXR1cm4gI3tET00oYGRvYy5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxID8gZG9jLmNoaWxkTm9kZXNbMF0gOiBkb2NgKX07XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2FyZ3VtZW50IGlzIG5vdCBET00gY29udmVydGlibGUnXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIEJyb3dzZXJcblxuY2xhc3MgV2luZG93XG4gICMgR2V0IHRoZSB7RE9NOjpEb2N1bWVudH0gZm9yIHRoaXMgd2luZG93LlxuICAjXG4gICMgQHJldHVybiBbRE9NOjpEb2N1bWVudF1cbiAgZGVmIGRvY3VtZW50XG4gICAgRE9NKGAjQG5hdGl2ZS5kb2N1bWVudGApXG4gIGVuZFxuZW5kXG5cbmVuZFxuXG4kZG9jdW1lbnQgPSAkd2luZG93LmRvY3VtZW50XG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpLZXJuZWw+IiwiWE1MIiwid2hhdCIsIkRPTSIsImJsb2NrIiwiZG9jdW1lbnQiLCIkcmV0X29yXzEiLCJhcmdzIiwic2hpZnQiLCIkZG9jdW1lbnQiLCJyb290cyIsIm5ldyIsIkJyb3dzZXI6OkRPTTo6QnVpbGRlciIsIkJyb3dzZXI6OkRPTSIsIkJyb3dzZXIiLCJ0b19wcm9jIiwidG9fYSIsImxlbmd0aCIsIjEiLCJmaXJzdCIsIkJyb3dzZXI6OkRPTTo6Tm9kZVNldCIsIk9wYWwiLCJyZXNwb25kX3RvPyIsInRvX2RvbSIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIm5hdGl2ZT8iLCJCcm93c2VyOjpET006Ok5vZGUiLCJ0YXAiLCJjcmVhdGVfZWxlbWVudCIsImJsb2NrIGluIERPTSIsImRpdiIsImJsb2NrICgyIGxldmVscykgaW4gRE9NIiwiPDwiLCJTdHJpbmciLCJOYXRpdmUiLCJ0cnlfY29udmVydCIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6V2luZG93PiIsIkBuYXRpdmUiLCIkd2luZG93Il0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTtBQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLHNCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixrQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDRCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixrQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsbUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYscUNBQVJFO0VBQ0FELElB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cUJ0QixpQ0FBckJxQjtRQVJGO01BekJGO0lBREZyQixDQUFBQSxJQUFBQTtFQWpERkgsR0FBQUEsV0FBQUE7RUF5RkFxQztFQUFBQTs7SUFBQUE7O0lBRUFBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7TUFJRUEsT0FBQWpDLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFQLElBQUFLLEtBQUFBLENBQU1vQyxjQUFPbEMsU0FBYkY7TUFERkUsQ0FBQUEsR0FBQUE7SUFKRmlDLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBRkFELEdBQUFBLFdBQUFBO0VBYUF4QyxPQUFBWSxDQUFBQSxrQkFBWStCLGFBQU9uQyxVQUFBQSxDQUFBQSxDQUFuQkk7QUFwSEFaOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMjg2MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvaHR0cC9yZXNwb25zZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdqc29uJ1xuXG5tb2R1bGUgQnJvd3NlcjsgbW9kdWxlIEhUVFBcblxuIyBSZXByZXNlbnRzIGFuIEhUVFAgcmVzcG9uc2UuXG5jbGFzcyBSZXNwb25zZVxuICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gIFN0YXR1cyA9IFN0cnVjdC5uZXcoOmNvZGUsIDp0ZXh0KVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHJlcXVlc3RcbiAgIyBAcmV0dXJuIFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCB0byB0aGlzIHJlc3BvbnNlXG4gIGF0dHJfcmVhZGVyIDpyZXF1ZXN0XG5cbiAgIyBDcmVhdGUgYSByZXNwb25zZSBmcm9tIGEgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdFxuICBkZWYgaW5pdGlhbGl6ZShyZXF1ZXN0KVxuICAgIHN1cGVyKHJlcXVlc3QudG9fbilcblxuICAgIEByZXF1ZXN0ID0gcmVxdWVzdFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBoZWFkZXJzXG4gICMgQHJldHVybiBbSGVhZGVyc10gdGhlIHJlc3BvbnNlIGhlYWRlcnNcbiAgZGVmIGhlYWRlcnNcbiAgICBAaGVhZGVycyB8fD0gSGVhZGVycy5wYXJzZShgI0BuYXRpdmUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBzdGF0dXNcbiAgIyBAcmV0dXJuIFtTdGF0dXNdIHRoZSByZXNwb25zZSBzdGF0dXNcbiAgZGVmIHN0YXR1c1xuICAgIFN0YXR1cy5uZXcoYCNAbmF0aXZlLnN0YXR1cyB8fCBuaWxgLCBgI0BuYXRpdmUuc3RhdHVzVGV4dCB8fCBuaWxgKVxuICBlbmRcblxuICAjIENoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWxcbiAgZGVmIHN1Y2Nlc3M/XG4gICAgaWYgY29kZSA9IHN0YXR1cy5jb2RlXG4gICAgICBjb2RlID49IDIwMCAmJiBjb2RlIDwgMzAwIHx8IGNvZGUgPT0gMzA0XG4gICAgZWxzZVxuICAgICAgZmFsc2VcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgcmVzcG9uc2UgZmFpbGVkXG4gIGRlZiBmYWlsdXJlP1xuICAgICFzdWNjZXNzP1xuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB1cmxcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXNwb25zZSBVUkwgKGFmdGVyIHJlZGlyZWN0cylcbiAgYWxpYXNfbmF0aXZlIDp1cmwsIDpyZXNwb25zZVVSTFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHRleHRcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXNwb25zZSBib2R5IGFzIHRleHRcbiAgZGVmIHRleHRcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAjQG5hdGl2ZS5yZXNwb25zZVRleHQ7XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBqc29uXG4gICMgQHJldHVybiBbSGFzaCwgQXJyYXldIHRoZSByZXNwb25zZSBib2R5IGFzIEpTT05cbiAgZGVmIGpzb25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAjQG5hdGl2ZS5yZXNwb25zZVRleHQ7XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje0pTT04ucGFyc2UoYHJlc3VsdGApfTtcbiAgICB9XG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHhtbFxuICAjIEByZXR1cm4gW0RPTTo6RG9jdW1lbnRdIHRoZSByZXNwb25zZSBib2R5IGFzIERPTSBkb2N1bWVudFxuICBkZWYgeG1sXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI0BuYXRpdmUucmVzcG9uc2VYTUw7XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRE9NKGByZXN1bHRgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBiaW5hcnlcbiAgIyBAcmV0dXJuIFtCaW5hcnldIHRoZSByZXNwb25zZSBib2R5IGFzIGJpbmFyeVxuICBkZWYgYmluYXJ5XG4gICAgcmV0dXJuIHVubGVzcyByZXF1ZXN0LmJpbmFyeT9cblxuICAgIGlmIEJ1ZmZlci5zdXBwb3J0ZWQ/XG4gICAgICAleHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICNAbmF0aXZlLnJlc3BvbnNlO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBCaW5hcnkubmV3KEJ1ZmZlci5uZXcoYHJlc3VsdGApKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiB1bmxlc3MgdGV4dFxuXG4gICAgICBCaW5hcnkubmV3KHRleHQpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6SFRUUD4iLCI8Y2xhc3M6UmVzcG9uc2U+IiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsIlN0cnVjdCIsIm5ldyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsInJlcXVlc3QiLCJ0b19uIiwiQHJlcXVlc3QiLCJoZWFkZXJzIiwiQGhlYWRlcnMiLCIkcmV0X29yXzEiLCJIZWFkZXJzIiwicGFyc2UiLCJAbmF0aXZlIiwic3RhdHVzIiwiU3RhdHVzIiwic3VjY2Vzcz8iLCJjb2RlIiwiJHJldF9vcl8yIiwiPj0iLCIyMDAiLCI8IiwiMzAwIiwiPT0iLCIzMDQiLCJmYWlsdXJlPyIsIiEiLCJhbGlhc19uYXRpdmUiLCJ0ZXh0IiwianNvbiIsIkpTT04iLCJ4bWwiLCJET00iLCJiaW5hcnkiLCJiaW5hcnk/IiwiQnVmZmVyIiwic3VwcG9ydGVkPyIsIkJpbmFyeSJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixNQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BR2hCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFSixJQUFBSyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtRQUVBLGtDQUFTRyxZQUFNQyxLQUFBQSxDQUFLLE1BQVgsRUFBa0IsTUFBWkEsQ0FBZjtRQUlBVCxJQUFBVSxhQUFBQSxDQUFZLFNBQVpBOztBQUtBQyxRQUFBQSwwQkFBQUEsc0JBQWVDLE9BQWZEO0FBQUFBLFVBQUFBOztVQUFBQTs7VUFDRSxPQUFBWCxJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFBLENBQU1ZLE9BQU9DLE1BQUFB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QUFBLElBQUFBO0lBSGdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMDAzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci93aW5kb3cvdmlldy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgV2luZG93XG5cbmNsYXNzIFZpZXdcbiAgZGVmIGluaXRpYWxpemUod2luZG93KVxuICAgIEB3aW5kb3cgPSB3aW5kb3dcbiAgICBAbmF0aXZlID0gd2luZG93LnRvX25cbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ1dpbmRvdy5pbm5lclNpemUnXG4gICAgZGVmIHdpZHRoXG4gICAgICBgI0BuYXRpdmUuaW5uZXJXaWR0aGBcbiAgICBlbmRcblxuICAgIGRlZiBoZWlnaHRcbiAgICAgIGAjQG5hdGl2ZS5pbm5lckhlaWdodGBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQuY2xpZW50U2l6ZSdcbiAgICBkZWYgaGVpZ2h0XG4gICAgICBgI0BuYXRpdmUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodGBcbiAgICBlbmRcblxuICAgIGRlZiB3aWR0aFxuICAgICAgYCNAbmF0aXZlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aGBcbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiB3aWR0aFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3dpbmRvdyBzaXplIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuXG4gICAgZGVmIGhlaWdodFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3dpbmRvdyBzaXplIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIEdldCBhIGRldmljZSBwaXhlbCByYXRpby4gQ2FuIGJlIHVzZWQgdG8gaGFuZGxlIGRlc2t0b3AgYnJvd3NlclxuICAjIHpvb20sIHJldGluYSBkZXZpY2VzIGFuZCBjdXN0b20gc2NyZWVuIHNjYWxlIGZvciBtb2JpbGUgZGV2aWNlcy5cbiAgIyBVc2UgJHdpbmRvdy52aXN1YWxfdmlld3BvcnQuc2NhbGUgdG8gaGFuZGxlIG1vYmlsZSB6b29tLlxuICBkZWYgem9vbVxuICAgIGAjQG5hdGl2ZS5kZXZpY2VQaXhlbFJhdGlvYFxuICBlbmRcblxuICAjIEhhbmRsZSAjcGl4ZWxfcmF0aW8gY2hhbmdlcy4gVGhpcyB3aWxsIHRyaWdnZXIgYSBibG9jayBvbiB6b29tLlxuICBkZWYgb25fem9vbSAmYmxvY2tcbiAgICAleHtcbiAgICAgIHZhciBtcVN0cmluZyA9IFwiKHJlc29sdXRpb246IFwiICsgI0BuYXRpdmUuZGV2aWNlUGl4ZWxSYXRpbyArIFwiZHBweClcIjtcbiAgICAgICNAbmF0aXZlLm1hdGNoTWVkaWEobXFTdHJpbmcpLmFkZExpc3RlbmVyKCN7YmxvY2sudG9fbn0pO1xuICAgIH1cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpXaW5kb3c+IiwiPGNsYXNzOlZpZXc+IiwiaW5pdGlhbGl6ZSIsIndpbmRvdyIsIkB3aW5kb3ciLCJAbmF0aXZlIiwidG9fbiIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJ3aWR0aCIsImhlaWdodCIsInNlbGYiLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ6b29tIiwib25fem9vbSIsImJsb2NrIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7O0FBQ0VDLFFBQUFBLDBCQUFBQSxzQkFBZUMsTUFBZkQ7QUFBQUEsVUFBQUE7OztVQUNFRSxjQUFVRDtVQUNWRCxPQUFBRyxDQUFBQSxpQkFBVUYsTUFBTUcsTUFBQUEsQ0FBQUEsQ0FBaEJEO1FBRkZILENBQUFBLEdBQUFBO1FBS0EsSUFBQSxRQUFHSyxhQUFPQyxjQUFBQSxDQUFXUCxrQkFBWE8sQ0FBVixDQUFBOzs7QUFDRUMsVUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUosY0FBT0k7VUFEWEEsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVMLGNBQU9LO1VBRFhBLENBQUFBLEdBQUFBO1FBTEYsT0FRQSxJQUFBLFFBQU1ILGFBQU9DLGNBQUFBLENBQVdQLG9CQUFYTyxDQUFiLENBQUE7OztBQUNFRSxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFTCxjQUFPSztVQURYQSxDQUFBQSxHQUFBQTs7QUFJQUQsVUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUosY0FBT0k7VUFEWEEsQ0FBQUEsR0FBQUE7UUFMRjs7O0FBU0VBLFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFFLElBQUFDLE9BQUFBLENBQU1DLHlCQUFOLEVBQTJCSix5QkFBM0JHO1VBREZILENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBQyxJQUFBQyxPQUFBQSxDQUFNQyx5QkFBTixFQUEyQkgseUJBQTNCRTtVQURGRixDQUFBQSxHQUFBQTtRQWJGOztBQXFCQUksUUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRVQsY0FBT1M7UUFEWEEsQ0FBQUEsR0FBQUE7UUFLQWIsT0FBQWMsdUJBQUFBLG1CQUFBQTtBQUFBQSxVQUFBQTs7VUFBQUE7Ozs7QUFFRkEsdUNBQXdDVixjQUFPVTtBQUMvQ0EsTUFBT1YsY0FBT1Usa0NBQW9DQyxLQUFLVixNQUFBQSxDQUFBQSxDQUFNUztBQUM3REE7UUFKRUEsQ0FBQUEsR0FBQUE7TUF4Q0ZkLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMDk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9kZXZpY2VfbW90aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBEZXZpY2VNb3Rpb24gPCBFdmVudFxuICBoYW5kbGVzICdkZXZpY2Vtb3Rpb24nXG4gIFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRldmljZU1vdGlvbidcbiAgZW5kXG5cbiAgQWNjZWxlcmF0aW9uID0gU3RydWN0Lm5ldyg6eCwgOnksIDp6KVxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGFjY2VsZXJhdGlvbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYWNjZWxlcmF0aW9uID0gI3t2YWx1ZS50b19ufWBcbiAgICBlbmRcblxuICAgIGRlZiBhY2NlbGVyYXRpb25fd2l0aF9ncmF2aXR5PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5ID0gI3t2YWx1ZS50b19ufWBcbiAgICBlbmRcblxuICAgIGRlZiByb3RhdGlvbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUucm90YXRpb25SYXRlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgaW50ZXJ2YWw9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmludGVydmFsID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRGV2aWNlTW90aW9uRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJEZXZpY2VNb3Rpb25FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXREZXZpY2VNb3Rpb25FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy5hY2NlbGVyYXRpb24sIGRlc2MuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSxcbiAgICAgICAgICAgICAgZGVzYy5yb3RhdGlvblJhdGUsIGRlc2MuaW50ZXJ2YWwpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFjY2VsZXJhdGlvblxuICBhbGlhc19uYXRpdmUgOmFjY2VsZXJhdGlvbl93aXRoX2dyYXZpdHksIDphY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5XG4gIGFsaWFzX25hdGl2ZSA6cm90YXRpb24sIDpyb3RhdGlvblJhdGVcbiAgYWxpYXNfbmF0aXZlIDppbnRlcnZhbFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkRldmljZU1vdGlvbj4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiU3RydWN0IiwibmV3IiwiPGNsYXNzOkRlZmluaXRpb24+IiwiYWNjZWxlcmF0aW9uPSIsInZhbHVlIiwiQG5hdGl2ZSIsInRvX24iLCJhY2NlbGVyYXRpb25fd2l0aF9ncmF2aXR5PSIsInJvdGF0aW9uPSIsImludGVydmFsPSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsOENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLHdDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixvQkFBWEU7UUFEVEYsQ0FBQUEsR0FBQUE7UUFJQSx3Q0FBZUcsWUFBTUMsS0FBQUEsQ0FBSyxHQUFYLEVBQWUsR0FBZixFQUFtQixHQUFiQSxDQUFyQjtRQUVBQztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsNkJBQUFBLHVDQUFrQkMsS0FBbEJEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixnQkFBa0JDLEtBQUtFLE1BQUFBLENBQUFBO1VBRGxDSCxDQUFBQSxHQUFBQTs7QUFJQUksVUFBQUEsMENBQUFBLG9EQUErQkgsS0FBL0JHO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRSxnQ0FBa0NILEtBQUtFLE1BQUFBLENBQUFBO1VBRGxEQyxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEseUJBQUFBLG1DQUFjSixLQUFkSTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0csZ0JBQWtCSjtVQUQ3QkksQ0FBQUEsR0FBQUE7VUFJQU4sT0FBQU8seUJBQUFBLG1DQUFjTCxLQUFkSztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUosY0FBT0ksWUFBY0w7VUFEekJLLENBQUFBLEdBQUFBO1FBYkZQLEdBQUFBLFdBQUFBLEVBQW1CUSxnQkFBbkJSO1FBa0JBLElBQUEsUUFlT1AsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FmUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VZLE1BQUloQixJQUFKZ0IsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0Esc0JBQXdCQyxJQUFLRCxFQUFJRSxJQUFLRjtZQUR6Q0EsQ0FBQUEsR0FBQUE7VUFERixPQUlBLElBQUEsUUFBTWIsYUFBT0MsY0FBQUEsQ0FBV0wsY0FBWEssQ0FBYixDQUFBO1lBQ0VZLE1BQUloQixJQUFKZ0IsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtZQVJJQSxDQUFBQSxHQUFBQTtVQURGO1FBSkE7UUFpQkFoQixJQUFBbUIsY0FBQUEsQ0FBYSxjQUFiQTtRQUNBbkIsSUFBQW1CLGNBQUFBLENBQWEsMkJBQWIsRUFBeUMsOEJBQXpDQTtRQUNBbkIsSUFBQW1CLGNBQUFBLENBQWEsVUFBYixFQUF3QixjQUF4QkE7UUFDQXBCLE9BQUFDLElBQUFtQixjQUFBQSxDQUFhLFVBQWJBO01BL0NGcEIsR0FBQUEsV0FBQUEsRUFBcUJxQixXQUFyQnJCO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMTgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci92ZXJzaW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG4gIFZFUlNJT04gPSAnMC4zLjMnXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQSxtQ0FBVUEsT0FBVjtFQURGQSxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzMxOTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2Nzcy9ydWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgQ1NTXG5cbmNsYXNzIFJ1bGVcbiAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgU1RZTEVfUlVMRSAgICAgICAgICAgICAgID0gMVxuICBDSEFSU0VUX1JVTEUgICAgICAgICAgICAgPSAyXG4gIElNUE9SVF9SVUxFICAgICAgICAgICAgICA9IDNcbiAgTUVESUFfUlVMRSAgICAgICAgICAgICAgID0gNFxuICBGT05UX0ZBQ0VfUlVMRSAgICAgICAgICAgPSA1XG4gIFBBR0VfUlVMRSAgICAgICAgICAgICAgICA9IDZcbiAgS0VZRlJBTUVTX1JVTEUgICAgICAgICAgID0gN1xuICBLRVlGUkFNRV9SVUxFICAgICAgICAgICAgPSA4XG4gIE5BTUVTUEFDRV9SVUxFICAgICAgICAgICA9IDEwXG4gIENPVU5URVJfU1RZTEVfUlVMRSAgICAgICA9IDExXG4gIFNVUFBPUlRTX1JVTEUgICAgICAgICAgICA9IDEyXG4gIERPQ1VNRU5UX1JVTEUgICAgICAgICAgICA9IDEzXG4gIEZPTlRfRkVBVFVSRV9WQUxVRVNfUlVMRSA9IDE0XG4gIFZJRVdQT1JUX1JVTEUgICAgICAgICAgICA9IDE1XG4gIFJFR0lPTl9TVFlMRV9SVUxFICAgICAgICA9IDE2XG5cbiAgZGVmIHNlbGYubmV3KHJ1bGUpXG4gICAgaWYgc2VsZiA9PSBSdWxlXG4gICAgICBAY2xhc3NlcyB8fD0gW25pbCwgU3R5bGVdXG5cbiAgICAgIGlmIGtsYXNzID0gQGNsYXNzZXNbYHJ1bGUudHlwZWBdXG4gICAgICAgIGtsYXNzLm5ldyhydWxlKVxuICAgICAgZWxzZVxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnY2Fubm90IGluc3RhbnRpYXRlIGEgbm9uIGRlcml2ZWQgUnVsZSBvYmplY3QnXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdXBlcihydWxlKVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhc19uYXRpdmUgOnRleHQsIDpjc3NUZXh0XG4gIGFsaWFzX25hdGl2ZSA6dG9fcywgOmNzc1RleHRcblxuICBkZWYgcGFyZW50XG4gICAgUnVsZS5uZXcoYCNAbmF0aXZlLnBhcmVudFJ1bGVgKSBpZiBgI0BuYXRpdmUucGFyZW50UnVsZSAhPSBudWxsYFxuICBlbmRcblxuICBkZWYgc3R5bGVfc2hlZXRcbiAgICBTdHlsZVNoZWV0Lm5ldyhgI0BuYXRpdmUucGFyZW50U3R5bGVTaGVldGApIGlmIGAjQG5hdGl2ZS5wYXJlbnRTdHlsZVNoZWV0ICE9IG51bGxgXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkNTUz4iLCI8Y2xhc3M6UnVsZT4iLCJzZWxmIiwiaW5jbHVkZSIsIkJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXIiLCJCcm93c2VyIiwiMSIsIjIiLCIzIiwiNCIsIjUiLCI2IiwiNyIsIjgiLCIxMCIsIjExIiwiMTIiLCIxMyIsIjE0IiwiMTUiLCIxNiIsIm5ldyIsInJ1bGUiLCJSdWxlIiwiQGNsYXNzZXMiLCIkcmV0X29yXzEiLCJTdHlsZSIsImtsYXNzIiwiW10iLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJhbGlhc19uYXRpdmUiLCJwYXJlbnQiLCJAbmF0aXZlIiwic3R5bGVfc2hlZXQiLCJTdHlsZVNoZWV0Il0sIm1hcHBpbmdzIjoiQUFBQUEsbUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsd0JBQVJEO1FBRUEsc0NBQTJCRyxDQUEzQjtRQUNBLHdDQUEyQkMsQ0FBM0I7UUFDQSx1Q0FBMkJDLENBQTNCO1FBQ0Esc0NBQTJCQyxDQUEzQjtRQUNBLDBDQUEyQkMsQ0FBM0I7UUFDQSxxQ0FBMkJDLENBQTNCO1FBQ0EsMENBQTJCQyxDQUEzQjtRQUNBLHlDQUEyQkMsQ0FBM0I7UUFDQSwwQ0FBMkJDLEVBQTNCO1FBQ0EsOENBQTJCQyxFQUEzQjtRQUNBLHlDQUEyQkMsRUFBM0I7UUFDQSx5Q0FBMkJDLEVBQTNCO1FBQ0Esb0RBQTJCQyxFQUEzQjtRQUNBLHlDQUEyQkMsRUFBM0I7UUFDQSw2Q0FBMkJDLEVBQTNCO1FBRUFDLE1BQUluQixJQUFKbUIsVUFBQUEscUJBQWFDLElBQWJEO0FBQUFBLFVBQUFBO0FBQUFBOztVQUFBQTtVQUNFLElBQUEsTUFBR25CLElBQUgsRUFBV3FCLFVBQVgsQ0FBQTs7WUFDRUMsZUF2Qk4sQ0FBQSxRQUFBQyxDQUFBQSxZQXVCTUQsWUF2Qk5DLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBdUJtQixDQUFDLEdBQUQsRUFBTUMsV0FBTixDQXZCbkIsQ0FBQTtZQXlCTSxJQUFBLFFBQUdDLENBQUFBLFFBQVFILFlBQVFJLE9BQUFBLENBQUVQLFNBQUZPLENBQWhCRCxDQUFILENBQUE7Y0FDRU4sT0FBQU0sS0FBS04sS0FBQUEsQ0FBS0MsSUFBTEQ7WUFEUDtjQUdFQSxPQUFBbkIsSUFBQTJCLE9BQUFBLENBQU1DLG1CQUFOLEVBQXFCVCw4Q0FBckJRO1lBSEY7VUFIRjtZQVNFUixPQUFBLE9BQUFuQixJQUFBLEVBQUEsa0RBQUEsT0FBQSxFQUFBLENBQU1vQixJQUFOLENBQUEsRUFBQSxJQUFBO1VBVEY7UUFERkQsQ0FBQUEsR0FBQUE7UUFjQW5CLElBQUE2QixjQUFBQSxDQUFhLE1BQWIsRUFBb0IsU0FBcEJBO1FBQ0E3QixJQUFBNkIsY0FBQUEsQ0FBYSxNQUFiLEVBQW9CLFNBQXBCQTs7QUFFQUMsUUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRSxJQUFBLFFBQXFDQyxjQUFPRCxtQkFBNUMsQ0FBQTtZQUFBQSxPQUFBVCxVQUFJRixLQUFBQSxDQUFPWSxjQUFPRCxXQUFkWDtVQUFKO1lBdkNKVyxPQUFBO1VBdUNJO1FBREZBLENBQUFBLEdBQUFBO1FBSUEvQixPQUFBaUMsMkJBQUFBLHVCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRSxJQUFBLFFBQWlERCxjQUFPQyx5QkFBeEQsQ0FBQTtZQUFBQSxPQUFBQyxnQkFBVWQsS0FBQUEsQ0FBT1ksY0FBT0MsaUJBQWRiO1VBQVY7WUEzQ0phLE9BQUE7VUEyQ0k7UUFERkEsQ0FBQUEsR0FBQUE7TUF4Q0ZqQyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUZnQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzI3NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY3NzL2RlY2xhcmF0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgQ1NTXG5cbmNsYXNzIERlY2xhcmF0aW9uXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBkZWYgcnVsZVxuICAgIFJ1bGUubmV3KGAjQG5hdGl2ZS5wYXJlbnRSdWxlYCkgaWYgZGVmaW5lZD8oYCNAbmF0aXZlLnBhcmVudFJ1bGVgKVxuICBlbmRcblxuICBkZWYgYXNzaWduKGRhdGEpXG4gICAgZGF0YS5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICBzZWxmW25hbWVdID0gdmFsdWVcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKHN0cmluZylcbiAgICBgI0BuYXRpdmUuY3NzVGV4dCA9ICN7c3RyaW5nfWBcbiAgZW5kXG5cbiAgZGVmIGFwcGx5KCZibG9jaylcbiAgICBQYWdnaW86OkNTUzo6RGVmaW5pdGlvbi5uZXcoJmJsb2NrKS5lYWNoIHt8c3R5bGV8XG4gICAgICBpZiBzdHlsZS5pbXBvcnRhbnRcbiAgICAgICAgYCNAbmF0aXZlLnNldFByb3BlcnR5KCN7c3R5bGUubmFtZX0sICN7c3R5bGUudmFsdWV9LCBcImltcG9ydGFudFwiKWBcbiAgICAgIGVsc2VcbiAgICAgICAgYCNAbmF0aXZlLnNldFByb3BlcnR5KCN7c3R5bGUubmFtZX0sICN7c3R5bGUudmFsdWV9LCBcIlwiKWBcbiAgICAgIGVuZFxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShuYW1lKVxuICAgIGAjQG5hdGl2ZS5yZW1vdmVQcm9wZXJ0eSgje25hbWV9KWBcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI0BuYXRpdmUuZ2V0UHJvcGVydHlWYWx1ZSgje25hbWV9KTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBgI0BuYXRpdmUuc2V0UHJvcGVydHkoI3tuYW1lfSwgI3t2YWx1ZS50b19zfSwgXCJcIilgXG4gIGVuZFxuXG4gIGRlZiBpbXBvcnRhbnQ/KG5hbWUpXG4gICAgYCNAbmF0aXZlLmdldFByb3BlcnR5UHJpb3JpdHkoI3tuYW1lfSkgPT0gXCJpbXBvcnRhbnRcImBcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAjQG5hdGl2ZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSAgPSAjQG5hdGl2ZS5pdGVtKGkpO1xuXG4gICAgICAgICN7eWllbGQgYG5hbWVgLCBzZWxmW2BuYW1lYF19XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhc19uYXRpdmUgOmxlbmd0aFxuICBhbGlhc19uYXRpdmUgOnRvX3MsIDpjc3NUZXh0XG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsIHZhbHVlID0gbmlsKVxuICAgIGlmIG5hbWUuZW5kX3dpdGg/ID89XG4gICAgICBzZWxmW25hbWVbMCAuLiAtMl1dID0gdmFsdWVcbiAgICBlbHNlXG4gICAgICBzZWxmW25hbWVdXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkNTUz4iLCI8Y2xhc3M6RGVjbGFyYXRpb24+Iiwic2VsZiIsImluY2x1ZGUiLCJCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyIiwiQnJvd3NlciIsIkVudW1lcmFibGUiLCJydWxlIiwiQG5hdGl2ZSIsIlJ1bGUiLCJuZXciLCJhc3NpZ24iLCJkYXRhIiwiZWFjaCIsImJsb2NrIGluIGFzc2lnbiIsIm5hbWUiLCJ2YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gYXNzaWduIiwiW109IiwicmVwbGFjZSIsInN0cmluZyIsImFwcGx5IiwiUGFnZ2lvOjpDU1M6OkRlZmluaXRpb24iLCJQYWdnaW86OkNTUyIsIlBhZ2dpbyIsImJsb2NrIiwidG9fcHJvYyIsImJsb2NrIGluIGFwcGx5Iiwic3R5bGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGFwcGx5IiwiaW1wb3J0YW50IiwiZGVsZXRlIiwiW10iLCJ0b19zIiwiaW1wb3J0YW50PyIsImJsb2NrX2dpdmVuPyIsImVu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QUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFDRSxLQUE2QnNCLGVBQTdCO1lBQUEsT0FBT2pDLElBQUFrQyxVQUFBQSxDQUFTLE1BQVRBO1VBQVA7O0FBR0p2QiwrQkFBZ0NMLGNBQU9LO0FBQ3ZDQSxvQkFBcUJMLGNBQU9LOztBQUU1QkEsUUFBVSxvQkFBT0EsSUFBUCxFQUFjWCxJQUFJOEIsT0FBQUEsQ0FBRW5CLElBQUZtQixDQUFsQjtBQUNWbkI7QUFDQUE7VUFFSUEsT0FBQVg7UUFYRlcsQ0FBQUEsR0FBQUE7UUFjQVgsSUFBQW1DLGNBQUFBLENBQWEsUUFBYkE7UUFDQW5DLElBQUFtQyxjQUFBQSxDQUFhLE1BQWIsRUFBb0IsU0FBcEJBO1FBRUFwQyxPQUFBcUMsOEJBQUFBLDBCQUFtQnZCLElBQUQsRUFBT0MsS0FBekJzQjtBQUFBQSxVQUFBQTs7O1VBQXlCLDJCQUFRO1VBQy9CLElBQUEsUUFBR3ZCLElBQUl3QixjQUFBQSxDQUFXRCxHQUFYQyxDQUFQLENBQUE7WUFDRUQsT0FBSXBCLE1BQUFBLENBQUNILElBQUlpQixPQUFBQSxDQUFDLE9BQUFRLENBQUEsRUFBS0MsRUFBTCxRQUFEVCxDQUFULEVBQXNCaEIsS0FBbEJFLENBQUFBLEVBQUFBLE1BQUpoQixJQUFJZ0IsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7VUFETjtZQUdFb0IsT0FBQXBDLElBQUk4QixPQUFBQSxDQUFDakIsSUFBRGlCO1VBSE47UUFERk0sQ0FBQUEsSUFBQUE7TUF2RUZyQyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUZnQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzQxNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZm9jdXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEZvY3VzIDwgVUlcbiAgaGFuZGxlcyAnYmx1cicsICdmb2N1cycsICdmb2N1c2luJywgJ2ZvY3Vzb3V0J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuRm9jdXMnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBVSTo6RGVmaW5pdGlvblxuICAgIGRlZiB2aWV3PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS52aWV3ID0gI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9YFxuICAgIGVuZFxuXG4gICAgZGVmIHJlbGF0ZWQ9KGVsZW0pXG4gICAgICBgI0BuYXRpdmUucmVsYXRlZFRhcmdldCA9ICN7TmF0aXZlLmNvbnZlcnQoZWxlbSl9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IEZvY3VzRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJGb2N1c0V2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEZvY3VzRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2MudmlldyB8fCB3aW5kb3csIDAsIGRlc2MucmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGRlZiByZWxhdGVkXG4gICAgRE9NKGAjQG5hdGl2ZS5yZWxhdGVkVGFyZ2V0YClcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6Rm9jdXM+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsInZpZXc9IiwidmFsdWUiLCJAbmF0aXZlIiwiTmF0aXZlIiwiY29udmVydCIsInJlbGF0ZWQ9IiwiZWxlbSIsIlVJOjpEZWZpbml0aW9uIiwiVUkiLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsInJlbGF0ZWQiLCJET00iXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixNQUFSLEVBQWdCQSxPQUFoQixFQUF5QkEsU0FBekIsRUFBb0NBLFVBQXBDRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsaUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGFBQVhFO1FBRFRGLENBQUFBLEdBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxxQkFBQUEsK0JBQVVDLEtBQVZEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixRQUFVRyxZQUFNQyxTQUFBQSxDQUFTSCxLQUFURztVQUQzQkosQ0FBQUEsR0FBQUE7VUFJQUQsT0FBQU0sd0JBQUFBLGtDQUFhQyxJQUFiRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0csaUJBQW1CRixZQUFNQyxTQUFBQSxDQUFTRSxJQUFURjtVQURwQ0MsQ0FBQUEsR0FBQUE7UUFMRk4sR0FBQUEsV0FBQUEsRUFBbUJRLElBQUFDLFFBQUFELGVBQW5CUjtRQVVBLElBQUEsUUFjT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VXLE1BQUlmLElBQUplLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLGVBQWlCQyxJQUFLRCxFQUFJRSxJQUFLRjtZQURsQ0EsQ0FBQUEsR0FBQUE7VUFERixPQUlBLElBQUEsUUFBTVosYUFBT0MsY0FBQUEsQ0FBV0wsY0FBWEssQ0FBYixDQUFBO1lBQ0VXLE1BQUlmLElBQUplLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBOztBQUVKQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7WUFQSUEsQ0FBQUEsR0FBQUE7VUFERjtRQUpBO1FBZ0JBaEIsT0FBQW1CLHVCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFsQixJQUFBbUIsS0FBQUEsQ0FBTVgsY0FBT1UsY0FBYkM7UUFERkQsQ0FBQUEsR0FBQUE7TUFqQ0ZuQixHQUFBQSxXQUFBQSxFQUFjZSxRQUFkZjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzQ4OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY3NzL3J1bGUvc3R5bGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBDU1M7IGNsYXNzIFJ1bGVcblxuY2xhc3MgU3R5bGUgPCBSdWxlXG4gIGFsaWFzX25hdGl2ZSA6c2VsZWN0b3IsIDpzZWxlY3RvclRleHRcbiAgYWxpYXNfbmF0aXZlIDppZCwgOnNlbGVjdG9yVGV4dFxuXG4gIGRlZiBkZWNsYXJhdGlvblxuICAgIERlY2xhcmF0aW9uLm5ldyhgI0BuYXRpdmUuc3R5bGVgKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcoKmFyZ3MsICZibG9jaylcbiAgICBkZWNsYXJhdGlvbi5fX3NlbmRfXygqYXJncywgJmJsb2NrKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkNTUz4iLCI8Y2xhc3M6UnVsZT4iLCI8Y2xhc3M6U3R5bGU+Iiwic2VsZiIsImFsaWFzX25hdGl2ZSIsImRlY2xhcmF0aW9uIiwiRGVjbGFyYXRpb24iLCJuZXciLCJAbmF0aXZlIiwibWV0aG9kX21pc3NpbmciLCJfX3NlbmRfXyIsImFyZ3MiLCJibG9jayIsInRvX3Byb2MiLCJSdWxlIl0sIm1hcHBpbmdzIjoiQUFBQUEseUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxjQUFBQSxDQUFhLFVBQWIsRUFBd0IsY0FBeEJBO1VBQ0FELElBQUFDLGNBQUFBLENBQWEsSUFBYixFQUFrQixjQUFsQkE7O0FBRUFDLFVBQUFBLDJCQUFBQSx1QkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFDLGlCQUFXQyxLQUFBQSxDQUFPQyxjQUFPSCxNQUFkRTtVQURiRixDQUFBQSxHQUFBQTtVQUlBSCxPQUFBTyw4QkFBQUEsMEJBVkYsRUFVRUE7QUFBQUEsWUFBQUE7O1lBQUFBOzs7WUFWRjtZQVVxQjtZQUNqQkEsT0FBV0MsTUFBWFAsSUFBQUUsYUFBQUEsQ0FBQUEsQ0FBV0ssWUFBQUEsRUFBVSxNQUFDQyxJQUFELENBQVZELEVBQWtCRSxLQUFEQyxTQUFBQSxDQUFBQSxDQUFqQkg7VUFEYkQsQ0FBQUEsSUFBQUE7UUFSRlAsR0FBQUEsV0FBQUEsRUFBY1ksVUFBZFo7TUFGNEJELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzM1MzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2FuaW1hdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQW5pbWF0aW9uIDwgRXZlbnRcbiAgaGFuZGxlcyAnYW5pbWF0aW9uZW5kJywgJ2FuaW1hdGlvbml0ZXJhdGlvbicsICdhbmltYXRpb25zdGFydCdcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkFuaW1hdGlvbidcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgYW5pbWF0aW9uPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5hbmltYXRpb25OYW1lID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgZWxhcHNlZD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZWxhcHNlZFRpbWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBBbmltYXRpb25FdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkFuaW1hdGlvbkV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEFuaW1hdGlvbkV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLmFuaW1hdGlvbk5hbWUsIGRlc2MuZWxhcHNlZFRpbWUpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOm5hbWUsIDphbmltYXRpb25OYW1lXG4gIGFsaWFzX25hdGl2ZSA6ZWxhcHNlZCwgOmVsYXBzZWRUaW1lXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6QW5pbWF0aW9uPiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJhbmltYXRpb249IiwidmFsdWUiLCJAbmF0aXZlIiwiZWxhcHNlZD0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLGNBQVIsRUFBd0JBLG9CQUF4QixFQUE4Q0EsZ0JBQTlDRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEscUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGlCQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsMEJBQUFBLG9DQUFlQyxLQUFmRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsaUJBQW1CQztVQUQ5QkQsQ0FBQUEsR0FBQUE7VUFJQUQsT0FBQUksd0JBQUFBLGtDQUFhRixLQUFiRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsZUFBaUJGO1VBRDVCRSxDQUFBQSxHQUFBQTtRQUxGSixHQUFBQSxXQUFBQSxFQUFtQkssZ0JBQW5CTDtRQVVBLElBQUEsUUFjT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VPLE1BQUlYLElBQUpXLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLG1CQUFxQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEdENBLENBQUFBLEdBQUFBO1VBREYsT0FJQSxJQUFBLFFBQU1SLGFBQU9DLGNBQUFBLENBQVdMLGNBQVhLLENBQWIsQ0FBQTtZQUNFTyxNQUFJWCxJQUFKVyxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUElBLENBQUFBLEdBQUFBO1VBREY7UUFKQTtRQWdCQVgsSUFBQWMsY0FBQUEsQ0FBYSxNQUFiLEVBQW9CLGVBQXBCQTtRQUNBZixPQUFBQyxJQUFBYyxjQUFBQSxDQUFhLFNBQWIsRUFBdUIsYUFBdkJBO01BbENGZixHQUFBQSxXQUFBQSxFQUFrQmdCLFdBQWxCaEI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzM2MDgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2hlbHBlcnMnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50J1xuXG5jbGFzcyBQYWdnaW9cblxuY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0XG4gIGF0dHJfcmVhZGVyIDp2ZXJzaW9uXG5cbiAgZGVmIGluaXRpYWxpemUodmVyc2lvbiA9IDUsIGRlZmVyOiBmYWxzZSwgJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgIEB2ZXJzaW9uID0gdmVyc2lvblxuICAgIEByb290cyAgID0gW11cbiAgICBAY3VycmVudCA9IG5pbFxuXG4gICAgQGJsb2NrID0gYmxvY2tcblxuICAgIGJ1aWxkISB1bmxlc3MgZGVmZXJcbiAgZW5kXG5cbiAgZGVmIDw8KHdoYXQpXG4gICAgKEBjdXJyZW50IHx8IEByb290cykgPDwgd2hhdFxuICBlbmRcblxuICBkZWYgYnVpbGQhKGZvcmNlX2NhbGw6IGZhbHNlKVxuICAgIGlmICFmb3JjZV9jYWxsICYmIEBibG9jay5hcml0eSA9PSAwXG4gICAgICBpbnN0YW5jZV9leGVjKCZAYmxvY2spXG4gICAgZWxzZVxuICAgICAgQGJsb2NrLmNhbGwoc2VsZilcbiAgICBlbmRcbiAgICBAYmxvY2sgPSBuaWxcbiAgZW5kXG5cbiAgZGVmIHJvb3QhXG4gICAgQHJvb3RzLmZpcnN0XG4gIGVuZFxuXG4gIGRlZiByb290cyFcbiAgICBAcm9vdHNcbiAgZW5kXG5cbiAgZGVmIGVsZW1lbnQhXG4gICAgQGN1cnJlbnRcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZCEoZWxlbWVudCA9IG5pbCwgJmJsb2NrKVxuICAgIG9sZCwgQGN1cnJlbnQgPSBAY3VycmVudCwgZWxlbWVudFxuXG4gICAgcmVzdWx0ID0gYmxvY2suY2FsbChzZWxmKVxuXG4gICAgaWYgOjpTdHJpbmcgPT09IHJlc3VsdFxuICAgICAgQGN1cnJlbnQuaW5zdGFuY2VfZXZhbCB7IEBpbm5lcl9odG1sID0gcmVzdWx0IH1cbiAgICBlbmRcblxuICAgIEBjdXJyZW50ID0gb2xkXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICBAcm9vdHMuZWFjaCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0ZXh0KCpmcmFnbWVudHMsICZibG9jaylcbiAgICBmcmFnbWVudHMgPDwgeWllbGQgaWYgYmxvY2tcbiAgICBmcmFnbWVudHMuZWFjaCB7IHxmcmFnbWVudHwgc2VsZiA8PCBmcmFnbWVudCB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIGlmIG5hbWUudG9fcy5lbmRfd2l0aD8gPyFcbiAgICAgIHJldHVybiBzdXBlclxuICAgIGVuZFxuXG4gICAgdW5sZXNzIGFyZ3MuZW1wdHk/IHx8IDo6SGFzaCA9PT0gYXJncy5maXJzdFxuICAgICAgY29udGVudCA9IDo6UGFnZ2lvOjpVdGlscy5oZXJlZG9jKGFyZ3Muc2hpZnQudG9fcylcbiAgICBlbmRcblxuICAgIGVsZW1lbnQgPSBFbGVtZW50Lm5ldyhzZWxmLCBuYW1lLCAqYXJncylcbiAgICBlbGVtZW50IDw8IGNvbnRlbnQgaWYgY29udGVudFxuXG4gICAgaWYgYmxvY2tcbiAgICAgIHBhcmVudCAgID0gQGN1cnJlbnRcbiAgICAgIEBjdXJyZW50ID0gZWxlbWVudFxuICAgICAgcmVzdWx0ICAgPSBibG9jay5jYWxsKHNlbGYpXG4gICAgICBAY3VycmVudCA9IHBhcmVudFxuXG4gICAgICBpZiA6OlN0cmluZyA9PT0gcmVzdWx0XG4gICAgICAgIGVsZW1lbnQuaW5zdGFuY2VfZXZhbCB7IEBpbm5lcl9odG1sID0gcmVzdWx0IH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgc2VsZiA8PCBlbGVtZW50XG5cbiAgICBlbGVtZW50XG4gIGVuZFxuXG4gICMgU3VwcG9ydCBmb3IgY3VzdG9tIGVsZW1lbnRzXG4gIGFsaWFzIGUgbWV0aG9kX21pc3NpbmdcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIEByb290cy5lbXB0eT9cbiAgICAgIFwiIzxIVE1MKCNAdmVyc2lvbik+XCJcbiAgICBlbHNlXG4gICAgICBcIiM8SFRNTCgjQHZlcnNpb24pOiAje0Byb290cy5pbnNwZWN0WzEgLi4gLTJdfT5cIlxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIjUiLCJibG9jayIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIkB2ZXJzaW9uIiwidmVyc2lvbiIsIkByb290cyIsIkBjdXJyZW50IiwiQGJsb2NrIiwiZGVmZXIiLCJidWlsZCEiLCI8PCIsIndoYXQiLCIkcmV0X29yXzEiLCIka3dhcmdzIiwiZm9yY2VfY2FsbCIsImFyaXR5IiwiMCIsImluc3RhbmNlX2V4ZWMiLCJ0b19wcm9jIiwiY2FsbCIsInJvb3QhIiwiZmlyc3QiLCJyb290cyEiLCJlbGVtZW50ISIsImV4dGVuZCEiLCJlbGVtZW50Iiwib2xkIiwicmVzdWx0IiwiU3RyaW5nIiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIGluIGV4dGVuZCEiLCJibG9jayAoMiBsZXZlbHMpIGluIGV4dGVuZCEiLCJAaW5uZXJfaHRtbCIsImVhY2giLCJ0ZXh0IiwiZnJhZ21lbnRzIiwiYmxvY2sgaW4gdGV4dCIsImZyYWdtZW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0ZXh0IiwibWV0aG9kX21pc3NpbmciLCJuYW1lIiwidG9fcyIsImVuZF93aXRoPyIsImFyZ3MiLCJlbXB0eT8iLCJIYXNoIiwiY29udGVudCIsIlBhZ2dpbzo6VXRpbHMiLCJQYWdnaW8iLCJoZXJlZG9jIiwic2hpZnQiLCJuZXciLCJFbGVtZW50IiwicGFyZW50IiwiYmxvY2sgaW4gbWV0aG9kX21pc3NpbmciLCJibG9jayAoMiBsZXZlbHMpIGluIG1ldGhvZF9taXNzaW5nIiwiaW5zcGVjdCIsIltdIiwiMSIsIi0yIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSw4QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFVQUMsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBRUFBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VILElBQUFJLGFBQUFBLENBQVksU0FBWkE7O0FBRUFDLE1BQUFBLDBCQUFBQSxzQkFsQkYsRUFrQmdCLEVBbEJoQixFQWtCRUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFsQkY7UUFBQTtRQUFBOztRQWtCaUIsd0RBQUEsK0JBQVVDOztRQUFHLGdDQUFBLDJCQUFPO1FBQ2pDLEtBQUEsUUFBd0RDLEtBQXhELENBQUE7VUFBQUMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NMLGdCQUF4Qkk7UUFBUjtRQUVBRSxlQUFXQztRQUNYQyxhQUFXO1FBQ1hDLGVBQVc7UUFFWEMsYUFBU1I7UUFFVCxJQUFBLFFBQWNTLEtBQWQsQ0FBQTtVQTNCSlgsT0FBQTtRQTJCSTtVQUFBQSxPQUFBTCxJQUFBaUIsV0FBQUEsQ0FBQUE7UUFBQTtNQVRGWixDQUFBQSxJQUFBQTs7QUFZQWEsTUFBQUEsa0JBQUFBLHdCQUFPQyxJQUFQRDtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQyxDQUFBLFFBQUFFLENBQUFBLFlBQUFO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QUFBQSxDQUFDLE9BQUFDLENBQUEsRUFBS0MsRUFBTCxRQUFERixDQUFwQyxDQUFBLEdBQThDRDtRQUhoRDtNQURGQSxDQUFBQSxHQUFBQTtJQTlGRjdELEdBQUFBLFdBQUFBLEVBQWFpRSxpQkFBYmpFO0VBRkFELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBYkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzc3OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2NvbW1lbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuY2xhc3MgQ29tbWVudCA8IENoYXJhY3RlckRhdGFcbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RE9NOjpDb21tZW50OiAje3ZhbHVlfT5cIlxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkNvbW1lbnQ+IiwiaW5zcGVjdCIsInNlbGYiLCJ2YWx1ZSIsIkNoYXJhY3RlckRhdGEiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7O1FBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUNBLGtCQUFELEdBQUEsQ0FBbUJDLElBQUFDLE9BQUFBLENBQUFBLENBQW5CLENBQUEsR0FBeUJGO1FBRDNCQSxDQUFBQSxHQUFBQTtNQURGRCxHQUFBQSxXQUFBQSxFQUFnQkksbUJBQWhCSjtJQUZnQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzgwNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvdXRpbHMucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcbiAgUHJvbWlzZSA9IGRlZmluZWQ/KFByb21pc2VWMikgPyBQcm9taXNlVjIgOiA6OlByb21pc2VcblxuICBTaXplICAgICA9IFN0cnVjdC5uZXcoOndpZHRoLCA6aGVpZ2h0KVxuICBQb3NpdGlvbiA9IFN0cnVjdC5uZXcoOngsIDp5KVxuXG4gICMge0Jyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXJ9IGlzIGEgc3BlY2lhbCBjYXNlIG9mIHtOYXRpdmU6OldyYXBwZXJ9LlxuICAjXG4gICMgV2hhdCB0aGlzIG1vZHVsZSBkb2VzIGlzIGl0IG1ha2VzIHN1cmUgdGhhdCB5b3VyIFJ1Ynkgb2JqZWN0c1xuICAjIGFyZSBtYXBwZWQgMToxIHRvIHlvdXIgSmF2YXNjcmlwdCBvYmplY3RzLiBTbyB0aGF0IGZvciBpbnN0YW5jZVxuICAjIHlvdXIgYCRkb2N1bWVudC5hdF9jc3MoJ2JvZHknKWAgaXMgYWx3YXlzIHRoZSBzYW1lIFJ1Ynkgb2JqZWN0LlxuICAjXG4gICMgWW91IGNhbiBvbmx5IHVzZSBpdCBpZiB5b3VyIGZpbmFsIGAubmV3YCBpcyBvZiB0aGUgc2lnbmF0dXJlXG4gICMgYC5uZXcobmF0aXZlKWAgYW5kIHlvdXIgbmF0aXZlIChwcm9iYWJseSBET00pIG9iamVjdCBwZXJzaXN0cyBhbmRcbiAgIyBkb2Vzbid0IG1pbmQgYXJiaXRyYXJ5IHByb3BlcnRpZXMuXG4gICNcbiAgIyBUaGUgcnVsZSBvZiB0aHVtYiBpczogaWYgaXQgZG9lcyBvdmVybG9hZCBgI2luaXRpYWxpemVgJ3Mgc2lnbmF0dXJlXG4gICMgYW5kIG5vdCBgLm5ld2AncyAtIGl0IHdvbid0IHdvcmsuIFVzZSB7TmF0aXZlOjpXcmFwcGVyfSBpbiB0aGlzIGNhc2UuXG4gIG1vZHVsZSBOYXRpdmVDYWNoZWRXcmFwcGVyXG4gICAgZGVmIHNlbGYuaW5jbHVkZWQoa2xhc3MpXG4gICAgICBrbGFzcy5pbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuICAgICAga2xhc3MuZXh0ZW5kIE5hdGl2ZUNhY2hlZFdyYXBwZXJDbGFzc01ldGhvZHNcbiAgICBlbmRcblxuICAgIGRlZiByZXN0cmljdGVkP1xuICAgICAgISFAcmVzdHJpY3RlZFxuICAgIGVuZFxuXG4gICAgIyBDaGFuZ2UgYSBuYXRpdmUgcmVmZXJlbmNlIGFuZCBtYWtlIHN1cmUgdGhlIGNoYW5nZSBpcyByZWZsZWN0ZWQgb24gSlNcbiAgICAjIHNpZGUgYXMgd2VsbC4gVGhpcyBtZXRob2QgaXMgdXNlZCBieSBOb2RlI2luaXRpYWxpemVfY29weS4gUGxlYXNlIGRvbid0XG4gICAgIyB1c2UgdGhpcyBtZXRob2Qgb3V0c2lkZSBvZiB0aGUgY2xvbmluZyBzZW1hbnRpYy5cbiAgICBkZWYgc2V0X25hdGl2ZV9yZWZlcmVuY2UobmF0aXZlKVxuICAgICAgYCN7bmF0aXZlfS4kJG9wYWxfbmF0aXZlX2NhY2hlZCA9ICN7c2VsZn1gXG4gICAgICBAbmF0aXZlID0gbmF0aXZlXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBOYXRpdmVDYWNoZWRXcmFwcGVyQ2xhc3NNZXRob2RzXG4gICAgIyBDaGVjayBpZiB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byBhcmJpdHJhcnkgcHJvcGVydGllcyBvZiBhIChwcmVzdW1hYmx5KVxuICAgICMgbmF0aXZlIG9iamVjdC5cbiAgICBwcml2YXRlIGRlZiByZXN0cmljdGVkPyhuYXRpdmUpXG4gICAgICAleHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0eXBlb2YoI3tuYXRpdmV9LiQkdHJ5X3Jlc3RyaWN0ZWRfYWNjZXNzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT0gJ1NlY3VyaXR5RXJyb3InKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgbmV3KG5hdGl2ZSlcbiAgICAgICMgV2UgY2FuJ3QgYWNjZXNzIGFyYml0cmFyeSBwcm9wZXJ0aWVzIGlmIGFuIGVsZW1lbnQgaXMgcmVzdHJpY3RlZFxuICAgICAgIyBpLmUuIHRoZSBET00gZWxlbWVudCBpcyBhbiBpdGVtIHdlIGNhbid0IGZ1bGx5IGFjY2VzcyBkdWUgdG8gQ09SUy5cbiAgICAgIGlmIHJlc3RyaWN0ZWQ/KG5hdGl2ZSlcbiAgICAgICAgIyBMZXQncyB0cnkgdG8gYnlwYXNzIGFueSBmdXJ0aGVyIGluaXRpYWxpemVycy4uLiBtYXkgYmUgdWdseSwgYnV0XG4gICAgICAgICMgd29ya3MuXG4gICAgICAgIG9iaiA9IGFsbG9jYXRlXG4gICAgICAgIG9iai5pbnN0YW5jZV92YXJpYWJsZV9zZXQgOkBuYXRpdmUsIG5hdGl2ZVxuICAgICAgICBvYmouaW5zdGFuY2VfdmFyaWFibGVfc2V0IDpAcmVzdHJpY3RlZCwgdHJ1ZVxuICAgICAgICByZXR1cm4gb2JqXG4gICAgICBlbmRcblxuICAgICAgIyBJdCdzIG5vdCBhIG5hdGl2ZSBlbGVtZW50PyBXZWlyZCwgYmV0dGVyIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IgaWYgIW5hdGl2ZT8obmF0aXZlKVxuXG4gICAgICBpZiBkZWZpbmVkPyBgI3tuYXRpdmV9LiQkb3BhbF9uYXRpdmVfY2FjaGVkYFxuICAgICAgICBgI3tuYXRpdmV9LiQkb3BhbF9uYXRpdmVfY2FjaGVkYFxuICAgICAgZWxzZVxuICAgICAgICBgI3tuYXRpdmV9LiQkb3BhbF9uYXRpdmVfY2FjaGVkID0gI3tzdXBlcihuYXRpdmUpfWBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBPYmplY3RcbiAgIyBFbmNvZGUgYXMgVVJJLlxuICAjXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBGb3JtRGF0YS5lbmNvZGVfdXJpXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUge09iamVjdCN0b19zfSBlbmNvZGVkIGZvciB1c2FnZSBhcyBVUklcbiAgZGVmIGVuY29kZV91cmlcbiAgICB3YXJuIFwib3BhbC1icm93c2VyOiBPYmplY3QjZW5jb2RlX3VyaSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZvcm1EYXRhLmVuY29kZV91cmlcIlxuICAgIEZvcm1EYXRhLmVuY29kZV91cmkodG9fcylcbiAgZW5kXG5cbiAgIyBFbmNvZGUgYXMgVVJJIGNvbXBvbmVudC5cbiAgI1xuICAjIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgRm9ybURhdGEuZW5jb2RlXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUge09iamVjdCN0b19zfSBlbmNvZGVkIGZvciB1c2FnZSBhcyBVUkkgY29tcG9uZW50XG4gIGRlZiBlbmNvZGVfdXJpX2NvbXBvbmVudFxuICAgIHdhcm4gXCJvcGFsLWJyb3dzZXI6IE9iamVjdCNlbmNvZGVfdXJpX2NvbXBvbmVudCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZvcm1EYXRhLmVuY29kZVwiXG4gICAgRm9ybURhdGEuZW5jb2RlKHRvX3MpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICAjIEVuY29kZSBhcyBVUkkgY29tcG9uZW50LlxuICAjXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBGb3JtRGF0YS5lbmNvZGVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgZW5jb2RlZCBmb3IgdXNhZ2UgYXMgVVJJIGNvbXBvbmVudFxuICBkZWYgZW5jb2RlX3VyaV9jb21wb25lbnRcbiAgICB3YXJuIFwib3BhbC1icm93c2VyOiBTdHJpbmcjZW5jb2RlX3VyaV9jb21wb25lbnQgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGb3JtRGF0YS5lbmNvZGVcIlxuICAgIEZvcm1EYXRhLmVuY29kZShzZWxmKVxuICBlbmRcblxuICAjIEVuY29kZSBhcyBVUkkuXG4gICNcbiAgIyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEZvcm1EYXRhLmVuY29kZV91cmlcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgZW5jb2RlZCBhcyBVUklcbiAgZGVmIGVuY29kZV91cmlcbiAgICB3YXJuIFwib3BhbC1icm93c2VyOiBTdHJpbmcjZW5jb2RlX3VyaSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZvcm1EYXRhLmVuY29kZV91cmlcIlxuICAgIEZvcm1EYXRhLmVuY29kZV91cmkoc2VsZilcbiAgZW5kXG5cbiAgIyBEZWNvZGUgYXMgVVJJIGNvbXBvbmVudC5cbiAgI1xuICAjIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgRm9ybURhdGEuZGVjb2RlXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGRlY29kZWQgYXMgVVJJIGNvbXBvbmVudFxuICBkZWYgZGVjb2RlX3VyaV9jb21wb25lbnRcbiAgICB3YXJuIFwib3BhbC1icm93c2VyOiBTdHJpbmcjZGVjb2RlX3VyaV9jb21wb25lbnQgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGb3JtRGF0YS5kZWNvZGVcIlxuICAgIEZvcm1EYXRhLmRlY29kZShzZWxmKVxuICBlbmRcblxuICAjIERlY29kZSBhcyBVUkkuXG4gICNcbiAgIyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEZvcm1EYXRhLmRlY29kZV91cmlcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgZGVjb2RlZCBhcyBVUklcbiAgZGVmIGRlY29kZV91cmlcbiAgICB3YXJuIFwib3BhbC1icm93c2VyOiBTdHJpbmcjZGVjb2RlX3VyaSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZvcm1EYXRhLmRlY29kZV91cmlcIlxuICAgIEZvcm1EYXRhLmRlY29kZV91cmkoc2VsZilcbiAgZW5kXG5lbmRcblxuY2xhc3MgSGFzaFxuICAjIERlY29kZSBhbiBVUkwgZW5jb2RlZCBmb3JtIHRvIGEge0hhc2h9LlxuICAjXG4gICMgQHBhcmFtIHN0cmluZyBbU3RyaW5nXSB0aGUgVVJMIGVuY29kZWQgZm9ybVxuICAjXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBGb3JtRGF0YS5wYXJzZV9xdWVyeVxuICAjIEByZXR1cm4gW0hhc2hdXG4gIGRlZiBzZWxmLmRlY29kZV91cmkoc3RyaW5nKVxuICAgIHdhcm4gXCJvcGFsLWJyb3dzZXI6IEhhc2guZGVjb2RlX3VyaSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZvcm1EYXRhLnBhcnNlX3F1ZXJ5XCJcbiAgICBGb3JtRGF0YS5wYXJzZV9xdWVyeShzdHJpbmcpXG4gIGVuZFxuXG4gICMgRW5jb2RlIHRoZSBIYXNoIHRvIGFuIFVSTCBmb3JtLlxuICAjXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBGb3JtRGF0YS5idWlsZF9xdWVyeVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIFVSTCBlbmNvZGVkIGZvcm1cbiAgZGVmIGVuY29kZV91cmlcbiAgICB3YXJuIFwib3BhbC1icm93c2VyOiBIYXNoI2VuY29kZV91cmkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGb3JtRGF0YS5idWlsZF9xdWVyeVwiXG4gICAgRm9ybURhdGEuYnVpbGRfcXVlcnkoc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIlByb21pc2VWMiIsIlByb21pc2UiLCJTdHJ1Y3QiLCJuZXciLCI8bW9kdWxlOk5hdGl2ZUNhY2hlZFdyYXBwZXI+IiwiaW5jbHVkZWQiLCJzZWxmIiwia2xhc3MiLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwiZXh0ZW5kIiwiTmF0aXZlQ2FjaGVkV3JhcHBlckNsYXNzTWV0aG9kcyIsInJlc3RyaWN0ZWQ/IiwiQHJlc3RyaWN0ZWQiLCIhIiwic2V0X25hdGl2ZV9yZWZlcmVuY2UiLCJuYXRpdmUkIiwiQG5hdGl2ZSIsIjxtb2R1bGU6TmF0aXZlQ2FjaGVkV3JhcHBlckNsYXNzTWV0aG9kcz4iLCJwcml2YXRlIiwib2JqIiwiYWxsb2NhdGUiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJuYXRpdmU/IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiPGNsYXNzOk9iamVjdD4iLCJlbmNvZGVfdXJpIiwid2FybiIsIkZvcm1EYXRhIiwidG9fcyIsImVuY29kZV91cmlfY29tcG9uZW50IiwiZW5jb2RlIiwiPGNsYXNzOlN0cmluZz4iLCJkZWNvZGVfdXJpX2NvbXBvbmVudCIsImRlY29kZSIsImRlY29kZV91cmkiLCI8Y2xhc3M6SGFzaD4iLCJzdHJpbmciLCJwYXJzZV9xdWVyeSIsImJ1aWxkX3F1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0UsbUNBQVUsQ0FBQSxRQUFBLENBQUEsb0NBQUEsb0JBQUEsQ0FBQSxHQUFBLENBQXNCQyxlQUF0QixJQUFBLENBQWtDQyxjQUFsQyxDQUFBLENBQVY7SUFFQSxnQ0FBV0MsWUFBTUMsS0FBQUEsQ0FBSyxPQUFYLEVBQW1CLFFBQWJBLENBQWpCO0lBQ0Esb0NBQVdELFlBQU1DLEtBQUFBLENBQUssR0FBWCxFQUFlLEdBQVRBLENBQWpCO0lBY0FDO0lBQUFBOztNQUFBQTs7O01BQ0VDLE1BQUlDLElBQUpELGVBQUFBLG9CQUFrQkUsS0FBbEJGO0FBQUFBOztRQUNFRSxLQUFLQyxTQUFBQSxDQUFTQyxJQUFBQyxZQUFBRCxZQUFURDtRQUNMSCxPQUFBRSxLQUFLSSxRQUFBQSxDQUFRQyxxQ0FBUkQ7TUFGUE4sQ0FBQUEsR0FBQUE7O0FBS0FRLE1BQUFBLDJCQUFBQSxnREFBQUE7QUFBQUEsUUFBQUE7QUFBQUE7O1FBQ0VBLE9BQUVDLGVBQURDLE1BQUFBLENBQUFBLENBQURBLE1BQUFBLENBQUFBO01BREZGLENBQUFBLEdBQUFBO01BT0FULE9BQUFZLG9DQUFBQSxnQ0FBeUJDLE9BQXpCRDtBQUFBQSxRQUFBQTs7O1FBQ0tDLE9BQU9ELHdCQUEwQlY7UUFDcENVLE9BQUFFLENBQUFBLGlCQUFVRCxPQUFWQztNQUZGRixDQUFBQSxHQUFBQTtJQWJG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RlZILENBQUFBLEdBQUFBO0lBU0FDLE9BQUFWLDBCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFdEIsSUFBQXVCLE1BQUFBLENBQUtELDhFQUFMQztNQUNBRCxPQUFBRSxjQUFRVyxhQUFBQSxDQUFhbkMsSUFBYm1DO0lBRlZiLENBQUFBLEdBQUFBO0VBaEJGVSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQXJJQXhDOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzk3MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvbW91c2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIE1vdXNlIDwgVUlcbiAgaGFuZGxlcyAnY2xpY2snLCAnY29udGV4dG1lbnUnLCAnZGJsY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNlZW50ZXInLFxuICAgICAgICAgICdtb3VzZWxlYXZlJywgJ21vdXNlbW92ZScsICdtb3VzZW91dCcsICdtb3VzZW92ZXInLCAnbW91c2V1cCcsXG4gICAgICAgICAgJ3Nob3cnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIG5vdCAkJFs6TW91c2VFdmVudF0ubmlsP1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgVUk6OkRlZmluaXRpb25cbiAgICBjbGFzcyBDbGllbnRcbiAgICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLmNsaWVudFggPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgeT0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5jbGllbnRZID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNsYXNzIExheWVyXG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5sYXllclggPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgeT0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5sYXllclkgPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY2xhc3MgT2Zmc2V0XG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5vZmZzZXRYID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUub2Zmc2V0WT0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNsYXNzIFBhZ2VcbiAgICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnBhZ2VYID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUucGFnZVkgPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY2xhc3MgU2NyZWVuXG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5zY3JlZW5YID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUuc2NyZWVuWSA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjbGFzcyBBbmNlc3RvclxuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgZGVmIHg9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUueCA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnkgPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHg9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnNjcmVlblggPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zY3JlZW5ZID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgYWx0IVxuICAgICAgYCNAbmF0aXZlLmFsdEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgY3RybCFcbiAgICAgIGAjQG5hdGl2ZS5jdHJsS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBtZXRhIVxuICAgICAgYCNAbmF0aXZlLm1ldGFLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGJ1dHRvbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYnV0dG9uID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgY2xpZW50XG4gICAgICBDbGllbnQubmV3KEBuYXRpdmUpXG4gICAgZW5kXG5cbiAgICBkZWYgbGF5ZXJcbiAgICAgIExheWVyLm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIG9mZnNldFxuICAgICAgT2Zmc2V0Lm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIHBhZ2VcbiAgICAgIFBhZ2UubmV3KEBuYXRpdmUpXG4gICAgZW5kXG5cbiAgICBkZWYgc2NyZWVuXG4gICAgICBTY3JlZW4ubmV3KEBuYXRpdmUpXG4gICAgZW5kXG5cbiAgICBkZWYgYW5jZXN0b3JcbiAgICAgIEFuY2VzdG9yLm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIHJlbGF0ZWQ9KGVsZW0pXG4gICAgICBgI0BuYXRpdmUucmVsYXRlZFRhcmdldCA9ICN7TmF0aXZlLnRyeV9jb252ZXJ0KGVsZW0pfWBcbiAgICBlbmRcblxuICAgIGRlZiBmcm9tPShlbGVtKVxuICAgICAgYCNAbmF0aXZlLmZyb21FbGVtZW50ID0gI3tOYXRpdmUudHJ5X2NvbnZlcnQoZWxlbSl9YFxuICAgIGVuZFxuXG4gICAgZGVmIHRvPShlbGVtKVxuICAgICAgYCNAbmF0aXZlLnRvRWxlbWVudCA9ICN7TmF0aXZlLnRyeV9jb252ZXJ0KGVsZW0pfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBNb3VzZUV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY3JlYXRlJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRNb3VzZUV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLnZpZXcgfHwgd2luZG93LCBkZXNjLmRldGFpbCB8fCAwLFxuICAgICAgICAgICAgICBkZXNjLnNjcmVlblggfHwgMCwgZGVzYy5zY3JlZW5ZIHx8IDAsXG4gICAgICAgICAgICAgIGRlc2MuY2xpZW50WCB8fCAwLCBkZXNjLmNsaWVudFkgfHwgMCxcbiAgICAgICAgICAgICAgZGVzYy5jdHJsS2V5IHx8IGZhbHNlLCBkZXNjLmFsdEtleSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgZGVzYy5zaGlmdEtleSB8fCBmYWxzZSwgZGVzYy5tZXRhS2V5IHx8IGZhbHNlLFxuICAgICAgICAgICAgICBkZXNjLmJ1dHRvbiB8fCAwLCBkZXNjLnJlbGF0ZWRUYXJnZXQgfHwgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6YWx0PywgOmFsdEtleVxuICBhbGlhc19uYXRpdmUgOmN0cmw/LCA6Y3RybEtleVxuICBhbGlhc19uYXRpdmUgOm1ldGE/LCA6bWV0YUtleVxuICBhbGlhc19uYXRpdmUgOnNoaWZ0PywgOnNoaWZ0S2V5XG4gIGFsaWFzX25hdGl2ZSA6YnV0dG9uXG5cbiAgZGVmIGNsaWVudFxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUuY2xpZW50WGAsIGAjQG5hdGl2ZS5jbGllbnRZYClcbiAgZW5kXG5cbiAgZGVmIGxheWVyXG4gICAgUG9zaXRpb24ubmV3KGAjQG5hdGl2ZS5sYXllclhgLCBgI0BuYXRpdmUubGF5ZXJZYCkgdW5sZXNzIGAjQG5hdGl2ZS5sYXllclggPT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIG9mZnNldFxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUub2Zmc2V0WGAsIGAjQG5hdGl2ZS5vZmZzZXRZYCkgdW5sZXNzIGAjQG5hdGl2ZS5vZmZzZXRYID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBwYWdlXG4gICAgUG9zaXRpb24ubmV3KGAjQG5hdGl2ZS5wYWdlWGAsIGAjQG5hdGl2ZS5wYWdlWWApIHVubGVzcyBgI0BuYXRpdmUucGFnZVggPT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIHNjcmVlblxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUuc2NyZWVuWGAsIGAjQG5hdGl2ZS5zY3JlZW5ZYCkgdW5sZXNzIGAjQG5hdGl2ZS5zY3JlZW5YID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBhbmNlc3RvclxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUueGAsIGAjQG5hdGl2ZS55YCkgdW5sZXNzIGAjQG5hdGl2ZS54ID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiB4XG4gICAgc2NyZWVuLnhcbiAgZW5kXG5cbiAgZGVmIHlcbiAgICBzY3JlZW4ueVxuICBlbmRcblxuICBkZWYgcmVsYXRlZFxuICAgIERPTShgI0BuYXRpdmUucmVsYXRlZFRhcmdldGApIHVubGVzcyBgI0BuYXRpdmUucmVsYXRlZFRhcmdldCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgZnJvbVxuICAgIERPTShgI0BuYXRpdmUuZnJvbUVsZW1lbnRgKSB1bmxlc3MgYCNAbmF0aXZlLmZyb21FbGVtZW50ID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiB0b1xuICAgIERPTShgI0BuYXRpdmUudG9FbGVtZW50YCkgdW5sZXNzIGAjQG5hdGl2ZS50b0VsZW1lbnQgPT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIGNsaWNrP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2NsaWNrJ1xuICBlbmRcblxuICBkZWYgZG91YmxlX2NsaWNrP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2RibGNsaWNrJ1xuICBlbmRcblxuICBkZWYgZG93bj9cbiAgICBuYW1lLmRvd25jYXNlID09ICdtb3VzZWRvd24nXG4gIGVuZFxuXG4gIGRlZiBlbnRlcj9cbiAgICBuYW1lLmRvd25jYXNlID09ICdtb3VzZWVudGVyJ1xuICBlbmRcblxuICBkZWYgbGVhdmU/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2VsZWF2ZSdcbiAgZW5kXG5cbiAgZGVmIG1vdmU/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2Vtb3ZlJ1xuICBlbmRcblxuICBkZWYgb3V0P1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ21vdXNlb3V0J1xuICBlbmRcblxuICBkZWYgb3Zlcj9cbiAgICBuYW1lLmRvd25jYXNlID09ICdtb3VzZW92ZXInXG4gIGVuZFxuXG4gIGRlZiB1cD9cbiAgICBuYW1lLmRvd25jYXNlID09ICdtb3VzZXVwJ1xuICBlbmRcblxuICBkZWYgc2hvdz9cbiAgICBuYW1lLmRvd25jYXNlID09ICdzaG93J1xuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpNb3VzZT4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCIkJCIsIltdIiwibmlsPyIsIiEiLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCI8Y2xhc3M6Q2xpZW50PiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJ4PSIsInZhbHVlIiwiQG5hdGl2ZSIsInk9IiwiPGNsYXNzOkxheWVyPiIsIjxjbGFzczpPZmZzZXQ+IiwiPGNsYXNzOlBhZ2U+IiwiPGNsYXNzOlNjcmVlbj4iLCI8Y2xhc3M6QW5jZXN0b3I+IiwiYWx0ISIsImN0cmwhIiwibWV0YSEiLCJidXR0b249IiwiY2xpZW50IiwiQ2xpZW50IiwibmV3IiwibGF5ZXIiLCJMYXllciIsIm9mZnNldCIsIk9mZnNldCIsInBhZ2UiLCJQYWdlIiwic2NyZWVuIiwiU2NyZWVuIiwiYW5jZXN0b3IiLCJBbmNlc3RvciIsInJlbGF0ZWQ9IiwiZWxlbSIsInRyeV9jb252ZXJ0IiwiZnJvbT0iLCJ0bz0iLCJVSTo6RGVmaW5pdGlvbiIsIlVJIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiUG9zaXRpb24iLCJ4IiwieSIsInJlbGF0ZWQiLCJET00iLCJmcm9tIiwidG8iLCJjbGljaz8iLCJkb3duY2FzZSIsIj09IiwiZG91YmxlX2NsaWNrPyIsImRvd24/IiwiZW50ZXI/IiwibGVhdmU/IiwibW92ZT8iLCJvdXQ/Iiwib3Zlcj8iLCJ1cD8iLCJzaG93PyJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLE9BQVIsRUFBaUJBLGFBQWpCLEVBQWdDQSxVQUFoQyxFQUE0Q0EsV0FBNUMsRUFBeURBLFlBQXpELEVBQ1FBLFlBRFIsRUFDc0JBLFdBRHRCLEVBQ21DQSxVQURuQyxFQUMrQ0EsV0FE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QSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHSSxZQUFISjtRQURoQkksQ0FBQUEsR0FBQUE7O0FBSUFDLFFBQUFBLHFCQUFBQSw2QkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFqRSxJQUFBZ0QsTUFBQUEsQ0FBQUEsQ0FBSVcsVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR0ssV0FBSEw7UUFEaEJLLENBQUFBLEdBQUFBOztBQUlBQyxRQUFBQSxvQkFBQUEsNEJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBbEUsSUFBQWdELE1BQUFBLENBQUFBLENBQUlXLFVBQUFBLENBQUFBLENBQVVDLE9BQUFBLENBQUdNLFVBQUhOO1FBRGhCTSxDQUFBQSxHQUFBQTs7QUFJQUMsUUFBQUEscUJBQUFBLDZCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQW5FLElBQUFnRCxNQUFBQSxDQUFBQSxDQUFJVyxVQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHTyxXQUFIUDtRQURoQk8sQ0FBQUEsR0FBQUE7O0FBSUFDLFFBQUFBLG1CQUFBQSwyQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFwRSxJQUFBZ0QsTUFBQUEsQ0FBQUEsQ0FBSVcsVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR1EsU0FBSFI7UUFEaEJRLENBQUFBLEdBQUFBO1FBSUFyRSxPQUFBc0UscUJBQUFBLDZCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQXJFLElBQUFnRCxNQUFBQSxDQUFBQSxDQUFJVyxVQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHUyxNQUFIVDtRQURoQlMsQ0FBQUEsR0FBQUE7TUExUEZ0RSxHQUFBQSxXQUFBQSxFQUFjNkMsUUFBZDdDO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0NDA2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9qc29uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBKU09OXG4gIGNsYXNzIEpTT05FcnJvciA8IFN0YW5kYXJkRXJyb3JcbiAgZW5kXG5cbiAgY2xhc3MgUGFyc2VyRXJyb3IgPCBKU09ORXJyb3JcbiAgZW5kXG5cbiAgJXh7XG4gICAgdmFyICRoYXNPd24gPSBPcGFsLmhhc093blByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gJHBhcnNlKHNvdXJjZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc291cmNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgI3tyYWlzZSBKU09OOjpQYXJzZXJFcnJvciwgYGUubWVzc2FnZWB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b19vcGFsKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YXIga2xhc3MsIGFyciwgaGFzaCwgaSwgaWksIGs7XG5cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgcmV0dXJuIG5pbDtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiBuaWw7XG5cbiAgICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgYXJyID0gI3tgb3B0aW9ucy5hcnJheV9jbGFzc2AubmV3fTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICN7YGFycmAucHVzaChgdG9fb3BhbCh2YWx1ZVtpXSwgb3B0aW9ucylgKX07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzaCA9ICN7YG9wdGlvbnMub2JqZWN0X2NsYXNzYC5uZXd9O1xuXG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKCRoYXNPd24uY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAje2BoYXNoYFtga2BdID0gYHRvX29wYWwodmFsdWVba10sIG9wdGlvbnMpYH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBhcnNlICYmIChrbGFzcyA9ICN7YGhhc2hgW0pTT04uY3JlYXRlX2lkXX0pICE9IG5pbCkge1xuICAgICAgICAgICAgICByZXR1cm4gI3s6Ok9iamVjdC5jb25zdF9nZXQoYGtsYXNzYCkuanNvbl9jcmVhdGUoYGhhc2hgKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhdHRyX2FjY2Vzc29yIDpjcmVhdGVfaWRcbiAgZW5kXG5cbiAgc2VsZi5jcmVhdGVfaWQgPSA6anNvbl9jbGFzc1xuXG4gIGRlZiBzZWxmLltdKHZhbHVlLCBvcHRpb25zID0ge30pXG4gICAgaWYgU3RyaW5nID09PSB2YWx1ZVxuICAgICAgcGFyc2UodmFsdWUsIG9wdGlvbnMpXG4gICAgZWxzZVxuICAgICAgZ2VuZXJhdGUodmFsdWUsIG9wdGlvbnMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBhcnNlKHNvdXJjZSwgb3B0aW9ucyA9IHt9KVxuICAgIGZyb21fb2JqZWN0KGAkcGFyc2Uoc291cmNlKWAsIG9wdGlvbnMubWVyZ2UocGFyc2U6IHRydWUpKVxuICBlbmRcblxuICBkZWYgc2VsZi5wYXJzZSEoc291cmNlLCBvcHRpb25zID0ge30pXG4gICAgcGFyc2Uoc291cmNlLCBvcHRpb25zKVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2FkKHNvdXJjZSwgb3B0aW9ucyA9IHt9KVxuICAgIGZyb21fb2JqZWN0KGAkcGFyc2Uoc291cmNlKWAsIG9wdGlvbnMpXG4gIGVuZFxuXG4gICMgUmF3IGpzIG9iamVjdCA9PiBvcGFsIG9iamVjdFxuICBkZWYgc2VsZi5mcm9tX29iamVjdChqc19vYmplY3QsIG9wdGlvbnMgPSB7fSlcbiAgICBvcHRpb25zWzpvYmplY3RfY2xhc3NdIHx8PSBIYXNoXG4gICAgb3B0aW9uc1s6YXJyYXlfY2xhc3NdICB8fD0gQXJyYXlcblxuICAgIGB0b19vcGFsKGpzX29iamVjdCwgb3B0aW9ucy4kJHNtYXApYFxuICBlbmRcblxuICBkZWYgc2VsZi5nZW5lcmF0ZShvYmosIG9wdGlvbnMgPSB7fSlcbiAgICBvYmoudG9fanNvbihvcHRpb25zKVxuICBlbmRcblxuICBkZWYgc2VsZi5kdW1wKG9iaiwgaW8gPSBuaWwsIGxpbWl0ID0gbmlsKVxuICAgIHN0cmluZyA9IGdlbmVyYXRlKG9iailcblxuICAgIGlmIGlvXG4gICAgICBpbyA9IGlvLnRvX2lvIGlmIGlvLnJlc3BvbmRzX3RvPyA6dG9faW9cbiAgICAgIGlvLndyaXRlIHN0cmluZ1xuXG4gICAgICBpb1xuICAgIGVsc2VcbiAgICAgIHN0cmluZ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBPYmplY3RcbiAgZGVmIHRvX2pzb25cbiAgICB0b19zLnRvX2pzb25cbiAgZW5kXG5lbmRcblxuIyBCVUc6IEVudW1lcmFibGUgbXVzdCBjb21lIGJlZm9yZSBBcnJheSwgb3RoZXJ3aXNlIGl0IG92ZXJyaWRlcyAjdG9fanNvblxuIyAgICAgIHRoaXMgaXMgZHVlIHRvIGhvdyBtb2R1bGVzIGFyZSBpbXBsZW1lbnRlZC5cbm1vZHVsZSBFbnVtZXJhYmxlXG4gIGRlZiB0b19qc29uXG4gICAgdG9fYS50b19qc29uXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEFycmF5XG4gIGRlZiB0b19qc29uXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAje3NlbGZ9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7YHNlbGZbaV1gLnRvX2pzb259KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsJykgKyAnXSc7XG4gICAgfVxuICBlbmRcbmVuZFxuXG5jbGFzcyBCb29sZWFuXG4gIGRlZiB0b19qc29uXG4gICAgYChzZWxmID09IHRydWUpID8gJ3RydWUnIDogJ2ZhbHNlJ2BcbiAgZW5kXG5lbmRcblxuY2xhc3MgSGFzaFxuICBkZWYgdG9fanNvblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goI3tga2V5YC50b19zLnRvX2pzb259ICsgJzonICsgI3tgdmFsdWVgLnRvX2pzb259KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICd7JyArIHJlc3VsdC5qb2luKCcsJykgKyAnfSc7XG4gICAgfVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOaWxDbGFzc1xuICBkZWYgdG9fanNvblxuICAgICdudWxsJ1xuICBlbmRcbmVuZFxuXG5jbGFzcyBOdW1lcmljXG4gIGRlZiB0b19qc29uXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gIGRlZiB0b19qc29uXG4gICAgYEpTT04uc3RyaW5naWZ5KHNlbGYpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBUaW1lXG4gIGRlZiB0b19qc29uXG4gICAgc3RyZnRpbWUoJyVGVCVUJXonKS50b19qc29uXG4gIGVuZFxuZW5kXG5cbmNsYXNzIERhdGVcbiAgZGVmIHRvX2pzb25cbiAgICB0b19zLnRvX2pzb25cbiAgZW5kXG5cbiAgZGVmIGFzX2pzb25cbiAgICB0b19zXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6SlNPTj4iLCI8Y2xhc3M6SlNPTkVycm9yPiIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6UGFyc2VyRXJyb3I+IiwiSlNPTkVycm9yIiwic2VsZiIsInJhaXNlIiwiSlNPTjo6UGFyc2VyRXJyb3IiLCJKU09OIiwibmV3IiwicHVzaCIsIltdPSIsIltdIiwiY3JlYXRlX2lkIiwiT2JqZWN0IiwiY29uc3RfZ2V0IiwianNvbl9jcmVhdGUiLCJhdHRyX2FjY2Vzc29yIiwiY3JlYXRlX2lkPSIsInZhbHVlIiwib3B0aW9ucyIsIlN0cmluZyIsInBhcnNlIiwiZ2VuZXJhdGUiLCJzb3VyY2UiLCJmcm9tX29iamVjdCIsIm1lcmdlIiwicGFyc2UhIiwibG9hZCIsImpzX29iamVjdCIsIiRyZXRfb3JfMSIsIkhhc2giLCJBcnJheSIsIm9iaiIsInRvX2pzb24iLCJkdW1wIiwiaW8iLCJsaW1pdCIsInN0cmluZyIsInJlc3BvbmRzX3RvPyIsInRvX2lvIiwid3JpdGUiLCI8Y2xhc3M6T2JqZWN0PiIsInRvX3MiLCI8bW9kdWxlOkVudW1lcmFibGU+IiwidG9fYSIsIjxjbGFzczpBcnJheT4iLCI8Y2xhc3M6Qm9vbGVhbj4iLCI8Y2xhc3M6SGFzaD4iLCI8Y2xhc3M6TmlsQ2xhc3M+IiwiPGNsYXNzOk51bWVyaWM+IiwiPGNsYXNzOlN0cmluZz4iLCI8Y2xhc3M6VGltZT4iLCJzdHJmdGltZSIsIjxjbGFzczpEYXRlPiIsImFzX2pzb24iXSwibWFwcGluZ3MiOiJBQUFBQSx1QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsT0FBQUEsV0FBQUEsRUFBa0JDLG1CQUFsQkQ7SUFHQUUsT0FBQUEsV0FBQUEsRUFBb0JDLGVBQXBCRDs7QUFJRkg7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFFBQVVLLElBQUFDLE9BQUFBLENBQU1DLElBQUFDLFVBQUFELGdCQUFOLEVBQTBCUCxTQUExQk0sQ0FBcUNOO0FBQy9DQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0JBQW9CQSxDQUFDQSxtQkFBREEsQ0FBcUJTLEtBQUFBLENBQUFBLENBQUtUOztBQUU5Q0E7QUFDQUEsY0FBZ0JBLENBQUNBLEdBQURBLENBQUtVLE1BQUFBLENBQU9WLDBCQUFQVSxDQUFvQ1Y7QUFDekRBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxtQkFBcUJBLENBQUNBLG9CQUFEQSxDQUFzQlMsS0FBQUEsQ0FBQUEsQ0FBS1Q7O0FBRWhEQTtBQUNBQTtBQUNBQSxnQkFBd0JXLE1BQUFBLENBQUVYLENBQVIsRUFBZUEsMEJBQVRXLENBQUFBLEVBQUFBLE1BQU5YLENBQUNBLElBQURBLENBQU1XLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLGtCQUFxQ1g7QUFDN0RBO0FBQ0FBOztBQUVBQSwyQ0FBNkNBLENBQUNBLElBQURBLENBQU1ZLE9BQUFBLENBQUNKLFVBQUlLLFdBQUFBLENBQUFBLENBQUxELENBQWlCWjtBQUNwRUEscUJB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QUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBdUJBQztFQUFBQTs7O0lBQ0VBLE9BQUFmLHVCQUFBQSxZQUNFZSxNQURGZixDQUFBQSxHQUFBQTtFQURGZSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQU1BQztFQUFBQTs7O0lBQ0VBLE9BQUFoQix1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxlQUFEQTtJQURGQSxDQUFBQSxHQUFBQTtFQURGZ0IsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFNQUM7RUFBQUE7OztJQUNFQSxPQUFBakIsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esb0JBQURBO0lBREZBLENBQUFBLEdBQUFBO0VBREZpQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQU1BQztFQUFBQTs7O0lBQ0VBLE9BQUFsQix1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBN0IsSUFBQWdELFVBQUFBLENBQVNuQixTQUFUbUIsQ0FBbUJuQixTQUFBQSxDQUFBQTtJQURyQkEsQ0FBQUEsR0FBQUE7RUFERmtCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBTUFyRCxPQUFBdUQ7RUFBQUE7Ozs7O0FBQ0VwQixJQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBN0IsSUFBQXNDLE1BQUFBLENBQUFBLENBQUlULFNBQUFBLENBQUFBO0lBRE5BLENBQUFBLEdBQUFBO0lBSUFvQixPQUFBQyx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBbEQsSUFBQXNDLE1BQUFBLENBQUFBO0lBREZZLENBQUFBLEdBQUFBO0VBTEZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBdk1BdkQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0Njg2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbmNsYXNzIEV2ZW50XG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0V2ZW50cy9DcmVhdGluZ19hbmRfdHJpZ2dlcmluZ19ldmVudHNcbiAgY2xhc3MgRGVmaW5pdGlvblxuICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAjIEBwcml2YXRlXG4gICAgZGVmIHNlbGYubmV3KCZibG9jaylcbiAgICAgIGRhdGEgPSBzdXBlcihgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH1gKVxuICAgICAgYmxvY2suY2FsbChkYXRhKSBpZiBibG9ja1xuXG4gICAgICBkYXRhLnRvX25cbiAgICBlbmRcblxuICAgICMgU2V0IHRoZSBldmVudCBhcyBidWJibGluZy5cbiAgICBkZWYgYnViYmxlcz0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYnViYmxlcyA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgIyBTZXQgdGhlIGV2ZW50IGFzIGNhbmNlbGFibGUuXG4gICAgZGVmIGNhbmNlbGFibGU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmNhbmNlbGFibGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIFRhcmdldFxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgc2VsZi5jb252ZXJ0ZXJzXG4gICAgICBAY29udmVydGVycyB8fD0gW11cbiAgICBlbmRcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgc2VsZi5yZWdpc3RlcigmYmxvY2spXG4gICAgICBjb252ZXJ0ZXJzIDw8IGJsb2NrXG4gICAgZW5kXG5cbiAgICAjIEBwcml2YXRlXG4gICAgZGVmIHNlbGYuY29udmVydCh2YWx1ZSlcbiAgICAgIHJldHVybiB2YWx1ZSB1bmxlc3MgbmF0aXZlPyh2YWx1ZSlcblxuICAgICAgY29udmVydGVycy5lYWNoIHt8YmxvY2t8XG4gICAgICAgIGlmIHJlc3VsdCA9IGJsb2NrLmNhbGwodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBlbmRcbiAgICAgIH1cblxuICAgICAgbmlsXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5pbmNsdWRlZChrbGFzcylcbiAgICAgIGtsYXNzLmluc3RhbmNlX2V2YWwge1xuICAgICAgICBkZWYgc2VsZi50YXJnZXQoJmJsb2NrKVxuICAgICAgICAgIEV2ZW50OjpUYXJnZXQucmVnaXN0ZXIoJmJsb2NrKVxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGNsYXNzIENhbGxiYWNrXG4gICAgICBhdHRyX3JlYWRlciA6dGFyZ2V0LCA6bmFtZSwgOnNlbGVjdG9yXG5cbiAgICAgICMgQHByaXZhdGVcbiAgICAgIGRlZiBpbml0aWFsaXplKHRhcmdldCwgbmFtZSwgc2VsZWN0b3IgPSBuaWwsICZibG9jaylcbiAgICAgICAgQHRhcmdldCAgID0gdGFyZ2V0XG4gICAgICAgIEBuYW1lICAgICA9IG5hbWVcbiAgICAgICAgQHNlbGVjdG9yID0gc2VsZWN0b3JcbiAgICAgICAgQGJsb2NrICAgID0gYmxvY2tcbiAgICAgIGVuZFxuXG4gICAgICAjIENhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIGdpdmVuIGV2ZW50LlxuICAgICAgI1xuICAgICAgIyBAcGFyYW0gZXZlbnQgW25hdGl2ZV0gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcbiAgICAgIGRlZiBjYWxsKGV2ZW50KVxuICAgICAgICB0b19wcm9jLmNhbGwoZXZlbnQpXG4gICAgICBlbmRcblxuICAgICAgIyBHZXQgdGhlIG5hdGl2ZSBmdW5jdGlvbiBsaW5rZWQgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgZGVmIHRvX3Byb2NcbiAgICAgICAgQHByb2MgfHw9IC0+IGV2ZW50IHtcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gc2VsZi50YXJnZXQubmF0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2ZW50ID0gRXZlbnQubmV3KGV2ZW50LCBzZWxmKVxuXG4gICAgICAgICAgdW5sZXNzIGV2ZW50LnN0b3BwZWQ/XG4gICAgICAgICAgICBAYmxvY2suY2FsbChldmVudCwgKmV2ZW50LmFyZ3VtZW50cylcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgICFldmVudC5wcmV2ZW50ZWQ/XG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICAjIEAhYXR0cmlidXRlIFtyXSBldmVudFxuICAgICAgIyBAcmV0dXJuIFtDbGFzc10gdGhlIGNsYXNzIGZvciB0aGUgZXZlbnRcbiAgICAgIGRlZiBldmVudFxuICAgICAgICBFdmVudC5jbGFzc19mb3IoQG5hbWUpXG4gICAgICBlbmRcblxuICAgICAgIyBTdG9wIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IGxpbmtlZCB0byB0aGUgY2FsbGJhY2suXG4gICAgICBkZWYgb2ZmXG4gICAgICAgIHRhcmdldC5vZmYoc2VsZilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY2xhc3MgRGVsZWdhdGVcbiAgICAgIGRlZiBpbml0aWFsaXplKHRhcmdldCwgbmFtZSwgcGFpcilcbiAgICAgICAgQHRhcmdldCA9IHRhcmdldFxuICAgICAgICBAbmFtZSAgID0gbmFtZVxuICAgICAgICBAcGFpciAgID0gcGFpclxuICAgICAgZW5kXG5cbiAgICAgICMgU3RvcCBsaXN0ZW5pbmcgZm9yIHRoZSBldmVudCBsaW5rZWQgdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgZGVmIG9mZlxuICAgICAgICBkZWxlZ2F0ZSA9IEB0YXJnZXQuZGVsZWdhdGVkW0BuYW1lXVxuICAgICAgICBkZWxlZ2F0ZS5sYXN0LmRlbGV0ZShAcGFpcilcblxuICAgICAgICBpZiBkZWxlZ2F0ZS5sYXN0LmVtcHR5P1xuICAgICAgICAgIGRlbGVnYXRlLmZpcnN0Lm9mZlxuICAgICAgICAgIGRlbGVnYXRlLmRlbGV0ZShAbmFtZSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIERlbGVnYXRlcyA9IFN0cnVjdC5uZXcoOmNhbGxiYWNrLCA6aGFuZGxlcnMpXG5cbiAgICAjIEBvdmVybG9hZCBvbihuYW1lLCAmYmxvY2spXG4gICAgI1xuICAgICMgICBTdGFydCBsaXN0ZW5pbmcgZm9yIGFuIGV2ZW50IG9uIHRoZSB0YXJnZXQuXG4gICAgI1xuICAgICMgICBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZVxuICAgICNcbiAgICAjICAgQHlpZWxkcGFyYW0gZXZlbnQgW0V2ZW50XSB0aGUgZXZlbnRcbiAgICAjXG4gICAgIyAgIEByZXR1cm4gW0NhbGxiYWNrXVxuICAgICNcbiAgICAjIEBvdmVybG9hZCBvbihuYW1lLCBzZWxlY3RvciwgJmJsb2NrKVxuICAgICNcbiAgICAjICAgU3RhcnQgbGlzdGVuaW5nIGZvciBhbiBldmVudCBvbiB0aGUgdGFyZ2V0IGNoaWxkcmVuLlxuICAgICNcbiAgICAjICAgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWVcbiAgICAjICAgQHBhcmFtIHNlbGVjdG9yIFtTdHJpbmddIHRoZSBDU1Mgc2VsZWN0b3IgdG8gdHJpZ2dlciB0aGUgZXZlbnQgb25cbiAgICAjXG4gICAgIyAgIEB5aWVsZHBhcmFtIGV2ZW50IFtFdmVudF0gdGhlIGV2ZW50XG4gICAgI1xuICAgICMgICBAcmV0dXJuIFtEZWxlZ2F0ZV1cbiAgICBkZWYgb24obmFtZSwgc2VsZWN0b3IgPSBuaWwsICZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBoYXMgYmVlbiBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIG5hbWUgPSBFdmVudC5uYW1lX2ZvcihuYW1lKVxuXG4gICAgICBpZiBzZWxlY3RvclxuICAgICAgICB1bmxlc3MgZGVsZWdhdGUgPSBkZWxlZ2F0ZWRbbmFtZV1cbiAgICAgICAgICBkZWxlZ2F0ZSA9IGRlbGVnYXRlZFtuYW1lXSA9IERlbGVnYXRlcy5uZXdcblxuICAgICAgICAgIGlmICV3W2JsdXIgZm9jdXNdLmluY2x1ZGU/KG5hbWUpXG4gICAgICAgICAgICBkZWxlZ2F0ZS5jYWxsYmFjayA9IG9uISBuYW1lIGRvIHxlfFxuICAgICAgICAgICAgICBkZWxlZ2F0ZShkZWxlZ2F0ZSwgZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGVnYXRlLmNhbGxiYWNrID0gb24gbmFtZSBkbyB8ZXxcbiAgICAgICAgICAgICAgZGVsZWdhdGUoZGVsZWdhdGUsIGUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHBhaXIgPSBbc2VsZWN0b3IsIGJsb2NrXVxuICAgICAgICAgIGRlbGVnYXRlLmhhbmRsZXJzID0gW3BhaXJdXG5cbiAgICAgICAgICBEZWxlZ2F0ZS5uZXcoc2VsZiwgbmFtZSwgcGFpcilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHBhaXIgPSBbc2VsZWN0b3IsIGJsb2NrXVxuICAgICAgICAgIGRlbGVnYXRlLmhhbmRsZXJzIDw8IHBhaXJcblxuICAgICAgICAgIERlbGVnYXRlLm5ldyhzZWxmLCBuYW1lLCBwYWlyKVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgY2FsbGJhY2sgPSBDYWxsYmFjay5uZXcoc2VsZiwgbmFtZSwgc2VsZWN0b3IsICZibG9jaylcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG5cbiAgICAgICAgYXR0YWNoKGNhbGxiYWNrKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIFN0YXJ0IGxpc3RlbmluZyBmb3IgYW4gZXZlbnQgaW4gdGhlIGNhcHR1cmluZyBwaGFzZS5cbiAgICAjXG4gICAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZVxuICAgICNcbiAgICAjIEB5aWVsZHBhcmFtIGV2ZW50IFtFdmVudF0gdGhlIGV2ZW50XG4gICAgI1xuICAgICMgQHJldHVybiBbQ2FsbGJhY2tdXG4gICAgZGVmIG9uIShuYW1lLCAmYmxvY2spXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgaGFzIGJlZW4gZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgICBuYW1lICAgICA9IEV2ZW50Lm5hbWVfZm9yKG5hbWUpXG4gICAgICBjYWxsYmFjayA9IENhbGxiYWNrLm5ldyhzZWxmLCBuYW1lLCAmYmxvY2spXG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjaylcblxuICAgICAgYXR0YWNoIShjYWxsYmFjaylcbiAgICBlbmRcblxuICAgIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5hZGRMaXN0ZW5lcidcbiAgICAgIGRlZiBhdHRhY2goY2FsbGJhY2spXG4gICAgICAgIGAjQG5hdGl2ZS5hZGRFdmVudExpc3RlbmVyKCN7Y2FsbGJhY2submFtZX0sICN7Y2FsbGJhY2sudG9fcHJvY30pYFxuXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICBlbmRcblxuICAgICAgZGVmIGF0dGFjaCEoY2FsbGJhY2spXG4gICAgICAgIGAjQG5hdGl2ZS5hZGRFdmVudExpc3RlbmVyKCN7Y2FsbGJhY2submFtZX0sICN7Y2FsbGJhY2sudG9fcHJvY30sIHRydWUpYFxuXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICBlbmRcbiAgICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuYXR0YWNoJ1xuICAgICAgZGVmIGF0dGFjaChjYWxsYmFjaylcbiAgICAgICAgaWYgY2FsbGJhY2suZXZlbnQgPT0gQ3VzdG9tXG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICBpZiAoISNAbmF0aXZlLiRjdXN0b20pIHtcbiAgICAgICAgICAgICAgI0BuYXRpdmUuJGN1c3RvbSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICNAbmF0aXZlLiRjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9ICNAbmF0aXZlLiRjYWxsYmFja3NbaV07XG5cbiAgICAgICAgICAgICAgICAgIGlmICgje2BjYWxsYmFja2AuZXZlbnQgPT0gQ3VzdG9tfSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gY2FsbGJhY2submFtZTtcblxuICAgICAgICAgICAgICAgICAgICAje2BjYWxsYmFja2AuY2FsbChgZXZlbnRgKX07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICNAbmF0aXZlLmF0dGFjaEV2ZW50KFwib25kYXRhYXZhaWxhYmxlXCIsICNAbmF0aXZlLiRjdXN0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGAjQG5hdGl2ZS5hdHRhY2hFdmVudChcIm9uXCIgKyAje2NhbGxiYWNrLm5hbWV9LCAje2NhbGxiYWNrLnRvX3Byb2N9KWBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgYXR0YWNoIShjYWxsYmFjaylcbiAgICAgICAgY2FzZSBjYWxsYmFjay5uYW1lXG4gICAgICAgIHdoZW4gOmJsdXJcbiAgICAgICAgICBgI0BuYXRpdmUuYXR0YWNoRXZlbnQoXCJvbmZvY3Vzb3V0XCIsICN7Y2FsbGJhY2sudG9fcHJvY30pYFxuXG4gICAgICAgIHdoZW4gOmZvY3VzXG4gICAgICAgICAgYCNAbmF0aXZlLmF0dGFjaEV2ZW50KFwib25mb2N1c2luXCIsICN7Y2FsbGJhY2sudG9fcHJvY30pYFxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3YXJuIFwiYXR0YWNoOiBjYXB0dXJlIGRvZXNuJ3Qgd29yayBvbiB0aGlzIGJyb3dzZXJcIlxuICAgICAgICAgIGF0dGFjaChjYWxsYmFjaylcbiAgICAgICAgZW5kXG5cbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICMgQHRvZG8gaW1wbGVtZW50IHBvbHlmaWxsXG4gICAgICAjIEBwcml2YXRlXG4gICAgICBkZWYgYXR0YWNoKCopXG4gICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgICAgIGVuZFxuXG4gICAgICAjIEB0b2RvIGltcGxlbWVudCBwb2x5ZmlsbFxuICAgICAgIyBAcHJpdmF0ZVxuICAgICAgZGVmIGF0dGFjaCEoKilcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIEBvdmVybG9hZCBvbmUobmFtZSwgJmJsb2NrKVxuICAgICNcbiAgICAjICAgU3RhcnQgbGlzdGVuaW5nIGZvciBhbiBldmVudCBvbiB0aGUgdGFyZ2V0LiBSZW1vdmUgdGhlIGV2ZW50IGFmdGVyIGZpcmluZ1xuICAgICMgICBzbyB0aGF0IGl0IGlzIGZpcmVkIGF0IG1vc3Qgb25jZS5cbiAgICAjXG4gICAgIyAgIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBldmVudCBuYW1lXG4gICAgI1xuICAgICMgICBAeWllbGRwYXJhbSBldmVudCBbRXZlbnRdIHRoZSBldmVudFxuICAgICNcbiAgICAjICAgQHJldHVybiBbQ2FsbGJhY2tdXG4gICAgI1xuICAgICMgQG92ZXJsb2FkIG9uZShuYW1lLCBzZWxlY3RvciwgJmJsb2NrKVxuICAgICNcbiAgICAjICAgU3RhcnQgbGlzdGVuaW5nIGZvciBhbiBldmVudCBvbiB0aGUgdGFyZ2V0IGNoaWxkcmVuLiBSZW1vdmUgdGhlIGV2ZW50IGFmdGVyXG4gICAgIyAgIGZpcmluZyBzbyB0aGF0IGl0IGlzIGZpcmVkIGF0IG1vc3Qgb25jZS5cbiAgICAjXG4gICAgIyAgIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBldmVudCBuYW1lXG4gICAgIyAgIEBwYXJhbSBzZWxlY3RvciBbU3RyaW5nXSB0aGUgQ1NTIHNlbGVjdG9yIHRvIHRyaWdnZXIgdGhlIGV2ZW50IG9uXG4gICAgI1xuICAgICMgICBAeWllbGRwYXJhbSBldmVudCBbRXZlbnRdIHRoZSBldmVudFxuICAgICNcbiAgICAjICAgQHJldHVybiBbRGVsZWdhdGVdXG4gICAgZGVmIG9uZSAobmFtZSwgc2VsZWN0b3IgPSBuaWwsICZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBoYXMgYmVlbiBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIGNiID0gb24gbmFtZSwgc2VsZWN0b3IgZG8gfCphcmdzfFxuICAgICAgICBvdXQgPSBibG9jay5jYWxsKCphcmdzKVxuICAgICAgICBjYi5vZmZcbiAgICAgICAgb3V0XG4gICAgICBlbmRcbiAgICBlbmRcbiAgICAjIEBvdmVybG9hZCBvZmYoKVxuICAgICMgICBTdG9wIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50LlxuICAgICNcbiAgICAjIEBvdmVybG9hZCBvZmYod2hhdClcbiAgICAjICAgU3RvcCBsaXN0ZW5pbmcgZm9yIGFuIGV2ZW50LlxuICAgICNcbiAgICAjICAgQHBhcmFtIHdoYXQgW0NhbGxiYWNrLCBTdHJpbmcsIFJlZ2V4cF0gd2hhdCB0byBzdG9wIGxpc3RlbmluZyBmb3JcbiAgICBkZWYgb2ZmKHdoYXQgPSBuaWwpXG4gICAgICBjYXNlIHdoYXRcbiAgICAgIHdoZW4gQ2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2tzLmRlbGV0ZSh3aGF0KVxuICAgICAgICBkZXRhY2god2hhdClcblxuICAgICAgd2hlbiBTdHJpbmdcbiAgICAgICAgaWYgd2hhdC5pbmNsdWRlPyg/Kikgb3Igd2hhdC5pbmNsdWRlPyg/PylcbiAgICAgICAgICBvZmYoUmVnZXhwLm5ldyh3aGF0LmdzdWIoL1xcKi8sICcuKj8nKS5nc3ViKC9cXD8vLCA/LikpKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgd2hhdCA9IEV2ZW50Lm5hbWVfZm9yKHdoYXQpXG5cbiAgICAgICAgICBjYWxsYmFja3MuZGVsZXRlX2lmIHt8Y2FsbGJhY2t8XG4gICAgICAgICAgICBpZiBjYWxsYmFjay5uYW1lID09IHdoYXRcbiAgICAgICAgICAgICAgZGV0YWNoKGNhbGxiYWNrKVxuXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG5cbiAgICAgIHdoZW4gUmVnZXhwXG4gICAgICAgIGNhbGxiYWNrcy5kZWxldGVfaWYge3xjYWxsYmFja3xcbiAgICAgICAgICBpZiBjYWxsYmFjay5uYW1lID1+IHdoYXRcbiAgICAgICAgICAgIGRldGFjaChjYWxsYmFjaylcblxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIGVuZFxuICAgICAgICB9XG5cbiAgICAgIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzLmVhY2gge3xjYWxsYmFja3xcbiAgICAgICAgICBkZXRhY2goY2FsbGJhY2spXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFja3MuY2xlYXJcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LnJlbW92ZUxpc3RlbmVyJ1xuICAgICAgZGVmIGRldGFjaChjYWxsYmFjaylcbiAgICAgICAgYCNAbmF0aXZlLnJlbW92ZUV2ZW50TGlzdGVuZXIoI3tjYWxsYmFjay5uYW1lfSwgI3tjYWxsYmFjay50b19wcm9jfSwgZmFsc2UpYFxuICAgICAgZW5kXG4gICAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmRldGFjaCdcbiAgICAgIGRlZiBkZXRhY2goY2FsbGJhY2spXG4gICAgICAgIGlmIGNhbGxiYWNrLmV2ZW50ID09IEN1c3RvbVxuICAgICAgICAgIGlmIGNhbGxiYWNrcy5ub25lPyB7IHxjfCBjLmV2ZW50ID09IEN1c3RvbSB9XG4gICAgICAgICAgICAleHtcbiAgICAgICAgICAgICAgI0BuYXRpdmUuZGV0YWNoRXZlbnQoXCJvbmRhdGFhdmFpbGFibGVcIiwgI0BuYXRpdmUuJGN1c3RvbSk7XG5cbiAgICAgICAgICAgICAgZGVsZXRlICNAbmF0aXZlLiRjdXN0b207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgI0BuYXRpdmUuZGV0YWNoRXZlbnQoXCJvblwiICsgI3tjYWxsYmFjay5uYW1lfSwgI3tjYWxsYmFjay50b19wcm9jfSlgXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgIyBAdG9kbyBpbXBsZW1lbnQgaW50ZXJuYWwgaGFuZGxlciB0aGluZ1xuICAgICAgIyBAcHJpdmF0ZVxuICAgICAgZGVmIGRldGFjaChjYWxsYmFjaylcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIFRyaWdnZXIgYW4gZXZlbnQgb24gdGhlIHRhcmdldC5cbiAgICAjXG4gICAgIyBAcGFyYW0gZXZlbnQgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWVcbiAgICAjIEBwYXJhbSBhcmdzIFtBcnJheV0gb3B0aW9uYWwgYXJndW1lbnRzIHRvIHRoZSBldmVudCBjYWxsYmFja1xuICAgICNcbiAgICAjIEB5aWVsZHBhcmFtIGRlZmluaXRpb24gW0RlZmluaXRpb25dIGRlZmluaXRpb24gdG8gY3VzdG9taXplIHRoZSBldmVudFxuICAgIGRlZiB0cmlnZ2VyKGV2ZW50LCAqYXJncywgJmJsb2NrKVxuICAgICAgaWYgZXZlbnQuaXNfYT8gU3RyaW5nXG4gICAgICAgIGV2ZW50ID0gRXZlbnQuY3JlYXRlKGV2ZW50LCAqYXJncywgJmJsb2NrKVxuICAgICAgZW5kXG5cbiAgICAgIGRpc3BhdGNoKGV2ZW50KVxuICAgIGVuZFxuXG4gICAgIyBUcmlnZ2VyIGFuIGV2ZW50IG9uIHRoZSB0YXJnZXQgd2l0aG91dCBidWJibGluZy5cbiAgICAjXG4gICAgIyBAcGFyYW0gZXZlbnQgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWVcbiAgICAjIEBwYXJhbSBhcmdzIFtBcnJheV0gb3B0aW9uYWwgYXJndW1lbnRzIHRvIHRoZSBldmVudCBjYWxsYmFja1xuICAgICNcbiAgICAjIEB5aWVsZHBhcmFtIGRlZmluaXRpb24gW0RlZmluaXRpb25dIGRlZmluaXRpb24gdG8gY3VzdG9taXplIHRoZSBldmVudFxuICAgIGRlZiB0cmlnZ2VyIShldmVudCwgKmFyZ3MsICZibG9jaylcbiAgICAgIHRyaWdnZXIgZXZlbnQsICphcmdzIGRvIHxlfFxuICAgICAgICBibG9jay5jYWxsKGUpIGlmIGJsb2NrXG4gICAgICAgIGUuYnViYmxlcyA9IGZhbHNlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5kaXNwYXRjaCdcbiAgICAgIGRlZiBkaXNwYXRjaChldmVudClcbiAgICAgICAgYCNAbmF0aXZlLmRpc3BhdGNoRXZlbnQoI3tldmVudC50b19ufSlgXG4gICAgICBlbmRcbiAgICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuZmlyZSdcbiAgICAgIGRlZiBkaXNwYXRjaChldmVudClcbiAgICAgICAgaWYgQ3VzdG9tID09PSBldmVudFxuICAgICAgICAgIGAjQG5hdGl2ZS5maXJlRXZlbnQoXCJvbmRhdGFhdmFpbGFibGVcIiwgI3tldmVudC50b19ufSlgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgI0BuYXRpdmUuZmlyZUV2ZW50KFwib25cIiArICN7ZXZlbnQubmFtZX0sICN7ZXZlbnQudG9fbn0pYFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICMgQHRvZG8gaW1wbGVtZW50IHBvbHlmaWxsXG4gICAgICAjIEBwcml2YXRlXG4gICAgICBkZWYgZGlzcGF0Y2goKilcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJpdmF0ZVxuICAgIGRlZiBjYWxsYmFja3NcbiAgICAgICV4e1xuICAgICAgICBpZiAoISNAbmF0aXZlLiRjYWxsYmFja3MpIHtcbiAgICAgICAgICAjQG5hdGl2ZS4kY2FsbGJhY2tzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI0BuYXRpdmUuJGNhbGxiYWNrcztcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBkZWxlZ2F0ZWRcbiAgICAgICV4e1xuICAgICAgICBpZiAoISNAbmF0aXZlLiRkZWxlZ2F0ZWQpIHtcbiAgICAgICAgICAjQG5hdGl2ZS4kZGVsZWdhdGVkID0gI3t7fX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI0BuYXRpdmUuJGRlbGVnYXRlZDtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBkZWxlZ2F0ZShkZWxlZ2F0ZXMsIGV2ZW50LCBlbGVtZW50ID0gZXZlbnQudGFyZ2V0KVxuICAgICAgcmV0dXJuIGlmIGVsZW1lbnQubmlsPyB8fCBlbGVtZW50ID09IGV2ZW50Lm9uXG5cbiAgICAgIGRlbGVnYXRlcy5oYW5kbGVycy5lYWNoIHt8c2VsZWN0b3IsIGJsb2NrfFxuICAgICAgICBpZiBlbGVtZW50ID1+IHNlbGVjdG9yXG4gICAgICAgICAgbmV3ICAgID0gZXZlbnQuZHVwXG4gICAgICAgICAgbmV3Lm9uID0gZWxlbWVudFxuXG4gICAgICAgICAgYmxvY2suY2FsbCBuZXcsICpuZXcuYXJndW1lbnRzXG4gICAgICAgIGVuZFxuICAgICAgfVxuXG4gICAgICBkZWxlZ2F0ZShkZWxlZ2F0ZXMsIGV2ZW50LCBlbGVtZW50LnBhcmVudClcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+Iiwic2VsZiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJuZXciLCJkYXRhIiwiYmxvY2siLCJjYWxsIiwidG9fbiIsImJ1YmJsZXM9IiwidmFsdWUiLCJAbmF0aXZlIiwiY2FuY2VsYWJsZT0iLCI8bW9kdWxlOlRhcmdldD4iLCJjb252ZXJ0ZXJzIiwiQGNvbnZlcnRlcnMiLCIkcmV0X29yXzEiLCJyZWdpc3RlciIsIjw8IiwiY29udmVydCIsIm5hdGl2ZT8iLCJlYWNoIiwiYmxvY2sgaW4gY29udmVydCIsImJsb2NrICgyIGxldmVscykgaW4gY29udmVydCIsInJlc3VsdCIsImluY2x1ZGVkIiwia2xhc3MiLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2sgaW4gaW5jbHVkZWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGluY2x1ZGVkIiwidGFyZ2V0IiwiRXZlbnQ6OlRhcmdldCIsIkV2ZW50IiwidG9fcHJvYyIsIjxjbGFzczpDYWxsYmFjaz4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJuYW1lIiwic2VsZWN0b3IiLCJAdGFyZ2V0IiwiQG5hbWUiLCJAc2VsZWN0b3IiLCJAYmxvY2siLCJldmVudCIsIkBwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInN0b3BwZWQ/IiwiYXJndW1lbnRzIiwicHJldmVudGVkPyIsIiEiLCJjbGFzc19mb3IiLCJvZmYiLCI8Y2xhc3M6RGVsZWdhdGU+IiwicGFpciIsIkBwYWlyIiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZWQiLCJbXSIsImxhc3QiLCJkZWxldGUiLCJlbXB0eT8iLCJmaXJzdCIsIlN0cnVjdCIsIm9uIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwibmFtZV9mb3IiLCJoYW5kbGVycyIsIkRlbGVnYXRlIiwiW109IiwiRGVsZWdhdGVzIiwiaW5jbHVkZT8iLCJjYWxsYmFjaz0iLCJvbiEiLCJibG9jayBpbiBvbiIsImUiLCJibG9jayAoMiBsZXZlbHMpIGluIG9uIiwiaGFuZGxlcnM9IiwiY2FsbGJhY2siLCJDYWxsYmFjayIsImNhbGxiYWNrcyIsInB1c2giLCJhdHRhY2giLCJhdHRhY2ghIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIkN1c3RvbSIsIj09Iiwid2FybiIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJvbmUiLCJjYiIsImJsb2NrIGluIG9uZSIsImJsb2NrICgyIGxldmVscykgaW4gb25lIiwib3V0IiwiYXJncyIsIndoYXQiLCJkZXRhY2giLCJTdHJpbmciLCJSZWdleHAiLCJnc3ViIiwiZGVsZXRlX2lmIiwiYmxvY2sgaW4gb2ZmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBvZmYiLCI9fiIsImNsZWFyIiwibm9uZT8iLCJibG9jayBpbiBkZXRhY2giLCJjIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZXRhY2giLCJ0cmlnZ2VyIiwiaXNfYT8iLCJjcmVhdGUiLCJkaXNwYXRjaCIsInRyaWdnZXIhIiwiYmxvY2sgaW4gdHJpZ2dlciEiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyaWdnZXIhIiwicHJpdmF0ZSIsImRlbGVnYXRlcyIsImVsZW1lbnQiLCJuaWw/IiwiYmxvY2sgaW4gZGVsZWdhdGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGVnYXRlIiwibmV3JCIsImR1cCIsIm9uPSIsInBhcmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFFQUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsWUFBQUQsWUFBUkQ7TUFHQUc7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUosSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsWUFBQUQsWUFBUkQ7UUFHQUksTUFBSUwsSUFBSkssVUFBQUEsMkJBQUFBO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBQ0VDLE9BQU8sT0FBQU4sSUFBQSxFQUFBLHdEQUFBLE9BQUEsRUFBQSxDQUFPSyxtQ0FBUCxDQUFBLEVBQUEsSUFBQTtVQUNQLElBQUEsUUFBb0JFLEtBQXBCLENBQUE7WUFBQUEsS0FBS0MsTUFBQUEsQ0FBTUYsSUFBTkU7VUFBTDtVQUVBSCxPQUFBQyxJQUFJRyxNQUFBQSxDQUFBQTtRQUpOSixDQUFBQSxHQUFBQTs7QUFRQUssUUFBQUEsd0JBQUFBLGtDQUFhQyxLQUFiRDtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRUUsY0FBT0YsV0FBYUM7UUFEeEJELENBQUFBLEdBQUFBO1FBS0FOLE9BQUFTLDJCQUFBQSxxQ0FBZ0JGLEtBQWhCRTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRUQsY0FBT0MsY0FBZ0JGO1FBRDNCRSxDQUFBQSxHQUFBQTtNQWpCRlQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7TUFzQkFMLE9BQUFlO01BQUFBOztRQUFBQTs7O1FBRUVDLE1BQUlmLElBQUplLGlCQUFBQSxzQkFBQUE7QUFBQUEsVUFBQUE7QUFBQUE7O1VBQ0VBLE9BQUFDLENBQUFBLGtCQS9CTixDQUFBLFFBQUFDLENBQUFBLFlBK0JNRCxlQS9CTkMsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0ErQnNCLEVBL0J0QixDQUFBLENBK0JNRDtRQURGRCxDQUFBQSxHQUFBQTtRQUtBRyxNQUFJbEIsSUFBSmtCLGVBQUFBLG9CQUFBQTtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQUNFQSxPQUFBbEIsSUFBQWUsWUFBQUEsQ0FBQUEsQ0FBV0ksT0FBQUEsQ0FBR1osS0FBSFk7UUFEYkQsQ0FBQUEsR0FBQUE7UUFLQUUsTUFBSXBCLElBQUpvQixjQUFBQSxtQkFBaUJULEtBQWpCUyxHQUFBQSxNQUFBQSxJQUFBQSw4QkFBQUE7QUFBQUEsVUFBQUE7OztVQUNFLEtBQUEsUUFBb0JwQixJQUFBcUIsWUFBQUEsQ0FBUVYsS0FBUlUsQ0FBcEIsQ0FBQTtZQUFBLE9BQU9WO1VBQVA7VUFFVVcsTUFBVnRCLElBQUFlLFlBQUFBLENBQUFBLENBQVVPLFFBQUFBLEVBQUFBLEVBQUFBLEVBQVZDLGFBQWtCaEIsS0FBbEJnQixFQUFBQzs7O1lBQWtCO1lBQ2hCLElBQUEsUUFBR0MsQ0FBQUEsU0FBU2xCLEtBQUtDLE1BQUFBLENBQU1HLEtBQU5ILENBQWRpQixDQUFILENBQUE7Y0FDRSxTQUFBLFFBQU9BLE1BQVA7WUFERjtjQTVDUkQsT0FBQTtZQTRDUSxFQURGRCxDQUFBQSxHQUFBQSw0QkFBQUEsQ0FBVUQ7VUFNVkYsT0FBQSxJQVRGQTtZQUFBQTtZQUFBQTtVQUFBQTtRQUFBQSxDQUFBQSxHQUFBQTtRQVlBTSxNQUFJMUIsSUFBSjBCLGVBQUFBLG9CQUFrQkMsS0FBbEJEO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFLRSxNQUFMRCxLQUFLQyxpQkFBQUEsRUFBQUEsRUFBQUEsRUFBTEMsYUFBQUEsRUFBQUM7O1lBQ0VBLE9BQUFDLE1BQUkvQixJQUFKK0IsYUFBQUEsa0JBQUFBO0FBQUFBLGNBQUFBOztjQUFBQTs7O2NBQ0VBLE9BQWFiLE1BQWJjLElBQUFDLFdBQUFELFdBQWFkLFlBQUFBLEVBQUFBLEVBQUFBLEVBQVdYLEtBQUQyQixTQUFBQSxDQUFBQSxDQUFWaEI7WUFEZmEsQ0FBQUEsR0FBQUEsQ0FERkYsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUtEO1FBRFBGLENBQUFBLEdBQUFBO1FBUUFTO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VuQyxJQUFBb0MsYUFBQUEsQ0FBWSxRQUFaLEVBQXFCLE1BQXJCLEVBQTRCLFVBQTVCQTs7QUFHQUMsVUFBQUEsMEJBQUFBLHNCQUFlTixNQUFELEVBQVNPLElBQVQsRUFBZUMsUUFBN0JGO0FBQUFBLFlBQUFBOztZQUFBQTs7O1lBQTZCLGlDQUFXO1lBQ3RDRyxjQUFZVDtZQUNaVSxZQUFZSDtZQUNaSSxnQkFBWUg7WUFDWkYsT0FBQU0sQ0FBQUEsYUFBWXBDLEtBQVpvQztVQUpGTixDQUFBQSxJQUFBQTs7QUFVQTdCLFVBQUFBLG9CQUFBQSxnQkFBU29DLEtBQVRwQztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQVIsSUFBQWtDLFNBQUFBLENBQUFBLENBQU8xQixNQUFBQSxDQUFNb0MsS0FBTnBDO1VBRFRBLENBQUFBLEdBQUFBOztBQUtBMEIsVUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQVcsQ0FBQUEsWUFoRlIsYUFBQSxJQUFBLFFBQUE1QixDQUFBQSxZQWdGUTRCLFNBaEZSNUIsQ0FBQSxDQUFBO2NBQUFpQixPQUFBO1lBQUE7Y0FnRmtCQSxPQUFBLFFBQUFZLGFBQUdGLEtBQUhFLEVBQUFDO0FBQUFBOzs7Z0JBQUc7O0FBRXJCQTtBQUNBQTtBQUNBQTtBQUNBQTtnQkFFVUgsUUFBUVgsV0FBSzVCLEtBQUFBLENBQUt1QyxLQUFWLEVBQWlCNUMsSUFBWks7Z0JBRWIsS0FBQSxRQUFPdUMsS0FBS0ksYUFBQUEsQ0FBQUEsQ0FBWixDQUFBO2tCQUNReEMsTUFBTm1DLFVBQU1uQyxRQUFBQSxFQUFOLENBQVlvQyxLQUFaLENBQUEsUUFBbUIsTUFBQ0EsS0FBS0ssV0FBQUEsQ0FBQUEsQ0FBTixDQUFuQixDQUFNekM7Z0JBRFI7Z0JBSUF1QyxPQUFDSCxLQUFLTSxlQUFBQSxDQUFBQSxDQUFOQyxNQUFBQSxDQUFBQSxFQWJRTCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQTtZQWhGbEIsQ0FBQSxJQWdGUUQ7VUFERlgsQ0FBQUEsR0FBQUE7O0FBb0JBVSxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBWCxXQUFLbUIsV0FBQUEsQ0FBV1gsU0FBWFc7VUFEUFIsQ0FBQUEsR0FBQUE7VUFLQVQsT0FBQWtCLG1CQUFBQSxlQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQXJELElBQUErQixRQUFBQSxDQUFBQSxDQUFNc0IsS0FBQUEsQ0FBS3JELElBQUxxRDtVQURSQSxDQUFBQSxHQUFBQTtRQTVDRmxCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO1FBaURBbUI7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VqQixVQUFBQSwwQkFBQUEsc0JBQWVOLE1BQUQsRUFBU08sSUFBVCxFQUFlaUIsSUFBN0JsQjtBQUFBQSxZQUFBQTs7O1lBQ0VHLGNBQVVUO1lBQ1ZVLFlBQVVIO1lBQ1ZELE9BQUFtQixDQUFBQSxZQUFVRCxJQUFWQztVQUhGbkIsQ0FBQUEsR0FBQUE7VUFPQWlCLE9BQUFELG1CQUFBQSxlQUFBQTtBQUFBQSxZQUFBQTs7O1lBQ0VJLFdBQVdqQixXQUFPa0IsV0FBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBQ2xCLFNBQURrQjtZQUM1QkYsUUFBUUcsTUFBQUEsQ0FBQUEsQ0FBS0MsUUFBQUEsQ0FBUUwsU0FBUks7WUFFYixJQUFBLFFBQUdKLFFBQVFHLE1BQUFBLENBQUFBLENBQUtFLFdBQUFBLENBQUFBLENBQWhCLENBQUE7O2NBQ0VMLFFBQVFNLE9BQUFBLENBQUFBLENBQU1WLEtBQUFBLENBQUFBO2NBQ2RBLE9BQUFJLFFBQVFJLFFBQUFBLENBQVFwQixTQUFSb0I7WUFGVjtjQXpIUlIsT0FBQTtZQXlIUTtVQUpGQSxDQUFBQSxHQUFBQTtRQVJGQyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtRQW1CQSxxQ0FBWVUsWUFBTTNELEtBQUFBLENBQUssVUFBWCxFQUFzQixVQUFoQkEsQ0FBbEI7O0FBc0JBNEQsUUFBQUEsa0JBQUFBLGNBQU8zQixJQUFELEVBQU9DLFFBQWIwQjtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQUFhLGlDQUFXO1VBQ3RCLEtBQUEsUUFBc0QxRCxLQUF0RCxDQUFBO1lBQUFQLElBQUFrRSxPQUFBQSxDQUFNQyxtQkFBTixFQUFxQkYseUJBQXJCQztVQUFBO1VBRUE1QixPQUFPTCxXQUFLbUMsVUFBQUEsQ0FBVTlCLElBQVY4QjtVQUVaLElBQUEsUUFBRzdCLFFBQUgsQ0FBQTtZQUNFLElBQUEsUUFBT2tCLENBQUFBLFdBQVd6RCxJQUFBMEQsV0FBQUEsQ0FBQUEsQ0FBU0MsT0FBQUEsQ0FBQ3JCLElBQURxQixDQUFwQkYsQ0FBUCxDQUFBOztjQWtCRUYsT0FBTyxDQUFDaEIsUUFBRCxFQUFXaEMsS0FBWDtjQUNQa0QsUUFBUVksVUFBQUEsQ0FBQUEsQ0FBVWxELE9BQUFBLENBQUdvQyxJQUFIcEM7Y0FFbEI4QyxPQUFBSyxjQUFRakUsS0FBQUEsQ0FBS0wsSUFBYixFQUFtQnNDLElBQW5CLEVBQXlCaUIsSUFBakJsRDtZQXJCVjs7Y0FDRW9ELFdBQW9CYyxNQUFBQSxDQUFDakMsSUFBVixFQUFrQmtDLGVBQVNuRSxLQUFBQSxDQUFBQSxDQUFsQmtFLENBQUFBLEVBQUFBLE1BQVR2RSxJQUFBMEQsV0FBQUEsQ0FBQUEsQ0FBU2EsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7Y0FFcEIsSUFBQSxRQUFHLENBQUdOLE1BQUgsRUFBUUEsT0FBUixDQUFjUSxhQUFBQSxDQUFVbkMsSUFBVm1DLENBQWpCLENBQUE7Z0JBQ0VoQixRQUFRaUIsY0FBQUEsQ0FBWUMsTUFBQTNFLElBQUEyRSxPQUFBQSxFQUFBQSxDQUFJckMsSUFBSnFDLENBQUFBLEVBQUFDLGFBQWFDLENBQWJELEVBQUFFOzs7a0JBQWE7a0JBQy9CQSxPQUFBOUUsSUFBQXlELFVBQUFBLENBQVNBLFFBQVQsRUFBbUJvQixDQUFuQnBCLEVBRGtCbUIsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFELENBQVpEO2NBRFY7Z0JBS0VqQixRQUFRaUIsY0FBQUEsQ0FBWVQsTUFBQWpFLElBQUFpRSxNQUFBQSxFQUFBQSxDQUFHM0IsSUFBSDJCLENBQUFBLEVBQUFXLGFBQVlDLENBQVpELEVBQUFFOzs7a0JBQVk7a0JBQzlCQSxPQUFBOUUsSUFBQXlELFVBQUFBLENBQVNBLFFBQVQsRUFBbUJvQixDQUFuQnBCLEVBRGtCbUIsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFYLENBQVpTO2NBTFY7Y0FVQW5CLE9BQU8sQ0FBQ2hCLFFBQUQsRUFBV2hDLEtBQVg7Y0FDUGtELFFBQVFzQixjQUFBQSxDQUFZLENBQUN4QixJQUFELENBQVp3QjtjQUVSZCxPQUFBSyxjQUFRakUsS0FBQUEsQ0FBS0wsSUFBYixFQUFtQnNDLElBQW5CLEVBQXlCaUIsSUFBakJsRDtZQWhCVjtVQURGOztZQXlCRTJFLFdBQW1CM0UsTUFBUjRFLGNBQVE1RSxPQUFBQSxFQUFBQSxDQUFLTCxJQUFiLEVBQW1Cc0MsSUFBbkIsRUFBeUJDLFFBQWpCbEMsQ0FBQUEsRUFBNEJFLEtBQUQyQixTQUFBQSxDQUFBQSxDQUEzQjdCO1lBQ25CTCxJQUFBa0YsV0FBQUEsQ0FBQUEsQ0FBU0MsTUFBQUEsQ0FBTUgsUUFBTkc7WUFFVGxCLE9BQUFqRSxJQUFBb0YsUUFBQUEsQ0FBT0osUUFBUEk7VUE1QkY7UUFMRm5CLENBQUFBLElBQUFBOztBQTRDQVUsUUFBQUEsbUJBQUFBLDJCQUFRckMsSUFBUnFDO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBQ0UsS0FBQSxRQUFzRHBFLEtBQXRELENBQUE7WUFBQVAsSUFBQWtFLE9BQUFBLENBQU1DLG1CQUFOLEVBQXFCUSx5QkFBckJUO1VBQUE7VUFFQTVCLE9BQVdMLFdBQUttQyxVQUFBQSxDQUFVOUIsSUFBVjhCO1VBQ2hCWSxXQUFtQjNFLE1BQVI0RSxjQUFRNUUsT0FBQUEsRUFBQUEsQ0FBS0wsSUFBYixFQUFtQnNDLElBQVhqQyxDQUFBQSxFQUFrQkUsS0FBRDJCLFNBQUFBLENBQUFBLENBQWpCN0I7VUFDbkJMLElBQUFrRixXQUFBQSxDQUFBQSxDQUFTQyxNQUFBQSxDQUFNSCxRQUFORztVQUVUUixPQUFBM0UsSUFBQXFGLFlBQUFBLENBQVFMLFFBQVJLO1FBUEZWLENBQUFBLEdBQUFBO1FBVUEsSUFBQSxRQUFHVyxhQUFPQyxjQUFBQSxDQUFXekUsbUJBQVh5RSxDQUFWLENBQUE7OztBQUNFSCxVQUFBQSxzQkFBQUEsa0JBQVdKLFFBQVhJO0FBQUFBLFlBQUFBO0FBQUFBOzs7WUFDSXhFLGNBQU93RSxrQkFBb0JKLFFBQVExQyxNQUFBQSxDQUFBQSxDQUFNOEMsRUFBSUosUUFBUTlDLFNBQUFBLENBQUFBLENBQVNrRDtZQUVoRUEsT0FBQUo7VUFIRkksQ0FBQUEsR0FBQUE7O0FBTUFDLFVBQUFBLHVCQUFBQSxnQ0FBWUwsUUFBWks7QUFBQUEsWUFBQUE7QUFBQUE7OztZQUNJekUsY0FBT3lFLGtCQUFvQkwsUUFBUTFDLE1BQUFBLENBQUFBLENBQU0rQyxFQUFJTCxRQUFROUMsU0FBQUEsQ0FBQUEsQ0FBU21EO1lBRWhFQSxPQUFBTDtVQUhGSyxDQUFBQSxHQUFBQTtRQVBGLE9BWUEsSUFBQSxRQUFNQyxhQUFPQyxjQUFBQSxDQUFXekUsY0FBWHlFLENBQWIsQ0FBQTs7O0FBQ0VILFVBQUFBLHNCQUFBQSxrQkFBV0osUUFBWEk7QUFBQUEsWUFBQUE7QUFBQUE7OztZQUNFLElBQUEsTUFBR0osUUFBUXBDLE9BQUFBLENBQUFBLENBQVgsRUFBcUI0QyxZQUFyQixDQUFBOztBQUVSSixpQkFBa0J4RSxjQUFPd0U7QUFDekJBLGNBQWV4RSxjQUFPd0U7QUFDdEJBLHlDQUEwQ3hFLGNBQU93RTtBQUNqREEsaUNBQWtDeEUsY0FBT3dFOztBQUV6Q0Esc0JBQXdCQSxDQUFDQSxRQUFEQSxDQUFVeEMsT0FBQUEsQ0FBQUEsQ0FBTzZDLE9BQUFBLENBQUdELFlBQUhDLENBQVVMO0FBQ25EQTs7QUFFQUEsb0JBQXNCQSxDQUFDQSxRQUFEQSxDQUFVNUUsTUFBQUEsQ0FBTzRFLEtBQVA1RSxDQUFlNEU7QUFDL0NBO0FBQ0FBO0FBQ0FBOztBQUVBQSxjQUFleEUsY0FBT3dFLGdDQUFpQ3hFLGNBQU93RTtBQUM5REE7QUFDQUE7WUFqQlE7Y0FtQkl4RSxjQUFPd0Usb0JBQXNCSixRQUFRMUMsTUFBQUEsQ0FBQUEsQ0FBTThDLEVBQUlKLFFBQVE5QyxTQUFBQSxDQUFBQSxDQUFTa0Q7WUFuQnBFO1lBc0JBQSxPQUFBSjtVQXZCRkksQ0FBQUEsR0FBQUE7O0FBMEJBQyxVQUFBQSx1QkFBQUEsZ0NBQVlMLFFBQVpLO0FBQUFBLFlBQUFBO0FBQUFBOzs7O1lBRUUsUUFES0wsUUFBUTFDLE1BQUFBLENBQUFBLENBQ2I7Y0FBQSxLQUFLLE1BQUw7Z0JBQ0kxQixjQUFPeUUsMkJBQTZCTCxRQUFROUMsU0FBQUEsQ0FBQUEsQ0FBU21EO2dCQUR6RDtjQUdBLEtBQUssT0FBTDtnQkFDSXpFLGNBQU95RSwwQkFBNEJMLFFBQVE5QyxTQUFBQSxDQUFBQSxDQUFTbUQ7Z0JBRHhEO2NBQUE7O2dCQUlFckYsSUFBQTBGLE1BQUFBLENBQUtMLDhDQUFMSztnQkFDQTFGLElBQUFvRixRQUFBQSxDQUFPSixRQUFQSTtZQVJGO1lBV0FDLE9BQUFMO1VBYkZLLENBQUFBLEdBQUFBO1FBM0JGOzs7QUE2Q0VELFVBQUFBLHNCQUFBQSxrQkFyUU4sRUFxUU1BO0FBQUFBLFlBQUFBOzs7WUFyUU47WUFxUWlCO1lBQ1RBLE9BQUFwRixJQUFBa0UsT0FBQUEsQ0FBTXlCLHlCQUFOekI7VUFERmtCLENBQUFBLElBQUFBOztBQU1BQyxVQUFBQSx1QkFBQUEsZ0NBM1FOLEVBMlFNQTtBQUFBQSxZQUFBQTs7O1lBM1FOO1lBMlFrQjtZQUNWQSxPQUFBckYsSUFBQWtFLE9BQUFBLENBQU15Qix5QkFBTnpCO1VBREZtQixDQUFBQSxJQUFBQTtRQW5ERjs7QUE4RUFPLFFBQUFBLG1CQUFBQSxlQUFTdEQsSUFBRCxFQUFPQyxRQUFmcUQ7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFBZSxpQ0FBVztVQUN4QixLQUFBLFFBQXNEckYsS0FBdEQsQ0FBQTtZQUFBUCxJQUFBa0UsT0FBQUEsQ0FBTUMsbUJBQU4sRUFBcUJ5Qix5QkFBckIxQjtVQUFBO1VBRUEwQixPQUFBQyxDQUFBQSxLQUFLNUIsTUFBQWpFLElBQUFpRSxNQUFBQSxFQUFBQSxDQUFHM0IsSUFBSCxFQUFTQyxRQUFUMEIsQ0FBQUEsRUFBQTZCLGNBelNYLEVBeVNXQSxFQUFBQzs7O1lBelNYO1lBeVNpQztZQUN6QkMsTUFBV3hGLE1BQUxELEtBQUtDLFFBQUFBLEVBQU0sTUFBQ3lGLElBQUQsQ0FBTnpGO1lBQ1hxRixFQUFFeEMsS0FBQUEsQ0FBQUE7WUFDRjBDLE9BQUFDLElBSEdGLENBQUFBLElBQUE3QixDQUFMNEI7UUFIRkQsQ0FBQUEsSUFBQUE7O0FBZ0JBdkMsUUFBQUEsbUJBQUFBLGVBQVE2QyxJQUFSN0M7QUFBQUEsVUFBQUE7OztVQUFRLHlCQUFPO1VBRWIsSUFBQSxRQUFLNEIsY0FBTCxFQURBaEUsQ0FBQUEsWUFBS2lGLElBQUxqRixDQUNBLENBQUE7O1lBQ0VqQixJQUFBa0YsV0FBQUEsQ0FBQUEsQ0FBU3JCLFFBQUFBLENBQVFxQyxJQUFSckM7WUFDVFIsT0FBQXJELElBQUFtRyxRQUFBQSxDQUFPRCxJQUFQQztVQUZGLE9BSUEsSUFBQSxRQUFLQyxZQUFMLEVBNVROLFNBNFRNLENBQUE7WUFDRSxJQUFHLENBQUEsUUFBQUYsSUFBSXpCLGFBQUFBLENBQVVwQixHQUFWb0IsQ0FBSixDQUFBLElBQUEsQ0FBQSxRQUFxQnlCLElBQUl6QixhQUFBQSxDQUFVcEIsR0FBVm9CLENBQXpCLENBQUEsQ0FBQSxDQUFIO2NBQ0VwQixPQUFBckQsSUFBQXFELEtBQUFBLENBQUlnRCxZQUFNaEcsS0FBQUEsQ0FBSzZGLElBQUlJLE1BQUFBLENBQU0sSUFBVixFQUFnQmpELEtBQVppRCxDQUFrQkEsTUFBQUEsQ0FBTSxJQUE1QixFQUFrQ2pELEdBQVppRCxDQUEzQmpHLENBQVZnRDtZQURGOztjQUdFNkMsT0FBT2pFLFdBQUttQyxVQUFBQSxDQUFVOEIsSUFBVjlCO2NBRVpmLE9BQVNrRCxNQUFUdkcsSUFBQWtGLFdBQUFBLENBQUFBLENBQVNxQixhQUFBQSxFQUFBQSxFQUFBQSxFQUFUQyxjQUFzQnhCLFFBQXRCd0IsRUFBQUM7OztnQkFBc0I7Z0JBQ3BCLElBQUEsTUFBR3pCLFFBQVExQyxNQUFBQSxDQUFBQSxDQUFYLEVBQW9CNEQsSUFBcEIsQ0FBQTs7a0JBQ0VsRyxJQUFBbUcsUUFBQUEsQ0FBT25CLFFBQVBtQjtrQkFFQU0sT0FBQTtnQkFIRjtrQkFuVVpBLE9BQUE7Z0JBbVVZLEVBREZELENBQUFBLEdBQUFBLHFCQUFBQSxDQUFTRDtZQUxYO1VBREYsT0FlQSxJQUFBLFFBQUtGLFlBQUwsRUEzVU4sU0EyVU0sQ0FBQTtZQUNFaEQsT0FBU2tELE1BQVR2RyxJQUFBa0YsV0FBQUEsQ0FBQUEsQ0FBU3FCLGFBQUFBLEVBQUFBLEVBQUFBLEVBQVRDLGNBQXNCeEIsUUFBdEJ3QixFQUFBQzs7O2NBQXNCO2NBQ3BCLElBQUEsUUFBR3pCLFFBQVExQyxNQUFBQSxDQUFBQSxDQUFNb0UsT0FBQUEsQ0FBR1IsSUFBSFEsQ0FBakIsQ0FBQTs7Z0JBQ0UxRyxJQUFBbUcsUUFBQUEsQ0FBT25CLFFBQVBtQjtnQkFFQU0sT0FBQTtjQUhGO2dCQTdVVkEsT0FBQTtjQTZVVSxFQURGRCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBU0Q7VUFEWDs7WUFVV2pGLE1BQVR0QixJQUFBa0YsV0FBQUEsQ0FBQUEsQ0FBUzVELFFBQUFBLEVBQUFBLEVBQUFBLEVBQVRrRixjQUFpQnhCLFFBQWpCd0IsRUFBQUM7OztjQUFpQjtjQUNmQSxPQUFBekcsSUFBQW1HLFFBQUFBLENBQU9uQixRQUFQbUIsRUFERkssQ0FBQUEsR0FBQUEscUJBQUFBLENBQVNsRjtZQUlUK0IsT0FBQXJELElBQUFrRixXQUFBQSxDQUFBQSxDQUFTeUIsT0FBQUEsQ0FBQUE7VUFkWDtRQXJCRnRELENBQUFBLElBQUFBO1FBdUNBLElBQUEsUUFBR2lDLGFBQU9DLGNBQUFBLENBQVd6RSxzQkFBWHlFLENBQVYsQ0FBQTs7QUFDRVksVUFBQUEsc0JBQUFBLGtCQUFXbkIsUUFBWG1CO0FBQUFBLFlBQUFBO0FBQUFBOztZQUNFQSxPQUFFdkYsY0FBT3VGLHFCQUF1Qm5CLFFBQVExQyxNQUFBQSxDQUFBQSxDQUFNNkQsRUFBSW5CLFFBQVE5QyxTQUFBQSxDQUFBQSxDQUFTaUU7VUFEckVBLENBQUFBLEdBQUFBO1FBREYsT0FJQSxJQUFBLFFBQU1iLGFBQU9DLGNBQUFBLENBQVd6RSxjQUFYeUUsQ0FBYixDQUFBOztBQUNFWSxVQUFBQSxzQkFBQUEsa0JBQVduQixRQUFYbUI7QUFBQUEsWUFBQUE7QUFBQUE7O1lBQ0UsSUFBQSxNQUFHbkIsUUFBUXBDLE9BQUFBLENBQUFBLENBQVgsRUFBcUI0QyxZQUFyQixDQUFBO2NBQ0UsSUFBQSxRQUFZb0IsTUFBVDVHLElBQUFrRixXQUFBQSxDQUFBQSxDQUFTMEIsU0FBQUEsRUFBQUEsRUFBQUEsRUFBVEMsY0FBbUJDLENBQW5CRDs7Z0JBQW1CO2dCQUFHRSxPQUFBRCxDQUFDbEUsT0FBQUEsQ0FBQUEsQ0FBTzZDLE9BQUFBLENBQUdELFlBQUhDLEVBQTlCb0IsQ0FBQUEsR0FBU0QsQ0FBWixDQUFBOztBQUVWVCxjQUFldkYsY0FBT3VGLGdDQUFpQ3ZGLGNBQU91Rjs7QUFFOURBLHFCQUFzQnZGLGNBQU91RjtBQUM3QkE7Y0FMVTtnQkFwV1ZBLE9BQUE7Y0FvV1U7WUFERjtjQVNFQSxPQUFFdkYsY0FBT3VGLG9CQUFzQm5CLFFBQVExQyxNQUFBQSxDQUFBQSxDQUFNNkQsRUFBSW5CLFFBQVE5QyxTQUFBQSxDQUFBQSxDQUFTaUU7WUFUcEU7VUFERkEsQ0FBQUEsR0FBQUE7UUFERjs7QUFpQkVBLFVBQUFBLHNCQUFBQSxrQkFBV25CLFFBQVhtQjtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQW5HLElBQUFrRSxPQUFBQSxDQUFNeUIseUJBQU56QjtVQURGaUMsQ0FBQUEsR0FBQUE7UUFqQkY7O0FBNEJBYSxRQUFBQSx1QkFBQUEsbUJBQVlwRSxLQUFELEVBN1hmLEVBNlhJb0U7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUE3WEo7VUE2WHVCO1VBQ2pCLElBQUEsUUFBR3BFLEtBQUtxRSxVQUFBQSxDQUFPYixZQUFQYSxDQUFSLENBQUE7WUFDRXJFLFFBQWFzRSxNQUFMakYsV0FBS2lGLFVBQUFBLEVBQUwsQ0FBYXRFLEtBQWIsQ0FBQSxRQUFvQixNQUFDcUQsSUFBRCxDQUFwQixDQUFLaUIsRUFBdUIzRyxLQUFEMkIsU0FBQUEsQ0FBQUEsQ0FBdEJnRjtVQURmO1VBSUFGLE9BQUFoSCxJQUFBbUgsVUFBQUEsQ0FBU3ZFLEtBQVR1RTtRQUxGSCxDQUFBQSxJQUFBQTs7QUFjQUksUUFBQUEsd0JBQUFBLGlDQUFheEUsS0FBRCxFQTNZaEIsRUEyWUl3RTtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQTNZSjtVQTJZd0I7VUFDbEJBLE9BQUFKLE1BQUFoSCxJQUFBZ0gsV0FBQUEsRUFBQSxDQUFRcEUsS0FBUixDQUFBLFFBQWUsTUFBQ3FELElBQUQsQ0FBZixDQUFBZSxFQUFBSyxjQUF5QnhDLENBQXpCd0MsRUFBQUM7OztZQUF5QjtZQUN2QixJQUFBLFFBQWlCL0csS0FBakIsQ0FBQTtjQUFBQSxLQUFLQyxNQUFBQSxDQUFNcUUsQ0FBTnJFO1lBQUw7WUFDQThHLE9BQUM1RyxNQUFBQSxDQUFXLEtBQVhBLENBQUFBLEVBQUFBLE1BQURtRSxDQUFDbkUsWUFBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRkgyRyxDQUFBQSxHQUFBTDtRQURGSSxDQUFBQSxJQUFBQTtRQU9BLElBQUEsUUFBRzlCLGFBQU9DLGNBQUFBLENBQVd6RSxnQkFBWHlFLENBQVYsQ0FBQTs7QUFDRTRCLFVBQUFBLHdCQUFBQSxvQkFBYXZFLEtBQWJ1RTtBQUFBQSxZQUFBQTtBQUFBQTs7WUFDRUEsT0FBRXZHLGNBQU91RyxlQUFpQnZFLEtBQUtuQyxNQUFBQSxDQUFBQSxDQUFNMEc7VUFEdkNBLENBQUFBLEdBQUFBO1FBREYsT0FJQSxJQUFBLFFBQU03QixhQUFPQyxjQUFBQSxDQUFXekUsWUFBWHlFLENBQWIsQ0FBQTs7QUFDRTRCLFVBQUFBLHdCQUFBQSxvQkFBYXZFLEtBQWJ1RTtBQUFBQSxZQUFBQTtBQUFBQTs7WUFDRSxJQUFBLFFBQUczQixZQUFILEVBQWM1QyxLQUFkLENBQUE7Y0FDRXVFLE9BQUV2RyxjQUFPdUcsOEJBQWdDdkUsS0FBS25DLE1BQUFBLENBQUFBLENBQU0wRztZQUR0RDtjQUdFQSxPQUFFdkcsY0FBT3VHLGtCQUFvQnZFLEtBQUtOLE1BQUFBLENBQUFBLENBQU02RSxFQUFJdkUsS0FBS25DLE1BQUFBLENBQUFBLENBQU0wRztZQUh6RDtVQURGQSxDQUFBQSxHQUFBQTtRQURGOztBQVdFQSxVQUFBQSx3QkFBQUEsb0JBamFOLEVBaWFNQTtBQUFBQSxZQUFBQTs7O1lBamFOO1lBaWFtQjtZQUNYQSxPQUFBbkgsSUFBQWtFLE9BQUFBLENBQU15Qix5QkFBTnpCO1VBREZpRCxDQUFBQSxJQUFBQTtRQVhGO1FBZ0JGbkgsSUFBQXVILFNBQUFBLENBQUFBOztBQUNFckMsUUFBQUEseUJBQUFBLHFCQUFBQTtBQUFBQSxVQUFBQTtBQUFBQTs7O0FBRUpBLGFBQWN0RSxjQUFPc0U7QUFDckJBLFVBQVd0RSxjQUFPc0U7QUFDbEJBOztBQUVBQSxlQUFnQnRFLGNBQU9zRTtBQUN2QkE7UUFQSUEsQ0FBQUEsR0FBQUE7O0FBVUF4QixRQUFBQSx5QkFBQUEscUJBQUFBO0FBQUFBLFVBQUFBO0FBQUFBOzs7QUFFSkEsYUFBYzlDLGNBQU84QztBQUNyQkEsVUFBVzlDLGNBQU84QyxjQUFnQixZQUFBLEVBQUdBO0FBQ3JDQTs7QUFFQUEsZUFBZ0I5QyxjQUFPOEM7QUFDdkJBO1FBUElBLENBQUFBLEdBQUFBO1FBVUE1QyxPQUFBMkMsd0JBQUFBLG9CQUFhK0QsU0FBRCxFQUFZNUUsS0FBWixFQUFtQjZFLE9BQS9CaEU7QUFBQUEsVUFBQUE7OztVQUErQiwrQkFBVWIsS0FBS2IsUUFBQUEsQ0FBQUE7VUFDNUMsSUFBVSxDQUFBLFFBQUEwRixPQUFPQyxTQUFBQSxDQUFBQSxDQUFQLENBQUEsSUFBQSxDQUFBLE1BQWdCRCxPQUFoQixFQUEyQjdFLEtBQUtxQixJQUFBQSxDQUFBQSxDQUFoQyxDQUFBLENBQUEsQ0FBVjtZQUFBLE9BQUE7VUFBQTtVQUVrQjNDLE1BQWxCa0csU0FBU25ELFVBQUFBLENBQUFBLENBQVMvQyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFsQnFHLGNBQTBCcEYsUUFBRCxFQUFXaEMsS0FBcENvSCxFQUFBQzs7O1lBQTBCO1lBQVU7WUFDbEMsSUFBQSxRQUFHSCxPQUFRZixPQUFBQSxDQUFHbkUsUUFBSG1FLENBQVgsQ0FBQTs7Y0FDRW1CLE9BQVNqRixLQUFLa0YsS0FBQUEsQ0FBQUE7Y0FDZEQsSUFBR0UsUUFBQUEsQ0FBTU4sT0FBTk07Y0FFSEgsT0FBS3BILE1BQUxELEtBQUtDLFFBQUFBLEVBQUwsQ0FBV3FILElBQVgsQ0FBQSxRQUFnQixNQUFDQSxJQUFHNUUsV0FBQUEsQ0FBQUEsQ0FBSixDQUFoQixDQUFLekM7WUFKUDtjQS9iUm9ILE9BQUE7WUErYlEsRUFERkQsQ0FBQUEsR0FBa0JyRztVQVNsQm1DLE9BQUF6RCxJQUFBeUQsVUFBQUEsQ0FBUytELFNBQVQsRUFBb0I1RSxLQUFwQixFQUEyQjZFLE9BQU9PLFFBQUFBLENBQUFBLENBQWxDdkU7UUFaRkEsQ0FBQUEsSUFBQUE7TUEvWkYzQyxHQUFBQSxXQUFBQTtJQTFCRmYsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFGQUQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1MjY0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9jdXN0b20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnb3N0cnVjdCdcblxubW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEN1c3RvbSA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuQ3VzdG9tJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCB2YWx1ZSlcbiAgICAgIGlmIG5hbWUuZW5kX3dpdGg/ID89XG4gICAgICAgIGAjQG5hdGl2ZVsje25hbWVbMCAuLiAtMl19XSA9IHZhbHVlYFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgICAgYnViYmxlczogICAgZGVzYy5idWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgIGRldGFpbDogICAgIGRlc2MgfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSwgZGVzYyk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY3JlYXRlT2JqZWN0J1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgTmF0aXZlKGBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpYCkubWVyZ2UhKGB7XG4gICAgICAgIHR5cGU6ICAgICAgIG5hbWUsXG4gICAgICAgIGJ1YmJsZXM6ICAgIGRlc2MuYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICBkZXRhaWw6ICAgICBkZXNjIH1gKS50b19uXG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIE5hdGl2ZShkZXNjKS5tZXJnZSEoYHtcbiAgICAgICAgdHlwZTogICAgICAgbmFtZSxcbiAgICAgICAgYnViYmxlczogICAgZGVzYy5idWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgIGRldGFpbDogICAgIGRlc2MgfWApLnRvX25cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZXZlbnQsIGNhbGxiYWNrID0gbmlsKVxuICAgIHN1cGVyKGV2ZW50LCBjYWxsYmFjaylcblxuICAgIEBkZXRhaWwgPSBIYXNoLm5ldyhgI3tldmVudH0uZGV0YWlsYClcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKGlkLCAqKVxuICAgIHJldHVybiBAZGV0YWlsW2lkXSBpZiBAZGV0YWlsLmhhc19rZXk/KGlkKVxuXG4gICAgc3VwZXJcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpDdXN0b20+Iiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJtZXRob2RfbWlzc2luZyIsIm5hbWUiLCJ2YWx1ZSIsImVuZF93aXRoPyIsIkBuYXRpdmUiLCJbXSIsIjAiLCItMiIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJkZXNjIiwiTmF0aXZlIiwibWVyZ2UhIiwidG9fbiIsImluaXRpYWxpemUiLCJldmVudCIsImNhbGxiYWNrIiwiQGRldGFpbCIsIkhhc2giLCJuZXciLCJpZCIsImhhc19rZXk/IiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsU0FBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsTUFBSUwsSUFBSkssaUJBQUFBLGtDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixjQUFYRTtRQURURixDQUFBQSxHQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBO1VBQ0VBLE9BQUFDLDhCQUFBQSwwQkFBbUJDLElBQUQsRUFBT0MsS0FBekJGO0FBQUFBLFlBQUFBOztZQUNFLElBQUEsUUFBR0MsSUFBSUUsY0FBQUEsQ0FBV0gsR0FBWEcsQ0FBUCxDQUFBO2NBQ0VILE9BQUVJLGNBQU9KLENBQUdDLElBQUlJLE9BQUFBLENBQUMsT0FBQUMsQ0FBQSxFQUFLQyxFQUFMLFFBQURGLENBQVVMO1lBRDVCO2NBWE5BLE9BQUE7WUFXTTtVQURGQSxDQUFBQSxHQUFBQTtRQURGRCxHQUFBQSxXQUFBQSxFQUFtQlMsZ0JBQW5CVDtRQVFBLElBQUEsUUFBR0YsYUFBT0MsY0FBQUEsQ0FBV0gsbUJBQVhHLENBQVYsQ0FBQTtVQUNFVyxNQUFJbEIsSUFBSmtCLGdCQUFBQSxxQkFBbUJSLElBQUQsRUFBT1MsSUFBekJEO0FBQUFBO1lBQ0dBO0FBQ1BBO0FBQ0FBO0FBQ0FBO1VBSklBLENBQUFBLEdBQUFBO1FBREYsT0FPQSxJQUFBLFFBQU1aLGFBQU9DLGNBQUFBLENBQVdILGNBQVhHLENBQWIsQ0FBQTtVQUNFVyxNQUFJbEIsSUFBSmtCLGdCQUFBQSxxQkFBbUJSLElBQUQsRUFBT1MsSUFBekJEO0FBQUFBOztBQUVKQTtBQUNBQTs7QUFFQUE7QUFDQUE7VUFOSUEsQ0FBQUEsR0FBQUE7UUFERixPQVNBLElBQUEsUUFBTVosYUFBT0MsY0FBQUEsQ0FBV0gsb0JBQVhHLENBQWIsQ0FBQTtVQUNFVyxNQUFJbEIsSUFBSmtCLGdCQUFBQSxxQkFBbUJSLElBQUQsRUFBT1MsSUFBekJEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBbEIsSUFBQW9CLFFBQUFBLENBQVFGLDRCQUFSRSxDQUFzQ0MsV0FBQUEsQ0FBU0g7QUFDckRBO0FBQ0FBO0FBQ0FBO0FBQ0FBLDBCQUo0Q0csQ0FJaEJDLE1BQUFBLENBQUFBO1VBTHhCSixDQUFBQSxHQUFBQTtRQURGO1VBU0VBLE1BQUlsQixJQUFKa0IsZ0JBQUFBLHFCQUFtQlIsSUFBRCxFQUFPUyxJQUF6QkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFsQixJQUFBb0IsUUFBQUEsQ0FBT0QsSUFBUEMsQ0FBWUMsV0FBQUEsQ0FBU0g7QUFDM0JBO0FBQ0FBO0FBQ0FBO0FBQ0FBLDBCQUprQkcsQ0FJVUMsTUFBQUEsQ0FBQUE7VUFMeEJKLENBQUFBLEdBQUFBO1FBVEY7O0FBa0JBSyxRQUFBQSwwQkFBQUEsc0JBQWVDLEtBQUQsRUFBUUMsUUFBdEJGO0FBQUFBLFVBQUFBOztVQUFBQTs7VUFBc0IsaUNBQVc7VUFDL0IsT0FBQXZCLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTXdCLEtBQU4sRUFBYUMsUUFBYixDQUFBLEVBQUEsSUFBQTtVQUVBRixPQUFBRyxDQUFBQSxjQUFVQyxVQUFJQyxLQUFBQSxDQUFRSixLQUFNRCxPQUFkSyxDQUFkRjtRQUhGSCxDQUFBQSxJQUFBQTtRQU1BbkIsT0FBQUssOEJBQUFBLDBCQUFtQm9CLEVBQUQsRUF6RHBCLEVBeURFcEI7QUFBQUEsVUFBQUE7O1VBQUFBOztVQXpERjtVQXlEeUI7VUFDckIsSUFBQSxRQUFzQmlCLFdBQU9JLGFBQUFBLENBQVVELEVBQVZDLENBQTdCLENBQUE7WUFBQSxPQUFPSixXQUFPWixPQUFBQSxDQUFDZSxFQUFEZjtVQUFkO1VBRUFMLE9BQUEsT0FBQVQsSUFBQSxFQUFBLGtFQUFBLGtCQUFBLEVBQUEsQ0FBQTZCLEVBQUEsQ0FBQSxRQUFBLE1BQUEsU0FBQSxDQUFBLENBQUEsRUFBQSxNQUFBO1FBSEZwQixDQUFBQSxJQUFBQTtNQXJERkwsR0FBQUEsV0FBQUEsRUFBZTJCLFdBQWYzQjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNTM3MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvd2luZG93L3NpemUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIFdpbmRvd1xuXG4jIEFsbG93cyBhY2Nlc3MgYW5kIG1hbmlwdWxhdGlvbiBvZiB0aGUge1dpbmRvd30gc2l6ZS5cbmNsYXNzIFNpemVcbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZSh3aW5kb3cpXG4gICAgQHdpbmRvdyA9IHdpbmRvd1xuICAgIEBuYXRpdmUgPSB3aW5kb3cudG9fblxuICBlbmRcblxuICBkZWYgc2V0KCphcmdzKVxuICAgIGlmIEhhc2ggPT09IGFyZ3MuZmlyc3RcbiAgICAgIHdpZHRoLCBoZWlnaHQgPSBhcmdzLmZpcnN0LnZhbHVlc19hdCg6d2lkdGgsIDpoZWlnaHQpXG4gICAgZWxzZVxuICAgICAgd2lkdGgsIGhlaWdodCA9IGFyZ3NcbiAgICBlbmRcblxuICAgIHdpZHRoICB8fD0gc2VsZi53aWR0aFxuICAgIGhlaWdodCB8fD0gc2VsZi5oZWlnaHRcblxuICAgIGAjQG5hdGl2ZS5yZXNpemVUbygje3dpZHRofSwgI3toZWlnaHR9KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSB3aWR0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSB3aWR0aCBvZiB0aGUgd2luZG93XG5cbiAgIyBAIWF0dHJpYnV0ZSBoZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgaGVpZ2h0IG9mIHRoZSB3aW5kb3dcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnV2luZG93Lm91dGVyU2l6ZSdcbiAgICBkZWYgd2lkdGhcbiAgICAgIGAjQG5hdGl2ZS5vdXRlcldpZHRoYFxuICAgIGVuZFxuXG4gICAgZGVmIGhlaWdodFxuICAgICAgYCNAbmF0aXZlLm91dGVySGVpZ2h0YFxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIHdpZHRoXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnd2luZG93IG91dGVyIHNpemUgbm90IHN1cHBvcnRlZCdcbiAgICBlbmRcblxuICAgIGRlZiBoZWlnaHRcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICd3aW5kb3cgb3V0ZXIgc2l6ZSBub3Qgc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgd2lkdGg9KHZhbHVlKVxuICAgIHNldCh3aWR0aDogdmFsdWUpXG4gIGVuZFxuXG4gIGRlZiBoZWlnaHQ9KHZhbHVlKVxuICAgIHNldChoZWlnaHQ6IHZhbHVlKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIGlubmVyX3dpZHRoXG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIGlubmVyIHdpZHRoIG9mIHRoZSB3aW5kb3dcblxuICBkZWYgaW5uZXJfd2lkdGhcbiAgICBgI0BuYXRpdmUuaW5uZXJXaWR0aGBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBpbm5lcl9oZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgaW5uZXIgaGVpZ2h0IG9mIHRoZSB3aW5kb3dcblxuICBkZWYgaW5uZXJfaGVpZ2h0XG4gICAgYCNAbmF0aXZlLmlubmVySGVpZ2h0YFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOldpbmRvdz4iLCI8Y2xhc3M6U2l6ZT4iLCJpbml0aWFsaXplIiwid2luZG93IiwiQHdpbmRvdyIsIkBuYXRpdmUiLCJ0b19uIiwic2V0IiwiSGFzaCIsImFyZ3MiLCJmaXJzdCIsInZhbHVlc19hdCIsIndpZHRoIiwiaGVpZ2h0IiwiJHJldF9vcl8xIiwic2VsZiIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ3aWR0aD0iLCJ2YWx1ZSIsImhlaWdodD0iLCJpbm5lcl93aWR0aCIsImlubmVyX2hlaWdodCJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFHaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7OztBQUVFQyxRQUFBQSwwQkFBQUEsc0JBQWVDLE1BQWZEO0FBQUFBLFVBQUFBOzs7VUFDRUUsY0FBVUQ7VUFDVkQsT0FBQUcsQ0FBQUEsaUJBQVVGLE1BQU1HLE1BQUFBLENBQUFBLENBQWhCRDtRQUZGSCxDQUFBQSxHQUFBQTs7QUFLQUssUUFBQUEsbUJBQUFBLGVBVkYsRUFVRUE7QUFBQUEsVUFBQUE7OztVQVZGO1VBVVU7VUFDTixJQUFBLFFBQUdDLFVBQUgsRUFBWUMsSUFBSUMsT0FBQUEsQ0FBQUEsQ0FBaEIsQ0FBQTtZQUNFLEtBQWdCRCxJQUFJQyxPQUFBQSxDQUFBQSxDQUFNQyxXQUFBQSxDQUFXLE9BQXJCLEVBQTZCLFFBQW5CQSxDQUExQixrQkFBQSxFQUFBQyxDQUFBQSxRQUFBLDZCQUFBQSxDQUFBLEVBQU9DLENBQUFBLFNBQVAsNkJBQU9BLENBQVA7VUFERjtZQUdFLEtBQWdCSixJQUFoQixrQkFBQSxFQUFBRyxDQUFBQSxRQUFBLDZCQUFBQSxDQUFBLEVBQU9DLENBQUFBLFNBQVAsNkJBQU9BLENBQVA7VUFIRjtVQU1BRCxRQWpCSixDQUFBLFFBQUFFLENBQUFBLFlBaUJJRixLQWpCSkUsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FpQmVDLElBQUlILE9BQUFBLENBQUFBLENBakJuQixDQUFBO1VBa0JJQyxTQWxCSixDQUFBLFFBQUFDLENBQUFBLFlBa0JJRCxNQWxCSkMsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FrQmVDLElBQUlGLFFBQUFBLENBQUFBLENBbEJuQixDQUFBO1VBb0JNUixjQUFPRSxVQUFZSyxLQUFNTCxFQUFJTSxNQUFPTjtVQUV0Q0EsT0FBQVE7UUFaRlIsQ0FBQUEsSUFBQUE7UUFxQkEsSUFBQSxRQUFHUyxhQUFPQyxjQUFBQSxDQUFXaEIsa0JBQVhnQixDQUFWLENBQUE7OztBQUNFTCxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFUCxjQUFPTztVQURYQSxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRVIsY0FBT1E7VUFEWEEsQ0FBQUEsR0FBQUE7UUFMRjs7O0FBU0VELFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFHLElBQUFHLE9BQUFBLENBQU1DLHlCQUFOLEVBQTJCUCxpQ0FBM0JNO1VBREZOLENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBRSxJQUFBRyxPQUFBQSxDQUFNQyx5QkFBTixFQUEyQk4saUNBQTNCSztVQURGTCxDQUFBQSxHQUFBQTtRQWJGOztBQWtCQU8sUUFBQUEsc0JBQUFBLDBCQUFXQyxLQUFYRDtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUwsSUFBQVIsS0FBQUEsQ0FBSSxtQkFBQSxTQUFPYyxLQUFQLEVBQUpkO1FBREZhLENBQUFBLEdBQUFBOztBQUlBRSxRQUFBQSx1QkFBQUEsMkJBQVlELEtBQVpDO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBUCxJQUFBUixLQUFBQSxDQUFJLG9CQUFBLFVBQVFjLEtBQVIsRUFBSmQ7UUFERmUsQ0FBQUEsR0FBQUE7O0FBT0FDLFFBQUFBLDJCQUFBQSx1QkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVsQixjQUFPa0I7UUFEWEEsQ0FBQUEsR0FBQUE7UUFPQXRCLE9BQUF1Qiw0QkFBQUEsd0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFbkIsY0FBT21CO1FBRFhBLENBQUFBLEdBQUFBO01BaEVGdkIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFIZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzU0NzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L3VpLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBVSSA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuVUknXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGRldGFpbD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGV0YWlsID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgdmlldz0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudmlldyA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFVJRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJVSUV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdFVJRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2MudmlldyB8fCB3aW5kb3csIGRlc2MuZGV0YWlsIHx8IDApO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmRldGFpbFxuICBhbGlhc19uYXRpdmUgOnZpZXdcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpVST4iLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJkZXRhaWw9IiwidmFsdWUiLCJAbmF0aXZlIiwidmlldz0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLE1BQUlDLElBQUpELGlCQUFBQSw4QkFBQUE7QUFBQUE7VUFDRUEsT0FBQUUsYUFBT0MsY0FBQUEsQ0FBV0gsVUFBWEc7UUFEVEgsQ0FBQUEsR0FBQUE7UUFJQUk7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLHVCQUFBQSxpQ0FBWUMsS0FBWkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLFVBQVlDO1VBRHZCRCxDQUFBQSxHQUFBQTtVQUlBRCxPQUFBSSxxQkFBQUEsK0JBQVVGLEtBQVZFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxRQUFVRjtVQURyQkUsQ0FBQUEsR0FBQUE7UUFMRkosR0FBQUEsV0FBQUEsRUFBbUJLLGdCQUFuQkw7UUFVQSxJQUFBLFFBY09ILElBQUFELGVBQUFBLENBQUFBLENBZFAsQ0FBQTtVQUFBLElBQUEsUUFBR0UsYUFBT0MsY0FBQUEsQ0FBV0osbUJBQVhJLENBQVYsQ0FBQTtZQUNFTyxNQUFJVCxJQUFKUyxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxZQUFjQyxJQUFLRCxFQUFJRSxJQUFLRjtZQUQvQkEsQ0FBQUEsR0FBQUE7VUFERixPQUlBLElBQUEsUUFBTVIsYUFBT0MsY0FBQUEsQ0FBV0osY0FBWEksQ0FBYixDQUFBO1lBQ0VPLE1BQUlULElBQUpTLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBOztBQUVKQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7WUFQSUEsQ0FBQUEsR0FBQUE7VUFERjtRQUpBO1FBZ0JBVCxJQUFBWSxjQUFBQSxDQUFhLFFBQWJBO1FBQ0FkLE9BQUFFLElBQUFZLGNBQUFBLENBQWEsTUFBYkE7TUFoQ0ZkLEdBQUFBLFdBQUFBLEVBQVdlLFdBQVhmO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1NTQ1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZG9jdW1lbnRfZnJhZ21lbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBUT0RPOiBEb2N1bWVudEZyYWdtZW50IGlzIG5vdCBhIHN1YmNsYXNzIG9mIEVsZW1lbnQsIGJ1dFxuIyAgICAgICBhIHN1YmNsYXNzIG9mIE5vZGUuIEl0IGltcGxlbWVudHMgYSBQYXJlbnROb2RlLlxuI1xuIyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwtYnJvd3Nlci9wdWxsLzQ2XG5jbGFzcyBEb2N1bWVudEZyYWdtZW50IDwgRWxlbWVudFxuICBkZWYgc2VsZi5uZXcobm9kZSlcbiAgICBpZiBzZWxmID09IERvY3VtZW50RnJhZ21lbnRcbiAgICAgIGlmIGRlZmluZWQ/IGAje25vZGV9Lm1vZGVgXG4gICAgICAgIFNoYWRvd1Jvb3QubmV3KG5vZGUpXG4gICAgICBlbHNlXG4gICAgICAgIHN1cGVyXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5jcmVhdGVcbiAgICAkZG9jdW1lbnQuY3JlYXRlX2RvY3VtZW50X2ZyYWdtZW50XG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RG9jdW1lbnRGcmFnbWVudD4iLCJuZXciLCJzZWxmIiwibm9kZSIsIkRvY3VtZW50RnJhZ21lbnQiLCJTaGFkb3dSb290IiwiY3JlYXRlIiwiJGRvY3VtZW50IiwiY3JlYXRlX2RvY3VtZW50X2ZyYWdtZW50IiwiRWxlbWVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLGdEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFNaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLE1BQUlDLElBQUpELFVBQUFBLGlDQUFhRSxJQUFiRjtBQUFBQSxVQUFBQTs7VUFBQUE7VUFDRSxJQUFBLE1BQUdDLElBQUgsRUFBV0Usc0JBQVgsQ0FBQTtZQUNFLElBQUEsUUFBRyxRQUFZRCxJQUFLRixLQUFqQixrQkFBSCxDQUFBO2NBQ0VBLE9BQUFJLGdCQUFVSixLQUFBQSxDQUFLRSxJQUFMRjtZQURaO2NBR0VBLE9BQUEsT0FBQUMsSUFBQSxFQUFBLDhEQUFBLE9BQUEsRUFBQSxDQUFBQyxJQUFBLENBQUEsRUFBQSxNQUFBO1lBSEY7VUFERjtZQU9FRixPQUFBLE9BQUFDLElBQUEsRUFBQSw4REFBQSxPQUFBLEVBQUEsQ0FBQUMsSUFBQSxDQUFBLEVBQUEsTUFBQTtVQVBGO1FBREZGLENBQUFBLEdBQUFBO1FBWUFELE9BQUFNLE1BQUlKLElBQUpJLGFBQUFBLGtCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUMsZUFBU0MsMEJBQUFBLENBQUFBO1FBRFhGLENBQUFBLEdBQUFBO01BYkZOLEdBQUFBLFdBQUFBLEVBQXlCUyxhQUF6QlQ7SUFOZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzU1ODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9ub2RlX3NldC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG4jIEFsbG93cyBtYW5pcHVsYXRpb24gb2YgYSBzZXQgb2Yge05vZGV9cy5cbmNsYXNzIE5vZGVTZXRcbiAgIyBDcmVhdGUgYSBuZXcge05vZGVTZXR9IGZyb20gdGhlIGdpdmVuIG5vZGVzLlxuICAjXG4gICMgTm90ZSB0aGF0IHRoZSBub2RlcyBhcmUgZmxhdHRlbmVkIGFuZCBjb252ZXJ0ZWQgd2l0aCBET00gYXV0b21hdGljYWxseSxcbiAgIyB0aGlzIG1lYW5zIHlvdSBjYW4gcGFzcyB7Tm9kZVNldH1zIGFuZCB7TmF0aXZlOjpBcnJheX1zIGFzIHdlbGwuXG4gIGRlZiBzZWxmLltdKCpub2RlcylcbiAgICBuZXcobm9kZXMuZmxhdHRlbi5tYXAgeyB8eHwgRE9NKE5hdGl2ZS5jb252ZXJ0KHgpKSB9LnVuaXEpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGxpdGVyYWwpXG4gICAgQGxpdGVyYWwgPSBsaXRlcmFsXG4gIGVuZFxuXG4gICMgQW55IG90aGVyIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBub2RlIGluIHRoZSBzZXQuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIHVubGVzcyBAbGl0ZXJhbC5yZXNwb25kX3RvPyBuYW1lXG4gICAgICBlYWNoIHt8ZWx8XG4gICAgICAgIGVsLl9fc2VuZF9fKG5hbWUsICphcmdzLCAmYmxvY2spXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZW5kXG5cbiAgICByZXN1bHQgPSBAbGl0ZXJhbC5fX3NlbmRfXyBuYW1lLCAqYXJncywgJmJsb2NrXG5cbiAgICBpZiBgcmVzdWx0ID09PSAjQGxpdGVyYWxgXG4gICAgICBzZWxmXG4gICAgZWxzaWYgQXJyYXkgPT09IHJlc3VsdFxuICAgICAgTm9kZVNldC5uZXcocmVzdWx0KVxuICAgIGVsc2VcbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhuYW1lLCAqKVxuICAgIEBsaXRlcmFsLnJlc3BvbmRfdG8/KG5hbWUpXG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3JzLlxuICAjXG4gICMgQHBhcmFtIHJ1bGVzIFtBcnJheTxTdHJpbmc+XSB0aGUgQ1NTIHNlbGVjdG9ycyB0byBtYXRjaCB3aXRoXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlP11cbiAgZGVmIGF0X2NzcygqcnVsZXMpXG4gICAgZWFjaCB7fG5vZGV8XG4gICAgICBpZiBub2RlID0gbm9kZS5hdF9jc3MoKnJ1bGVzKVxuICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBYUGF0aC5cbiAgI1xuICAjIEBwYXJhbSBwYXRocyBbQXJyYXk8U3RyaW5nPl0gdGhlIFhQYXRoIHRvIG1hdGNoIHdpdGhcbiAgI1xuICAjIEByZXR1cm4gW05vZGU/XVxuICBkZWYgYXRfeHBhdGgoKnBhdGhzKVxuICAgIGVhY2gge3xub2RlfFxuICAgICAgaWYgbm9kZSA9IG5vZGUuYXRfeHBhdGgoKnBhdGhzKVxuICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gICMgUXVlcnkgZm9yIGNoaWxkcmVuIG1hdGNoaW5nIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gICNcbiAgIyBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgQ1NTIHNlbGVjdG9yXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlU2V0XVxuICBkZWYgY3NzKHBhdGgpXG4gICAgTm9kZVNldFtAbGl0ZXJhbC5tYXAge3xub2RlfFxuICAgICAgbm9kZS5jc3MocGF0aClcbiAgICB9XVxuICBlbmRcblxuICAjIENyZWF0ZSBhbm90aGVyIHtOb2RlU2V0fSB3aXRoIGFsbCB0aGUgbm9kZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW5cbiAgIyBleHByZXNzaW9uLlxuICAjXG4gICMgQHBhcmFtIGV4cHJlc3Npb24gW1N0cmluZ10gYSBDU1Mgc2VsZWN0b3JcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSBuZXcge05vZGVTZXR9IHdpdGggdGhlIG1hdGNoaW5nIG5vZGVzXG4gIGRlZiBmaWx0ZXIoZXhwcmVzc2lvbilcbiAgICBOb2RlU2V0W0BsaXRlcmFsLnNlbGVjdCB7IHxub2RlfCBub2RlID1+IGV4cHJlc3Npb24gfV1cbiAgZW5kXG5cbiAgIyBTZWFyY2ggZm9yIG11bHRpcGxlIHNlbGVjdG9yc1xuICBkZWYgc2VhcmNoKCp3aGF0KVxuICAgIE5vZGVTZXRbQGxpdGVyYWwubWFwIHsgfG5vZGV8IG5vZGUuc2VhcmNoKCp3aGF0KSB9XVxuICBlbmRcblxuICAjIE91dGVyIEhUTUwgb2YgdGhlIGVudGlyZSBub2Rlc2V0XG4gIGRlZiBvdXRlcl9odG1sXG4gICAgQGxpdGVyYWwubWFwKCY6b3V0ZXJfaHRtbCkuam9pblxuICBlbmRcblxuICAjIFF1ZXJ5IGZvciBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gWFBhdGguXG4gICNcbiAgIyBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgWFBhdGhcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdXG4gIGRlZiB4cGF0aChwYXRoKVxuICAgIE5vZGVTZXRbQGxpdGVyYWwubWFwIHt8bm9kZXxcbiAgICAgIG5vZGUueHBhdGgocGF0aClcbiAgICB9XVxuICBlbmRcblxuICBkZWYgdG9fYXJ5XG4gICAgQGxpdGVyYWxcbiAgZW5kXG5cbiAgYWxpYXMgdG9fYSB0b19hcnlcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOk5vZGVTZXQ+IiwiW10iLCJzZWxmIiwibmV3IiwibWFwIiwibm9kZXMiLCJmbGF0dGVuIiwiYmxvY2sgaW4gW10iLCJ4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBbXSIsIkRPTSIsIk5hdGl2ZSIsImNvbnZlcnQiLCJ1bmlxIiwiaW5pdGlhbGl6ZSIsIm1ldGhvZF9taXNzaW5nIiwibmFtZSIsIkBsaXRlcmFsIiwicmVzcG9uZF90bz8iLCJlYWNoIiwiYmxvY2sgaW4gbWV0aG9kX21pc3NpbmciLCJlbCIsImJsb2NrICgyIGxldmVscykgaW4gbWV0aG9kX21pc3NpbmciLCJfX3NlbmRfXyIsImFyZ3MiLCJibG9jayIsInRvX3Byb2MiLCJyZXN1bHQiLCJBcnJheSIsIk5vZGVTZXQiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiYXRfY3NzIiwiYmxvY2sgaW4gYXRfY3NzIiwibm9kZSIsInJ1bGVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhdF9jc3MiLCJhdF94cGF0aCIsImJsb2NrIGluIGF0X3hwYXRoIiwicGF0aHMiLCJibG9jayAoMiBsZXZlbHMpIGluIGF0X3hwYXRoIiwiY3NzIiwicGF0aCIsImJsb2NrIGluIGNzcyIsImJsb2NrICgyIGxldmVscykgaW4gY3NzIiwiZmlsdGVyIiwiZXhwcmVzc2lvbiIsInNlbGVjdCIsImJsb2NrIGluIGZpbHRlciIsImJsb2NrICgyIGxldmVscykgaW4gZmlsdGVyIiwiPX4iLCJzZWFyY2giLCJibG9jayBpbiBzZWFyY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHNlYXJjaCIsIndoYXQiLCJvdXRlcl9odG1sIiwiam9pbiIsInhwYXRoIiwiYmxvY2sgaW4geHBhdGgiLCJibG9jayAoMiBsZXZlbHMpIGluIHhwYXRoIiwidG9fYXJ5Il0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUdoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFLRUMsTUFBSUMsSUFBSkQsU0FBQUEsdUJBUkYsRUFRRUE7QUFBQUEsVUFBQUE7OztVQVJGO1VBUWM7VUFDVkEsT0FBQUMsSUFBQUMsS0FBQUEsQ0FBaUJDLE1BQWJDLEtBQUtDLFNBQUFBLENBQUFBLENBQVFGLE9BQUFBLEVBQUFBLEVBQUFBLEVBQWJHLGFBQXFCQyxDQUFyQkQsRUFBQUU7OztZQUFxQjtZQUFHQSxPQUFBUCxJQUFBUSxLQUFBQSxDQUFJQyxZQUFNQyxTQUFBQSxDQUFTSixDQUFUSSxDQUFWRixFQUF4Qkgs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QSxhQUFNLE1BQU4sRUFBVyxRQUFYO01BbEhGQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUhnQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNTc1MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vYnVmZmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ25hdGl2ZSdcbnJlcXVpcmUgJ2J1ZmZlci9hcnJheSdcbnJlcXVpcmUgJ2J1ZmZlci92aWV3J1xuXG5jbGFzcyBCdWZmZXJcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgISQkWzpBcnJheUJ1ZmZlcl0ubmlsP1xuICBlbmRcblxuICBkZWYgc2VsZi5uYW1lX2ZvcihiaXRzLCB0eXBlKVxuICAgIHBhcnQgPSBjYXNlIHR5cGVcbiAgICAgICAgICAgd2hlbiA6dW5zaWduZWQgdGhlbiAnVWludCdcbiAgICAgICAgICAgd2hlbiA6c2lnbmVkICAgdGhlbiAnSW50J1xuICAgICAgICAgICB3aGVuIDpmbG9hdCAgICB0aGVuICdGbG9hdCdcbiAgICAgICAgICAgZW5kXG4gICAgXCIje3BhcnR9I3tiaXRzfVwiXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHNpemUsIGJpdHMgPSA4KVxuICAgIGlmIG5hdGl2ZT8oc2l6ZSlcbiAgICAgIHN1cGVyKHNpemUpXG4gICAgZWxzZVxuICAgICAgc3VwZXIoYG5ldyBBcnJheUJ1ZmZlcihzaXplICogKGJpdHMgLyA4KSlgKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYCN7QG5hdGl2ZX0uYnl0ZUxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIHRvX2EoYml0cyA9IDgsIHR5cGUgPSA6dW5zaWduZWQpXG4gICAgQXJyYXkubmV3KHNlbGYsIGJpdHMsIHR5cGUpXG4gIGVuZFxuXG4gIGRlZiB2aWV3KG9mZnNldCA9IG5pbCwgbGVuZ3RoID0gbmlsKVxuICAgIFZpZXcubmV3KHNlbGYsIG9mZnNldCwgbGVuZ3RoKVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIHRvX2EudG9fYS5wYWNrKCdjKicpXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6QnVmZmVyPiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJzdXBwb3J0ZWQ/IiwiJCQiLCJbXSIsIm5pbD8iLCIhIiwibmFtZV9mb3IiLCJiaXRzIiwidHlwZSIsInBhcnQiLCIkcmV0X29yXzEiLCJpbml0aWFsaXplIiwic2l6ZSIsIjgiLCJuYXRpdmU/IiwibGVuZ3RoIiwiQG5hdGl2ZSIsInRvX2EiLCJBcnJheSIsIm5ldyIsInZpZXciLCJvZmZzZXQiLCJWaWV3IiwidG9fcyIsInBhY2siXSwibWFwcGluZ3MiOiJBQUFBQSx5QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsUUFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsYUFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsSUFBQUMsWUFBQUQsWUFBUkQ7SUFFQUcsTUFBSU4sSUFBSk0saUJBQUFBLGtDQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0MsUUFBRUMsT0FBQUEsQ0FBQyxhQUFEQSxDQUFjQyxTQUFBQSxDQUFBQSxDQUFqQkMsTUFBQUEsQ0FBQUE7SUFERkosQ0FBQUEsR0FBQUE7SUFJQUssTUFBSVgsSUFBSlcsZUFBQUEsb0JBQWtCQyxJQUFELEVBQU9DLElBQXhCRjtBQUFBQSxNQUFBQTs7O01BQ0VHLE9BQ08sQ0FBQSxRQUFLLFVBQUwsRUFEQUMsQ0FBQUEsWUFBS0YsSUFBTEUsQ0FDQSxDQUFBLEdBQUEsQ0FBb0JKLE1BQXBCLElBQ0EsQ0FBQSxRQUFLLFFBQUwsRUFkWCxTQWNXLENBQUEsR0FBQSxDQUFvQkEsS0FBcEIsSUFDQSxDQUFBLFFBQUssT0FBTCxFQWZYLFNBZVcsQ0FBQSxHQUFBLENBQW9CQSxPQUFwQixJQUFBLENBSEEsR0FHQSxDQUFBLENBREEsQ0FEQTtNQUlQQSxPQUFBLEVBQUEsR0FBQSxDQUFHRyxJQUFILENBQUEsR0FBQSxDQUFVRixJQUFWO0lBTkZELENBQUFBLEdBQUFBOztBQVNBSyxJQUFBQSwwQkFBQUEsc0JBQWVDLElBQUQsRUFBT0wsSUFBckJJO0FBQUFBLE1BQUFBOztNQUFBQTs7TUFBcUIseUJBQU9FO01BQzFCLElBQUEsUUFBR2xCLElBQUFtQixZQUFBQSxDQUFRRixJQUFSRSxDQUFILENBQUE7UUFDRUgsT0FBQSxPQUFBaEIsSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFNaUIsSUFBTixDQUFBLEVBQUEsSUFBQTtNQURGO1FBR0VELE9BQUEsT0FBQWhCLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBT2dCLGtDQUFQLENBQUEsRUFBQSxJQUFBO01BSEY7SUFERkEsQ0FBQUEsSUFBQUE7O0FBUUFJLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUdDLGNBQVFEO0lBRGJBLENBQUFBLEdBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsZ0JBQVNWLElBQUQsRUFBV0MsSUFBbkJTO0FBQUFBLE1BQUFBOzs7TUFBUyx5QkFBT0o7TUFBRyx5QkFBTztNQUN4QkksT0FBQUMsV0FBS0MsS0FBQUEsQ0FBS3hCLElBQVYsRUFBZ0JZLElBQWhCLEVBQXNCQyxJQUFqQlc7SUFEUEYsQ0FBQUEsSUFBQUE7O0FBSUFHLElBQUFBLG9CQUFBQSxnQkFBU0MsTUFBRCxFQUFlTixNQUF2Qks7QUFBQUEsTUFBQUE7OztNQUFTLDZCQUFTO01BQUssNkJBQVM7TUFDOUJBLE9BQUFFLFVBQUlILEtBQUFBLENBQUt4QixJQUFULEVBQWUwQixNQUFmLEVBQXVCTixNQUFuQkk7SUFETkMsQ0FBQUEsSUFBQUE7O0FBSUFHLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE1QixJQUFBc0IsTUFBQUEsQ0FBQUEsQ0FBSUEsTUFBQUEsQ0FBQUEsQ0FBS08sTUFBQUEsQ0FBTUQsSUFBTkM7SUFEWEQsQ0FBQUEsR0FBQUE7SUFJQTFCLE9BQUEsYUFBTSxNQUFOLEVBQVcsUUFBWDtFQXhDRkEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFKQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1ODI3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9mb3JtX2RhdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuY2xhc3MgRm9ybURhdGFcbiAgaW5jbHVkZSBOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgbW9kdWxlIENvbnZlcnRlclxuICAgICMgRW5jb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGVuY29kZWQgZm9yIHVzYWdlIGFzIFVSSSBjb21wb25lbnRcbiAgICBkZWYgZW5jb2RlKHN0cmluZylcbiAgICAgIGBlbmNvZGVVUklDb21wb25lbnQoI3tzdHJpbmd9KWBcbiAgICBlbmRcblxuICAgICMgRGVjb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGRlY29kZWQgYXMgVVJJIGNvbXBvbmVudFxuICAgIGRlZiBkZWNvZGUoc3RyaW5nKVxuICAgICAgYGRlY29kZVVSSUNvbXBvbmVudCgje3N0cmluZ30pYFxuICAgIGVuZFxuXG4gICAgIyBFbmNvZGUgYXMgVVJJLlxuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBlbmNvZGVkIGFzIFVSSVxuICAgIGRlZiBlbmNvZGVfdXJpKHN0cmluZylcbiAgICAgIGBlbmNvZGVVUkkoI3tzdHJpbmd9KWBcbiAgICBlbmRcblxuICAgICMgRGVjb2RlIGFzIFVSSS5cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgZGVjb2RlZCBhcyBVUklcbiAgICBkZWYgZGVjb2RlX3VyaShzdHJpbmcpXG4gICAgICBgZGVjb2RlVVJJKCN7c3RyaW5nfSlgXG4gICAgZW5kXG5cbiAgICAjIEZsYXR0ZW5zIGEgaGFzaCB0byBidWlsZCBhIGZsYXQgYXJyYXksIGxhdGVyIHRvIGJlIGZvcm1hdHRlZCB0b1xuICAgICMgcHJvZHVjZSBhIG5lc3RlZCBxdWVyeS5cbiAgICAjXG4gICAgIyBUaGlzIGNvZGUgc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aCB3aGF0IFJhY2s6OlV0aWxzI2J1aWxkX25lc3RlZF9xdWVyeSBbMV1cbiAgICAjIGRvZXMuXG4gICAgI1xuICAgICMgWzFdIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWNrL3JhY2svYmxvYi9tYXN0ZXIvbGliL3JhY2svdXRpbHMucmJcbiAgICBkZWYgZmxhdHRlbih2YWx1ZSwga2V5PVwiXCIpXG4gICAgICBjYXNlIHZhbHVlXG4gICAgICB3aGVuIEhhc2hcbiAgICAgICAgb3V0ID0gW11cbiAgICAgICAgdmFsdWUuZWFjaCBkbyB8ayx2fFxuICAgICAgICAgIGsgPSBcIiN7a2V5fVsje2t9XVwiIGlmIGtleSAhPSAnJ1xuICAgICAgICAgIG91dCArPSBmbGF0dGVuKHYsaylcbiAgICAgICAgZW5kXG4gICAgICAgIG91dFxuICAgICAgd2hlbiBBcnJheVxuICAgICAgICBvdXQgPSBbXVxuICAgICAgICB2YWx1ZS5lYWNoIGRvIHx2fFxuICAgICAgICAgIGsgPSBcIiN7a2V5fVtdXCJcbiAgICAgICAgICBvdXQgKz0gZmxhdHRlbih2LGspXG4gICAgICAgIGVuZFxuICAgICAgICBvdXRcbiAgICAgIGVsc2VcbiAgICAgICAgW1trZXksdmFsdWVdXVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIENvbnZlcnRzIGEgZmxhdCBhcnJheSB0byBhIEhhc2guXG4gICAgI1xuICAgICMgVGhpcyBjb2RlIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGggd2hhdCBSYWNrOjpVdGlscyNwYXJzZV9uZXN0ZWRfcXVlcnkgWzFdXG4gICAgIyBkb2VzLlxuICAgICNcbiAgICAjIFsxXSBodHRwczovL2dpdGh1Yi5jb20vcmFjay9yYWNrL2Jsb2IvbWFzdGVyL2xpYi9yYWNrL3V0aWxzLnJiXG4gICAgZGVmIHVuZmxhdHRlbihhcnJheSlcbiAgICAgIG91dCA9IHt9XG4gICAgICBhcnJheS5lYWNoIGRvIHxrLHZ8XG4gICAgICAgIHBhdGggPSBbay5zcGxpdChcIltcIikuZmlyc3RdICsgay5zY2FuKC9cXFsoLio/KVxcXS8pLmZsYXR0ZW5cbiAgICAgICAgYyA9IG91dFxuXG4gICAgICAgIHNldCA9IHByb2MgeyB8dix3ZWFrfCB9ICMgRG8gbm90aGluZyBmb3IgdGhlIGZpcnN0IGxldmVsXG5cbiAgICAgICAgcGF0aC5lYWNoIGRvIHxpfFxuICAgICAgICAgIGNhc2UgaVxuICAgICAgICAgIHdoZW4gXCJcIiAjIEFycmF5XG4gICAgICAgICAgICBzZXQuKFtdLCB0cnVlKVxuICAgICAgICAgICAgc2V0ID0gcHJvYyBkbyB8dix3ZWFrfFxuICAgICAgICAgICAgICBjIDw8IHZcbiAgICAgICAgICAgICAgYyA9IGMubGFzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSAjIEhhc2hcbiAgICAgICAgICAgIHNldC4oe30sIHRydWUpXG4gICAgICAgICAgICBzZXQgPSBwcm9jIGRvIHx2LHdlYWt8XG4gICAgICAgICAgICAgIGNbaV0gfHw9IHZcbiAgICAgICAgICAgICAgY1tpXSA9IHYgaWYgIXdlYWtcbiAgICAgICAgICAgICAgYyA9IGNbaV1cbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgc2V0Lih2LCBmYWxzZSlcblxuICAgICAgZW5kXG4gICAgICBvdXRcbiAgICBlbmRcblxuICAgICMgQ2hlY2tzIGlmIGEgcXVlcnkgSGFzaCBjb250YWlucyBhbnkgZmlsZXMuXG4gICAgZGVmIGNvbnRhaW5fZmlsZXM/KGhhc2gpXG4gICAgICBmbGF0dGVuKGhhc2gpLmFueT8geyB8ayx2fCBbRmlsZSwgQmxvYl0uaW5jbHVkZT8odi5jbGFzcykgfVxuICAgIGVuZFxuXG4gICAgIyBDb252ZXJ0IGEgcXVlcnkgSGFzaCB0byBhIHF1ZXJ5IHN0cmluZ1xuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBlbmNvZGVkIGFzIFVSSVxuICAgIGRlZiBidWlsZF9xdWVyeShoYXNoLCBzZXA9PyYpXG4gICAgICBmbGF0dGVuKGhhc2gpLm1hcCB7IHxrLHZ8IGVuY29kZShrKSArID89ICsgZW5jb2RlKHYudG9fcykgfS5qb2luKHNlcClcbiAgICBlbmRcblxuICAgICMgQ29udmVydCBhIHF1ZXJ5IEhhc2ggdG8gYSBGb3JtRGF0YSBpbnN0YW5jZVxuICAgICNcbiAgICAjIEByZXR1cm4gW0Zvcm1EYXRhXSB0aGUgaW5zdGFuY2Ugb2YgRm9ybURhdGFcbiAgICBkZWYgYnVpbGRfZm9ybV9kYXRhKGhhc2gpXG4gICAgICBmZCA9IEZvcm1EYXRhLmNyZWF0ZVxuICAgICAgZmxhdHRlbihoYXNoKS5lYWNoIHsgfGssdnwgZmQgPDwgW2ssdl0gfVxuICAgICAgZmRcbiAgICBlbmRcblxuICAgICMgQ29udmVydCBhIHF1ZXJ5IHN0cmluZyB0byBhIHF1ZXJ5IEhhc2hcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtIYXNoXSB0aGUgcXVlcnkgaGFzaFxuICAgIGRlZiBwYXJzZV9xdWVyeShzdHJpbmcsIHNlcD0/JilcbiAgICAgIHVuZmxhdHRlbihzdHJpbmcuc3BsaXQoc2VwKS5tYXAgeyB8c3wgcy5zcGxpdCg/PSkubWFwKCZtZXRob2QoOmRlY29kZSkpIH0pXG4gICAgZW5kXG5cbiAgICAjIENvbnZlcnRzIGEgSlMgbmF0aXZlIHZhbHVlIHRvIGEgd3JhcHBlZCBvbmUgaWYgcG9zc2libGUuXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nLCBGaWxlLCBCbG9iXVxuICAgIGRlZiBmcm9tX25hdGl2ZShuKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBjID0gI3tufS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGMgPT09IEZpbGUpIHtcbiAgICAgICAgICAje24gPSBGaWxlLm5ldyhuKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBCbG9iKSB7XG4gICAgICAgICAgI3tuID0gQmxvYi5uZXcobil9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5cbiAgICBlbmRcbiAgZW5kXG5cbiAgZXh0ZW5kIENvbnZlcnRlclxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIENyZWF0ZSBhIG5ldyBGb3JtRGF0YSBpbnN0YW5jZVxuICBkZWYgc2VsZi5jcmVhdGUoaGFzaD1uaWwpXG4gICAgaWYgSGFzaCA9PT0gaGFzaFxuICAgICAgRm9ybURhdGEuYnVpbGRfZm9ybV9kYXRhKGhhc2gpXG4gICAgZWxzaWYgRE9NOjpFbGVtZW50OjpGb3JtID09PSBoYXNoXG4gICAgICBuZXcoYG5ldyBGb3JtRGF0YSgje2hhc2gudG9fbn0pYClcbiAgICBlbHNlXG4gICAgICBuZXcoYG5ldyBGb3JtRGF0YSgpYClcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBBcHBlbmQgYSB0dXBsZSB0byB0aGlzIEZvcm1EYXRhIGluc3RhbmNlXG4gICNcbiAgIyBAcGFyYW0gdHVwbGUgW0FycmF5KFN0cmluZywgU3RyaW5nKSwgQXJyYXkoU3RyaW5nLCBCbG9iKSwgQXJyYXkoU3RyaW5nLCBGaWxlKSxcbiAgIyAgICAgICAgICAgICAgIEFycmF5KFN0cmluZywgQmxvYiwgU3RyaW5nKSwgQXJyYXkoU3RyaW5nLCBGaWxlLCBTdHJpbmcpXVxuICAjICAgICAgICBhIHR1cGxlIG9mIGEga2V5LCB2YWx1ZSBhbmQgcG9zc2libHkgYSBmaWxlbmFtZVxuICBkZWYgPDwodHVwbGUpXG4gICAga2V5LCB2YWx1ZSwgZmlsZW5hbWUgPSB0dXBsZVxuXG4gICAgdW5sZXNzIGZpbGVuYW1lXG4gICAgICBgI0BuYXRpdmUuYXBwZW5kKCN7a2V5fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUuYXBwZW5kKCN7a2V5fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9LCAje2ZpbGVuYW1lfSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgR2V0IGEgZmllbGQgZnJvbSB0aGlzIEZvcm1EYXRhIGluc3RhbmNlIHdpdGggYSBnaXZlbiBuYW1lXG4gIGRlZiBbXShrZXkpXG4gICAgRm9ybURhdGEuZnJvbV9uYXRpdmUoYCNAbmF0aXZlLmdldCgje2tleX0pYClcbiAgZW5kXG5cbiAgIyBTZXQgYSBmaWVsZCBpbiB0aGlzIEZvcm1EYXRhIGluc3RhbmNlIHdpdGggYSBnaXZlbiBuYW1lXG4gIGRlZiBzZXQoa2V5LCB2YWx1ZSwgZmlsZW5hbWUgPSBuaWwpXG4gICAgdW5sZXNzIGZpbGVuYW1lXG4gICAgICBgI0BuYXRpdmUuc2V0KCN7a2V5fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUuc2V0KCN7a2V5fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9LCAje2ZpbGVuYW1lfSlgXG4gICAgZW5kXG4gIGVuZFxuICBhbGlhcyBbXT0gc2V0XG5cbiAgIyBDb252ZXJ0IHRvIGhhc2hcbiAgZGVmIHRvX2hcbiAgICBoYXNoID0ge31cbiAgICAleHtcbiAgICAgIHZhciBwYWlyLCB2LCBlID0gI0BuYXRpdmUuZW50cmllcygpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdiA9IGUubmV4dCgpO1xuICAgICAgICBpZiAodi5kb25lKSBicmVhaztcbiAgICAgICAgcGFpciA9IHYudmFsdWU7XG4gICAgICAgICN7aGFzaFtgcGFpclswXWBdID0gRm9ybURhdGEuZnJvbV9uYXRpdmUoYHBhaXJbMV1gKX1cbiAgICAgIH1cbiAgICB9XG4gICAgaGFzaFxuICBlbmRcblxuICAjIENvbnZlcnQgdG8gYXJyYXlcbiAgZGVmIHRvX2FcbiAgICB0b19oLnRvX2FcbiAgZW5kXG5cbiAgIyBJdGVyYXRlIG92ZXIgYWxsIGVsZW1lbnRzIG9mIHRoaXMgRm9ybURhdGFcbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHRvX2guZWFjaCgmYmxvY2spXG4gIGVuZFxuXG4gICMgQ2hlY2tzIGlmIGEgZmllbGQgb2YgdGhpcyBuYW1lIGV4aXN0cyBpbiB0aGlzIEZvcm1EYXRhIGluc3RhbmNlXG4gIGRlZiBpbmNsdWRlPyhrZXkpXG4gICAgYCNAbmF0aXZlLmhhcygje2tleX0pYFxuICBlbmRcblxuICAjIERlbGV0ZSBhIGZpZWxkIGZyb20gdGhpcyBGb3JtRGF0YSBpbnN0YW5jZVxuICBkZWYgZGVsZXRlKGtleSlcbiAgICBgI0BuYXRpdmUuZGVsZXRlKCN7a2V5fSlgXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkZvcm1EYXRhPiIsInNlbGYiLCJpbmNsdWRlIiwiTmF0aXZlQ2FjaGVkV3JhcHBlciIsIjxtb2R1bGU6Q29udmVydGVyPiIsImVuY29kZSIsInN0cmluZyIsImRlY29kZSIsImVuY29kZV91cmkiLCJkZWNvZGVfdXJpIiwiZmxhdHRlbiIsInZhbHVlIiwia2V5IiwiSGFzaCIsIiRyZXRfb3JfMSIsIm91dCIsImVhY2giLCJibG9jayBpbiBmbGF0dGVuIiwiayIsInYiLCJibG9jayAoMiBsZXZlbHMpIGluIGZsYXR0ZW4iLCIrIiwiQXJyYXkiLCJ1bmZsYXR0ZW4iLCJhcnJheSIsImJsb2NrIGluIHVuZmxhdHRlbiIsImJsb2NrICgyIGxldmVscykgaW4gdW5mbGF0dGVuIiwicGF0aCIsInNwbGl0IiwiZmlyc3QiLCJzY2FuIiwiYyIsInNldCIsInByb2MiLCJ3ZWFrIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiB1bmZsYXR0ZW4iLCJpIiwiY2FsbCIsIjw8IiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiB1bmZsYXR0ZW4iLCJsYXN0IiwiJHJldF9vcl8yIiwiW10iLCJbXT0iLCJjb250YWluX2ZpbGVzPyIsImhhc2giLCJhbnk/IiwiYmxvY2sgaW4gY29udGFpbl9maWxlcz8iLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbnRhaW5fZmlsZXM/IiwiRmlsZSIsIkJsb2IiLCJpbmNsdWRlPyIsImNsYXNzIiwiYnVpbGRfcXVlcnkiLCJzZXAiLCJtYXAiLCJibG9jayBpbiBidWlsZF9xdWVyeSIsImJsb2NrICgyIGxldmVscykgaW4gYnVpbGRfcXVlcnkiLCJ0b19zIiwiam9pbiIsImJ1aWxkX2Zvcm1fZGF0YSIsImZkIiwiRm9ybURhdGEiLCJjcmVhdGUiLCJibG9jayBpbiBidWlsZF9mb3JtX2RhdGEiLCJibG9jayAoMiBsZXZlbHMpIGluIGJ1aWxkX2Zvcm1fZGF0YSIsInBhcnNlX3F1ZXJ5IiwiYmxvY2sgaW4gcGFyc2VfcXVlcnkiLCJzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwYXJzZV9xdWVyeSIsIm1ldGhvZCIsInRvX3Byb2MiLCJmcm9tX25hdGl2ZSIsIm4iLCJuZXciLCJleHRlbmQiLCJDb252ZXJ0ZXIiLCJFbnVtZXJhYmxlIiwiRE9NOjpFbGVtZW50OjpGb3JtIiwiRE9NOjpFbGVtZW50IiwiRE9NIiwidG9fbiIsInR1cGxlIiwiZmlsZW5hbWUiLCJAbmF0aXZlIiwiTmF0aXZlIiwiY29udmVydCIsInRvX2giLCJ0b19hIiwiYmxvY2siLCJkZWxldGUiXSwibWFwcGluZ3MiOiJBQUFBQSxvQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBRUFBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLHlCQUFSRDtNQUVBRTtNQUFBQTs7UUFBQUE7Ozs7QUFJRUMsUUFBQUEs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InNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2RvY3VtZW50X29yX3NoYWRvd19yb290LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbiMgRG9jdW1lbnQgYW5kIFNoYWRvd1Jvb3QgaGF2ZSBzb21lIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgaW4gY29tbW9uLlxuIyBUaGlzIHNvbHV0aW9uIG1pbWljcyBob3cgaXQncyBkb25lIGluIERPTS5cbiNcbiMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRPclNoYWRvd1Jvb3Rcbm1vZHVsZSBEb2N1bWVudE9yU2hhZG93Um9vdFxuICAjIEAhYXR0cmlidXRlIFtyXSBzdHlsZV9zaGVldHNcbiAgIyBAcmV0dXJuIFtBcnJheTxDU1M6OlN0eWxlU2hlZXQ+XSB0aGUgc3R5bGUgc2hlZXRzIGZvciB0aGUgZG9jdW1lbnRcbiAgZGVmIHN0eWxlX3NoZWV0c1xuICAgIE5hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5zdHlsZVNoZWV0c2ApIHt8ZXxcbiAgICAgIENTUzo6U3R5bGVTaGVldC5uZXcoZSlcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHN0eWxlc2hlZXRzIHN0eWxlX3NoZWV0c1xuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8bW9kdWxlOkRvY3VtZW50T3JTaGFkb3dSb290PiIsInN0eWxlX3NoZWV0cyIsIm5ldyIsIk5hdGl2ZTo6QXJyYXkiLCJOYXRpdmUiLCJAbmF0aXZlIiwiYmxvY2sgaW4gc3R5bGVfc2hlZXRzIiwiZSIsImJsb2NrICgyIGxldmVscykgaW4gc3R5bGVfc2hlZXRzIiwiQ1NTOjpTdHlsZVNoZWV0IiwiQ1NTIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0RBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQU1oQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7O0FBR0VDLFFBQUFBLDRCQUFBQSx3QkFBQUE7QUFBQUEsVUFBQUE7QUFBQUE7O1VBQ0VBLE9BQWFDLE1BQWJDLElBQUFDLFlBQUFELFVBQWFELE9BQUFBLEVBQUFBLENBQU9HLGNBQU9KLFlBQWRDLENBQUFBLEVBQWJJLGFBQTRDQyxDQUE1Q0Q7O1lBQTRDO1lBQzFDRSxPQUFBQyxJQUFBQyxTQUFBRCxlQUFlUCxLQUFBQSxDQUFLSyxDQUFMTCxFQURqQkksQ0FBQUEsR0FBYUo7UUFEZkQsQ0FBQUEsR0FBQUE7UUFNQUQsT0FBQSxhQUFNLGFBQU4sRUFBa0IsY0FBbEI7TUFURkEsR0FBQUEsV0FBQUE7SUFOZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzYxNDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vZm9ybWF0dGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxucmVxdWlyZSAnc3RyaW5naW8nXG5cbmNsYXNzIFBhZ2dpb1xuXG5jbGFzcyBGb3JtYXR0ZXJcbiAgZGVmIHNlbGYudG9faFxuICAgIEBmb3JtYXR0ZXJzIHx8PSB7fVxuICBlbmRcblxuICBkZWYgc2VsZi5mb3Ioa2xhc3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgdG9faFtrbGFzc10gPSBibG9ja1xuICAgIGVsc2VcbiAgICAgIHRvX2hba2xhc3NdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm9wdGlvbnMob3B0aW9ucywgJmJsb2NrKVxuICAgIG9sZCA9IE9QVElPTlMuZHVwXG4gICAgVXRpbHMuZGVlcF9tZXJnZSEoT1BUSU9OUywgb3B0aW9ucylcblxuICAgIHJlc3VsdCA9IGJsb2NrLmNhbGxcblxuICAgIE9QVElPTlMucmVwbGFjZShvbGQpXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgT1BUSU9OUyA9IHtcbiAgICBpbmRlbnQ6IHtcbiAgICAgIGxldmVsOiAwLFxuICAgICAgd2l0aDogIFwiXFx0XCJcbiAgICB9XG4gIH1cblxuICBkZWYgaW5pdGlhbGl6ZShpbyA9IG5pbCwgb3B0aW9ucyA9IHt9KVxuICAgIGlmIEhhc2ggPT09IGlvXG4gICAgICBAaW8gICAgICA9IFN0cmluZ0lPLm5ld1xuICAgICAgQG9wdGlvbnMgPSBpb1xuICAgIGVsc2VcbiAgICAgIEBpbyAgICAgID0gaW8gfHwgU3RyaW5nSU8ubmV3XG4gICAgICBAb3B0aW9ucyA9IG9wdGlvbnNcbiAgICBlbmRcblxuICAgIEBvcHRpb25zID0gT1BUSU9OUy5tZXJnZShAb3B0aW9ucylcbiAgZW5kXG5cbiAgZGVmIGZvcm1hdChpdGVtKVxuICAgIEZvcm1hdHRlci50b19oLmVhY2gge3xrbGFzcywgYmxvY2t8XG4gICAgICBpZiBrbGFzcyA9PT0gaXRlbVxuICAgICAgICBibG9jay5jYWxsKHNlbGYsIGl0ZW0pXG4gICAgICAgIGJyZWFrXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgQGlvLnN0cmluZ1xuICBlbmRcblxuICBkZWYgaW5kZW50PygmYmxvY2spXG4gICAgQG9wdGlvbnNbOmluZGVudF1bOmxldmVsXVxuICByZXNjdWVcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5kZW50KCZibG9jaylcbiAgICBpZiBpbmRlbnQ/XG4gICAgICBpZiBibG9ja1xuICAgICAgICBAb3B0aW9uc1s6aW5kZW50XVs6bGV2ZWxdICs9IDFcbiAgICAgICAgYmxvY2suY2FsbFxuICAgICAgICBAb3B0aW9uc1s6aW5kZW50XVs6bGV2ZWxdIC09IDFcbiAgICAgIGVsc2VcbiAgICAgICAgQG9wdGlvbnNbOmluZGVudF1bOmxldmVsXSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBibG9jay5jYWxsIGlmIGJsb2NrXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkZWluZGVudFxuICAgIGlmIGluZGVudD9cbiAgICAgIEBvcHRpb25zWzppbmRlbnRdWzpsZXZlbF0gLT0gMVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcHJpbnQodGV4dClcbiAgICBpZiBsZXZlbCA9IGluZGVudD9cbiAgICAgIHRleHQubGluZXMuZWFjaCB7fGxpbmV8XG4gICAgICAgIEBpby5wdXRzIFwiI3tAb3B0aW9uc1s6aW5kZW50XVs6d2l0aF0gKiBsZXZlbH0je2xpbmUuY2hvbXB9XCJcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBAaW8ucHJpbnQgdGV4dFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZXNjYXBlKHN0cmluZylcbiAgICBzdHJpbmcudG9fcy5nc3ViKC9bXCI+PCddfCYoPyEoW2EtekEtWl0rfCgjXFxkKykpOykvLCB7XG4gICAgICAnJicgPT4gJyZhbXA7JyxcbiAgICAgICc+JyA9PiAnJmd0OycsXG4gICAgICAnPCcgPT4gJyZsdDsnLFxuICAgICAgJ1wiJyA9PiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiID0+ICcmIzM5OycgfSlcbiAgZW5kXG5lbmRcblxuRm9ybWF0dGVyLmZvciBIVE1MIGRvIHxmLCBpdGVtfFxuICBjYXNlIGl0ZW0udmVyc2lvblxuICB3aGVuIDVcbiAgICBmLnByaW50ICc8IURPQ1RZUEUgaHRtbD4nXG4gIGVuZFxuXG4gIGYucHJpbnQgJzxodG1sPidcbiAgZi5pbmRlbnQge1xuICAgIGl0ZW0uZWFjaCB7fHJvb3R8XG4gICAgICBmLmZvcm1hdChyb290KVxuICAgIH1cbiAgfVxuICBmLnByaW50ICc8L2h0bWw+J1xuZW5kXG5cbkZvcm1hdHRlci5mb3IgSFRNTDo6RWxlbWVudCBkbyB8ZiwgaXRlbXxcbiAgbmFtZSwgYXR0cmlidXRlcywgY2xhc3NfbmFtZXMgPSBpdGVtLmluc3RhbmNlX2V2YWwge1xuICAgIFtAbmFtZSwgQGF0dHJpYnV0ZXMsIEBjbGFzc19uYW1lc11cbiAgfVxuXG4gIGlmIGF0dHJpYnV0ZXMuZW1wdHk/ICYmIGNsYXNzX25hbWVzLmVtcHR5P1xuICAgIGYucHJpbnQgXCI8I3tuYW1lfT5cIlxuICBlbHNlXG4gICAgYXR0cnMgPSBhdHRyaWJ1dGVzLm1hcCB7fGtleSwgdmFsdWV8XG4gICAgICAlUXsje2YuZXNjYXBlKGtleSl9PVwiI3tmLmVzY2FwZSh2YWx1ZSl9XCJ9XG4gICAgfVxuXG4gICAgdW5sZXNzIGNsYXNzX25hbWVzLmVtcHR5P1xuICAgICAgYXR0cnMgPDwgJVF7Y2xhc3M9XCIje2YuZXNjYXBlKGNsYXNzX25hbWVzLmpvaW4oJyAnKSl9XCJ9XG4gICAgZW5kXG5cbiAgICBmLnByaW50IFwiPCN7bmFtZX0gI3thdHRycy5qb2luKCcgJyl9PlwiXG4gIGVuZFxuXG4gIG5leHQgaWYgJXdbXG4gICAgYXJlYSBiYXNlIGJyIGNvbCBlbWJlZCBociBpbWcgaW5wdXQga2V5Z2VuIGxpbmtcbiAgICBtZW51aXRlbSBtZXRhIHBhcmFtIHNvdXJjZSB0cmFjayB3YnJcbiAgXS5pbmNsdWRlPyhuYW1lLnRvX3MuZG93bmNhc2UpXG5cbiAgZi5pbmRlbnQge1xuICAgIGlmIGlubmVyID0gaXRlbS5pbnN0YW5jZV9ldmFsIHsgQGlubmVyX2h0bWwgfVxuICAgICAgZi5wcmludCBpbm5lclxuICAgIGVsc2VcbiAgICAgIGl0ZW0uZWFjaCB7fGNoaWxkfFxuICAgICAgICBjYXNlIGNoaWxkXG4gICAgICAgIHdoZW4gU3RyaW5nXG4gICAgICAgICAgZi5wcmludCBmLmVzY2FwZShjaGlsZClcblxuICAgICAgICB3aGVuIENTU1xuICAgICAgICAgIGYucHJpbnQgJzxzdHlsZT4nXG4gICAgICAgICAgZi5pbmRlbnQge1xuICAgICAgICAgICAgZi5mb3JtYXQoY2hpbGQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGYucHJpbnQgJzwvc3R5bGU+J1xuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmLmZvcm1hdChjaGlsZClcbiAgICAgICAgZW5kXG4gICAgICB9XG4gICAgZW5kXG4gIH1cblxuICBmLnByaW50IFwiPC8je25hbWV9PlwiXG5lbmRcblxuRm9ybWF0dGVyLmZvciBDU1M6OkRlZmluaXRpb246OlN0eWxlIGRvIHxmLCBzdHlsZXxcbiAgZi5wcmludCBcIiN7c3R5bGUubmFtZX06ICN7c3R5bGUudmFsdWV9I3snICFpbXBvcnRhbnQnIGlmIHN0eWxlLmltcG9ydGFudH07XCJcbmVuZFxuXG5Gb3JtYXR0ZXIuZm9yIENTUyBkbyB8ZiwgaXRlbXxcbiAgaXRlbS5mb250cy5lYWNoIHt8Zm9udHxcbiAgICBmLnByaW50ICdAZm9udC1mYWNlIHsnXG4gICAgZi5pbmRlbnQge1xuICAgICAgZm9udC5lYWNoIHt8c3R5bGV8XG4gICAgICAgIGYuZm9ybWF0IHN0eWxlXG4gICAgICB9XG4gICAgfVxuICAgIGYucHJpbnQgJ30nXG4gIH1cblxuICBpdGVtLmFuaW1hdGlvbnMuZWFjaCB7fGFuaW1hdGlvbnxcbiAgICBbJycsICctd2Via2l0LScsICctbW96LScsICctby0nXS5lYWNoIHt8cGxhdGZvcm18XG4gICAgICBmLnByaW50IFwiQCN7cGxhdGZvcm19a2V5ZnJhbWVzICN7YW5pbWF0aW9uLm5hbWV9IHtcIlxuICAgICAgYW5pbWF0aW9uLnN0ZXBzLmVhY2gge3xzdGVwfFxuICAgICAgICBmLnByaW50IFwiI3tzdGVwLnZhbHVlfSB7XCJcbiAgICAgICAgc3RlcC5lYWNoIHt8c3R5bGV8XG4gICAgICAgICAgZi5mb3JtYXQgc3R5bGVcbiAgICAgICAgfVxuICAgICAgICBmLnByaW50ICd9J1xuICAgICAgfVxuICAgICAgZi5wcmludCAnfSdcbiAgICB9XG4gIH1cblxuICBpdGVtLnJ1bGVzLnJldmVyc2UuZWFjaCB7fHJ1bGV8XG4gICAgbmV4dCBpZiBydWxlLmVtcHR5P1xuXG4gICAgaWYgbSA9IHJ1bGUubWVkaWFcbiAgICAgIGYucHJpbnQgXCJAbWVkaWEgI3ttfSB7XCJcbiAgICAgIGYuaW5kZW50XG4gICAgZW5kXG5cbiAgICBmLnByaW50IFwiI3tydWxlLnNlbGVjdG9yfSB7XCJcbiAgICBmLmluZGVudCB7XG4gICAgICBydWxlLmVhY2gge3xzdHlsZXxcbiAgICAgICAgZi5mb3JtYXQgc3R5bGVcbiAgICAgIH1cbiAgICB9XG4gICAgZi5wcmludCAnfSdcblxuICAgIGlmIHJ1bGUubWVkaWFcbiAgICAgIGYucHJpbnQgJ30nXG4gICAgICBmLmRlaW5kZW50XG4gICAgZW5kXG4gIH1cbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpGb3JtYXR0ZXI+IiwidG9faCIsIkBmb3JtYXR0ZXJzIiwiJHJldF9vcl8xIiwiZm9yIiwia2xhc3MiLCJibG9jayIsIltdPSIsIltdIiwib3B0aW9ucyIsIm9sZCIsIk9QVElPTlMiLCJkdXAiLCJVdGlscyIsImRlZXBfbWVyZ2UhIiwicmVzdWx0IiwiY2FsbCIsInJlcGxhY2UiLCIwIiwiaW5pdGlhbGl6ZSIsImlvIiwiSGFzaCIsIkBpbyIsIlN0cmluZ0lPIiwibmV3IiwiQG9wdGlvbnMiLCJtZXJnZSIsImZvcm1hdCIsIml0ZW0iLCJlYWNoIiwiRm9ybWF0dGVyIiwiYmxvY2sgaW4gZm9ybWF0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmb3JtYXQiLCJ0b19zIiwic3RyaW5nIiwiaW5kZW50PyIsIlN0YW5kYXJkRXJyb3IiLCJpbmRlbnQiLCIkYmluYXJ5X29wX3JlY3ZyX3RtcF8xIiwiKyIsIjEiLCIkYmluYXJ5X29wX3JlY3ZyX3RtcF8yIiwiLSIsIiRiaW5hcnlfb3BfcmVjdnJfdG1wXzMiLCJkZWluZGVudCIsIiRiaW5hcnlfb3BfcmVjdnJfdG1wXzQiLCJwcmludCIsInRleHQiLCJsZXZlbCIsImxpbmVzIiwiYmxvY2sgaW4gcHJpbnQiLCJsaW5lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcmludCIsInB1dHMiLCIqIiwiY2hvbXAiLCJlc2NhcGUiLCJnc3ViIiwiSFRNTCIsImJsb2NrIGluIDxjbGFzczpQYWdnaW8+IiwiZiIsInZlcnNpb24iLCI1IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6UGFnZ2lvPiIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOlBhZ2dpbz4iLCJyb290IiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiA8Y2xhc3M6UGFnZ2lvPiIsIkhUTUw6OkVsZW1lbnQiLCJpbnN0YW5jZV9ldmFsIiwiQG5hbWUiLCJAYXR0cmlidXRlcyIsIkBjbGFzc19uYW1lcyIsIm5hbWUiLCJhdHRyaWJ1dGVzIiwiY2xhc3NfbmFtZXMiLCJlbXB0eT8iLCJhdHRycyIsIm1hcCIsImtleSIsInZhbHVlIiwiPDwiLCJqb2luIiwiaW5jbHVkZT8iLCJkb3duY2FzZSIsImlubmVyIiwiQGlubmVyX2h0bWwiLCJjaGlsZCIsIlN0cmluZyIsIkNTUyIsImJsb2NrICg1IGxldmVscykgaW4gPGNsYXNzOlBhZ2dpbz4iLCJDU1M6OkRlZmluaXRpb246OlN0eWxlIiwiQ1NTOjpEZWZpbml0aW9uIiwic3R5bGUiLCJpbXBvcnRhbnQiLCJmb250cyIsImZvbnQiLCJhbmltYXRpb25zIiwiYW5pbWF0aW9uIiwicGxhdGZvcm0iLCJzdGVwcyIsInN0ZXAiLCJibG9jayAoNiBsZXZlbHMpIGluIDxjbGFzczpQYWdnaW8+IiwicnVsZXMiLCJyZXZlcnNlIiwicnVsZSIs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Q0FBQTs7VUFDRTlDLENBQUNkLE9BQUFBLENBQU9rQixHQUFQbEI7VUFDRGtCLE9BQUFKLENBQUNoQixVQUFBQSxDQUFBQTtRQUZIO1VBcE9Kb0IsT0FBQTtRQW9PSSxFQWhCRkQsQ0FBQUEsR0FBa0JsQyxFQXpCcEI4QixDQUFBQSxHQUFTdkQ7RUEvS1RMLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBWkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNjQ2MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBSZXF1aXJlcyBhcmUgbW92ZWQgdG8gdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cbm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbmNsYXNzIEVsZW1lbnQgPCBOb2RlXG4gIGRlZiBzZWxmLmNyZWF0ZSgqYXJncywgJmJsb2NrKVxuICAgIGlmIERvY3VtZW50ID09PSBhcmdzLmZpcnN0XG4gICAgICBkb2N1bWVudCA9IGFyZ3Muc2hpZnRcbiAgICBlbHNlXG4gICAgICBkb2N1bWVudCA9ICRkb2N1bWVudFxuICAgIGVuZFxuXG4gICAgaWYgc2VsZiA9PSBFbGVtZW50XG4gICAgICBkb2N1bWVudC5jcmVhdGVfZWxlbWVudCgqYXJncywgJmJsb2NrKVxuICAgIGVsc2lmIEB0YWdfbmFtZVxuICAgICAgZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoQHRhZ19uYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIGVsc2lmIEBzZWxlY3RvclxuICAgICAgIyBUaGF0J3MgY3J1ZGUsIGJ1dCBzaG91bGQgY292ZXIgdGhlIG1vc3QgYmFzaWMgY2FzZXMuXG4gICAgICAjIEp1c3QgaW4gY2FzZSwgeW91IGNhbiBvdmVycmlkZSBpdCBzYWZlbHkuIFRvIHJlaXRlcmF0ZTpcbiAgICAgICMgLmNyZWF0ZSBpcyBub3QgdG8gYmUgdXNlZCBpbnNpZGUgbGlicmFyaWVzLCB0aG9zZSBhcmVcbiAgICAgICMgZXhwZWN0ZWQgdG8gdXNlIHRoZSBEb2N1bWVudCNjcmVhdGVfZWxlbWVudCBBUEkuXG4gICAgICBrd2FyZ3MgPSB7fVxuICAgICAga3dhcmdzID0gYXJncy5wb3AgaWYgSGFzaCA9PT0gYXJncy5sYXN0XG4gICAgICBjdXN0b21fYXR0cnMsIGN1c3RvbV9pZCwgY3VzdG9tX2NsYXNzZXMgPSBuaWwsIG5pbCwgbmlsXG4gICAgICB0YWdfbmFtZSA9IChAc2VsZWN0b3Iuc2NhbigvXltcXHctXSsvKS5maXJzdCB8fCBcImRpdlwiKS51cGNhc2VcbiAgICAgIGNsYXNzZXMgPSBAc2VsZWN0b3Iuc2NhbigvXFwuKFtcXHctXSspLykuZmxhdHRlblxuICAgICAgY2xhc3NlcyB8PSBjdXN0b21fY2xhc3NlcyBpZiBjdXN0b21fY2xhc3NlcyA9IGt3YXJncy5kZWxldGUoOmNsYXNzZXMpXG4gICAgICBpZCA9IEBzZWxlY3Rvci5zY2FuKC8jKFtcXHctXSspLykuZmxhdHRlbi5maXJzdFxuICAgICAgaWQgPSBjdXN0b21faWQgaWYgY3VzdG9tX2lkID0ga3dhcmdzLmRlbGV0ZSg6aWQpXG4gICAgICBhdHRycyA9IEBzZWxlY3Rvci5zY2FuKC9cXFsoW1xcdy1dKyk9KChbXCInXSkoLio/KVxcM3xbXFx3Xy1dKilcXF0vKS5tYXAgeyB8YSxiLF8sZHwgW2EsZHx8Yl0gfS50b19oXG4gICAgICBhdHRycyA9IGF0dHJzLm1lcmdlKGN1c3RvbV9hdHRycykgaWYgY3VzdG9tX2F0dHJzID0ga3dhcmdzLmRlbGV0ZSg6YXR0cnMpXG4gICAgICBkb2N1bWVudC5jcmVhdGVfZWxlbWVudCh0YWdfbmFtZSwgKmFyZ3MsIGNsYXNzZXM6IGNsYXNzZXMsIGlkOiBpZCwgYXR0cnM6IGF0dHJzLCAqKmt3YXJncywgJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuc3ViY2xhc3Nlc1xuICAgIEBzdWJjbGFzc2VzIHx8PSBbXVxuICBlbmRcblxuICAjIERlZmluZSBhIHNlbGVjdG9yIGZvciBzdWJjbGFzcyBkaXNwYXRjaFxuICAjXG4gICMgRXhhbXBsZTpcbiAgIyBgYGBcbiAgIyBjbGFzcyBDdXN0b21FbGVtZW50IDwgQnJvd3Nlcjo6RE9NOjpFbGVtZW50XG4gICMgICBkZWZfc2VsZWN0b3IgXCJkaXYuaGVsbG8td29ybGRcIlxuICAjIGVuZFxuICAjIGBgYFxuICBkZWYgc2VsZi5kZWZfc2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgRWxlbWVudC5zdWJjbGFzc2VzIDw8IHNlbGZcblxuICAgIEBzZWxlY3RvciA9IHNlbGVjdG9yXG5cbiAgICAjIEEgc3BlY2lhbCBjYXNlIHRvIHNwZWVkdXAgZGlzcGF0Y2hcbiAgICBAdGFnX25hbWUgPSBzZWxlY3Rvci51cGNhc2UgdW5sZXNzIHNlbGVjdG9yID1+IC9bXlxcdy1dL1xuICBlbmRcblxuICBkZWYgc2VsZi5zZWxlY3RvclxuICAgIEBzZWxlY3RvclxuICBlbmRcblxuICBkZWYgc2VsZi50YWdfbmFtZVxuICAgIEB0YWdfbmFtZVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXcoKmFyZ3MsICZibG9jaylcbiAgICBpZiBhcmdzLmxlbmd0aCA9PSAxICYmICFibG9ja19naXZlbj8gJiYgT3BhbC5uYXRpdmU/KGFyZ3NbMF0pXG4gICAgICAjIFVzZSBgLm5ld2AgYXMgYSB3cmFwcGluZyBtZXRob2QuXG4gICAgICBub2RlID0gYXJnc1swXVxuICAgIGVsc2VcbiAgICAgICMgVXNlIGAubmV3YCBhcyBhbiBhbGlhcyBmb3IgYC5jcmVhdGVgLlxuICAgICAgcmV0dXJuIGNyZWF0ZSgqYXJncywgJmJsb2NrKVxuICAgIGVuZFxuXG4gICAgaWYgc2VsZiA9PSBFbGVtZW50XG4gICAgICBzdWJjbGFzcyA9IEVsZW1lbnQuc3ViY2xhc3Nlcy5zZWxlY3QgZG8gfHN1YmNsYXNzfFxuICAgICAgICBFbGVtZW50Lm5hdGl2ZV9pcz8obm9kZSwgc3ViY2xhc3MpXG4gICAgICBlbmQubGFzdFxuXG4gICAgICBpZiBzdWJjbGFzc1xuICAgICAgICBzdWJjbGFzcy5uZXcobm9kZSlcbiAgICAgIGVsc2VcbiAgICAgICAgc3VwZXIobm9kZSlcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHN1cGVyKG5vZGUpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGluY2x1ZGUgRXZlbnQ6OlRhcmdldFxuXG4gIHRhcmdldCB7fHZhbHVlfFxuICAgIGJlZ2luXG4gICAgICBET00odmFsdWUpXG4gICAgcmVzY3VlIFN0YW5kYXJkRXJyb3IsIEpTOjpFcnJvclxuICAgICAgbmlsXG4gICAgZW5kXG4gIH1cblxuICBkZWYgc2VsZi5uYXRpdmVfaXM/IChuYXRpdmUsIGtsYXNzKVxuICAgIGlmIHRhZ19uYW1lID0ga2xhc3MudGFnX25hbWVcbiAgICAgIGlzID0gYCgje25hdGl2ZX0uZ2V0QXR0cmlidXRlKFwiaXNcIikgfHwgXCJcIilgXG4gICAgICBgI3t0YWdfbmFtZX0gPT09ICN7aXN9LnRvVXBwZXJDYXNlKCkgfHwgI3t0YWdfbmFtZX0gPT09ICN7bmF0aXZlfS5ub2RlTmFtZWBcbiAgICBlbHNlXG4gICAgICBFbGVtZW50Lm5hdGl2ZV9tYXRjaGVzPyhuYXRpdmUsIGtsYXNzLnNlbGVjdG9yKVxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5tYXRjaGVzJ1xuICAgIGRlZiBzZWxmLm5hdGl2ZV9tYXRjaGVzPyAobmF0aXZlLCBzZWxlY3RvcilcbiAgICAgIGAje25hdGl2ZX0ubWF0Y2hlcygje3NlbGVjdG9yfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50Lm1hdGNoZXMgKE9wZXJhKSdcbiAgICBkZWYgc2VsZi5uYXRpdmVfbWF0Y2hlcz8gKG5hdGl2ZSwgc2VsZWN0b3IpXG4gICAgICBgI3tuYXRpdmV9Lm9NYXRjaGVzU2VsZWN0b3IoI3tzZWxlY3Rvcn0pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5tYXRjaGVzIChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgZGVmIHNlbGYubmF0aXZlX21hdGNoZXM/IChuYXRpdmUsIHNlbGVjdG9yKVxuICAgICAgYCN7bmF0aXZlfS5tc01hdGNoZXNTZWxlY3Rvcigje3NlbGVjdG9yfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50Lm1hdGNoZXMgKEZpcmVmb3gpJ1xuICAgIGRlZiBzZWxmLm5hdGl2ZV9tYXRjaGVzPyAobmF0aXZlLCBzZWxlY3RvcilcbiAgICAgIGAje25hdGl2ZX0ubW96TWF0Y2hlc1NlbGVjdG9yKCN7c2VsZWN0b3J9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQubWF0Y2hlcyAoQ2hyb21lKSdcbiAgICBkZWYgc2VsZi5uYXRpdmVfbWF0Y2hlcz8gKG5hdGl2ZSwgc2VsZWN0b3IpXG4gICAgICBgI3tuYXRpdmV9LndlYmtpdE1hdGNoZXNTZWxlY3Rvcigje3NlbGVjdG9yfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIubG9hZGVkPyAnU2l6emxlJ1xuICAgIGRlZiBzZWxmLm5hdGl2ZV9tYXRjaGVzPyAobmF0aXZlLCBzZWxlY3RvcilcbiAgICAgIGBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yKCN7bmF0aXZlfSwgI3tzZWxlY3Rvcn0pYFxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIHNlbGYubmF0aXZlX21hdGNoZXM/IChuYXRpdmUsIHNlbGVjdG9yKVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3NlbGVjdG9yIG1hdGNoaW5nIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIENoZWNrIHdoZXRoZXIgdGhlIGVsZW1lbnQgbWF0Y2hlcyB0aGUgZ2l2ZW4gc2VsZWN0b3IuXG4gICNcbiAgIyBAcGFyYW0gc2VsZWN0b3IgW1N0cmluZ10gdGhlIENTUyBzZWxlY3RvclxuICBkZWYgPX4oc2VsZWN0b3IpXG4gICAgRWxlbWVudC5uYXRpdmVfbWF0Y2hlcz8oQG5hdGl2ZSwgc2VsZWN0b3IpXG4gIGVuZFxuXG4gICMgQWxsb3cgZm9yIGNhc2UgZXhwcmVzc2lvbnNcbiAgYWxpYXMgPT09ID1+XG5cbiAgIyBRdWVyeSBmb3IgY2hpbGRyZW4gd2l0aCB0aGUgZ2l2ZW4gWFBwYXRocy5cbiAgI1xuICAjIEBwYXJhbSBwYXRocyBbQXJyYXk8U3RyaW5nPl0gdGhlIFhQYXRocyB0byBsb29rIGZvclxuICAjXG4gICMgQHJldHVybiBbTm9kZVNldF1cbiAgZGVmIC8oKnBhdGhzKVxuICAgIE5vZGVTZXRbcGF0aHMubWFwIHsgfHBhdGh8IHhwYXRoKHBhdGgpIH1dXG4gIGVuZFxuXG4gICMgR2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgI1xuICAjIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAjIEBwYXJhbSBvcHRpb25zIFtIYXNoXSBvcHRpb25zIGZvciB0aGUgYXR0cmlidXRlXG4gICNcbiAgIyBAb3B0aW9uIG9wdGlvbnMgW1N0cmluZ10gOm5hbWVzcGFjZSB0aGUgbmFtZXNwYWNlIGZvciB0aGUgYXR0cmlidXRlXG4gICNcbiAgIyBAcmV0dXJuIFtTdHJpbmc/XVxuICBkZWYgW10obmFtZSwgb3B0aW9ucyA9IHt9KVxuICAgIGF0dHJpYnV0ZXMuZ2V0KG5hbWUsIG9wdGlvbnMpXG4gIGVuZFxuXG4gICMgU2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgdmFsdWUuXG4gICNcbiAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgYXR0cmlidXRlIG5hbWVcbiAgIyBAcGFyYW0gdmFsdWUgW09iamVjdF0gdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICAjIEBwYXJhbSBvcHRpb25zIFtIYXNoXSB0aGUgb3B0aW9ucyBmb3IgdGhlIGF0dHJpYnV0ZVxuICAjXG4gICMgQG9wdGlvbiBvcHRpb25zIFtTdHJpbmddIDpuYW1lc3BhY2UgdGhlIG5hbWVzcGFjZSBmb3IgdGhlIGF0dHJpYnV0ZVxuICBkZWYgW109KG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pXG4gICAgYXR0cmlidXRlcy5zZXQobmFtZSwgdmFsdWUsIG9wdGlvbnMpXG4gIGVuZFxuXG4gICMgQWRkIGNsYXNzIG5hbWVzIHRvIHRoZSBlbGVtZW50LlxuICAjXG4gICMgQHBhcmFtIG5hbWVzIFtBcnJheTxTdHJpbmc+XSBjbGFzcyBuYW1lcyB0byBhZGRcbiAgI1xuICAjIEByZXR1cm4gW3NlbGZdXG4gIGRlZiBhZGRfY2xhc3MoKm5hbWVzKVxuICAgIGNsYXNzZXMgPSBjbGFzc19uYW1lcyArIG5hbWVzXG5cbiAgICB1bmxlc3MgY2xhc3Nlcy5lbXB0eT9cbiAgICAgIGAjQG5hdGl2ZS5jbGFzc05hbWUgPSAje2NsYXNzZXMudW5pcS5qb2luICcgJ31gXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gQ1NTIHNlbGVjdG9yIG9yIFhQYXRoLlxuICAjXG4gICMgQHBhcmFtIHBhdGhfb3Jfc2VsZWN0b3IgW1N0cmluZ10gYW4gWFBhdGggb3IgQ1NTIHNlbGVjdG9yXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlP11cbiAgZGVmIGF0KHBhdGhfb3Jfc2VsZWN0b3IpXG4gICAgeHBhdGgocGF0aF9vcl9zZWxlY3RvcikuZmlyc3QgfHwgY3NzKHBhdGhfb3Jfc2VsZWN0b3IpLmZpcnN0XG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3JzLlxuICAjXG4gICMgQHBhcmFtIHJ1bGVzIFtBcnJheTxTdHJpbmc+XSB0aGUgQ1NTIHNlbGVjdG9ycyB0byBtYXRjaCB3aXRoXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlP11cbiAgZGVmIGF0X2NzcygqcnVsZXMpXG4gICAgcmVzdWx0ID0gbmlsXG5cbiAgICBydWxlcy5lYWNoIHt8cnVsZXxcbiAgICAgIGlmIHJlc3VsdCA9IGNzcyhydWxlKS5maXJzdFxuICAgICAgICBicmVha1xuICAgICAgZW5kXG4gICAgfVxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBYUGF0aC5cbiAgI1xuICAjIEBwYXJhbSBwYXRocyBbQXJyYXk8U3RyaW5nPl0gdGhlIFhQYXRoIHRvIG1hdGNoIHdpdGhcbiAgI1xuICAjIEByZXR1cm4gW05vZGU/XVxuICBkZWYgYXRfeHBhdGgoKnBhdGhzKVxuICAgIHJlc3VsdCA9IG5pbFxuXG4gICAgcGF0aHMuZWFjaCB7fHBhdGh8XG4gICAgICBpZiByZXN1bHQgPSB4cGF0aChwYXRoKS5maXJzdFxuICAgICAgICBicmVha1xuICAgICAgZW5kXG4gICAgfVxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGFsaWFzIGF0dHIgW11cblxuICBhbGlhcyBhdHRyaWJ1dGUgW11cblxuICAjIEAhYXR0cmlidXRlIFtyXSBhdHRyaWJ1dGVzXG4gICMgQHJldHVybiBbQXR0cmlidXRlc10gdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBlbGVtZW50XG4gIGRlZiBhdHRyaWJ1dGVzKG9wdGlvbnMgPSB7fSlcbiAgICBBdHRyaWJ1dGVzLm5ldyhzZWxmLCBvcHRpb25zKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBhdHRyaWJ1dGVfbm9kZXNcbiAgIyBAcmV0dXJuIFtOb2RlU2V0XSB0aGUgYXR0cmlidXRlIG5vZGVzIGZvciB0aGUgZWxlbWVudFxuICBkZWYgYXR0cmlidXRlX25vZGVzXG4gICAgTm9kZVNldFtOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUuYXR0cmlidXRlc2AsIGdldDogOml0ZW0pXVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBjbGFzc19uYW1lXG4gICMgQHJldHVybiBbU3RyaW5nXSBhbGwgdGhlIGVsZW1lbnQgY2xhc3MgbmFtZXNcbiAgYWxpYXNfbmF0aXZlIDpjbGFzc19uYW1lLCA6Y2xhc3NOYW1lXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gY2xhc3NfbmFtZXNcbiAgIyBAcmV0dXJuIFtBcnJheTxTdHJpbmc+XSBhbGwgdGhlIGVsZW1lbnQgY2xhc3MgbmFtZXNcbiAgZGVmIGNsYXNzX25hbWVzXG4gICAgYCNAbmF0aXZlLmNsYXNzTmFtZWAuc3BsaXQoL1xccysvKS5yZWplY3QoJjplbXB0eT8pXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdRdWVyeS5jc3MnXG4gICAgZGVmIGNzcyhwYXRoKVxuICAgICAgTm9kZVNldFtOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUucXVlcnlTZWxlY3RvckFsbChwYXRoKWApXVxuICAgIHJlc2N1ZSBTdGFuZGFyZEVycm9yLCBKUzo6RXJyb3JcbiAgICAgIE5vZGVTZXRbXVxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLmxvYWRlZD8gJ1NpenpsZSdcbiAgICBkZWYgY3NzKHBhdGgpXG4gICAgICBOb2RlU2V0W2BTaXp6bGUocGF0aCwgI0BuYXRpdmUpYF1cbiAgICByZXNjdWUgU3RhbmRhcmRFcnJvciwgSlM6OkVycm9yXG4gICAgICBOb2RlU2V0W11cbiAgICBlbmRcbiAgZWxzZVxuICAgICMgUXVlcnkgZm9yIGNoaWxkcmVuIG1hdGNoaW5nIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gICAgI1xuICAgICMgQHBhcmFtIHNlbGVjdG9yIFtTdHJpbmddIHRoZSBDU1Mgc2VsZWN0b3JcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtOb2RlU2V0XVxuICAgIGRlZiBjc3Moc2VsZWN0b3IpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAncXVlcnkgYnkgQ1NTIHNlbGVjdG9yIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIENsaWNrIHRoZSBlbGVtZW50LiBpdCBmaXJlcyB0aGUgZWxlbWVudCdzIGNsaWNrIGV2ZW50LlxuICBkZWYgY2xpY2tcbiAgICBgI0BuYXRpdmUuY2xpY2soKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQG92ZXJsb2FkIGRhdGEoKVxuICAjXG4gICMgICBSZXR1cm4gdGhlIGRhdGEgZm9yIHRoZSBlbGVtZW50LlxuICAjXG4gICMgICBAcmV0dXJuIFtEYXRhXVxuICAjXG4gICMgQG92ZXJsb2FkIGRhdGEoaGFzaClcbiAgI1xuICAjICAgU2V0IGRhdGEgb24gdGhlIGVsZW1lbnQuXG4gICNcbiAgIyAgIEBwYXJhbSBoYXNoIFtIYXNoXSB0aGUgZGF0YSB0byBzZXRcbiAgI1xuICAjICAgQHJldHVybiBbc2VsZl1cbiAgZGVmIGRhdGEodmFsdWUgPSBuaWwpXG4gICAgZGF0YSA9IERhdGEubmV3KHNlbGYpXG5cbiAgICByZXR1cm4gZGF0YSB1bmxlc3MgdmFsdWVcblxuICAgIGlmIEhhc2ggPT09IHZhbHVlXG4gICAgICBkYXRhLmFzc2lnbih2YWx1ZSlcbiAgICBlbHNlXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndW5rbm93biBkYXRhIHR5cGUnXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGdldF9hdHRyaWJ1dGUgW11cblxuICBhbGlhcyBnZXQgW11cblxuICAjIEAhYXR0cmlidXRlIGhlaWdodFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgZGVmIGhlaWdodFxuICAgIHNpemUuaGVpZ2h0XG4gIGVuZFxuXG4gIGRlZiBoZWlnaHQ9KHZhbHVlKVxuICAgIHNpemUuaGVpZ2h0ID0gdmFsdWVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBpZFxuICAjIEByZXR1cm4gW1N0cmluZz9dIHRoZSBJRCBvZiB0aGUgZWxlbWVudFxuICBkZWYgaWRcbiAgICAleHtcbiAgICAgIHZhciBpZCA9ICNAbmF0aXZlLmlkO1xuXG4gICAgICBpZiAoaWQgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaWQ9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5pZCA9ICN7dmFsdWUudG9fc31gXG4gIGVuZFxuXG4gICMgU2V0IHRoZSBpbm5lciBET00gb2YgdGhlIGVsZW1lbnQgdXNpbmcgdGhlIHtCdWlsZGVyfS5cbiAgZGVmIGlubmVyX2RvbShidWlsZGVyPW5pbCwgJmJsb2NrKVxuICAgIHNlbGYuaW5uZXJfZG9tID0gQnVpbGRlci5uZXcoZG9jdW1lbnQsIGJ1aWxkZXIsICZibG9jaykudG9fYVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBTZXQgdGhlIGlubmVyIERPTSB3aXRoIHRoZSBnaXZlbiBub2RlLlxuICAjXG4gICMgKHNlZSAjYXBwZW5kX2NoaWxkKVxuICBkZWYgaW5uZXJfZG9tPShub2RlKVxuICAgIGNsZWFyXG5cbiAgICBzZWxmIDw8IG5vZGVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBpbm5lcl9odG1sXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgaW5uZXIgSFRNTCBvZiB0aGUgZWxlbWVudFxuICBkZWYgaW5uZXJfaHRtbFxuICAgIGAjQG5hdGl2ZS5pbm5lckhUTUxgXG4gIGVuZFxuXG4gIGRlZiBpbm5lcl9odG1sPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuaW5uZXJIVE1MID0gI3t2YWx1ZX1gXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgaW5zcGVjdCA9IG5hbWUuZG93bmNhc2VcblxuICAgIGlmIGlkXG4gICAgICBpbnNwZWN0ICs9ICcuJyArIGlkICsgJyEnXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgY2xhc3NfbmFtZXMuZW1wdHk/XG4gICAgICBpbnNwZWN0ICs9ICcuJyArIGNsYXNzX25hbWVzLmpvaW4oJy4nKVxuICAgIGVuZFxuXG4gICAgXCIjPCN7c2VsZi5jbGFzcy5uYW1lLmdzdWIoXCJCcm93c2VyOjpcIixcIlwiKX06ICN7aW5zcGVjdH0+XCJcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBvZmZzZXRcbiAgIyBAcmV0dXJuIFtPZmZzZXRdIHRoZSBvZmZzZXQgb2YgdGhlIGVsZW1lbnRcbiAgZGVmIG9mZnNldCgqdmFsdWVzKVxuICAgIG9mZiA9IE9mZnNldC5uZXcoc2VsZilcblxuICAgIHVubGVzcyB2YWx1ZXMuZW1wdHk/XG4gICAgICBvZmYuc2V0KCp2YWx1ZXMpXG4gICAgZW5kXG5cbiAgICBvZmZcbiAgZW5kXG5cbiAgZGVmIG9mZnNldD0odmFsdWUpXG4gICAgb2Zmc2V0LnNldCgqdmFsdWUpXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgb3V0ZXJfaHRtbFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG91dGVyIEhUTUwgb2YgdGhlIGVsZW1lbnRcbiAgZGVmIG91dGVyX2h0bWxcbiAgICBgI0BuYXRpdmUub3V0ZXJIVE1MYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBwb3NpdGlvblxuICAjIEByZXR1cm4gW1Bvc2l0aW9uXSB0aGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgZGVmIHBvc2l0aW9uXG4gICAgQHBvc2l0aW9uIHx8PSBQb3NpdGlvbi5uZXcoc2VsZilcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gc2Nyb2xsXG4gICMgQHJldHVybiBbU2Nyb2xsXSB0aGUgc2Nyb2xsaW5nIGZvciB0aGUgZWxlbWVudFxuICBkZWYgc2Nyb2xsXG4gICAgQHNjcm9sbCB8fD0gU2Nyb2xsLm5ldyhzZWxmKVxuICBlbmRcblxuICAjIFNlYXJjaCBmb3IgYWxsIHRoZSBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gWFBhdGhzIG9yIENTUyBzZWxlY3RvcnMuXG4gICNcbiAgIyBAcGFyYW0gc2VsZWN0b3JzIFtBcnJheTxTdHJpbmc+XSBtaXhlZCBsaXN0IG9mIFhQYXRocyBhbmQgQ1NTIHNlbGVjdG9yc1xuICAjXG4gICMgQHJldHVybiBbTm9kZVNldF1cbiAgZGVmIHNlYXJjaCgqc2VsZWN0b3JzKVxuICAgIE5vZGVTZXQubmV3IHNlbGVjdG9ycy5tYXAge3xzZWxlY3RvcnxcbiAgICAgIHhwYXRoKHNlbGVjdG9yKS50b19hLmNvbmNhdChjc3Moc2VsZWN0b3IpLnRvX2EpXG4gICAgfS5mbGF0dGVuLnVuaXFcbiAgZW5kXG5cbiAgYWxpYXMgc2V0IFtdPVxuXG4gIGFsaWFzIHNldF9hdHRyaWJ1dGUgW109XG5cbiAgIyBDcmVhdGVzIG9yIGFjY2Vzc2VzIHRoZSBzaGFkb3cgcm9vdCBvZiB0aGlzIGVsZW1lbnRcbiAgI1xuICAjIEBwYXJhbSBvcGVuIFtCb29sZWFuXSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgY2xvc2VkXG4gICMgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvdyByb290XG4gICNcbiAgIyBAcmV0dXJuIFtTaGFkb3dSb290XVxuICBkZWYgc2hhZG93IChvcGVuID0gdHJ1ZSlcbiAgICBpZiByb290ID0gYCNAbmF0aXZlLnNoYWRvd1Jvb3RgXG4gICAgICBET00ocm9vdClcbiAgICBlbHNlXG4gICAgICBET00oYCNAbmF0aXZlLmF0dGFjaFNoYWRvdyh7bW9kZTogI3tvcGVuID8gXCJvcGVuXCIgOiBcImNsb3NlZFwifX0pYClcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBDaGVja3MgZm9yIGEgcHJlc2VuY2Ugb2YgYSBzaGFkb3cgcm9vdCBvZiB0aGlzIGVsZW1lbnRcbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dXG4gIGRlZiBzaGFkb3c/XG4gICAgYCEhI0BuYXRpdmUuc2hhZG93Um9vdGBcbiAgZW5kXG5cbiAgIyBAb3ZlcmxvYWQgc3R5bGUoKVxuICAjXG4gICMgICBSZXR1cm4gdGhlIHN0eWxlIGZvciB0aGUgZWxlbWVudC5cbiAgI1xuICAjICAgQHJldHVybiBbQ1NTOjpEZWNsYXJhdGlvbl1cbiAgI1xuICAjIEBvdmVybG9hZCBzdHlsZShkYXRhKVxuICAjXG4gICMgICBTZXQgdGhlIENTUyBzdHlsZSBhcyBzdHJpbmcgb3Igc2V0IG9mIHZhbHVlcy5cbiAgI1xuICAjICAgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIG5ldyBzdHlsZVxuICAjXG4gICMgICBAcmV0dXJuIFtzZWxmXVxuICAjXG4gICMgQG92ZXJsb2FkIHN0eWxlKCZibG9jaylcbiAgI1xuICAjICAgU2V0IHRoZSBDU1Mgc3R5bGUgZnJvbSBhIENTUyBidWlsZGVyIERTTC5cbiAgI1xuICAjICAgQHJldHVybiBbc2VsZl1cbiAgZGVmIHN0eWxlKGRhdGEgPSBuaWwsICZibG9jaylcbiAgICBzdHlsZSA9IENTUzo6RGVjbGFyYXRpb24ubmV3KGAjQG5hdGl2ZS5zdHlsZWApXG5cbiAgICByZXR1cm4gc3R5bGUgdW5sZXNzIGRhdGEgfHwgYmxvY2tcblxuICAgIGlmIFN0cmluZyA9PT0gZGF0YVxuICAgICAgc3R5bGUucmVwbGFjZShkYXRhKVxuICAgIGVsc2lmIEhhc2ggPT09IGRhdGFcbiAgICAgIHN0eWxlLmFzc2lnbihkYXRhKVxuICAgIGVsc2lmIGJsb2NrXG4gICAgICBzdHlsZS5hcHBseSgmYmxvY2spXG4gICAgZWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3Vua25vd24gZGF0YSB0eXBlJ1xuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnQ1NTLmNvbXB1dGVkJ1xuICAgIGRlZiBzdHlsZSFcbiAgICAgIENTUzo6RGVjbGFyYXRpb24ubmV3KGAje3dpbmRvdy50b19ufS5nZXRDb21wdXRlZFN0eWxlKCNAbmF0aXZlLCBudWxsKWApXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdDU1MuY3VycmVudCdcbiAgICBkZWYgc3R5bGUhXG4gICAgICBDU1M6OkRlY2xhcmF0aW9uLm5ldyhgI0BuYXRpdmUuY3VycmVudFN0eWxlYClcbiAgICBlbmRcbiAgZWxzZVxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIHN0eWxlIVxuICAgICMgQHJldHVybiBbQ1NTOjpEZWNsYXJhdGlvbl0gZ2V0IHRoZSBjb21wdXRlZCBzdHlsZSBmb3IgdGhlIGVsZW1lbnRcbiAgICBkZWYgc3R5bGUhXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnY29tcHV0ZWQgc3R5bGUgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBlbGVtZW50LlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gIGRlZiByZW1vdmVfYXR0cmlidXRlKG5hbWUpXG4gICAgYCNAbmF0aXZlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKWBcbiAgZW5kXG5cbiAgIyBSZW1vdmUgY2xhc3MgbmFtZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgI1xuICAjIEBwYXJhbSBuYW1lcyBbQXJyYXk8U3RyaW5nPl0gY2xhc3MgbmFtZXMgdG8gcmVtb3ZlXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgcmVtb3ZlX2NsYXNzKCpuYW1lcylcbiAgICBjbGFzc2VzID0gY2xhc3NfbmFtZXMgLSBuYW1lc1xuXG4gICAgaWYgY2xhc3Nlcy5lbXB0eT9cbiAgICAgIGAjQG5hdGl2ZS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJylgXG4gICAgZWxzZVxuICAgICAgYCNAbmF0aXZlLmNsYXNzTmFtZSA9ICN7Y2xhc3Nlcy5qb2luICcgJ31gXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHNpemVcbiAgIyBAcmV0dXJuIFtTaXplXSB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudFxuICBkZWYgc2l6ZSgqaW5jKVxuICAgIFNpemUubmV3KHNlbGYsICppbmMpXG4gIGVuZFxuXG4gICMgVG9nZ2xlIGNsYXNzIG5hbWVzIG9mIHRoZSBlbGVtZW50LlxuICAjXG4gICMgQHBhcmFtIG5hbWVzIFtBcnJheTxTdHJpbmc+XSBjbGFzcyBuYW1lcyB0byB0b2dnbGVcbiAgI1xuICAjIEByZXR1cm4gW3NlbGZdXG4gIGRlZiB0b2dnbGVfY2xhc3MoKm5hbWVzKVxuICAgIHRvX3JlbW92ZSwgdG9fYWRkID0gbmFtZXMucGFydGl0aW9uIHsgfG5hbWV8IGNsYXNzX25hbWVzLmluY2x1ZGU/IG5hbWUgfVxuXG4gICAgYWRkX2NsYXNzKCp0b19hZGQpXG4gICAgcmVtb3ZlX2NsYXNzKCp0b19yZW1vdmUpXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgd2lkdGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgZGVmIHdpZHRoXG4gICAgc2l6ZS53aWR0aFxuICBlbmRcblxuICBkZWYgd2lkdGg9KHZhbHVlKVxuICAgIHNpemUud2lkdGggPSB2YWx1ZVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB3aW5kb3dcbiAgIyBAcmV0dXJuIFtXaW5kb3ddIHRoZSB3aW5kb3cgZm9yIHRoZSBlbGVtZW50XG4gIGRlZiB3aW5kb3dcbiAgICBkb2N1bWVudC53aW5kb3dcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8oJ1F1ZXJ5LnhwYXRoJykgfHwgQnJvd3Nlci5sb2FkZWQ/KCd3aWNrZWQtZ29vZC14cGF0aCcpXG4gICAgaWYgQnJvd3Nlci5sb2FkZWQ/ICd3aWNrZWQtZ29vZC14cGF0aCdcbiAgICAgIGB3Z3hwYXRoLmluc3RhbGwoKWBcbiAgICBlbmRcblxuICAgIGRlZiB4cGF0aChwYXRoKVxuICAgICAgTm9kZVNldFtOYXRpdmU6OkFycmF5Lm5ldyhcbiAgICAgICAgYCgjQG5hdGl2ZS5vd25lckRvY3VtZW50IHx8ICNAbmF0aXZlKS5ldmFsdWF0ZShwYXRoLFxuICAgICAgICAgICAjQG5hdGl2ZSwgbnVsbCwgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsIG51bGwpYCxcbiAgICAgICAgZ2V0OiAgICA6c25hcHNob3RJdGVtLFxuICAgICAgICBsZW5ndGg6IDpzbmFwc2hvdExlbmd0aCldXG4gICAgcmVzY3VlIFN0YW5kYXJkRXJyb3IsIEpTOjpFcnJvclxuICAgICAgTm9kZVNldFtdXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIFF1ZXJ5IGZvciBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gWFBhdGguXG4gICAgI1xuICAgICMgQHBhcmFtIHBhdGggW1N0cmluZ10gdGhlIFhQYXRoXG4gICAgI1xuICAgICMgQHJldHVybiBbTm9kZVNldF1cbiAgICBkZWYgeHBhdGgocGF0aClcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdxdWVyeSBieSBYUGF0aCB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcblxucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9hdHRyaWJ1dGVzJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9kYXRhJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9wb3NpdGlvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvb2Zmc2V0J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9zY3JvbGwnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L3NpemUnXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvYnV0dG9uJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9pbWFnZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvZm9ybSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvaW5wdXQnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L3NlbGVjdCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvdGVtcGxhdGUnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L3RleHRhcmVhJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9pZnJhbWUnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L21lZGlhJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiY3JlYXRlIiwic2VsZiIsIkRvY3VtZW50IiwiYXJncyIsImZpcnN0IiwiZG9jdW1lbnQiLCJzaGlmdCIsIiRkb2N1bWVudCIsIkVsZW1lbnQiLCJjcmVhdGVfZWxlbWVudCIsImJsb2NrIiwidG9fcHJvYyIsIkB0YWdfbmFtZSIsIkBzZWxlY3RvciIsImt3YXJncyIsIkhhc2giLCJsYXN0IiwicG9wIiwiY3VzdG9tX2F0dHJzIiwiY3VzdG9tX2lkIiwiY3VzdG9tX2NsYXNzZXMiLCJ0YWdfbmFtZSIsIiRyZXRfb3JfMSIsInNjYW4iLCJ1cGNhc2UiLCJjbGFzc2VzIiwiZmxhdHRlbiIsImRlbGV0ZSIsInwiLCJpZCIsImF0dHJzIiwibWFwIiwiYmxvY2sgaW4gY3JlYXRlIiwiYSIsImIiLCJfIiwiZCIsImJsb2NrICgyIGxldmVscykgaW4gY3JlYXRlIiwidG9faCIsIm1lcmdlIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwic3ViY2xhc3NlcyIsIkBzdWJjbGFzc2VzIiwiZGVmX3NlbGVjdG9yIiwic2VsZWN0b3IiLCI8PCIsIj1+IiwibmV3IiwibGVuZ3RoIiwiMSIsImJsb2NrX2dpdmVuPyIsIk9wYWwiLCJuYXRpdmU/IiwiW10iLCIwIiwibm9kZSIsInN1YmNsYXNzIiwic2VsZWN0IiwiYmxvY2sgaW4gbmV3IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuZXciLCJuYXRpdmVfaXM/IiwiaW5jbHVkZSIsIkV2ZW50OjpUYXJnZXQiLCJFdmVudCIsInRhcmdldCIsImJsb2NrIGluIDxjbGFzczpFbGVtZW50PiIsInZhbHVlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6RWxlbWVudD4iLCJET00iLCJTdGFuZGFyZEVycm9yIiwiSlM6OkVycm9yIiwiSlMiLCJuYXRpdmUkIiwia2xhc3MiLCJpcyIsIm5hdGl2ZV9tYXRjaGVzPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJsb2FkZWQ/IiwiQG5hdGl2ZSIsIi8iLCJOb2RlU2V0IiwicGF0aHMiLCJibG9jayBpbiAvIiwicGF0aCIsImJsb2NrICgyIGxldmVscykgaW4gLyIsInhwYXRoIiwibmFtZSIsIm9wdGlvbnMiLCJhdHRyaWJ1dGVzIiwiZ2V0IiwiW109Iiwic2V0IiwiYWRkX2NsYXNzIiwiKyIsImNsYXNzX25hbWVzIiwibmFtZXMiLCJlbXB0eT8iLCJ1bmlxIiwiam9pbiIsImF0IiwicGF0aF9vcl9zZWxlY3RvciIsImNzcyIsImF0X2NzcyIsInJlc3VsdCIsImVhY2giLCJydWxlcyIsImJsb2NrIGluIGF0X2NzcyIsInJ1bGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGF0X2NzcyIsImF0X3hwYXRoIiwiYmxvY2sgaW4gYXRfeHBhdGgiLCJibG9jayAoMiBsZXZlbHMpIGluIGF0X3hwYXRoIiwiQXR0cmlidXRlcyIsImF0dHJpYnV0ZV9ub2RlcyIsIk5hdGl2ZTo6QXJyYXkiLCJOYXRpdmUiLCJhbGlhc19uYXRpdmUiLCJyZWplY3QiLCJzcGxpdCIsImNsaWNrIiwiZGF0YSIsIkRhdGEiLCJhc3NpZ24iLCJBcmd1bWVudEVycm9yIiwiaGVpZ2h0Iiwic2l6ZSIsImhlaWdodD0iLCJpZD0iLCJ0b19zIiwiaW5uZXJfZG9tIiwiYnVpbGRlciIsImlubmVyX2RvbT0iLCJCdWlsZGVyIiwidG9fYSIsImNsZWFyIiwiaW5uZXJfaHRtbCIsImlubmVyX2h0bWw9IiwiaW5zcGVjdCIsImRvd25jYXNlIiwiY2xhc3MiLCJnc3ViIiwib2Zmc2V0Iiwib2ZmIiwiT2Zmc2V0IiwidmFsdWVzIiwib2Zmc2V0PSIsIm91dGVyX2h0bWwiLCJwb3NpdGlvbiIsIkBwb3NpdGlvbiIsIlBvc2l0aW9uIiwic2Nyb2xsIiwiQHNjcm9sbCIsIlNjcm9sbCIsInNlYXJjaCIsInNlbGVjdG9ycyIsImJsb2NrIGluIHNlYXJjaCIsImJsb2NrICgyIGxldmVscykgaW4gc2VhcmNoIiwiY29uY2F0Iiwic2hhZG93Iiwib3BlbiIsInJvb3QiLCJzaGFkb3c/Iiwic3R5bGUiLCJDU1M6OkRlY2xhcmF0aW9uIiwiQ1NTIiwiU3RyaW5nIiwicmVwbGFjZSIsImFwcGx5Iiwic3R5bGUhIiwid2luZG93IiwidG9fbiIsInJlbW92ZV9hdHRyaWJ1dGUiLCJyZW1vdmVfY2xhc3MiLCItIiwiU2l6ZSIsImluYyIsInRvZ2dsZV9jbGFzcyIsInBhcnRpdGlvbiIsImJsb2NrIGluIHRvZ2dsZV9jbGFzcyIsImJsb2NrICgyIGxldmVscykgaW4gdG9nZ2xlX2NsYXNzIiwiaW5jbHVkZT8iLCJ0b19yZW1vdmUiLCJ0b19hZGQiLCJ3aWR0aCIsIndpZHRoPSIsIk5vZGUiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLE1BQUlDLElBQUpELGFBQUFBLGtCQUxGLEVBS0VBO0FBQUFBLFVBQUFBO0FBQUFBO0FBQUFBO0FBQUFBOztVQUFBQTs7O1VBTEY7VUFLa0I7VUFDZCxJQUFBLFFBQUdFLGNBQUgsRUFBZ0JDLElBQUlDLE9BQUFBLENBQUFBLENBQXBCLENBQUE7WUFDRUMsV0FBV0YsSUFBSUcsT0FBQUEsQ0FBQUE7VUFEakI7WUFHRUQsV0FBV0U7VUFIYjtVQU1BLElBQUEsTUFBR04sSUFBSCxFQUFXTyxhQUFYLENBQUE7WUFDRVIsT0FBUVMsTUFBUkosUUFBUUksa0JBQUFBLEVBQWdCLE1BQUNOLElBQUQsQ0FBaEJNLEVBQXdCQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUF2QkY7VUFEVixPQUVBLElBQUEsUUFBTUcsYUFBTixDQUFBO1lBQ0VaLE9BQVFTLE1BQVJKLFFBQVFJLGtCQUFBQSxFQUFSLENBQXdCRyxhQUF4QixDQUFBLFFBQW1DLE1BQUNULElBQUQsQ0FBbkMsQ0FBUU0sRUFBbUNDLEtBQURDLFNBQUFBLENBQUFBLENBQWxDRjtVQURWLE9BRUEsSUFBQSxRQUFNSSxhQUFOLENBQUE7O1lBS0VDLFNBQVMsWUFBQTtZ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MkwsU0FBQUEsQ0FBUWhNLDRCQUFSZ007RUFDQTNMLElBQUEyTCxTQUFBQSxDQUFRaE0sMkJBQVJnTTtFQUNBM0wsSUFBQTJMLFNBQUFBLENBQVFoTSwwQkFBUmdNO0VBQ0EzTCxJQUFBMkwsU0FBQUEsQ0FBUWhNLDJCQUFSZ007RUFDQTNMLElBQUEyTCxTQUFBQSxDQUFRaE0sNEJBQVJnTTtFQUNBM0wsSUFBQTJMLFNBQUFBLENBQVFoTSw4QkFBUmdNO0VBQ0EzTCxJQUFBMkwsU0FBQUEsQ0FBUWhNLDhCQUFSZ007RUFDQTNMLElBQUEyTCxTQUFBQSxDQUFRaE0sNEJBQVJnTTtFQUNBaE0sT0FBQUssSUFBQTJMLFNBQUFBLENBQVFoTSwyQkFBUmdNO0FBem1CQWhNOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNzEzNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQva2V5Ym9hcmQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEtleWJvYXJkIDwgVUlcbiAgaGFuZGxlcyAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCdcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LktleWJvYXJkJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgVUk6OkRlZmluaXRpb25cbiAgICBkZWYgYWx0IVxuICAgICAgYCNAbmF0aXZlLmFsdEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgY3RybCFcbiAgICAgIGAjQG5hdGl2ZS5jdHJsS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBtZXRhIVxuICAgICAgYCNAbmF0aXZlLm1ldGFLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIHNoaWZ0IVxuICAgICAgYCNAbmF0aXZlLnNoaWZ0S2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBjb2RlPShjb2RlKVxuICAgICAgYCNAbmF0aXZlLmtleUNvZGUgPSAjQG5hdGl2ZS53aGljaCA9ICN7Y29kZX1gXG4gICAgZW5kXG5cbiAgICBkZWYga2V5PShrZXkpXG4gICAgICBgI0BuYXRpdmUua2V5ID0gI3trZXl9YFxuICAgIGVuZFxuXG4gICAgZGVmIGNoYXI9KGNoYXIpXG4gICAgICBgI0BuYXRpdmUuY2hhciA9ICNAbmF0aXZlLmNoYXJDb2RlID0gI3tjaGFyfWBcbiAgICBlbmRcblxuICAgIGRlZiByZXBlYXQhXG4gICAgICBgI0BuYXRpdmUucmVwZWF0ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBsb2NhbGU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmxvY2FsZSA9IHZhbHVlYFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IEtleWJvYXJkRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IFwiXCI7XG5cbiAgICAgICAgaWYgKGRlc2MuYWx0S2V5KSB7XG4gICAgICAgICAgbW9kaWZpZXJzICs9IFwiQWx0IFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuY3RybEtleSkge1xuICAgICAgICAgIG1vZGlmaWVycyArPSBcIkN0cmwgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5zaGlmdEtleSkge1xuICAgICAgICAgIG1vZGlmaWVycyArPSBcIlNoaWZ0XCIgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MubWV0YUtleSkge1xuICAgICAgICAgIG1vZGlmaWVycyArPSBcIk1ldGEgXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIktleWJvYXJkRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0S2V5Ym9hcmRFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgZGVzYy53aGljaCwgMCxcbiAgICAgICAgICAgICAgbW9kaWZpZXJzLCBkZXNjLnJlcGVhdCwgZGVzYy5sb2NhbGUpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFsdD8sIDphbHRLZXlcbiAgYWxpYXNfbmF0aXZlIDpjdHJsPywgOmN0cmxLZXlcbiAgYWxpYXNfbmF0aXZlIDptZXRhPywgOm1ldGFLZXlcbiAgYWxpYXNfbmF0aXZlIDpzaGlmdD8sIDpzaGlmdEtleVxuICBhbGlhc19uYXRpdmUgOmxvY2FsZVxuICBhbGlhc19uYXRpdmUgOnJlcGVhdD8sIDpyZXBlYXRcblxuICAjIElFIDExIGF0IGxlYXN0IGhhcyBkaWZmZXJlbnQgbmFtZXMgZm9yIHRob3NlIGtleXMuXG4gIElFX01BUCA9IHtcbiAgICAnRG93bicgPT4gJ0Fycm93RG93bicsXG4gICAgJ1VwJyA9PiAnQXJyb3dVcCcsXG4gICAgJ0xlZnQnID0+ICdBcnJvd0xlZnQnLFxuICAgICdSaWdodCcgPT4gJ0Fycm93UmlnaHQnLFxuICAgICdFc2MnID0+ICdFc2NhcGUnLFxuICAgICdEZWwnID0+ICdEZWxldGUnXG4gIH1cblxuICBkZWYga2V5XG4gICAga2V5ID0gYCNAbmF0aXZlLmtleSB8fCAjQG5hdGl2ZS5rZXlJZGVudGlmaWVyIHx8IG5pbGBcbiAgICBJRV9NQVBba2V5XSB8fCBrZXlcbiAgZW5kXG5cbiAgZGVmIGNvZGVcbiAgICBgI0BuYXRpdmUua2V5Q29kZSB8fCAjQG5hdGl2ZS53aGljaCB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiBjaGFyXG4gICAgYCNAbmF0aXZlLmNoYXIgfHwgI0BuYXRpdmUuY2hhckNvZGUgfHwgI3tjb2RlID8gY29kZS5jaHIgOiBuaWx9YFxuICBlbmRcblxuICBhbGlhcyB0b19pIGtleVxuXG4gIGRlZiBkb3duP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2tleWRvd24nXG4gIGVuZFxuXG4gIGRlZiBwcmVzcz9cbiAgICBuYW1lLmRvd25jYXNlID09ICdrZXlwcmVzcydcbiAgZW5kXG5cbiAgZGVmIHVwP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2tleXVwJ1xuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpLZXlib2FyZD4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwiYWx0ISIsIkBuYXRpdmUiLCJjdHJsISIsIm1ldGEhIiwic2hpZnQhIiwiY29kZT0iLCJjb2RlIiwia2V5PSIsImtleSIsImNoYXI9IiwiY2hhciQiLCJyZXBlYXQhIiwibG9jYWxlPSIsInZhbHVlIiwiVUk6OkRlZmluaXRpb24iLCJVSSIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiJHJldF9vcl8xIiwiSUVfTUFQIiwiW10iLCJjaGFyIiwiY2hyIiwiZG93bj8iLCJkb3duY2FzZSIsIj09IiwicHJlc3M/IiwidXA/Il0sIm1hcHBpbmdzIjoiQUFBQUEseUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsU0FBUixFQUFtQkEsVUFB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QyxHQUFBQSxXQUFBQSxFQUFpQnNCLFFBQWpCdEI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzczMTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9jZGF0YS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG5jbGFzcyBDREFUQSA8IFRleHRcbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RE9NOjpDREFUQTogI3t2YWx1ZX0+XCJcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpDREFUQT4iLCJpbnNwZWN0Iiwic2VsZiIsInZhbHVlIiwiVGV4dCJdLCJtYXBwaW5ncyI6IkFBQUFBLG9DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOzs7UUFDRUEsT0FBQUMsdUJBQUFBLG1CQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQ0EsZ0JBQUQsR0FBQSxDQUFpQkMsSUFBQUMsT0FBQUEsQ0FBQUEsQ0FBakIsQ0FBQSxHQUF1QkY7UUFEekJBLENBQUFBLEdBQUFBO01BREZELEdBQUFBLFdBQUFBLEVBQWNJLFVBQWRKO0lBRmdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3MzQzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vbm9kZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG4jIEFic3RyYWN0IGNsYXNzIGZvciBhbGwgRE9NIG5vZGUgdHlwZXMuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGVcbmNsYXNzIE5vZGVcbiAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgRUxFTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gMVxuICBBVFRSSUJVVEVfTk9ERSAgICAgICAgICAgICAgPSAyXG4gIFRFWFRfTk9ERSAgICAgICAgICAgICAgICAgICA9IDNcbiAgQ0RBVEFfU0VDVElPTl9OT0RFICAgICAgICAgID0gNFxuICBFTlRJVFlfUkVGRVJFTkNFX05PQ0UgICAgICAgPSA1XG4gIEVOVElUWV9OT0RFICAgICAgICAgICAgICAgICA9IDZcbiAgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFID0gN1xuICBDT01NRU5UX05PREUgICAgICAgICAgICAgICAgPSA4XG4gIERPQ1VNRU5UX05PREUgICAgICAgICAgICAgICA9IDlcbiAgRE9DVU1FTlRfVFlQRV9OT0RFICAgICAgICAgID0gMTBcbiAgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAgICAgID0gMTFcbiAgTk9UQVRJT05fTk9ERSAgICAgICAgICAgICAgID0gMTJcblxuICAjIFdyYXAgYSBuYXRpdmUgRE9NIG5vZGUuXG4gICNcbiAgIyBAcGFyYW0gdmFsdWUgW25hdGl2ZV0gdGhlIG5hdGl2ZSBET00gbm9kZVxuICAjXG4gICMgQHJldHVybiBbTm9kZV1cbiAgZGVmIHNlbGYubmV3KHZhbHVlKVxuICAgIGlmIHNlbGYgPT0gTm9kZVxuICAgICAgQGNsYXNzZXMgfHw9IFtuaWwsIEVsZW1lbnQsIEF0dHJpYnV0ZSwgVGV4dCwgQ0RBVEEsIG5pbCwgbmlsLCBuaWwsIENvbW1lbnQsIERvY3VtZW50LCBuaWwsIERvY3VtZW50RnJhZ21lbnRdXG5cbiAgICAgIGlmIGtsYXNzID0gQGNsYXNzZXNbYHZhbHVlLm5vZGVUeXBlYF1cbiAgICAgICAga2xhc3MubmV3KHZhbHVlKVxuICAgICAgZWxzZVxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnY2Fubm90IGluc3RhbnRpYXRlIGEgbm9uIGRlcml2ZWQgTm9kZSBvYmplY3QnXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShub2RlKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiUGxlYXNlIGVuc3VyZSB0aGF0ICNpbml0aWFsaXplIG9mICN7c2VsZi5jbGFzc30gYWNjZXB0cyBvbmUgYXJndW1lbnRcIiB1bmxlc3Mgbm9kZVxuICAgIHN1cGVyXG4gIGVuZFxuXG4gICMgUmV0dXJuIHRydWUgb2YgdGhlIG90aGVyIGVsZW1lbnQgaXMgdGhlIHNhbWUgdW5kZXJseWluZyBET00gbm9kZS5cbiAgI1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dXG4gIGRlZiA9PShvdGhlcilcbiAgICBgI0BuYXRpdmUgPT09ICN7TmF0aXZlLmNvbnZlcnQob3RoZXIpfWBcbiAgZW5kXG5cbiAgIyBJbml0aWFsaXplIGEgbmV3IG5vZGUgYWZ0ZXIgYCNkdXBgIG9yIGAjY2xvbmVgLlxuICAjXG4gICMgVGhpcyBtZXRob2QgaXMgbm90IHRvIGJlIGNhbGxlZCBkaXJlY3RseS4gVXNlIGBOb2RlI2R1cGAgb3JcbiAgIyBgTm9kZSNjbG9uZWAuXG4gICNcbiAgIyBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgZGVlcCBkZXRhY2hlZCBjbG9uZSBvZiBhIERPTSBzdWJ0cmVlIHRvIGJlIHVzZWRcbiAgIyBpbiB0aGUgc2FtZSBkb2N1bWVudC4gVGhlIG5ldyBub2RlIHdpbGwgaGF2ZSBhbGwgZXZlbnRzIGRldGFjaGVkLlxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG9sZClcbiAgICBzZXRfbmF0aXZlX3JlZmVyZW5jZSBgI3tvbGQudG9fbn0uY2xvbmVOb2RlKHRydWUpYFxuICBlbmRcblxuICAjIEFwcGVuZCBhIGNoaWxkIHRvIHRoZSBub2RlLlxuICAjXG4gICMgV2hlbiBwYXNzaW5nIGEge1N0cmluZ30gYSB0ZXh0IG5vZGUgd2lsbCBiZSBjcmVhdGVkLlxuICAjXG4gICMgV2hlbiBwYXNzaW5nIGFuIE9iamVjdCB0aGF0IHJlc3BvbmRzIHRvICNlYWNoLCBldmVyeSB5aWVsZGVkIGVsZW1lbnRcbiAgIyB3aWxsIGJlIGFkZGVkIGZvbGxvd2luZyB0aGUgc2FtZSBsb2dpYy5cbiAgI1xuICAjIEBwYXJhbSBub2RlIFtTdHJpbmcsIE5vZGUsICNlYWNoLCAjdG9fbl0gdGhlIG5vZGUgdG8gYXBwZW5kXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgPDwobm9kZSlcbiAgICBpZiBPcGFsLnJlc3BvbmRfdG8/IG5vZGUsIDplYWNoXG4gICAgICBub2RlLmVhY2ggeyB8bnwgc2VsZiA8PCBuIH1cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZWxzaWYgT3BhbC5yZXNwb25kX3RvPyBub2RlLCA6dG9fZG9tXG4gICAgICBub2RlID0gbm9kZS50b19kb20oZG9jdW1lbnQpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgbmF0aXZlPyhub2RlKVxuICAgICAgaWYgU3RyaW5nID09PSBub2RlXG4gICAgICAgIG5vZGUgPSBgI0BuYXRpdmUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKWBcbiAgICAgIGVsc2VcbiAgICAgICAgbm9kZSA9IE5hdGl2ZS5jb252ZXJ0KG5vZGUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5hcHBlbmRDaGlsZChub2RlKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmID4+KG5vZGUpXG4gICAgaWYgT3BhbC5yZXNwb25kX3RvPyBub2RlLCA6ZWFjaFxuICAgICAgbm9kZS5lYWNoIHsgfG58IHNlbGYgPj4gbiB9XG4gICAgICByZXR1cm4gc2VsZlxuICAgIGVsc2lmIE9wYWwucmVzcG9uZF90bz8gbm9kZSwgOnRvX2RvbVxuICAgICAgbm9kZSA9IG5vZGUudG9fZG9tKGRvY3VtZW50KVxuICAgIGVuZFxuXG4gICAgdW5sZXNzIG5hdGl2ZT8obm9kZSlcbiAgICAgIGlmIFN0cmluZyA9PT0gbm9kZVxuICAgICAgICBub2RlID0gYCNAbmF0aXZlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZSlgXG4gICAgICBlbHNlXG4gICAgICAgIG5vZGUgPSBOYXRpdmUuY29udmVydChub2RlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBpZiBgI0BuYXRpdmUuZmlyc3RDaGlsZCA9PSBudWxsYFxuICAgICAgYCNAbmF0aXZlLmFwcGVuZENoaWxkKG5vZGUpYFxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS5pbnNlcnRCZWZvcmUobm9kZSwgI0BuYXRpdmUuZmlyc3RDaGlsZClgXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhZGRfY2hpbGQobm9kZSA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBub2RlXG4gICAgICBub2RlID0gRE9NKCZibG9jaylcbiAgICBlbmRcblxuICAgIHNlbGYgPDwgbm9kZVxuICBlbmRcblxuICAjIEFkZCB0aGUgcGFzc2VkIG5vZGUgYWZ0ZXIgdGhpcyBvbmUuXG4gICNcbiAgIyBXaGVuIHBhc3NpbmcgYSB7U3RyaW5nfSBhIHRleHQgbm9kZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICNcbiAgIyBAcGFyYW0gbm9kZSBbU3RyaW5nLCBOb2RlLCAjdG9fbl0gdGhlIG5vZGUgdG8gYWRkXG4gIGRlZiBhZGRfbmV4dF9zaWJsaW5nKG5vZGUgPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3Mgbm9kZVxuICAgICAgbm9kZSA9IERPTSgmYmxvY2spXG4gICAgZW5kXG4gICAgbm9kZSA9IG5vZGUudG9fZG9tKGRvY3VtZW50KSBpZiBPcGFsLnJlc3BvbmRfdG8/IG5vZGUsIDp0b19kb21cblxuICAgIHVubGVzcyBuYXRpdmU/KG5vZGUpXG4gICAgICBpZiBTdHJpbmcgPT09IG5vZGVcbiAgICAgICAgbm9kZSA9IGAjQG5hdGl2ZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpYFxuICAgICAgZWxzZVxuICAgICAgICBub2RlID0gTmF0aXZlLmNvbnZlcnQobm9kZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYCNAbmF0aXZlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsICNAbmF0aXZlLm5leHRTaWJsaW5nKWBcbiAgZW5kXG5cbiAgIyBBZGQgdGhlIHBhc3NlZCBub2RlIGJlZm9yZSB0aGlzIG9uZS5cbiAgI1xuICAjIFdoZW4gcGFzc2luZyBhIHtTdHJpbmd9IGEgdGV4dCBub2RlIHdpbGwgYmUgY3JlYXRlZC5cbiAgI1xuICAjIEBwYXJhbSBub2RlIFtTdHJpbmcsIE5vZGUsICN0b19uXSB0aGUgbm9kZSB0byBhZGRcbiAgZGVmIGFkZF9wcmV2aW91c19zaWJsaW5nKG5vZGUgPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3Mgbm9kZVxuICAgICAgbm9kZSA9IERPTSgmYmxvY2spXG4gICAgZW5kXG4gICAgbm9kZSA9IG5vZGUudG9fZG9tKGRvY3VtZW50KSBpZiBPcGFsLnJlc3BvbmRfdG8/IG5vZGUsIDp0b19kb21cblxuICAgIHVubGVzcyBuYXRpdmU/KG5vZGUpXG4gICAgICBpZiBTdHJpbmcgPT09IG5vZGVcbiAgICAgICAgbm9kZSA9IGAjQG5hdGl2ZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpYFxuICAgICAgZWxzZVxuICAgICAgICBub2RlID0gTmF0aXZlLmNvbnZlcnQobm9kZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYCNAbmF0aXZlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsICNAbmF0aXZlKWBcbiAgZW5kXG5cbiAgYWxpYXMgYWZ0ZXIgYWRkX25leHRfc2libGluZ1xuXG4gICMgQXBwZW5kIHRoZSBub2RlIHRvIHRoZSBwYXNzZWQgb25lLlxuICAjXG4gICMgQHBhcmFtIG5vZGUgW05vZGVdIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xuICBkZWYgYXBwZW5kX3RvKG5vZGUpXG4gICAgbm9kZSA8PCBzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEdldCBhbiBhcnJheSBvZiBhbmNlc3RvcnMuXG4gICNcbiAgIyBQYXNzaW5nIGEgc2VsZWN0b3Igd2lsbCBzZWxlY3QgdGhlIGFuY2VzdG9ycyBtYXRjaGluZyBpdC5cbiAgI1xuICAjIEBwYXJhbSBleHByZXNzaW9uIFtTdHJpbmddIHRoZSBzZWxlY3RvciB0byB1c2UgYXMgZmlsdGVyXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlU2V0XVxuICBkZWYgYW5jZXN0b3JzKGV4cHJlc3Npb24gPSBuaWwpXG4gICAgcmV0dXJuIE5vZGVTZXRbXSB1bmxlc3MgcGFyZW50XG5cbiAgICBwYXJlbnRzID0gW3BhcmVudF1cblxuICAgIHdoaWxlIHBhcmVudCA9IHBhcmVudHMubGFzdC5wYXJlbnRcbiAgICAgIHBhcmVudHMgPDwgcGFyZW50XG4gICAgZW5kXG5cbiAgICBpZiBEb2N1bWVudCA9PT0gcGFyZW50cy5sYXN0XG4gICAgICBwYXJlbnRzLnBvcFxuICAgIGVuZFxuXG4gICAgaWYgZXhwcmVzc2lvblxuICAgICAgcGFyZW50cy5zZWxlY3QhIHsgfHB8IHAgPX4gZXhwcmVzc2lvbiB9XG4gICAgZW5kXG5cbiAgICBOb2RlU2V0Lm5ldyhwYXJlbnRzKVxuICBlbmRcblxuICBkZWYgYXR0YWNoZWQ/XG4gICAgYCNAbmF0aXZlLmlzQ29ubmVjdGVkYFxuICBlbmRcblxuICBhbGlhcyBiZWZvcmUgYWRkX3ByZXZpb3VzX3NpYmxpbmdcblxuICAjIFJlbW92ZSB0aGUgbm9kZSBmcm9tIGl0cyBwYXJlbnQuXG4gIGRlZiByZW1vdmVcbiAgICBwYXJlbnQucmVtb3ZlX2NoaWxkKHNlbGYpIGlmIHBhcmVudFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBSZW1vdmUgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZS5cbiAgZGVmIGNsZWFyXG4gICAgY2hpbGRyZW4ucmVtb3ZlXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgY29udGVudFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGlubmVyIHRleHQgY29udGVudCBvZiB0aGUgbm9kZVxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC50ZXh0Q29udGVudCdcbiAgICBkZWYgY29udGVudFxuICAgICAgYCNAbmF0aXZlLnRleHRDb250ZW50YFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbnRlbnQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnRleHRDb250ZW50ID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LmlubmVyVGV4dCdcbiAgICBkZWYgY29udGVudFxuICAgICAgYCNAbmF0aXZlLmlubmVyVGV4dGBcbiAgICBlbmRcblxuICAgIGRlZiBjb250ZW50PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5pbm5lclRleHQgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiBjb250ZW50XG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnbm9kZSB0ZXh0IGNvbnRlbnQgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG5cbiAgICBkZWYgY29udGVudD0odmFsdWUpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnbm9kZSB0ZXh0IGNvbnRlbnQgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBibGFuaz9cbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBDREFUQSBzZWN0aW9uLlxuICBkZWYgY2RhdGE/XG4gICAgbm9kZV90eXBlID09IENEQVRBX1NFQ1RJT05fTk9ERVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBjaGlsZFxuICAjIEByZXR1cm4gW05vZGU/XSB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIG5vZGVcbiAgZGVmIGNoaWxkXG4gICAgY2hpbGRyZW4uZmlyc3RcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBjaGlsZHJlblxuICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZVxuICBkZWYgY2hpbGRyZW5cbiAgICBOb2RlU2V0W05hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5jaGlsZE5vZGVzYCldXG4gIGVuZFxuXG4gIGRlZiBjaGlsZHJlbj0obm9kZSlcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBjb21tZW50LlxuICBkZWYgY29tbWVudD9cbiAgICBub2RlX3R5cGUgPT0gQ09NTUVOVF9OT0RFXG4gIGVuZFxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBjdXN0b20gZWxlbWVudC5cbiAgZGVmIGN1c3RvbT9cbiAgICBmYWxzZVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyd10gZG9jdW1lbnRcbiAgIyBAcmV0dXJuIFtEb2N1bWVudD9dIHRoZSBkb2N1bWVudCB0aGUgbm9kZSBpcyBhdHRhY2hlZCB0b1xuICBkZWYgZG9jdW1lbnRcbiAgICBET00oYCNAbmF0aXZlLm93bmVyRG9jdW1lbnRgKSBpZiBkZWZpbmVkPyhgI0BuYXRpdmUub3duZXJEb2N1bWVudGApXG4gIGVuZFxuXG4gICMgRGV0YWNoIGEgbm9kZSBhbmQgdHJhbnNmZXIgaXQgdG8gYW5vdGhlciBkb2N1bWVudC5cbiAgZGVmIGRvY3VtZW50PShuZXdfZG9jdW1lbnQpXG4gICAgYCN7TmF0aXZlLnRyeV9jb252ZXJ0KG5ld19kb2N1bWVudCwgbmV3X2RvY3VtZW50KX0uYWRvcHROb2RlKCNAbmF0aXZlKWBcbiAgZW5kXG5cbiAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIGRvY3VtZW50LlxuICBkZWYgZG9jdW1lbnQ/XG4gICAgbm9kZV90eXBlID09IERPQ1VNRU5UX05PREVcbiAgZW5kXG5cbiAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhbiBlbGVtZW50LlxuICBkZWYgZWxlbT9cbiAgICBub2RlX3R5cGUgPT0gRUxFTUVOVF9OT0RFXG4gIGVuZFxuXG4gIGFsaWFzIGVsZW1lbnQ/IGVsZW0/XG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gZWxlbWVudF9jaGlsZHJlblxuICAjIEByZXR1cm4gW05vZGVTZXRdIGFsbCB0aGUgY2hpbGRyZW4gd2hpY2ggYXJlIGVsZW1lbnRzXG4gIGRlZiBlbGVtZW50X2NoaWxkcmVuXG4gICAgY2hpbGRyZW4uc2VsZWN0KCY6ZWxlbWVudD8pXG4gIGVuZFxuXG4gIGFsaWFzIGVsZW1lbnRzIGVsZW1lbnRfY2hpbGRyZW5cblxuICAjIEAhYXR0cmlidXRlIFtyXSBmaXJzdF9lbGVtZW50X2NoaWxkXG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBmaXJzdCBlbGVtZW50IGNoaWxkXG4gIGRlZiBmaXJzdF9lbGVtZW50X2NoaWxkXG4gICAgZWxlbWVudF9jaGlsZHJlbi5maXJzdFxuICBlbmRcblxuICAjIFJldHVybiB0cnVlIGlmIHRoZSBub2RlIGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG4gIGRlZiBmcmFnbWVudD9cbiAgICBub2RlX3R5cGUgPT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERVxuICBlbmRcblxuICBhbGlhcyBpbm5lcl90ZXh0IGNvbnRlbnRcbiAgYWxpYXMgaW5uZXJfdGV4dD0gY29udGVudD1cblxuICAjIEAhYXR0cmlidXRlIFtyXSBsYXN0X2VsZW1lbnRfY2hpbGRcbiAgIyBAcmV0dXJuIFtFbGVtZW50P10gdGhlIGxhc3QgZWxlbWVudCBjaGlsZFxuICBkZWYgbGFzdF9lbGVtZW50X2NoaWxkXG4gICAgZWxlbWVudF9jaGlsZHJlbi5sYXN0XG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgbmFtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5vZGVcbiAgZGVmIG5hbWVcbiAgICBgI0BuYXRpdmUubm9kZU5hbWUgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgbmFtZT0odmFsdWUpXG4gICAgYCNAbmF0aXZlLm5vZGVOYW1lID0gI3t2YWx1ZS50b19zfWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbmFtZXNwYWNlXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgbmFtZXNwYWNlIG9mIHRoZSBub2RlXG4gIGRlZiBuYW1lc3BhY2VcbiAgICBgI0BuYXRpdmUubmFtZXNwYWNlVVJJIHx8IG5pbGBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBuZXh0XG4gICMgQHJldHVybiBbTm9kZT9dIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIG5vZGVcbiAgZGVmIG5leHRcbiAgICBET00oYCNAbmF0aXZlLm5leHRTaWJsaW5nYCkgaWYgYCNAbmF0aXZlLm5leHRTaWJsaW5nICE9IG51bGxgXG4gIGVuZFxuXG4gIGFsaWFzIG5leHQ9IGFkZF9uZXh0X3NpYmxpbmdcblxuICAjIEAhYXR0cmlidXRlIFtyXSBuZXh0X2VsZW1lbnRcbiAgIyBAcmV0dXJuIFtFbGVtZW50P10gdGhlIG5leHQgZWxlbWVudCBzaWJsaW5nIG9mIHRoZSBub2RlXG4gIGRlZiBuZXh0X2VsZW1lbnRcbiAgICBjdXJyZW50ID0gc2VsZi5uZXh0XG5cbiAgICB3aGlsZSBjdXJyZW50ICYmICFjdXJyZW50LmVsZW1lbnQ/XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0XG4gICAgZW5kXG5cbiAgICBjdXJyZW50XG4gIGVuZFxuXG4gIGFsaWFzIG5leHRfc2libGluZyBuZXh0XG5cbiAgYWxpYXMgbm9kZV9uYW1lIG5hbWVcblxuICBhbGlhcyBub2RlX25hbWU9IG5hbWU9XG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbm9kZV90eXBlXG4gICMgQHJldHVybiBbU3ltYm9sXSB0aGUgdHlwZSBvZiB0aGUgbm9kZVxuICBkZWYgbm9kZV90eXBlXG4gICAgYCNAbmF0aXZlLm5vZGVUeXBlYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIG91dGVyX2h0bWxcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzaW11bGF0ZWQgb3V0ZXIgaHRtbCBvZiB0aGUgbm9kZVxuICBkZWYgb3V0ZXJfaHRtbFxuICAgIGRpdiA9ICRkb2N1bWVudC5jcmVhdGVfZWxlbWVudChcIkRJVlwiKVxuICAgIGRpdiA8PCBzZWxmLmR1cFxuICAgIGRpdi5pbm5lcl9odG1sXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgcGFyZW50XG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBwYXJlbnQgb2YgdGhlIG5vZGVcbiAgZGVmIHBhcmVudFxuICAgIERPTShgI0BuYXRpdmUucGFyZW50Tm9kZWApIGlmIGAjQG5hdGl2ZS5wYXJlbnROb2RlICE9IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBwYXJlbnQ9KG5vZGUpXG4gICAgYCNAbmF0aXZlLnBhcmVudE5vZGUgPSAje05hdGl2ZS5jb252ZXJ0KG5vZGUpfWBcbiAgZW5kXG5cbiAgZGVmIHBhcnNlKHRleHQsIG9wdGlvbnMgPSB7fSlcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGRlZiBwYXRoXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICAjIFByZXBlbmQgdGhlIG5vZGUgdG8gdGhlIHBhc3NlZCBvbmUuXG4gICNcbiAgIyBAcGFyYW0gbm9kZSBbTm9kZV0gdGhlIG5vZGUgdG8gcHJlcGVuZCB0b1xuICBkZWYgcHJlcGVuZF90byhub2RlKVxuICAgIG5vZGUgPj4gc2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBwcmV2aW91c1xuICAjIEByZXR1cm4gW05vZGU/XSB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgbm9kZVxuICBkZWYgcHJldmlvdXNcbiAgICBET00oYCNAbmF0aXZlLnByZXZpb3VzU2libGluZ2ApIGlmIGAjQG5hdGl2ZS5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbGBcbiAgZW5kXG5cbiAgYWxpYXMgcHJldmlvdXM9IGFkZF9wcmV2aW91c19zaWJsaW5nXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcHJldmlvdXNfZWxlbWVudFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgcHJldmlvdXMgZWxlbWVudCBzaWJsaW5nIG9mIHRoZSBub2RlXG4gIGRlZiBwcmV2aW91c19lbGVtZW50XG4gICAgY3VycmVudCA9IHNlbGYucHJldmlvdXNcblxuICAgIHdoaWxlIGN1cnJlbnQgJiYgIWN1cnJlbnQuZWxlbWVudD9cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzXG4gICAgZW5kXG5cbiAgICBjdXJyZW50XG4gIGVuZFxuXG4gIGFsaWFzIHByZXZpb3VzX3NpYmxpbmcgcHJldmlvdXNcblxuICAjIFJlbW92ZSB0aGUgZ2l2ZW4gbm9kZSBmcm9tIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUuXG4gIGRlZiByZW1vdmVfY2hpbGQobm9kZSlcbiAgICBgI0BuYXRpdmUucmVtb3ZlQ2hpbGQoI3tOYXRpdmUudHJ5X2NvbnZlcnQobm9kZSl9KWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgUmVwbGFjZSB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBvbmUuXG4gICNcbiAgIyBAdG9kbyBpbXBsZW1lbnQgZm9yIE5vZGVTZXRcbiAgI1xuICAjIEBwYXJhbSBub2RlIFtOb2RlXSB0aGUgbm9kZSB0byByZXBsYWNlIHdpdGhcbiAgIyBAcmV0dXJuIFtOb2RlXSB0aGUgcGFzc2VkIG5vZGVcbiAgZGVmIHJlcGxhY2Uobm9kZSlcbiAgICBub2RlID0gbm9kZS50b19kb20oZG9jdW1lbnQpIGlmIE9wYWwucmVzcG9uZF90bz8gbm9kZSwgOnRvX2RvbVxuXG4gICAgdW5sZXNzIG5hdGl2ZT8obm9kZSlcbiAgICAgIGlmIFN0cmluZyA9PT0gbm9kZVxuICAgICAgICBub2RlID0gYCNAbmF0aXZlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZSlgXG4gICAgICBlbHNlXG4gICAgICAgIG5vZGUgPSBOYXRpdmUuY29udmVydChub2RlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBgI0BuYXRpdmUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgI0BuYXRpdmUpYFxuXG4gICAgRE9NKG5vZGUpXG4gIGVuZFxuXG4gIGFsaWFzIHJlcGxhY2Vfd2l0aCByZXBsYWNlXG5cbiAgYWxpYXMgdGV4dCBjb250ZW50XG4gIGFsaWFzIHRleHQ9IGNvbnRlbnQ9XG5cbiAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIHRleHQgbm9kZS5cbiAgZGVmIHRleHQ/XG4gICAgbm9kZV90eXBlID09IFRFWFRfTk9ERVxuICBlbmRcblxuICBkZWYgdHJhdmVyc2UoJmJsb2NrKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgYWxpYXMgdHlwZSBub2RlX3R5cGVcblxuICAjIEAhYXR0cmlidXRlIHZhbHVlXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgdmFsdWUgb2YgdGhlIG5vZGVcbiAgZGVmIHZhbHVlXG4gICAgYCNAbmF0aXZlLm5vZGVWYWx1ZSB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiB2YWx1ZT0odmFsdWUpXG4gICAgYCNAbmF0aXZlLm5vZGVWYWx1ZSA9IHZhbHVlYFxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPERPTTo6Tm9kZTogI3tuYW1lfT5cIlxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOk5vZGU+Iiwic2VsZiIsImluY2x1ZGUiLCJCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyIiwiQnJvd3NlciIsIjEiLCIyIiwiMyIsIjQiLCI1IiwiNiIsIjciLCI4IiwiOSIsIjEwIiwiMTEiLCIxMiIsIm5ldyIsInZhbHVlIiwiTm9kZSIsIkBjbGFzc2VzIiwiJHJldF9vcl8xIiwiRWxlbWVudCIsIkF0dHJpYnV0ZSIsIlRleHQiLCJDREFUQSIsIkNvbW1lbnQiLCJEb2N1bWVudCIsIkRvY3VtZW50RnJhZ21lbnQiLCJrbGFzcyIsIltdIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiaW5pdGlhbGl6ZSIsIm5vZGUiLCJjbGFzcyIsIj09Iiwib3RoZXIiLCJAbmF0aXZlIiwiTmF0aXZlIiwiY29udmVydCIsImluaXRpYWxpemVfY29weSIsIm9sZCIsInNldF9uYXRpdmVfcmVmZXJlbmNlIiwidG9fbiIsIjw8IiwiT3BhbCIsInJlc3BvbmRfdG8/IiwiZWFjaCIsImJsb2NrIGluIDw8IiwibiIsImJsb2NrICgyIGxldmVscykgaW4gPDwiLCJ0b19kb20iLCJkb2N1bWVudCIsIm5hdGl2ZT8iLCJTdHJpbmciLCI+PiIsImJsb2NrIGluID4+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA+PiIsImFkZF9jaGlsZCIsIkRPTSIsImJsb2NrIiwidG9fcHJvYyIsImFkZF9uZXh0X3NpYmxpbmciLCJhZGRfcHJldmlvdXNfc2libGluZyIsImFwcGVuZF90byIsImFuY2VzdG9ycyIsImV4cHJlc3Npb24iLCJwYXJlbnQiLCJOb2RlU2V0IiwicGFyZW50cyIsImxhc3QiLCJwb3AiLCJzZWxlY3QhIiwiYmxvY2sgaW4gYW5jZXN0b3JzIiwicCIsImJsb2NrICgyIGxldmVscykgaW4gYW5jZXN0b3JzIiwiPX4iLCJhdHRhY2hlZD8iLCJyZW1vdmUiLCJyZW1vdmVfY2hpbGQiLCJjbGVhciIsImNoaWxkcmVuIiwic3VwcG9ydHM/IiwiY29udGVudCIsImNvbnRlbnQ9IiwiTm90SW1wbGVtZW50ZWRFcnJvciIsImJsYW5rPyIsImNkYXRhPyIsIm5vZGVfdHlwZSIsIkNEQVRBX1NFQ1RJT05fTk9ERSIsImNoaWxkIiwiZmlyc3QiLCJOYXRpdmU6OkFycmF5IiwiY2hpbGRyZW49IiwiY29tbWVudD8iLCJDT01NRU5UX05PREUiLCJjdXN0b20/IiwiZG9jdW1lbnQ9IiwibmV3X2RvY3VtZW50IiwidHJ5X2NvbnZlcnQiLCJkb2N1bWVudD8iLCJET0NVTUVOVF9OT0RFIiwiZWxlbT8iLCJFTEVNRU5UX05PREUiLCJlbGVtZW50X2NoaWxkcmVuIiwic2VsZWN0IiwiZmlyc3RfZWxlbWVudF9jaGlsZCIsImZyYWdtZW50PyIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJsYXN0X2VsZW1lbnRfY2hpbGQiLCJuYW1lIiwibmFtZT0iLCJ0b19zIiwibmFtZXNwYWNlIiwibmV4dCIsIm5leHRfZWxlbWVudCIsImN1cnJlbnQiLCJlbGVtZW50PyIsIiEiLCJvdXRlcl9odG1sIiwiZGl2IiwiJGRvY3VtZW50IiwiY3JlYXRlX2VsZW1lbnQiLCJkdXAiLCJpbm5lcl9odG1sIiwicGFyZW50PSIsInBhcnNlIiwidGV4dCIsIm9wdGlvbnMiLCJwYXRoIiwicHJlcGVuZF90byIsInByZXZpb3VzIiwicHJldmlvdXNfZWxlbWVudCIsInJlcGxhY2UiLCJ0ZXh0PyIsIlRFWFRfTk9ERSIsInRyYXZlcnNlIiwidmFsdWU9IiwiaW5zcGVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFLaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLGFBQUFELHdCQUFSRDtRQUVBLHdDQUE4QkcsQ0FBOUI7UUFDQSwwQ0FBOEJDLENBQTlCO1FBQ0EscUNBQThCQyxDQUE5QjtRQUNBLDhDQUE4QkMsQ0FBOUI7UUFDQSxpREFBOEJDLENBQTlCO1FBQ0EsdUNBQThCQyxDQUE5QjtRQUNBLHVEQUE4QkMsQ0FBOUI7UUFDQSx3Q0FBOEJDLENBQTlCO1FBQ0EseUNBQThCQyxDQUE5QjtRQUNBLDhDQUE4QkMsRUFBOUI7UUFDQSxrREFBOEJDLEVBQTlCO1FBQ0EseUNBQThCQyxFQUE5QjtRQU9BQyxNQUFJaEIsSUFBSmdCLFVBQUFBLHFCQUFhQyxL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Q0FBQSxHQUFxQjRCO1FBRHZCQSxDQUFBQSxHQUFBQTtNQTdlRjNJLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBTGdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3OTEyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2Nzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbnJlcXVpcmUgJ3BhZ2dpby9jc3MvdW5pdCdcbnJlcXVpcmUgJ3BhZ2dpby9jc3MvY29sb3InXG5yZXF1aXJlICdwYWdnaW8vY3NzL2RlZmluaXRpb24nXG5yZXF1aXJlICdwYWdnaW8vY3NzL3J1bGUnXG5yZXF1aXJlICdwYWdnaW8vY3NzL2ZvbnQnXG5yZXF1aXJlICdwYWdnaW8vY3NzL2FuaW1hdGlvbidcblxuY2xhc3MgUGFnZ2lvXG5cbmNsYXNzIENTUyA8IEJhc2ljT2JqZWN0XG4gIGRlZiBzZWxmLnNlbGVjdG9yKGxpc3QpXG4gICAgcmVzdWx0ID0gJydcblxuICAgIGxpc3QuZWFjaCB7fHBhcnR8XG4gICAgICBpZiBwYXJ0LnN0YXJ0X3dpdGg/KCcmJylcbiAgICAgICAgcmVzdWx0ICs9IHBhcnRbMSAuLiAtMV1cbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgcGFydFxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgaWYgcmVzdWx0WzBdID09IFwiIFwiXG4gICAgICByZXN1bHRbMSAuLiAtMV1cbiAgICBlbHNlXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOnJ1bGVzLCA6bWVkaWEsIDpmb250cywgOmFuaW1hdGlvbnNcblxuICBkZWYgaW5pdGlhbGl6ZShkZWZlcjogZmFsc2UsICZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICBAc2VsZWN0b3IgICA9IFtdXG4gICAgQGN1cnJlbnQgICAgPSBbXVxuICAgIEBydWxlcyAgICAgID0gW11cbiAgICBAZm9udHMgICAgICA9IFtdXG4gICAgQGFuaW1hdGlvbnMgPSBbXVxuICAgIFxuICAgIEBibG9jayAgICAgID0gYmxvY2tcblxuICAgIGJ1aWxkISB1bmxlc3MgZGVmZXJcbiAgZW5kXG5cbiAgZGVmIGJ1aWxkIShmb3JjZV9jYWxsOiBmYWxzZSlcbiAgICBpZiAhZm9yY2VfY2FsbCAmJiBAYmxvY2suYXJpdHkgPT0gMFxuICAgICAgaW5zdGFuY2VfZXhlYygmQGJsb2NrKVxuICAgIGVsc2VcbiAgICAgIEBibG9jay5jYWxsKHNlbGYpXG4gICAgZW5kXG4gICAgQGJsb2NrID0gbmlsXG4gIGVuZFxuXG4gIGRlZiBydWxlKCpuYW1lcywgJmJsb2NrKVxuICAgIHJldHVybiB1bmxlc3MgYmxvY2tcblxuICAgIGlmIG5hbWVzLmFueT8geyB8bnwgbi5pbmNsdWRlPyAnLCcgfVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnc2VsZWN0b3JzIGNhbm5vdCBjb250YWluIGNvbW1hcydcbiAgICBlbmRcblxuICAgIG5hbWVzLmVhY2gge3xuYW1lfFxuICAgICAgQHNlbGVjdG9yIDw8IG5hbWVcbiAgICAgIEBjdXJyZW50ICA8PCBSdWxlLm5ldyhDU1Muc2VsZWN0b3IoQHNlbGVjdG9yKSwgQG1lZGlhKVxuXG4gICAgICBibG9jay5jYWxsXG5cbiAgICAgIEBzZWxlY3Rvci5wb3BcbiAgICAgIEBydWxlcyA8PCBAY3VycmVudC5wb3BcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZWRpYShxdWVyeSwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgb2xkLCBAbWVkaWEgPSBAbWVkaWEsIHF1ZXJ5XG4gICAgICBibG9jay5jYWxsXG4gICAgICBAbWVkaWEgPSBvbGRcbiAgICBlbHNlXG4gICAgICBtZXRob2RfbWlzc2luZyg6bWVkaWEsIHF1ZXJ5LCAqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGZvbnQobmFtZSwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgQGN1cnJlbnQgPDwgRm9udC5uZXcobmFtZSlcbiAgICAgIGJsb2NrLmNhbGxcbiAgICAgIEBmb250cyA8PCBAY3VycmVudC5wb3BcbiAgICBlbHNlXG4gICAgICBtZXRob2RfbWlzc2luZyg6Zm9udCwgbmFtZSwgKmFyZ3MpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhbmltYXRpb24obmFtZSwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgQGN1cnJlbnQgPDwgQW5pbWF0aW9uLm5ldyhuYW1lKVxuICAgICAgYmxvY2suY2FsbFxuICAgICAgQGFuaW1hdGlvbnMgPDwgQGN1cnJlbnQucG9wXG4gICAgZWxzZVxuICAgICAgbWV0aG9kX21pc3NpbmcoOmFuaW1hdGlvbiwgbmFtZSwgKmFyZ3MpXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgdGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgbWV0aG9kcyBpbnNpZGUgdGhlIHJ1bGUgYmxvY2tzIGFyZSBhY3R1YWxseVxuICAjIGNhbGxlZCBvbiB0aGUgQ1NTIG9iamVjdFxuICBkZWYgbWV0aG9kX21pc3NpbmcoKmFyZ3MsICZibG9jaylcbiAgICBAY3VycmVudC5sYXN0Ll9fc2VuZF9fKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEhUTUwgPCBCYXNpY09iamVjdFxuICBkZWYgc3R5bGUoJmJsb2NrKVxuICAgIChAY3VycmVudCB8fCBAcm9vdHMpIDw8IENTUy5uZXcoJmJsb2NrKVxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpDU1M+Iiwic2VsZWN0b3IiLCJsaXN0IiwicmVzdWx0IiwiZWFjaCIsImJsb2NrIGluIHNlbGVjdG9yIiwicGFydCIsInN0YXJ0X3dpdGg/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3RvciIsIisiLCJbXSIsIjEiLCItMSIsIjAiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCIka3dhcmdzIiwiYmxvY2siLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJAc2VsZWN0b3IiLCJAY3VycmVudCIsIkBydWxlcyIsIkBmb250cyIsIkBhbmltYXRpb25zIiwiQGJsb2NrIiwiZGVmZXIiLCJidWlsZCEiLCJmb3JjZV9jYWxsIiwiYXJpdHkiLCJpbnN0YW5jZV9leGVjIiwidG9fcHJvYyIsImNhbGwiLCJydWxlIiwiYW55PyIsIm5hbWVzIiwiYmxvY2sgaW4gcnVsZSIsIm4iLCJibG9jayAoMiBsZXZlbHMpIGluIHJ1bGUiLCJpbmNsdWRlPyIsIm5hbWUiLCI8PCIsIlJ1bGUiLCJuZXciLCJDU1MiLCJAbWVkaWEiLCJwb3AiLCJtZWRpYSIsInF1ZXJ5Iiwib2xkIiwibWV0aG9kX21pc3NpbmciLCJhcmdzIiwiZm9udCIsIkZvbnQiLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJfX3NlbmRfXyIsImxhc3QiLCJCYXNpY09iamVjdCIsIjxjbGFzczpIVE1MPiIsInN0eWxlIiwiJHJldF9vcl8xIiwiQHJvb3RzIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkJBQUFBLGdCQUFBQTtFQUFBQTs7RUFB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QUFBQSxpQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFDRUEsT0FBQyxDQUFBLFFBQUFDLENBQUFBLFlBQUF4QyxZQUFBd0MsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBWUMsVUFBWixDQUFBLENBQW9CckIsT0FBQUEsQ0FBTUUsTUFBSEMsU0FBR0QsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTTNCLEtBQURlLFNBQUFBLENBQUFBLENBQUxZLENBQU5GO01BRHZCbUIsQ0FBQUEsR0FBQUE7SUFERkQsR0FBQUEsV0FBQUEsRUFBYUQsaUJBQWJDO0VBckdBN0QsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFqQkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozODExMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL3NoYWRvd19yb290LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbmNsYXNzIFNoYWRvd1Jvb3QgPCBEb2N1bWVudEZyYWdtZW50XG4gIGluY2x1ZGUgRG9jdW1lbnRPclNoYWRvd1Jvb3RcblxuICAjIFVzZTogRWxlbWVudCNzaGFkb3dcbiAgZGVmIHNlbGYuY3JlYXRlXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvclxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOlNoYWRvd1Jvb3Q+Iiwic2VsZiIsImluY2x1ZGUiLCJEb2N1bWVudE9yU2hhZG93Um9vdCIsImNyZWF0ZSIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIkRvY3VtZW50RnJhZ21lbnQiXSwibWFwcGluZ3MiOiJBQUFBQSwwQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRQywwQkFBUkQ7UUFHQUYsT0FBQUksTUFBSUgsSUFBSkcsYUFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBSCxJQUFBSSxPQUFBQSxDQUFNQyxtQkFBTkQ7UUFERkQsQ0FBQUEsR0FBQUE7TUFKRkosR0FBQUEsV0FBQUEsRUFBbUJPLHNCQUFuQlA7SUFGZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzgxNDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL3N1cHBvcnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBUaGUgZW5naW5lIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgb24uXG4jXG4jIEtlZXAgaW4gbWluZCBpdCB1c2VzIHRoZSB1c2VyIGFnZW50IHRvIGtub3csIHNvIGl0J3Mgbm90IHJlbGlhYmxlIGluIGNhc2Ugb2ZcbiMgc3Bvb2ZpbmcuXG5CUk9XU0VSX0VOR0lORSA9IGAvTVNJRXxXZWJLaXR8UHJlc3RvfEdlY2tvLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpWzBdYC5kb3duY2FzZSByZXNjdWUgOnVua25vd25cblxubW9kdWxlIEJyb3dzZXJcbiAgIyBAcHJpdmF0ZVxuICBAc3VwcG9ydCA9IGB7fWBcblxuICAjIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBnaXZlbiBmZWF0dXJlLlxuICBkZWYgc2VsZi5zdXBwb3J0cz8oZmVhdHVyZSlcbiAgICBpZiBkZWZpbmVkPyhgI0BzdXBwb3J0WyN7ZmVhdHVyZX1dYClcbiAgICAgIHJldHVybiBgI0BzdXBwb3J0WyN7ZmVhdHVyZX1dYFxuICAgIGVuZFxuXG4gICAgc3VwcG9ydCA9IGNhc2UgZmVhdHVyZVxuICAgICAgd2hlbiAnTXV0YXRpb25PYnNlcnZlcidcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyYClcblxuICAgICAgd2hlbiAnV2ViU29ja2V0J1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LldlYlNvY2tldGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50U291cmNlJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LkV2ZW50U291cmNlYClcblxuICAgICAgd2hlbiAnWEhSJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LlhNTEh0dHBSZXF1ZXN0YClcblxuICAgICAgd2hlbiAnQWN0aXZlWCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5BY3RpdmVYT2JqZWN0YClcblxuICAgICAgd2hlbiAnV2ViU1FMJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm9wZW5EYXRhYmFzZWApXG5cbiAgICAgIHdoZW4gJ1F1ZXJ5LmNzcydcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGxgKVxuXG4gICAgICB3aGVuICdRdWVyeS54cGF0aCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmV2YWx1YXRlYClcblxuICAgICAgd2hlbiAnU3RvcmFnZS5sb2NhbCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5sb2NhbFN0b3JhZ2VgKVxuXG4gICAgICB3aGVuICdTdG9yYWdlLmdsb2JhbCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5nbG9iYWxTdG9yYWdlYClcblxuICAgICAgd2hlbiAnU3RvcmFnZS5zZXNzaW9uJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LnNlc3Npb25TdG9yYWdlYClcblxuICAgICAgd2hlbiAnSW1tZWRpYXRlJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LnNldEltbWVkaWF0ZWApXG5cbiAgICAgIHdoZW4gJ0ltbWVkaWF0ZSAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1zU2V0SW1tZWRpYXRlYClcblxuICAgICAgd2hlbiAnSW1tZWRpYXRlIChGaXJlZm94KSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5tb3pTZXRJbW1lZGlhdGVgKVxuXG4gICAgICB3aGVuICdJbW1lZGlhdGUgKE9wZXJhKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5vU2V0SW1tZWRpYXRlYClcblxuICAgICAgd2hlbiAnSW1tZWRpYXRlIChDaHJvbWUpJywgJ3NldEltbWVkaWF0ZSAoU2FmYXJpKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy53ZWJraXRTZXRJbW1lZGlhdGVgKVxuXG4gICAgICB3aGVuICdDU1MuY29tcHV0ZWQnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWApXG5cbiAgICAgIHdoZW4gJ0NTUy5jdXJyZW50J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZWApXG5cbiAgICAgIHdoZW4gJ1dpbmRvdy5zZW5kJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LnBvc3RNZXNzYWdlYClcblxuICAgICAgd2hlbiAnV2luZG93LnNlbmQgKEFzeW5jaHJvbm91cyknXG4gICAgICAgIGlmIGRlZmluZWQ/KGB3aW5kb3cucG9zdE1lc3NhZ2VgKSAmJiAhZGVmaW5lZD8oYHdpbmRvdy5pbXBvcnRTY3JpcHRzYClcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIG9rICA9IHRydWUsXG4gICAgICAgICAgICAgICAgICBvbGQgPSB3aW5kb3cub25tZXNzYWdlO1xuXG4gICAgICAgICAgICAgIHdpbmRvdy5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgb2sgPSBmYWxzZTsgfTtcbiAgICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKVxuICAgICAgICAgICAgICB3aW5kb3cub25tZXNzYWdlID0gb2xkO1xuXG4gICAgICAgICAgICAgIHJldHVybiBvaztcbiAgICAgICAgICAgIH0pKClcbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuXG4gICAgICB3aGVuICdXaW5kb3cuc2VuZCAoU3luY2hyb25vdXMpJ1xuICAgICAgICAhc3VwcG9ydHM/KCdXaW5kb3cuc2VuZCAoQXN5bmNocm9ub3VzKScpXG5cbiAgICAgIHdoZW4gJ1dpbmRvdy5pbm5lclNpemUnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuaW5uZXJIZWlnaHRgKVxuXG4gICAgICB3aGVuICdXaW5kb3cub3V0ZXJTaXplJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm91dGVySGVpZ2h0YClcblxuICAgICAgd2hlbiAnV2luZG93LnNjcm9sbCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0YClcblxuICAgICAgd2hlbiAnV2luZG93LnNjcm9sbEJ5J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEJ5YClcblxuICAgICAgd2hlbiAnV2luZG93LnBhZ2VPZmZzZXQnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cucGFnZVhPZmZzZXRgKVxuXG4gICAgICB3aGVuICdBdHRyLmlzSWQnXG4gICAgICAgICV4e1xuICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdpZCcsICd4eHh4eHh4eHh4eHh4Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YoZGl2LmF0dHJpYnV0ZXNbJ2lkJ10uaXNJZCkgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgICAgfSkoKVxuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuYWRkQmVoYXZpb3InXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkQmVoYXZpb3JgKVxuXG4gICAgICB3aGVuICdFbGVtZW50LmNsYXNzTmFtZSdcbiAgICAgICAgJXh7XG4gICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3NOYW1lJywgJ3gnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGRpdi5jbGFzc05hbWUgPT09ICd4JztcbiAgICAgICAgICB9KSgpXG4gICAgICAgIH1cblxuICAgICAgd2hlbiAnRWxlbWVudC5jbGFzcydcbiAgICAgICAgJXh7XG4gICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAneCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGl2LmNsYXNzTmFtZSA9PT0gJ3gnO1xuICAgICAgICAgIH0pKClcbiAgICAgICAgfVxuXG4gICAgICB3aGVuICdFbGVtZW50LmZvcidcbiAgICAgICAgJXh7XG4gICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ3gnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsLmh0bWxGb3IgPT09ICd4JztcbiAgICAgICAgICB9KSgpXG4gICAgICAgIH1cblxuICAgICAgd2hlbiAnRWxlbWVudC5odG1sRm9yJ1xuICAgICAgICAleHtcbiAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdodG1sRm9yJywgJ3gnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsLmh0bWxGb3IgPT09ICd4JztcbiAgICAgICAgICB9KSgpXG4gICAgICAgIH1cblxuICAgICAgd2hlbiAnRWxlbWVudC5jbGllbnRTaXplJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodGApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuc2Nyb2xsJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRgKVxuXG4gICAgICB3aGVuICdFbGVtZW50LnRleHRDb250ZW50J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnRleHRDb250ZW50YClcblxuICAgICAgd2hlbiAnRWxlbWVudC5pbm5lclRleHQnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaW5uZXJUZXh0YClcblxuICAgICAgd2hlbiAnRWxlbWVudC5tYXRjaGVzJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm1hdGNoZXNgKVxuXG4gICAgICB3aGVuICdFbGVtZW50Lm1hdGNoZXMgKEludGVybmV0IEV4cGxvcmVyKSdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5tc01hdGNoZXNTZWxlY3RvcmApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQubWF0Y2hlcyAoRmlyZWZveCknXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yYClcblxuICAgICAgd2hlbiAnRWxlbWVudC5tYXRjaGVzIChPcGVyYSknXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub01hdGNoZXNTZWxlY3RvcmApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQubWF0Y2hlcyAoQ2hyb21lKScsICdFbGVtZW50Lm1hdGNoZXMgKFNhZmFyaSknXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yYClcblxuICAgICAgd2hlbiAnRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0YClcblxuICAgICAgd2hlbiAnRXZlbnQucmVhZHlzdGF0ZWNoYW5nZSdcbiAgICAgICAgYFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilgXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgICAgICBiZWdpblxuICAgICAgICAgIGBuZXcgTW91c2VFdmVudChcImNsaWNrXCIpYFxuXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICByZXNjdWUgU3RhbmRhcmRFcnJvciwgSlM6OkVycm9yXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgZW5kXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmNyZWF0ZSdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmNyZWF0ZUV2ZW50YClcblxuICAgICAgd2hlbiAnRXZlbnQuY3JlYXRlT2JqZWN0J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3RgKVxuXG4gICAgICB3aGVuICdFdmVudC5hZGRMaXN0ZW5lcidcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXJgKVxuXG4gICAgICB3aGVuICdFdmVudC5hdHRhY2gnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5hdHRhY2hFdmVudGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LnJlbW92ZUxpc3RlbmVyJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcmApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmRldGFjaCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRldGFjaEV2ZW50YClcblxuICAgICAgd2hlbiAnRXZlbnQuZGlzcGF0Y2gnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kaXNwYXRjaEV2ZW50YClcblxuICAgICAgd2hlbiAnRXZlbnQuZmlyZSdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmZpcmVFdmVudGApXG5cbiAgICAgIHdoZW4gL15FdmVudFxcLihbQS1aXS4qPykkL1xuICAgICAgICBgKCN7JDF9ICsgXCJFdmVudFwiKSBpbiB3aW5kb3dgXG5cbiAgICAgIHdoZW4gJ0RvY3VtZW50LnZpZXcnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kZWZhdWx0Vmlld2ApXG5cbiAgICAgIHdoZW4gJ0RvY3VtZW50LndpbmRvdydcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LnBhcmVudFdpbmRvd2ApXG5cbiAgICAgIHdoZW4gJ0hpc3RvcnknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgKVxuXG4gICAgICB3aGVuICdIaXN0b3J5LnN0YXRlJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lmhpc3Rvcnkuc3RhdGVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24ucmVxdWVzdCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24ucmVxdWVzdCAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLnJlcXVlc3QgKEZpcmVmb3gpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5yZXF1ZXN0IChPcGVyYSknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5yZXF1ZXN0IChDaHJvbWUpJywgJ0FuaW1hdGlvbi5yZXF1ZXN0IChTYWZhcmkpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWwnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsIChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWwgKEZpcmVmb3gpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLmNhbmNlbCAoT3BlcmEpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWwgKENocm9tZSknLCAnQW5pbWF0aW9uLmNhbmNlbCAoU2FmYXJpKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0J1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cubXNDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsUmVxdWVzdCAoRmlyZWZveCknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cubW96Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLmNhbmNlbFJlcXVlc3QgKE9wZXJhKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5vQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLmNhbmNlbFJlcXVlc3QgKENocm9tZSknLCAnQW5pbWF0aW9uLmNhbmNlbFJlcXVlc3QgKFNhZmFyaSknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQXVkaW8nXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuQXVkaW9Db250ZXh0YClcblxuICAgICAgd2hlbiAnQXVkaW8gKFNhZmFyaSknLCAnQXVkaW8gKENocm9tZSknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0YClcbiAgICAgIFxuICAgICAgd2hlbiAnQ3VzdG9tIEVsZW1lbnRzJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LmN1c3RvbUVsZW1lbnRzYClcbiAgICBlbmRcblxuICAgIGAjQHN1cHBvcnRbI3tmZWF0dXJlfV0gPSAje3N1cHBvcnR9YFxuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSBnaXZlbiBwb2x5ZmlsbCBpcyBsb2FkZWQuXG4gIGRlZiBzZWxmLmxvYWRlZD8obmFtZSlcbiAgICBjYXNlIG5hbWVcbiAgICB3aGVuICdTaXp6bGUnXG4gICAgICBkZWZpbmVkPyhgd2luZG93LlNpenpsZWApXG5cbiAgICB3aGVuICd3aWNrZWQtZ29vZC14cGF0aCdcbiAgICAgIGRlZmluZWQ/KGB3aW5kb3cud2d4cGF0aGApXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsImRvd25jYXNlIiwiU3RhbmRhcmRFcnJvciIsIjxtb2R1bGU6QnJvd3Nlcj4iLCJAc3VwcG9ydCIsInN1cHBvcnRzPyIsInNlbGYiLCJmZWF0dXJlIiwic3VwcG9ydCIsIiRyZXRfb3JfMSIsIiEiLCJKUzo6RXJyb3IiLCJKUyIsImxvYWRlZD8iLCJuYW1lIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBSUEsMENBQWlCLGNBQUE7SUFBQUEsT0FBQUEsQ0FBQ0EsdURBQURBLENBQXlEQyxVQUFBQSxDQUFBQTtFQUF6RDtJQUFtRSxzQkFBQSxDQUFBQyxtQkFBQSxDQUFBO01BQUE7UUFBT0YsT0FBQTtNQUFQO0lBQUEsQ0FBbkU7RUFBQSxDQUFBLElBQWpCO0VBRUFBLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBRUVDLGVBQVlEO0lBR1pFLE1BQUlDLElBQUpELGdCQUFBQSxrQ0FBbUJFLE9BQW5CRjtBQUFBQSxNQUFBQTtBQUFBQTs7O01BQ0UsSUFBQSxRQUFHLFFBQVdELFlBQVFDLENBQUdFLE9BQVFGLENBQTlCLGtCQUFILENBQUE7UUFDRSxPQUFTRCxZQUFRQyxDQUFHRSxPQUFRRjtNQUQ5QjtNQUlBRyxVQUNFLGFBQUEsSUFBQSxRQUFLSCxrQkFBTCxFQURRSSxDQUFBQSxZQUFLRixPQUFMRSxDQUNSLENBQUE7UUFDRUosT0FBQSxRQUFVQSx1QkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxXQUFMLEVBcEJOLFNBb0JNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxnQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxhQUFMLEVBdkJOLFNBdUJNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxrQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxLQUFMLEVBMUJOLFNBMEJNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxxQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxTQUFMLEVBN0JOLFNBNkJNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxvQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxRQUFMLEVBaENOLFNBZ0NNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxtQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxXQUFMLEVBbkNOLFNBbUNNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSx5QkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxhQUFMLEVBdENOLFNBc0NNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxpQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxlQUFMLEVBekNOLFNBeUNNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxtQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxnQkFBTCxFQTVDTixTQTRDTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsb0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsaUJBQUwsRUEvQ04sU0ErQ00sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLHFCQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLFdBQUwsRUFsRE4sU0FrRE0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLG1CQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLCtCQUFMLEVBckROLFNBcURNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxxQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxxQkFBTCxFQXhETixTQXdETSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsc0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsbUJBQUwsRUEzRE4sU0EyRE0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLG9CQUFWO01BREYsT0FHQSxJQTlETixDQUFBLFFBOERXQSxvQkE5RFgsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLFFBOERpQ0EsdUJBOURqQyxFQUFBLFNBQUEsQ0FBQSxDQUFBLENBOERNO1FBQ0VBLE9BQUEsUUFBVUEseUJBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsY0FBTCxFQWpFTixTQWlFTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsdUJBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsYUFBTCxFQXBFTixTQW9FTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEscUNBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsYUFBTCxFQXZFTixTQXVFTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsa0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsNEJBQUwsRUExRU4sU0EwRU0sQ0FBQTtRQUNFLElBQUcsQ0FBQSxRQUFBLFFBQVVBLGtCQUFWLGtCQUFBLENBQUEsSUFBQSxDQUFBLEtBQW1DLFFBQVVBLG9CQUFWLGtCQUFuQyxDQUFBLENBQUEsQ0FBSDs7QUFFUkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtRQVpRO1VBM0VSQSxPQUFBO1FBMkVRO01BREYsT0FnQkEsSUFBQSxRQUFLQSwyQkFBTCxFQTFGTixTQTBGTSxDQUFBO1FBQ0VBLE9BQUNDLElBQUFELGNBQUFBLENBQVVBLDRCQUFWQSxDQUFESyxNQUFBQSxDQUFBQTtNQURGLE9BR0EsSUFBQSxRQUFLTCxrQkFBTCxFQTdGTixTQTZGTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsa0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0Esa0JBQUwsRUFoR04sU0FnR00sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLGtCQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLGVBQUwsRUFuR04sU0FtR00sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLG1DQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLGlCQUFMLEVBdEdOLFNBc0dNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxpQ0FBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxtQkFBTCxFQXpHTixTQXlHTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsa0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsV0FBTCxFQTVHTixTQTRHTSxDQUFBOztBQUVOQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7TUFSTSxPQVVBLElBQUEsUUFBS0EscUJBQUwsRUF0SE4sU0FzSE0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLG9DQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLG1CQUFMLEVBekhOLFNBeUhNLENBQUE7O0FBRU5BO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtNQVJNLE9BVUEsSUFBQSxRQUFLQSxlQUFMLEVBbklOLFNBbUlNLENBQUE7O0FBRU5BO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtNQVJNLE9BVUEsSUFBQSxRQUFLQSxhQUFMLEVBN0lOLFNBNklNLENBQUE7O0FBRU5BO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtNQVJNLE9BVUEsSUFBQSxRQUFLQSxpQkFBTCxFQXZKTixTQXVKTSxDQUFBOztBQUVOQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7TUFSTSxPQVVBLElBQUEsUUFBS0Esb0JBQUwsRUFqS04sU0FpS00sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLHFDQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLGdCQUFMLEVBcEtOLFNBb0tNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxtQ0FBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxxQkFBTCxFQXZLTixTQXVLTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsb0NBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsbUJBQUwsRUExS04sU0EwS00sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLGtDQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLGlCQUFMLEVBN0tOLFNBNktNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxnQ0FBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxxQ0FBTCxFQWhMTixTQWdMTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsMENBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsMkJBQUwsRUFuTE4sU0FtTE0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLDJDQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLHlCQUFMLEVBdExOLFNBc0xNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSx5Q0FBVjtNQURGLE9BR0EsSUF6TE4sQ0FBQSxRQXlMV0EsMEJBekxYLEVBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxRQXlMdUNBLDBCQXpMdkMsRUFBQSxTQUFBLENBQUEsQ0FBQSxDQXlMTTtRQUNFQSxPQUFBLFFBQVVBLDhDQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLCtCQUFMLEVBNUxOLFNBNExNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSw4Q0FBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSx3QkFBTCxFQS9MTixTQStMTSxDQUFBO1FBQ0VBLE9BQUNBLCtEQUFEQTtNQURGLE9BR0EsSUFBQSxRQUFLQSxtQkFBTCxFQWxNTixTQWtNTSxDQUFBOztRQUVJOztVQUFDQTtVQUVEQSxPQUFBO1FBRkE7VUFHRixzQkFBTyxDQUFBSCxtQkFBQSxFQUFlUyxJQUFBQyxRQUFBRCxVQUFmLENBQVA7WUFBQTtjQUNFTixPQUFBO1lBREY7VUFBQSxDQUhFO1FBQUE7TUFGSixPQVNBLElBQUEsUUFBS0EsY0FBTCxFQTNNTixTQTJNTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsb0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0Esb0JBQUwsRUE5TU4sU0E4TU0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLDBCQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLG1CQUFMLEVBak5OLFNBaU5NLENBQUE7UUFDRUEsT0FBQSxRQUFVQSx5QkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxjQUFMLEVBcE5OLFNBb05NLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxvQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxzQkFBTCxFQXZOTixTQXVOTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsNEJBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsY0FBTCxFQTFOTixTQTBOTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsb0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsZ0JBQUwsRUE3Tk4sU0E2Tk0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLHNCQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLFlBQUwsRUFoT04sU0FnT00sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLGtCQUFWO01BREYsT0FHQSxJQUFBLFFBQUsscUJBQUwsRUFuT04sU0FtT00sQ0FBQTtRQUNFQSxPQUFDQSxDQUFHLGlEQUFHQTtNQURULE9BR0EsSUFBQSxRQUFLQSxlQUFMLEVBdE9OLFNBc09NLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxvQkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxpQkFBTCxFQXpPTixTQXlPTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEscUJBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsU0FBTCxFQTVPTixTQTRPTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsd0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsZUFBTCxFQS9PTixTQStPTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsb0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsbUJBQUwsRUFsUE4sU0FrUE0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLDRCQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLHVDQUFMLEVBclBOLFNBcVBNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSw4QkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSw2QkFBTCxFQXhQTixTQXdQTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsK0JBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsMkJBQUwsRUEzUE4sU0EyUE0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLDZCQUFWO01BREYsT0FHQSxJQTlQTixDQUFBLFFBOFBXQSw0QkE5UFgsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLFFBOFB5Q0EsNEJBOVB6QyxFQUFBLFNBQUEsQ0FBQSxDQUFBLENBOFBNO1FBQ0VBLE9BQUEsUUFBVUEsa0NBQVY7TUFERixPQUdBLElBQUEsUUFBS0Esa0JBQUwsRUFqUU4sU0FpUU0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLDJCQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLHNDQUFMLEVBcFFOLFNBb1FNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSw2QkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSw0QkFBTCxFQXZRTixTQXVRTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsOEJBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsMEJBQUwsRUExUU4sU0EwUU0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLDRCQUFWO01BREYsT0FHQSxJQTdRTixDQUFBLFFBNlFXQSwyQkE3UVgsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLFFBNlF3Q0EsMkJBN1F4QyxFQUFBLFNBQUEsQ0FBQSxDQUFBLENBNlFNO1FBQ0VBLE9BQUEsUUFBVUEsaUNBQVY7TUFERixPQUdBLElBQUEsUUFBS0EseUJBQUwsRUFoUk4sU0FnUk0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLGtDQUFWO01BREYsT0FHQSxJQUFBLFFBQUtBLDZDQUFMLEVBblJOLFNBbVJNLENBQUE7UUFDRUEsT0FBQSxRQUFVQSxvQ0FBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxtQ0FBTCxFQXRSTixTQXNSTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEscUNBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsaUNBQUwsRUF6Uk4sU0F5Uk0sQ0FBQTtRQUNFQSxPQUFBLFFBQVVBLG1DQUFWO01BREYsT0FHQSxJQTVSTixDQUFBLFFBNFJXQSxrQ0E1UlgsRUFBQSxTQUFBLENBQUEsSUFBQSxDQUFBLFFBNFIrQ0Esa0NBNVIvQyxFQUFBLFNBQUEsQ0FBQSxDQUFBLENBNFJNO1FBQ0VBLE9BQUEsUUFBVUEsd0NBQVY7TUFERixPQUdBLElBQUEsUUFBS0EsT0FBTCxFQS9STixTQStSTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsbUJBQVY7TUFERixPQUdBLElBbFNOLENBQUEsUUFrU1dBLGdCQWxTWCxFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsUUFrUzZCQSxnQkFsUzdCLEVBQUEsU0FBQSxDQUFBLENBQUEsQ0FrU007UUFDRUEsT0FBQSxRQUFVQSx5QkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxpQkFBTCxFQXJTTixTQXFTTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEscUJBQVY7TUFERjtRQXJSUUEsT0FBQTtNQXFSUixDQXBSQTtNQXdSRkEsT0FBRUQsWUFBUUMsQ0FBR0UsT0FBUUYsSUFBTUc7SUE5UjdCSCxDQUFBQSxHQUFBQTtJQWtTQUYsT0FBQVUsTUFBSVAsSUFBSk8sY0FBQUEsZ0NBQWlCQyxJQUFqQkQ7QUFBQUE7O01BRUUsUUFES0MsSUFDTDtRQUFBLEtBQUtELFFBQUw7VUFDRUEsT0FBQSxRQUFVQSxhQUFWO1FBRUYsS0FBS0EsbUJBQUw7VUFDRUEsT0FBQSxRQUFVQSxjQUFWO1FBREY7VUFKQUEsT0FBQTtNQUNBO0lBRkZBLENBQUFBLEdBQUFBO0VBdlNGVixHQUFBQSxXQUFBQTtBQU5BSDsifX0seyJvZmZzZXQiOnsibGluZSI6Mzg0MDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9kb2N1bWVudC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG5jbGFzcyBEb2N1bWVudCA8IEVsZW1lbnRcbiAgaW5jbHVkZSBEb2N1bWVudE9yU2hhZG93Um9vdFxuXG4gICMgR2V0IHRoZSBmaXJzdCBlbGVtZW50IG1hdGNoaW5nIHRoZSBnaXZlbiBJRCwgQ1NTIHNlbGVjdG9yIG9yIFhQYXRoLlxuICAjXG4gICMgQHBhcmFtIHdoYXQgW1N0cmluZ10gSUQsIENTUyBzZWxlY3RvciBvciBYUGF0aFxuICAjXG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50XG4gIGRlZiBbXSh3aGF0KVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICNAbmF0aXZlLmdldEVsZW1lbnRCeUlkKHdoYXQpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiAje0RPTShgcmVzdWx0YCl9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNzcyh3aGF0KS5maXJzdCB8fCB4cGF0aCh3aGF0KS5maXJzdFxuICBlbmRcblxuICBhbGlhcyBhdCBbXVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGJvZHlcbiAgIyBAcmV0dXJuIFtFbGVtZW50P10gdGhlIGJvZHkgZWxlbWVudCBvZiB0aGUgZG9jdW1lbnRcbiAgZGVmIGJvZHlcbiAgICBET00oYCNAbmF0aXZlLmJvZHlgKVxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIHJhaXNlICckZG9jdW1lbnQuYm9keSBpcyBub3QgZGVmaW5lZDsgdHJ5IHRvIHdyYXAgeW91ciBjb2RlIGluICRkb2N1bWVudC5yZWFkeXt9J1xuICBlbmRcblxuICAjIENyZWF0ZSBhIG5ldyBlbGVtZW50IGZvciB0aGUgZG9jdW1lbnQuXG4gICNcbiAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgbm9kZSBuYW1lXG4gICMgQHBhcmFtIGJ1aWxkZXIgW0Jyb3dzZXI6OkRPTTo6QnVpbGRlcl0gb3B0aW9uYWwgYnVpbGRlciB0byBhcHBlbmQgZWxlbWVudCB0b1xuICAjIEBwYXJhbSBvcHRpb25zIFtTdHJpbmddIDpuYW1lc3BhY2Ugb3B0aW9uYWwgbmFtZXNwYWNlIG5hbWVcbiAgIyBAcGFyYW0gb3B0aW9ucyBbU3RyaW5nXSA6aXMgb3B0aW9uYWwgV2ViQ29tcG9uZW50cyBpcyBwYXJhbWV0ZXJcbiAgIyBAcGFyYW0gb3B0aW9ucyBbU3RyaW5nXSA6aWQgb3B0aW9uYWwgaWQgdG8gc2V0XG4gICMgQHBhcmFtIG9wdGlvbnMgW0FycmF5PFN0cmluZz5dIDpjbGFzc2VzIG9wdGlvbmFsIGNsYXNzZXMgdG8gc2V0XG4gICMgQHBhcmFtIG9wdGlvbnMgW0hhc2hdIDphdHRycyBvcHRpb25hbCBhdHRyaWJ1dGVzIHRvIHNldFxuICAjXG4gICMgQHJldHVybiBbRWxlbWVudF1cbiAgZGVmIGNyZWF0ZV9lbGVtZW50KG5hbWUsIGJ1aWxkZXI9bmlsLCAqKm9wdGlvbnMsICZibG9jaylcbiAgICBvcHRzID0ge31cblxuICAgIGlmIG9wdGlvbnNbOmlzXSB8fD0gKG9wdGlvbnMuZGlnKDphdHRycywgOmlzKSlcbiAgICAgIG9wdHNbOmlzXSA9IG9wdGlvbnNbOmlzXVxuICAgIGVuZFxuXG4gICAgaWYgbnMgPSBvcHRpb25zWzpuYW1lc3BhY2VdXG4gICAgICBlbGVtID0gYCNAbmF0aXZlLmNyZWF0ZUVsZW1lbnROUygje25zfSwgI3tuYW1lfSwgI3tvcHRzLnRvX259KWBcbiAgICBlbHNlXG4gICAgICBlbGVtID0gYCNAbmF0aXZlLmNyZWF0ZUVsZW1lbnQobmFtZSwgI3tvcHRzLnRvX259KWBcbiAgICBlbmRcblxuICAgIGlmIG9wdGlvbnNbOmNsYXNzZXNdXG4gICAgICBgI3tlbGVtfS5jbGFzc05hbWUgPSAje0FycmF5KG9wdGlvbnNbOmNsYXNzZXNdKS5qb2luKFwiIFwiKX1gXG4gICAgZW5kXG5cbiAgICBpZiBvcHRpb25zWzppZF1cbiAgICAgIGAje2VsZW19LmlkID0gI3tvcHRpb25zWzppZF19YFxuICAgIGVuZFxuXG4gICAgaWYgb3B0aW9uc1s6YXR0cnNdXG4gICAgICBvcHRpb25zWzphdHRyc10uZWFjaCBkbyB8ayx2fFxuICAgICAgICBuZXh0IHVubGVzcyB2XG4gICAgICAgIGAje2VsZW19LnNldEF0dHJpYnV0ZSgje2t9LCAje3Z9KWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZG9tID0gRE9NKGVsZW0pXG5cbiAgICBpZiBibG9ja19naXZlbj9cbiAgICAgIGRvbS5pbm5lcl9kb20oYnVpbGRlciwgJmJsb2NrKVxuICAgIGVuZFxuXG4gICAgaWYgYnVpbGRlclxuICAgICAgYnVpbGRlciA8PCBkb21cbiAgICBlbmRcblxuICAgIGRvbVxuICBlbmRcblxuICAjIENyZWF0ZSBhIG5ldyBkb2N1bWVudCBmcmFnbWVudC5cbiAgI1xuICAjIEByZXR1cm4gW0RvY3VtZW50RnJhZ21lbnRdXG4gIGRlZiBjcmVhdGVfZG9jdW1lbnRfZnJhZ21lbnRcbiAgICBET00oYCNAbmF0aXZlLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKWApXG4gIGVuZFxuXG4gICMgQ3JlYXRlIGEgbmV3IHRleHQgbm9kZSBmb3IgdGhlIGRvY3VtZW50LlxuICAjXG4gICMgQHBhcmFtIGNvbnRlbnQgW1N0cmluZ10gdGhlIHRleHQgY29udGVudFxuICAjXG4gICMgQHJldHVybiBbVGV4dF1cbiAgZGVmIGNyZWF0ZV90ZXh0KGNvbnRlbnQpXG4gICAgRE9NKGAjQG5hdGl2ZS5jcmVhdGVUZXh0Tm9kZSgje2NvbnRlbnR9KWApXG4gIGVuZFxuXG4gICMgQ3JlYXRlIGEgbmV3IGNvbW1lbnQgbm9kZSBmb3IgdGhlIGRvY3VtZW50LlxuICAjXG4gICMgQHBhcmFtIGNvbnRlbnQgW1N0cmluZ10gdGhlIGNvbW1lbnQgY29udGVudFxuICAjXG4gICMgQHJldHVybiBbQ29tbWVudF1cbiAgZGVmIGNyZWF0ZV9jb21tZW50KGNvbnRlbnQpXG4gICAgRE9NKGAjQG5hdGl2ZS5jcmVhdGVDb21tZW50KCN7Y29udGVudH0pYClcbiAgZW5kXG5cbiAgZGVmIGRvY3VtZW50XG4gICAgc2VsZlxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBoZWFkXG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBoZWFkIGVsZW1lbnQgb2YgdGhlIGRvY3VtZW50XG4gIGRlZiBoZWFkXG4gICAgRE9NKGAjQG5hdGl2ZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF1gKVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxET006OkRvY3VtZW50PlwiXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5hZGRMaXN0ZW5lcidcbiAgICBkZWYgcmVhZHkoJmJsb2NrKVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgcmV0dXJuIGJsb2NrLmNhbGwgaWYgcmVhZHk/XG5cbiAgICAgIG9uICdkb206bG9hZCcgZG8gfGV8XG4gICAgICAgIGUub2ZmXG5cbiAgICAgICAgYmxvY2suY2FsbFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5hdHRhY2gnXG4gICAgZGVmIHJlYWR5KCZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIHJldHVybiBibG9jay5jYWxsIGlmIHJlYWR5P1xuXG4gICAgICBvbiAncmVhZHk6c3RhdGU6Y2hhbmdlJyBkbyB8ZXxcbiAgICAgICAgaWYgcmVhZHk/XG4gICAgICAgICAgZS5vZmZcblxuICAgICAgICAgIGJsb2NrLmNhbGxcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZWxzZVxuICAgICMgV2FpdCBmb3IgdGhlIGRvY3VtZW50IHRvIGJlIHJlYWR5IGFuZCBjYWxsIHRoZSBibG9jay5cbiAgICBkZWYgcmVhZHkoJmJsb2NrKVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ2RvY3VtZW50IHJlYWR5IHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSBkb2N1bWVudCBpcyByZWFkeS5cbiAgZGVmIHJlYWR5P1xuICAgIGAjQG5hdGl2ZS5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHwgI0BuYXRpdmUucmVhZHlTdGF0ZSA9PT0gXCJpbnRlcmFjdGl2ZVwiYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIHJlZmVycmVyXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgcmVmZXJyaW5nIGRvY3VtZW50LCBvciBlbXB0eSBzdHJpbmcgaWYgZGlyZWN0IGFjY2Vzc1xuICBkZWYgcmVmZXJyZXJcbiAgICBgI0BuYXRpdmUucmVmZXJyZXJgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgcm9vdFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICBkZWYgcm9vdFxuICAgIERPTShgI0BuYXRpdmUuZG9jdW1lbnRFbGVtZW50YClcbiAgZW5kXG5cbiAgZGVmIHJvb3Q9KGVsZW1lbnQpXG4gICAgYCNAbmF0aXZlLmRvY3VtZW50RWxlbWVudCA9ICN7TmF0aXZlLmNvbnZlcnQoZWxlbWVudCl9YFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIHRpdGxlXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgZG9jdW1lbnQgdGl0bGVcbiAgZGVmIHRpdGxlXG4gICAgYCNAbmF0aXZlLnRpdGxlYFxuICBlbmRcblxuICBkZWYgdGl0bGU9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS50aXRsZSA9IHZhbHVlYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBoaWRkZW4/XG4gICMgQHJldHVybiBbQm9vbGVhbl0gaXMgdGhlIHBhZ2UgY29uc2lkZXJlZCBoaWRkZW4/XG4gIGRlZiBoaWRkZW4/XG4gICAgYCNAbmF0aXZlLmhpZGRlbmBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdmlzaWJpbGl0eVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIGRvY3VtZW50IC0gcHJlcmVuZGVyLCBoaWRkZW4gb3IgdmlzaWJsZVxuICBkZWYgdmlzaWJpbGl0eVxuICAgIGAjQG5hdGl2ZS52aXNpYmlsaXR5U3RhdGVgXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdEb2N1bWVudC52aWV3J1xuICAgIGRlZiB3aW5kb3dcbiAgICAgIFdpbmRvdy5uZXcoYCNAbmF0aXZlLmRlZmF1bHRWaWV3YClcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0RvY3VtZW50LndpbmRvdydcbiAgICBkZWYgd2luZG93XG4gICAgICBXaW5kb3cubmV3KGAjQG5hdGl2ZS5wYXJlbnRXaW5kb3dgKVxuICAgIGVuZFxuICBlbHNlXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gd2luZG93XG4gICAgIyBAcmV0dXJuIFtXaW5kb3ddIHRoZSB3aW5kb3cgZm9yIHRoZSBkb2N1bWVudFxuICAgIGRlZiB3aW5kb3dcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICd3aW5kb3cgZnJvbSBkb2N1bWVudCB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpEb2N1bWVudD4iLCJzZWxmIiwiaW5jbHVkZSIsIkRvY3VtZW50T3JTaGFkb3dSb290IiwiW10iLCJ3aGF0IiwiQG5hdGl2ZSIsIkRPTSIsIiRyZXRfb3JfMSIsImNzcyIsImZpcnN0IiwieHBhdGgiLCJib2R5IiwiQXJndW1lbnRFcnJvciIsInJhaXNlIiwiY3JlYXRlX2VsZW1lbnQiLCJuYW1lIiwib3B0cyIsIm9wdGlvbnMiLCJbXT0iLCJkaWciLCJucyIsImVsZW0iLCJ0b19uIiwiQXJyYXkiLCJqb2luIiwiZWFjaCIsImJsb2NrIGluIGNyZWF0ZV9lbGVtZW50IiwiayIsInYiLCJibG9jayAoMiBsZXZlbHMpIGluIGNyZWF0ZV9lbGVtZW50IiwiZG9tIiwiYmxvY2tfZ2l2ZW4/IiwiaW5uZXJfZG9tIiwiYnVpbGRlciIsImJsb2NrIiwidG9fcHJvYyIsIjw8IiwiY3JlYXRlX2RvY3VtZW50X2ZyYWdtZW50IiwiY3JlYXRlX3RleHQiLCJjb250ZW50IiwiY3JlYXRlX2NvbW1lbnQiLCJkb2N1bWVudCIsImhlYWQiLCJpbnNwZWN0IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsInJlYWR5IiwicmVhZHk/IiwiY2FsbCIsIm9uIiwiYmxvY2sgaW4gcmVhZHkiLCJlIiwib2ZmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWFkeSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJyZWZlcnJlciIsInJvb3QiLCJyb290PSIsImVsZW1lbnQiLCJOYXRpdmUiLCJjb252ZXJ0IiwidGl0bGUiLCJ0aXRsZT0iLCJ2YWx1ZSIsImhpZGRlbj8iLCJ2aXNpYmlsaXR5Iiwid2luZG93IiwiV2luZG93IiwibmV3IiwiRWxlbWVudCJdLCJtYXBwaW5ncyI6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QUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQUMsWUFBTUMsS0FBQUEsQ0FBTy9ELGNBQU82RCxZQUFkRTtVQURSRixDQUFBQSxHQUFBQTtRQURGLE9BSUEsSUFBQSxRQUFNdEIsYUFBT0MsY0FBQUEsQ0FBVzlDLGlCQUFYOEMsQ0FBYixDQUFBO1VBQ0U5QyxPQUFBbUUsc0JBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQUMsWUFBTUMsS0FBQUEsQ0FBTy9ELGNBQU82RCxhQUFkRTtVQURSRixDQUFBQSxHQUFBQTtRQURGO1VBT0VuRSxPQUFBbUUsc0JBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQWxFLElBQUFhLE9BQUFBLENBQU15Qyx5QkFBTixFQUEyQlksa0NBQTNCckQ7VUFERnFELENBQUFBLEdBQUFBO1FBUEY7TUF6TUZuRSxHQUFBQSxXQUFBQSxFQUFpQnNFLGFBQWpCdEU7SUFGZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mzg2NjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29zdHJ1Y3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgT3BlblN0cnVjdFxuICBkZWYgaW5pdGlhbGl6ZShoYXNoID0gbmlsKVxuICAgIEB0YWJsZSA9IHt9XG5cbiAgICBpZiBoYXNoXG4gICAgICBoYXNoLmVhY2hfcGFpciBkbyB8a2V5LCB2YWx1ZXxcbiAgICAgICAgQHRhYmxlW25ld19vc3RydWN0X21lbWJlcihrZXkpXSA9IHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgQHRhYmxlW25hbWUudG9fc3ltXVxuICBlbmRcblxuICBkZWYgW109KG5hbWUsIHZhbHVlKVxuICAgIEB0YWJsZVtuZXdfb3N0cnVjdF9tZW1iZXIobmFtZSldID0gdmFsdWVcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID4gMlxuICAgICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgIzxPcGVuU3RydWN0PlwiLCBuYW1lKVxuICAgIGVuZFxuICAgIGlmIG5hbWUuZW5kX3dpdGg/ICc9J1xuICAgICAgaWYgYXJncy5sZW5ndGggIT0gMVxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSknXG4gICAgICBlbmRcbiAgICAgIEB0YWJsZVtuZXdfb3N0cnVjdF9tZW1iZXIobmFtZVswLi4tMl0pXSA9IGFyZ3NbMF1cbiAgICBlbHNlXG4gICAgICBAdGFibGVbbmFtZS50b19zeW1dXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1pZCwgaW5jbHVkZV9wcml2YXRlID0gZmFsc2UpICMgOm5vZG9jOlxuICAgIG1uYW1lID0gbWlkLnRvX3MuY2hvbXAoJz0nKS50b19zeW1cbiAgICBAdGFibGUmLmtleT8obW5hbWUpIHx8IHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3BhaXJcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfcGFpciB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAdGFibGUuZWFjaF9wYWlyIGRvIHxwYWlyfFxuICAgICAgeWllbGQgcGFpclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pc19hPyhPcGVuU3RydWN0KVxuXG4gICAgQHRhYmxlID09IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QHRhYmxlKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaXNfYT8oT3BlblN0cnVjdClcblxuICAgIEB0YWJsZSA9PT0gb3RoZXIuaW5zdGFuY2VfdmFyaWFibGVfZ2V0KDpAdGFibGUpXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaXNfYT8oT3BlblN0cnVjdClcblxuICAgIEB0YWJsZS5lcWw/IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QHRhYmxlKVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIEB0YWJsZS5kdXBcbiAgZW5kXG5cbiAgZGVmIHRvX25cbiAgICBAdGFibGUudG9fblxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIEB0YWJsZS5oYXNoXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDp0YWJsZVxuXG4gIGRlZiBkZWxldGVfZmllbGQobmFtZSlcbiAgICBzeW0gPSBuYW1lLnRvX3N5bVxuICAgIGJlZ2luXG4gICAgICBzaW5nbGV0b25fY2xhc3MuX19zZW5kX18oOnJlbW92ZV9tZXRob2QsIHN5bSwgXCIje3N5bX09XCIpXG4gICAgcmVzY3VlIE5hbWVFcnJvclxuICAgIGVuZFxuICAgIEB0YWJsZS5kZWxldGUgc3ltXG4gIGVuZFxuXG4gIGRlZiBuZXdfb3N0cnVjdF9tZW1iZXIobmFtZSlcbiAgICBuYW1lID0gbmFtZS50b19zeW1cbiAgICB1bmxlc3MgcmVzcG9uZF90bz8obmFtZSlcbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUpIHsgQHRhYmxlW25hbWVdIH1cbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKFwiI3tuYW1lfT1cIikgeyB8eHwgQHRhYmxlW25hbWVdID0geCB9XG4gICAgZW5kXG4gICAgbmFtZVxuICBlbmRcblxuICBgdmFyIG9zdHJ1Y3RfaWRzO2BcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9IChvc3RydWN0X2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICBvc3RydWN0X2lkID0gI3tfX2lkX199O1xuICAgIH1cbiAgICBiZWdpblxuICAgICAgcmVzdWx0ID0gXCIjPCN7c2VsZi5jbGFzc31cIlxuICAgICAgJXh7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBvc3RydWN0X2lkcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvc3RydWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShvc3RydWN0X2lkKSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnIC4uLj4nO1xuICAgICAgICB9XG4gICAgICAgIG9zdHJ1Y3RfaWRzW29zdHJ1Y3RfaWRdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICcgJyBpZiBAdGFibGUuYW55P1xuXG4gICAgICByZXN1bHQgKz0gZWFjaF9wYWlyLm1hcCBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICAgIFwiI3tuYW1lfT0je3ZhbHVlLmluc3BlY3R9XCJcbiAgICAgIGVuZC5qb2luICcsICdcblxuICAgICAgcmVzdWx0ICs9ICc+J1xuXG4gICAgICByZXN1bHRcbiAgICBlbnN1cmVcbiAgICAgICV4e1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgb3N0cnVjdF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk9wZW5TdHJ1Y3Q+IiwiaW5pdGlhbGl6ZSIsImhhc2giLCJAdGFibGUiLCJlYWNoX3BhaXIiLCJibG9jayBpbiBpbml0aWFsaXplIiwia2V5IiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJbXT0iLCJzZWxmIiwibmV3X29zdHJ1Y3RfbWVtYmVyIiwiW10iLCJuYW1lIiwidG9fc3ltIiwibWV0aG9kX21pc3NpbmciLCI+IiwiYXJncyIsImxlbmd0aCIsIjIiLCJyYWlzZSIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJlbmRfd2l0aD8iLCIxIiwiQXJndW1lbnRFcnJvciIsIjAiLCItMiIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtaWQiLCJpbmNsdWRlX3ByaXZhdGUiLCJtbmFtZSIsInRvX3MiLCJjaG9tcCIsIiRyZXRfb3JfMSIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaF9wYWlyIiwicGFpciIsIj09Iiwib3RoZXIiLCJpc19hPyIsIk9wZW5TdHJ1Y3QiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCI9PT0iLCJlcWw/IiwidG9faCIsImR1cCIsInRvX24iLCJhdHRyX3JlYWRlciIsImRlbGV0ZV9maWVsZCIsInN5bSIsInNpbmdsZXRvbl9jbGFzcyIsIl9fc2VuZF9fIiwiTmFtZUVycm9yIiwiZGVsZXRlIiwicmVzcG9uZF90bz8iLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImJsb2NrIGluIG5ld19vc3RydWN0X21lbWJlciIsImJsb2NrICgyIGxldmVscykgaW4gbmV3X29zdHJ1Y3RfbWVtYmVyIiwieCIsImluc3BlY3QiLCJfX2lkX18iLCJyZXN1bHQiLCJjbGFzcyIsImFueT8iLCIrIiwibWFwIiwiYmxvY2sgaW4gaW5zcGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsImpvaW4iXSwibWFwcGluZ3MiOiJBQUFBQSwwQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0FBQUFBOzs7QUFDRUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxJQUFmRDtBQUFBQSxNQUFBQTs7O01BQWUseUJBQU87TUFDcEJFLGFBQVMsWUFBQTtNQUVULElBQUEsUUFBR0QsSUFBSCxDQUFBO1FBQ0VELE9BQUlHLE1BQUpGLElBQUlFLGFBQUFBLEVBQUFBLEVBQUFBLEVBQUpDLGFBQW1CQyxHQUFELEVBQU1DLEtBQXhCRixFQUFBRztBQUFBQTs7O1VBQW1CO1VBQUs7VUFDdEJBLE9BQU1DLE1BQUFBLENBQUNDLElBQUFDLG9CQUFBQSxDQUFtQkwsR0FBbkJLLENBQVAsRUFBa0NKLEtBQTVCRSxDQUFBQSxF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LFFBQUFBLENBQUFBLENBQU9EO0FBQ2hDQTs7TUFFTUEsT0FBQSxjQUFBOztNQUFBRSxTQUFVRixJQUFELEdBQUEsQ0FBS25ELElBQUlzRCxPQUFBQSxDQUFBQSxDQUFUOztBQUVmSDtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVNLElBQUEsUUFBaUIxRCxVQUFNOEQsU0FBQUEsQ0FBQUEsQ0FBdkIsQ0FBQTtRQUFBRixTQUFPRyxTQUFQSCxNQUFPRyxFQUFHTCxHQUFISztNQUFQO01BRUFILFNBQU9HLFNBQVBILE1BQU9HLEVBQVlDLE1BQVR6RCxJQUFBTixXQUFBQSxDQUFBQSxDQUFTK0QsT0FBQUEsRUFBQUEsRUFBQUEsRUFBVEMsY0FBa0J2RCxJQUFELEVBQU9OLEtBQXhCNkQ7O1FBQWtCO1FBQU07UUFDaENDLE9BQUEsRUFBQSxHQUFBLENBQUd4RCxJQUFILENBQUEsR0FBUXdELEdBQVIsR0FBQSxDQUFXOUQsS0FBS3NELFNBQUFBLENBQUFBLENBQWhCLEVBRFFPLENBQUFBLEdBQVNELENBRWhCRyxNQUFBQSxDQUFNVCxJQUFOUyxDQUZJSjtNQUlQSCxTQUFPRyxTQUFQSCxNQUFPRyxFQUFHTCxHQUFISztNQUVQTCxPQUFBRTtNQW5CQTs7QUFzQk5GO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BekJNLENBQUE7SUFOSkEsQ0FBQUEsR0FBQUE7SUFtQ0E3RCxPQUFBLGFBQU0sTUFBTixFQUFXLFNBQVg7RUFySUZBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozODg4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL3RleHQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBFbmNhcHN1bGF0ZXMgYSB0ZXh0IG5vZGUuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRcbmNsYXNzIFRleHQgPCBDaGFyYWN0ZXJEYXRhXG4gICMgKHNlZSBEb2N1bWVudCNjcmVhdGVfdGV4dClcbiAgZGVmIHNlbGYuY3JlYXRlKGNvbnRlbnQpXG4gICAgJGRvY3VtZW50LmNyZWF0ZV90ZXh0KGNvbnRlbnQpXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHdob2xlXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgd2hvbGUgdGV4dFxuICAjXG4gICMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dC53aG9sZVRleHRcbiAgZGVmIHdob2xlXG4gICAgYCNAbmF0aXZlLndob2xlVGV4dGBcbiAgZW5kXG5cbiAgIyBTcGxpdCB0aGUgdGV4dCBub2RlIGF0IGEgZ2l2ZW4gb2Zmc2V0LlxuICAjXG4gICMgQHBhcmFtIG9mZnNldCBbSW50ZWdlcl0gdGhlIG9mZnNldCB3aGVyZSB0byBzcGxpdCB0aGUgdGV4dCBub2RlXG4gICNcbiAgIyBAcmV0dXJuIFtUZXh0XSB0aGUgbmV3bHkgY3JlYXRlZCB0ZXh0IG5vZGVcbiAgI1xuICAjIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHQuc3BsaXRUZXh0XG4gIGRlZiBzcGxpdChvZmZzZXQpXG4gICAgRE9NKGAjQG5hdGl2ZS5zcGxpdFRleHQob2Zmc2V0KWApXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPERPTTo6VGV4dDogI3tkYXRhfT5cIlxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOlRleHQ+IiwiY3JlYXRlIiwic2VsZiIsImNvbnRlbnQiLCIkZG9jdW1lbnQiLCJjcmVhdGVfdGV4dCIsIndob2xlIiwiQG5hdGl2ZSIsInNwbGl0Iiwib2Zmc2V0IiwiRE9NIiwiaW5zcGVjdCIsImRhdGEiLCJDaGFyYWN0ZXJEYXRhIl0sIm1hcHBpbmdzIjoiQUFBQUEsbUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUtoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFFRUMsTUFBSUMsSUFBSkQsYUFBQUEsa0JBQWdCRSxPQUFoQkY7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFHLGVBQVNDLGFBQUFBLENBQWFGLE9BQWJFO1FBRFhKLENBQUFBLEdBQUFBOztBQVFBSyxRQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFQyxjQUFPRDtRQURYQSxDQUFBQSxHQUFBQTs7QUFXQUUsUUFBQUEscUJBQUFBLGlCQUFVQyxNQUFWRDtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQU4sSUFBQVEsS0FBQUEsQ0FBTUgsY0FBT0Msa0JBQWJFO1FBREZGLENBQUFBLEdBQUFBO1FBSUFSLE9BQUFXLHVCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUNBLGVBQUQsR0FBQSxDQUFnQlQsSUFBQVUsTUFBQUEsQ0FBQUEsQ0FBaEIsQ0FBQSxHQUFxQkQ7UUFEdkJBLENBQUFBLEdBQUFBO01BekJGWCxHQUFBQSxXQUFBQSxFQUFhYSxtQkFBYmI7SUFMZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mzg5MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9hdHRyaWJ1dGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBFbmNhcHN1bGF0ZXMgYW4ge0VsZW1lbnR9IGF0dHJpYnV0ZS5cbmNsYXNzIEF0dHJpYnV0ZVxuICBpbmNsdWRlIEJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXJcblxuICAjIEAhYXR0cmlidXRlIFtyXSBuYW1lXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gIGFsaWFzX25hdGl2ZSA6bmFtZVxuXG4gICMgQCFhdHRyaWJ1dGUgdmFsdWVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gIGFsaWFzX25hdGl2ZSA6dmFsdWVcbiAgYWxpYXNfbmF0aXZlIDp2YWx1ZT1cblxuICAjIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXR0cmlidXRlIGlzIGFuIGlkLlxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnQXR0ci5pc0lkJ1xuICAgIGFsaWFzX25hdGl2ZSA6aWQ/LCA6aXNJZFxuICBlbHNlXG4gICAgZGVmIGlkP1xuICAgICAgbmFtZSA9PSA6aWRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpBdHRyaWJ1dGU+Iiwic2VsZiIsImluY2x1ZGUiLCJCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyIiwiQnJvd3NlciIsImFsaWFzX25hdGl2ZSIsInN1cHBvcnRzPyIsImlkPyIsIm5hbWUiLCI9PSJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFHaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLGFBQUFELHdCQUFSRDtRQUlBRCxJQUFBSSxjQUFBQSxDQUFhLE1BQWJBO1FBSUFKLElBQUFJLGNBQUFBLENBQWEsT0FBYkE7UUFDQUosSUFBQUksY0FBQUEsQ0FBYSxRQUFiQTtRQUdBLElBQUEsUUFBR0QsYUFBT0UsY0FBQUEsQ0FBV04sV0FBWE0sQ0FBVixDQUFBO1VBQ0VOLE9BQUFDLElBQUFJLGNBQUFBLENBQWEsS0FBYixFQUFtQixNQUFuQkE7UUFERjtVQUdFTCxPQUFBTyxtQkFBQUEsOEJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBTixJQUFBTyxNQUFBQSxDQUFBQSxDQUFLQyxPQUFBQSxDQUFHLElBQUhBO1VBRFBGLENBQUFBLEdBQUFBO1FBSEY7TUFiRlAsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFIZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mzg5NzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L3NlbGVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgU2VsZWN0IDwgRWxlbWVudFxuICBkZWZfc2VsZWN0b3IgXCJzZWxlY3RcIlxuXG4gIGRlZiB2YWx1ZVxuICAgICV4e1xuICAgICAgaWYgKCNAbmF0aXZlLnZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI0BuYXRpdmUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWU9IHZhbHVlXG4gICAgYCNAbmF0aXZlLnZhbHVlID0gI3t2YWx1ZS50b19ufWBcbiAgZW5kXG5cbiAgZGVmIGxhYmVsc1xuICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLmxhYmVsc2ApXVxuICBlbmRcblxuICBkZWYgb3B0aW9uc1xuICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLm9wdGlvbnNgKV1cbiAgZW5kXG5cbiAgZGVmIG9wdGlvblxuICAgIERPTShgI0BuYXRpdmUub3B0aW9uc1sjQG5hdGl2ZS5zZWxlY3RlZEluZGV4XWApXG4gIGVuZFxuXG4gIGRlZiBpbmRleFxuICAgIGAjQG5hdGl2ZS5zZWxlY3RlZEluZGV4YFxuICBlbmRcblxuICBhbGlhc19uYXRpdmUgOm11bHRpcGxlPywgOm11bHRpcGxlXG4gIGFsaWFzX25hdGl2ZSA6cmVxdWlyZWQ/LCA6cmVxdWlyZWRcbiAgYWxpYXNfbmF0aXZlIDpsZW5ndGhcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6U2VsZWN0PiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJ2YWx1ZSIsIkBuYXRpdmUiLCJ2YWx1ZT0iLCJ0b19uIiwibGFiZWxzIiwiTm9kZVNldCIsIltdIiwiTmF0aXZlOjpBcnJheSIsIk5hdGl2ZSIsIm5ldyIsIm9wdGlvbnMiLCJvcHRpb24iLCJET00iLCJpbmRleCIsImFsaWFzX25hdGl2ZSIsIkVsZW1lbnQiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxjQUFBQSxDQUFhRixRQUFiRTs7QUFFQUMsVUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7O0FBRUZBLFVBQVdDLGNBQU9EO0FBQ2xCQTtBQUNBQTtBQUNBQTtBQUNBQSxlQUFnQkMsY0FBT0Q7QUFDdkJBO0FBQ0FBO1VBUkVBLENBQUFBLEdBQUFBOztBQVdBRSxVQUFBQSxzQkFBQUEsNEJBQVdGLEtBQVhFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxTQUFXRixLQUFLRyxNQUFBQSxDQUFBQTtVQUQzQkQsQ0FBQUEsR0FBQUE7O0FBSUFFLFVBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFDLGFBQU9DLE9BQUFBLENBQUNDLElBQUFDLFlBQUFELFVBQWFFLEtBQUFBLENBQU9SLGNBQU9HLE9BQWRLLENBQWRIO1VBRFRGLENBQUFBLEdBQUFBOztBQUlBTSxVQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBTCxhQUFPQyxPQUFBQSxDQUFDQyxJQUFBQyxZQUFBRCxVQUFhRSxLQUFBQSxDQUFPUixjQUFPUyxRQUFkRCxDQUFkSDtVQURUSSxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQWIsSUFBQWMsS0FBQUEsQ0FBTVgsY0FBT1UsU0FBVVYsY0FBT1UsZUFBOUJDO1VBREZELENBQUFBLEdBQUFBOztBQUlBRSxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFWixjQUFPWTtVQURYQSxDQUFBQSxHQUFBQTtVQUlBZixJQUFBZ0IsY0FBQUEsQ0FBYSxXQUFiLEVBQXlCLFVBQXpCQTtVQUNBaEIsSUFBQWdCLGNBQUFBLENBQWEsV0FBYixFQUF5QixVQUF6QkE7VUFDQWpCLE9BQUFDLElBQUFnQixjQUFBQSxDQUFhLFFBQWJBO1FBcENGakIsR0FBQUEsV0FBQUEsRUFBZWtCLGFBQWZsQjtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0JvQixVQUFoQnBCO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzkwNDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2lucHV0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBJbnB1dCA8IEVsZW1lbnRcbiAgZGVmX3NlbGVjdG9yIFwiaW5wdXRcIlxuXG4gIGRlZiB2YWx1ZVxuICAgICV4e1xuICAgICAgaWYgKCNAbmF0aXZlLnZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI0BuYXRpdmUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWU9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS52YWx1ZSA9ICN7dmFsdWV9YFxuICBlbmRcblxuICBkZWYgbmFtZV9cbiAgICBgI0BuYXRpdmUubmFtZWBcbiAgZW5kXG5cbiAgZGVmIHR5cGVcbiAgICBgI0BuYXRpdmUudHlwZWBcbiAgZW5kXG5cbiAgZGVmIGNoZWNrZWQ/XG4gICAgYCNAbmF0aXZlLmNoZWNrZWRgXG4gIGVuZFxuXG4gIGRlZiBjaGVjayFcbiAgICBgI0BuYXRpdmUuY2hlY2tlZCA9ICdjaGVja2VkJ2BcbiAgZW5kXG5cbiAgZGVmIHVuY2hlY2shXG4gICAgYCNAbmF0aXZlLmNoZWNrZWQgPSAnJ2BcbiAgZW5kXG5cbiAgZGVmIGVuYWJsZWQ/XG4gICAgYCNAbmF0aXZlLmVuYWJsZWRgXG4gIGVuZFxuXG4gIGRlZiBkaXNhYmxlIVxuICAgIGAjQG5hdGl2ZS5kaXNhYmxlZCA9ICdkaXNhYmxlZCdgXG4gIGVuZFxuXG4gIGRlZiBlbmFibGUhXG4gICAgYCNAbmF0aXZlLmRpc2FibGVkID0gJydgXG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgIGAjQG5hdGl2ZS52YWx1ZSA9ICcnYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBmaWxlc1xuICAjIEByZXR1cm4gW0FycmF5PEZpbGU+XSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoaXMge0lucHV0fVxuICBkZWYgZmlsZXNcbiAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUuZmlsZXNgKS5tYXAgeyB8ZnwgRmlsZS5uZXcoZi50b19uKSB9XG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpJbnB1dD4iLCJzZWxmIiwiZGVmX3NlbGVjdG9yIiwidmFsdWUiLCJAbmF0aXZlIiwidmFsdWU9IiwibmFtZV8iLCJ0eXBlIiwiY2hlY2tlZD8iLCJjaGVjayEiLCJ1bmNoZWNrISIsImVuYWJsZWQ/IiwiZGlzYWJsZSEiLCJlbmFibGUhIiwiY2xlYXIiLCJmaWxlcyIsIm1hcCIsIk5hdGl2ZTo6QXJyYXkiLCJOYXRpdmUiLCJuZXciLCJibG9jayBpbiBmaWxlcyIsImYiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbGVzIiwiRmlsZSIsInRvX24iLCJFbGVtZW50IiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDRDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUU1QkEsT0FBQUM7UUFBQUE7O1VBQUFBOztBQUFBQTs7VUFDRUMsSUFBQUMsY0FBQUEsQ0FBYUYsT0FBYkU7O0FBRUFDLFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7OztBQUVGQSxVQUFXQyxjQUFPRDtBQUNsQkE7QUFDQUE7QUFDQUE7QUFDQUEsZUFBZ0JDLGNBQU9EO0FBQ3ZCQTtBQUNBQTtVQVJFQSxDQUFBQSxHQUFBQTs7QUFXQUUsVUFBQUEsc0JBQUFBLDJCQUFXRixLQUFYRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsU0FBV0Y7VUFEdEJFLENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRTtVQURYQSxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0c7VUFEWEEsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLHdCQUFBQSwrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVKLGNBQU9JO1VBRFhBLENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSxzQkFBQUEsNkJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFTCxjQUFPSztVQURYQSxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEsd0JBQUFBLCtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRU4sY0FBT007VUFEWEEsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLHdCQUFBQSwrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVQLGNBQU9PO1VBRFhBLENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSx3QkFBQUEsK0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFUixjQUFPUTtVQURYQSxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEsdUJBQUFBLDhCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRVQsY0FBT1M7VUFEWEEsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVWLGNBQU9VO1VBRFhBLENBQUFBLEdBQUFBO1VBTUFkLE9BQUFlLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQW1DQyxNQUFuQ0MsSUFBQUMsWUFBQUQsVUFBYUUsS0FBQUEsQ0FBT2YsY0FBT1csTUFBZEksQ0FBc0JILE9BQUFBLEVBQUFBLEVBQUFBLEVBQW5DSSxhQUEyQ0MsQ0FBM0NEOztjQUEyQztjQUFHRSxPQUFBQyxVQUFJSixLQUFBQSxDQUFLRSxDQUFDRyxNQUFBQSxDQUFBQSxDQUFOTCxFQUFsREMsQ0FBQUEsR0FBbUNKO1VBRHJDRCxDQUFBQSxHQUFBQTtRQXhERmYsR0FBQUEsV0FBQUEsRUFBY3lCLGFBQWR6QjtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0IyQixVQUFoQjNCO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzkxNjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L3RlbXBsYXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBUZW1wbGF0ZSA8IEVsZW1lbnRcbiAgZGVmX3NlbGVjdG9yIFwidGVtcGxhdGVcIlxuXG4gIGRlZiBjb250ZW50XG4gICAgRE9NKGAjQG5hdGl2ZS5jb250ZW50YClcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOlRlbXBsYXRlPiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJjb250ZW50IiwiRE9NIiwiQG5hdGl2ZSIsIkVsZW1lbnQiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxjQUFBQSxDQUFhRixVQUFiRTtVQUVBRixPQUFBRyx1QkFBQUEsbUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBRixJQUFBRyxLQUFBQSxDQUFNQyxjQUFPRixRQUFiQztVQURGRCxDQUFBQSxHQUFBQTtRQUhGSCxHQUFBQSxXQUFBQSxFQUFpQk0sYUFBakJOO01BRjRCRCxHQUFBQSxXQUFBQSxFQUFnQlEsVUFBaEJSO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzkyMDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2ltYWdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBJbWFnZSA8IEVsZW1lbnRcbiAgZGVmX3NlbGVjdG9yIFwiaW1nXCJcblxuICBkZWYgY29tcGxldGU/XG4gICAgYCNAbmF0aXZlLmNvbXBsZXRlYFxuICBlbmRcblxuICBkZWYgY3Jvc3M/XG4gICAgYCNAbmF0aXZlLmNyb3NzT3JpZ2luYFxuICBlbmRcblxuICBkZWYgaGVpZ2h0XG4gICAgYCNAbmF0aXZlLm5hdHVyYWxIZWlnaHRgXG4gIGVuZFxuXG4gIGRlZiB3aWR0aFxuICAgIGAjQG5hdGl2ZS5uYXR1cmFsV2lkdGhgXG4gIGVuZFxuZW5kXG5cbkltZyA9IEltYWdlXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpJbWFnZT4iLCJzZWxmIiwiZGVmX3NlbGVjdG9yIiwiY29tcGxldGU/IiwiQG5hdGl2ZSIsImNyb3NzPyIsImhlaWdodCIsIndpZHRoIiwiRWxlbWVudCIsIkltYWdlIiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDRDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFFNUJDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGNBQUFBLENBQWFGLEtBQWJFOztBQUVBQyxVQUFBQSx5QkFBQUEsZ0NBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFQyxjQUFPRDtVQURYQSxDQUFBQSxHQUFBQTs7QUFJQUUsVUFBQUEsc0JBQUFBLDZCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0M7VUFEWEEsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FO1VBRFhBLENBQUFBLEdBQUFBO1VBSUFOLE9BQUFPLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVILGNBQU9HO1VBRFhBLENBQUFBLEdBQUFBO1FBZkZQLEdBQUFBLFdBQUFBLEVBQWNRLGFBQWRSO1FBb0JBRCxPQUFBLCtCQUFNVSxXQUFOO01BdEI0QlYsR0FBQUEsV0FBQUEsRUFBZ0JXLFVBQWhCWDtJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5MjU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vY2hhcmFjdGVyX2RhdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuY2xhc3MgQ2hhcmFjdGVyRGF0YSA8IE5vZGVcbiAgIyBBcHBlbmQgZGF0YSB0byB0aGUgbm9kZS5cbiAgI1xuICAjIEBwYXJhbSBzdHJpbmcgW1N0cmluZ10gdGhlIGRhdGEgdG8gYWRkXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgYXBwZW5kKHN0cmluZylcbiAgICBgI0BuYXRpdmUuYXBwZW5kRGF0YShzdHJpbmcpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBkYXRhXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgZGF0YSBvZiB0aGUgbm9kZVxuICBkZWYgZGF0YVxuICAgIGAjQG5hdGl2ZS5kYXRhYFxuICBlbmRcblxuICAjIERlbGV0ZSBkYXRhIGZyb20gdGhlIG5vZGUuXG4gICNcbiAgIyBAcGFyYW0gY291bnQgW0ludGVnZXJdIGhvdyBtdWNoIGRhdGEgdG8gZGVsZXRlXG4gICMgQHBhcmFtIG9mZnNldCBbSW50ZWdlcl0gdGhlIG9mZnNldCB0byBzdGFydCBhdFxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIGRlbGV0ZShjb3VudCwgb2Zmc2V0ID0gMClcbiAgICBgI0BuYXRpdmUuZGVsZXRlRGF0YShvZmZzZXQsIGNvdW50KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBJbnNlcnQgZGF0YSBpbiB0aGUgbm9kZS5cbiAgI1xuICAjIEBwYXJhbSBzdHJpbmcgW1N0cmluZ10gdGhlIGRhdGEgdG8gaW5zZXJ0XG4gICMgQHBhcmFtIG9mZnNldCBbSW50ZWdlcl0gdGhlIG9mZnNldCB0byBzdGFydCBhdFxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIGluc2VydChzdHJpbmcsIG9mZnNldCA9IDApXG4gICAgYCNAbmF0aXZlLmluc2VydERhdGEob2Zmc2V0LCBzdHJpbmcpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBsZW5ndGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbGVuZ3RoIG9mIHRoZSBub2RlXG4gIGFsaWFzX25hdGl2ZSA6bGVuZ3RoXG5cbiAgIyBSZXBsYWNlIGRhdGEgaW4gdGhlIG5vZGUuXG4gICNcbiAgIyBAcGFyYW0gc3RyaW5nIFtTdHJpbmddIHRoZSBkYXRhIHRvIHJlcGxhY2Ugd2l0aFxuICAjIEBwYXJhbSBvZmZzZXQgW0ludGVnZXJdIHRoZSBvZmZzZXQgdG8gc3RhcnQgYXRcbiAgIyBAcGFyYW0gY291bnQgW0ludGVnZXJdIGhvdyBtdWNoIGRhdGEgdG8gcmVwbGFjZVxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIHJlcGxhY2Uoc3RyaW5nLCBvZmZzZXQgPSAwLCBjb3VudCA9IGAjQG5hdGl2ZS5sZW5ndGhgKVxuICAgIGAjQG5hdGl2ZS5yZXBsYWNlRGF0YShvZmZzZXQsIGNvdW50LCBzdHJpbmcpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEdldCBhIHN1YnN0cmluZyBvZiB0aGUgZGF0YS5cbiAgI1xuICAjIEBwYXJhbSBjb3VudCBbSW50ZWdlcl0gaG93IG11Y2ggZGF0YSB0byBsaWNlXG4gICMgQHBhcmFtIG9mZnNldCBbSW50ZWdlcl0gdGhlIG9mZnNldCB0byBzdGFydCBhdFxuICAjXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3Vic3RyaW5nXG4gIGRlZiBzdWJzdHJpbmcoY291bnQsIG9mZnNldCA9IDApXG4gICAgYCNAbmF0aXZlLnN1YnN0cmluZ0RhdGEob2Zmc2V0LCBjb3VudClgXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6Q2hhcmFjdGVyRGF0YT4iLCJhcHBlbmQiLCJzdHJpbmciLCJAbmF0aXZlIiwic2VsZiIsImRhdGEiLCJkZWxldGUiLCJjb3VudCIsIm9mZnNldCIsIjAiLCJpbnNlcnQiLCJhbGlhc19uYXRpdmUiLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7OztBQU1FQyxRQUFBQSxzQkFBQUEsa0JBQVdDLE1BQVhEO0FBQUFBLFVBQUFBOzs7VUFDSUUsY0FBT0Y7VUFFVEEsT0FBQUc7UUFIRkgsQ0FBQUEsR0FBQUE7O0FBUUFJLFFBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVGLGNBQU9FO1FBRFhBLENBQUFBLEdBQUFBOztBQVVBQyxRQUFBQSxzQkFBQUEsaUNBQVdDLEtBQUQsRUFBUUMsTUFBbEJGO0FBQUFBLFVBQUFBOzs7VUFBa0IsNkJBQVNHO1VBQ3ZCTixjQUFPRztVQUVUQSxPQUFBRjtRQUhGRSxDQUFBQSxJQUFBQTs7QUFZQUksUUFBQUEsc0JBQUFBLGtCQUFXUixNQUFELEVBQVNNLE1BQW5CRTtBQUFBQSxVQUFBQTs7O1VBQW1CLDZCQUFTRDtVQUN4Qk4sY0FBT087VUFFVEEsT0FBQU47UUFIRk0sQ0FBQUEsSUFBQUE7UUFRQU4sSUFBQU8sY0FBQUEsQ0FBYSxRQUFiQTs7QUFTQUMsUUFBQUEsdUJBQUFBLG1CQUFZVixNQUFELEVBQVNNLE1BQVQsRUFBcUJELEtBQWhDSztBQUFBQSxVQUFBQTs7O1VBQW9CLDZCQUFTSDtVQUFHLDJCQUFVTixjQUFPUztVQUM3Q1QsY0FBT1M7VUFFVEEsT0FBQVI7UUFIRlEsQ0FBQUEsSUFBQUE7UUFZQVosT0FBQWEseUJBQUFBLHFCQUFjTixLQUFELEVBQVFDLE1BQXJCSztBQUFBQSxVQUFBQTs7O1VBQXFCLDZCQUFTSjtVQUM1QkksT0FBRVYsY0FBT1U7UUFEWEEsQ0FBQUEsSUFBQUE7TUFqRUZiLEdBQUFBLFdBQUFBLEVBQXNCYyxVQUF0QmQ7SUFGZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzkzMzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L21lZGlhLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBNZWRpYSA8IEVsZW1lbnRcbiAgZGVmIHBsYXlcbiAgICBgI0BuYXRpdmUucGxheSgpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBWaWRlbyA8IE1lZGlhXG4gIGRlZl9zZWxlY3RvciBcInZpZGVvXCJcbmVuZFxuXG5jbGFzcyBBdWRpbyA8IE1lZGlhXG4gIGRlZl9zZWxlY3RvciBcImF1ZGlvXCJcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6TWVkaWE+IiwicGxheSIsIkBuYXRpdmUiLCJFbGVtZW50IiwiPGNsYXNzOlZpZGVvPiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJNZWRpYSIsIjxjbGFzczpBdWRpbz4iLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUU1QkM7UUFBQUE7O1VBQUFBOztBQUFBQTtVQUNFQSxPQUFBQyxvQkFBQUEsZ0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFQyxjQUFPRDtVQURYQSxDQUFBQSxHQUFBQTtRQURGRCxHQUFBQSxXQUFBQSxFQUFjRyxhQUFkSDtRQU1BSTtRQUFBQTs7O1VBQ0VBLE9BQUFDLElBQUFDLGNBQUFBLENBQWFGLE9BQWJFO1FBREZGLEdBQUFBLFdBQUFBLEVBQWNHLFdBQWRIO1FBSUFMLE9BQUFTO1FBQUFBOzs7VUFDRUEsT0FBQUgsSUFBQUMsY0FBQUEsQ0FBYUUsT0FBYkY7UUFERkUsR0FBQUEsV0FBQUEsRUFBY0QsV0FBZEM7TUFaNEJULEdBQUFBLFdBQUFBLEVBQWdCVSxVQUFoQlY7SUFBWkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozOTM4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvYnV0dG9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBCdXR0b24gPCBFbGVtZW50XG4gIGRlZl9zZWxlY3RvciBcImJ1dHRvblwiXG5cbiAgZGVmIGRpc2FibGVkP1xuICAgIGAjQG5hdGl2ZS5kaXNhYmxlZGBcbiAgZW5kXG5cbiAgZGVmIGRpc2FibGVkPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuZGlzYWJsZWQgPSAje3ZhbHVlfWBcbiAgZW5kXG5cbiAgZGVmIGF1dG9mb2N1cz9cbiAgICBgI0BuYXRpdmUuYXV0b2ZvY3VzYFxuICBlbmRcblxuICBkZWYgYXV0b2ZvY3VzPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuYXV0b2ZvY3VzID0gI3t2YWx1ZX1gXG4gIGVuZFxuXG4gIGRlZiBuYW1lX1xuICAgIGAjQG5hdGl2ZS5uYW1lYFxuICBlbmRcblxuICBkZWYgbmFtZV89KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5uYW1lID0gI3t2YWx1ZX1gXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpCdXR0b24+Iiwic2VsZiIsImRlZl9zZWxlY3RvciIsImRpc2FibGVkPyIsIkBuYXRpdmUiLCJkaXNhYmxlZD0iLCJ2YWx1ZSIsImF1dG9mb2N1cz8iLCJhdXRvZm9jdXM9IiwibmFtZV8iLCJuYW1lXz0iLCJFbGVtZW50IiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUU1QkEsT0FBQUM7UUFBQUE7O1VBQUFBOztBQUFBQTs7VUFDRUMsSUFBQUMsY0FBQUEsQ0FBYUYsUUFBYkU7O0FBRUFDLFVBQUFBLHlCQUFBQSxpQ0FBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVDLGNBQU9EO1VBRFhBLENBQUFBLEdBQUFBOztBQUlBRSxVQUFBQSx5QkFBQUEsK0JBQWNDLEtBQWREO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxZQUFjQztVQUR6QkQsQ0FBQUEsR0FBQUE7O0FBSUFFLFVBQUFBLDBCQUFBQSxrQ0FBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVILGNBQU9HO1VBRFhBLENBQUFBLEdBQUFBOztBQUlBQyxVQUFBQSwwQkFBQUEsZ0NBQWVGLEtBQWZFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSixjQUFPSSxhQUFlRjtVQUQxQkUsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVMLGNBQU9LO1VBRFhBLENBQUFBLEdBQUFBO1VBSUFULE9BQUFVLHNCQUFBQSw0QkFBV0osS0FBWEk7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVOLGNBQU9NLFFBQVVKO1VBRHJCSSxDQUFBQSxHQUFBQTtRQXZCRlYsR0FBQUEsV0FBQUEsRUFBZVcsYUFBZlg7TUFGNEJELEdBQUFBLFdBQUFBLEVBQWdCYSxVQUFoQmI7SUFBWkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozOTQ1MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvdGV4dGFyZWEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbmNsYXNzIFRleHRhcmVhIDwgRWxlbWVudFxuICBkZWZfc2VsZWN0b3IgXCJ0ZXh0YXJlYVwiXG5cbiAgZGVmIHZhbHVlXG4gICAgJXh7XG4gICAgICBpZiAoI0BuYXRpdmUudmFsdWUgPT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjQG5hdGl2ZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB2YWx1ZT0odmFsdWUpXG4gICAgYCNAbmF0aXZlLnZhbHVlID0gI3t2YWx1ZX1gXG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgIGAjQG5hdGl2ZS52YWx1ZSA9ICcnYFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6VGV4dGFyZWE+Iiwic2VsZiIsImRlZl9zZWxlY3RvciIsInZhbHVlIiwiQG5hdGl2ZSIsInZhbHVlPSIsImNsZWFyIiwiRWxlbWVudCIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGNBQUFBLENBQWFGLFVBQWJFOztBQUVBQyxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOzs7QUFFRkEsVUFBV0MsY0FBT0Q7QUFDbEJBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGVBQWdCQyxjQUFPRDtBQUN2QkE7QUFDQUE7VUFSRUEsQ0FBQUEsR0FBQUE7O0FBV0FFLFVBQUFBLHNCQUFBQSw4QkFBV0YsS0FBWEU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLFNBQVdGO1VBRHRCRSxDQUFBQSxHQUFBQTtVQUlBTCxPQUFBTSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRTtVQURYQSxDQUFBQSxHQUFBQTtRQWxCRk4sR0FBQUEsV0FBQUEsRUFBaUJPLGFBQWpCUDtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0JTLFVBQWhCVDtJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5NTA5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvYSdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvYmFzZSdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvYmxvY2txdW90ZSdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvYnV0dG9uJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9jYW52YXMnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L2VtYmVkJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9pbWcnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L2lucHV0J1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9saW5rJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9vYmplY3QnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L29wdGlvbidcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvb3B0Z3JvdXAnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L3NlbGVjdCdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvdGQnXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuICBkZWYgc2VsZi5uZXcob3duZXIsIG5hbWUsIGF0dHJpYnV0ZXMgPSB7fSlcbiAgICByZXR1cm4gc3VwZXIgdW5sZXNzIHNlbGYgPT0gRWxlbWVudFxuXG4gICAgY29uc3QgPSBuYW1lLmNhcGl0YWxpemVcblxuICAgIGlmICFjb25zdC50b19zLmluY2x1ZGU/KCctJykgJiYgY29uc3RfZGVmaW5lZD8oY29uc3QpXG4gICAgICBjb25zdF9nZXQoY29uc3QpLm5ldyhvd25lciwgbmFtZSwgYXR0cmlidXRlcylcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShvd25lciwgbmFtZSwgYXR0cmlidXRlcyA9IHt9KVxuICAgIEBvd25lciAgICAgICA9IG93bmVyXG4gICAgQG5hbWUgICAgICAgID0gbmFtZVxuICAgIEBhdHRyaWJ1dGVzICA9IGF0dHJpYnV0ZXNcbiAgICBAY2hpbGRyZW4gICAgPSBbXVxuICAgIEBjbGFzc19uYW1lcyA9IFtdXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICBAY2hpbGRyZW4uZWFjaCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiA8PCh3aGF0KVxuICAgIEBjaGlsZHJlbiA8PCB3aGF0XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCBjb250ZW50ID0gbmlsLCAmYmxvY2spXG4gICAgaWYgbmFtZS50b19zLmVuZF93aXRoPyA/IVxuICAgICAgQGF0dHJpYnV0ZXNbOmlkXSA9IG5hbWVbMCAuLiAtMl1cbiAgICBlbHNlXG4gICAgICBAY2xhc3NfbmFtZXMgPDwgbmFtZVxuICAgIGVuZFxuXG4gICAgaWYgOjpIYXNoID09PSBjb250ZW50XG4gICAgICBpZiBjb250ZW50Lmhhc19rZXk/KDpjbGFzcykgfHwgY29udGVudC5oYXNfa2V5Pyg6Y2xhc3NlcylcbiAgICAgICAgQGNsYXNzX25hbWVzLnVuc2hpZnQoKihjb250ZW50LmRlbGV0ZSg6Y2xhc3MpLnRvX3Muc3BsaXQgfCBjb250ZW50LmRlbGV0ZSg6Y2xhc3NlcykudG9fYSkpXG4gICAgICBlbmRcblxuICAgICAgOjpQYWdnaW86OlV0aWxzLmRlZXBfbWVyZ2UhKEBhdHRyaWJ1dGVzLCBjb250ZW50KVxuICAgIGVsc2lmIGNvbnRlbnRcbiAgICAgIHNlbGYgPj4gY29udGVudFxuICAgIGVuZFxuXG4gICAgQG93bmVyLmV4dGVuZCEoc2VsZiwgJmJsb2NrKSBpZiBibG9ja1xuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgW10oKm5hbWVzKVxuICAgIGlmIGxhc3QgPSBAY2xhc3NfbmFtZXMucG9wXG4gICAgICBAY2xhc3NfbmFtZXMgPDwgW2xhc3QsICpuYW1lc10uam9pbignLScpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkbygmYmxvY2spXG4gICAgQG93bmVyLmV4dGVuZCEoc2VsZiwgJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgPj4oY29udGVudClcbiAgICBzZWxmIDw8IDo6UGFnZ2lvOjpVdGlscy5oZXJlZG9jKGNvbnRlbnQudG9fcylcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZmhlbHBlciA6c3R5bGUgZG8gfGhhc2h8XG4gICAgQGF0dHJpYnV0ZXNbOnN0eWxlXSA9IGhhc2gubWFwIHt8bmFtZSwgdmFsdWV8XG4gICAgICBcIiN7bmFtZX06ICN7dmFsdWV9XCJcbiAgICB9LmpvaW4oJzsnKVxuICBlbmRcblxuICBkZWZoZWxwZXIgOmRhdGEgZG8gfGhhc2h8XG4gICAgaGFzaC5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tcImRhdGEtI3tuYW1lfVwiXSA9IHZhbHVlLnRvX3NcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgaWYgQGNoaWxkcmVuLmVtcHR5P1xuICAgICAgXCIjPEhUTUw6OkVsZW1lbnQoI3tAbmFtZS51cGNhc2V9KT5cIlxuICAgIGVsc2VcbiAgICAgIFwiIzxIVE1MOjpFbGVtZW50KCN7QG5hbWUudXBjYXNlfSk6ICN7QGNoaWxkcmVuLmluc3BlY3RbMSAuLiAtMl19PlwiXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCJuZXciLCJvd25lciIsIm5hbWUiLCJhdHRyaWJ1dGVzIiwiRWxlbWVudCIsImNvbnN0JCIsImNhcGl0YWxpemUiLCJ0b19zIiwiaW5jbHVkZT8iLCJjb25zdF9kZWZpbmVkPyIsImNvbnN0X2dldCIsImluaXRpYWxpemUiLCJAb3duZXIiLCJAbmFtZSIsIkBhdHRyaWJ1dGVzIiwiQGNoaWxkcmVuIiwiQGNsYXNzX25hbWVzIiwiZWFjaCIsImJsb2NrIiwidG9fcHJvYyIsIjw8Iiwid2hhdCIsIm1ldGhvZF9taXNzaW5nIiwiY29udGVudCIsImVuZF93aXRoPyIsIltdPSIsIltdIiwiMCIsIi0yIiwiSGFzaCIsImhhc19rZXk/IiwidW5zaGlmdCIsImRlbGV0ZSIsInNwbGl0IiwifCIsInRvX2EiLCJQYWdnaW86OlV0aWxzIiwiUGFnZ2lvIiwiZGVlcF9tZXJnZSEiLCI+PiIsImV4dGVuZCEiLCJsYXN0IiwicG9wIiwibmFtZXMiLCJqb2luIiwiZG8iLCJoZXJlZG9jIiwiZGVmaGVscGVyIiwiYmxvY2sgaW4gPGNsYXNzOkVsZW1lbnQ+IiwiaGFzaCIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkVsZW1lbnQ+IiwibWFwIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpFbGVtZW50PiIsImluc3BlY3QiLCJlbXB0eT8iLCJ1cGNhc2UiLCIxIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFVQUMsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDBCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQ0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsNEJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDRCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiwyQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYseUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDJCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiwwQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsNEJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDRCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw4QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsNEJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHdCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFZEEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsTUFBSUwsSUFBSkssVUFBQUEsd0JBQWFDLEtBQUQsRUFBUUMsSUFBUixFQUFjQyxVQUExQkg7QUFBQUEsVUFBQUE7O1VBQUFBOztVQUEwQixxQ0FBYSxZQUFBO1VBQ3JDLEtBQUEsTUFBb0JMLElBQXBCLEVBQTRCUyxhQUE1QixDQUFBO1lBQUEsT0FBTyxPQUFBVCxJQUFBLEVBQUEscURBQUEsT0FBQSxFQUFBLENBQUFNLEtBQUEsRUFBQUMsSUFBQSxFQUFBQyxVQUFB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eyJvZmZzZXQiOnsibGluZSI6Mzk2ODIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vY3NzL2NvbG9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBDU1MgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBDb2xvclxuICBkZWYgaW5pdGlhbGl6ZSh2YWx1ZSwgdHlwZSlcbiAgICBAaW50ZXJuYWwgPSB2YWx1ZVxuICAgIEB0eXBlICAgICA9IHR5cGVcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcblxuY2xhc3MgU3RyaW5nXG4gICV3W3JnYiByZ2JhIGhzbCBoc2xhXS5tYXAoJjp0b19zeW0pLmVhY2gge3xuYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgUGFnZ2lvOjpDU1M6OkNvbG9yLm5ldyhzZWxmLCBuYW1lKVxuICAgIGVuZFxuICB9XG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgJXdbcmdiIHJnYmEgaHNsIGhzbGFdLm1hcCgmOnRvX3N5bSkuZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBQYWdnaW86OkNTUzo6Q29sb3IubmV3KHNlbGYsIG5hbWUpXG4gICAgZW5kXG4gIH1cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpDU1M+IiwiPGNsYXNzOkNvbG9yPiIsImluaXRpYWxpemUiLCJ2YWx1ZSIsInR5cGUiLCJAaW50ZXJuYWwiLCJAdHlwZSIsIkJhc2ljT2JqZWN0IiwiPGNsYXNzOlN0cmluZz4iLCJlYWNoIiwibWFwIiwidG9fcHJvYyIsImJsb2NrIGluIDxjbGFzczpTdHJpbmc+IiwibmFtZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOlN0cmluZz4iLCJkZWZpbmVfbWV0aG9kIiwic2VsZiIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOlN0cmluZz4iLCJQYWdnaW86OkNTUzo6Q29sb3IiLCJQYWdnaW86OkNTUyIsIlBhZ2dpbyIsIm5ldyIsIjxjbGFzczpBcnJheT4iLCJibG9jayBpbiA8Y2xhc3M6QXJyYXk+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6QXJyYXk+IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6QXJyYXk+Il0sIm1hcHBpbmdzIjoiQUFBQUEsbUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBVUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVkQSxPQUFBQztNQUFBQTs7O1FBQ0VBLE9BQUFDLDBCQUFBQSxzQkFBZUMsS0FBRCxFQUFRQyxJQUF0QkY7QUFBQUEsVUFBQUE7OztVQUNFRyxnQkFBWUY7VUFDWkQsT0FBQUksQ0FBQUEsWUFBWUYsSUFBWkU7UUFGRkosQ0FBQUEsR0FBQUE7TUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFGY0QsR0FBQUEsV0FBQUEsRUFBWU8saUJBQVpQO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBV0FTO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBbUNDLE1BQWRDLE1BQXJCLENBQUdGLEtBQUgsRUFBT0EsTUFBUCxFQUFZQSxLQUFaLEVBQWdCQSxNQUFoQixDQUFxQkUsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTSxRQUFEQyxTQUFBQSxDQUFBQSxDQUFMRCxDQUFjRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFuQ0csbUJBQTJDQyxJQUEzQ0QsRUFBQUU7OztNQUEyQztNQUN6Q0EsT0FBQUMsTUFBQUMsSUFBQUQsaUJBQUFBLEVBQUFBLENBQWNGLElBQWRFLENBQUFBLEVBQUFELGFBQUFBLEVBQUFHOztRQUNFQSxPQUFBQyxJQUFBQyxJQUFBQyxZQUFBRCxRQUFBRCxVQUFrQkcsS0FBQUEsQ0FBS0wsSUFBdkIsRUFBNkJILElBQVhRLENBRHBCUCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUMsRUFERkgsQ0FBQUEsR0FBQUEscUJBQUFBLENBQW1DSDtFQURyQ0QsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFRQVYsT0FBQXdCO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBbUNiLE1BQWRDLE1BQXJCLENBQUdZLEtBQUgsRUFBT0EsTUFBUCxFQUFZQSxLQUFaLEVBQWdCQSxNQUFoQixDQUFxQlosT0FBQUEsRUFBQUEsRUFBQUEsRUFBTSxRQUFEQyxTQUFBQSxDQUFBQSxDQUFMRCxDQUFjRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFuQ2Msa0JBQTJDVixJQUEzQ1UsRUFBQUM7OztNQUEyQztNQUN6Q0EsT0FBQVQsTUFBQUMsSUFBQUQsaUJBQUFBLEVBQUFBLENBQWNGLElBQWRFLENBQUFBLEVBQUFTLGFBQUFBLEVBQUFDOztRQUNFQSxPQUFBUCxJQUFBQyxJQUFBQyxZQUFBRCxRQUFBRCxVQUFrQkcsS0FBQUEsQ0FBS0wsSUFBdkIsRUFBNkJILElBQVhRLENBRHBCRyxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQVQsRUFERlEsQ0FBQUEsR0FBQUEscUJBQUFBLENBQW1DZDtFQURyQ2EsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUE3QkF4QjsifX0seyJvZmZzZXQiOnsibGluZSI6Mzk3MzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2F0dHJpYnV0ZXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbmNsYXNzIEF0dHJpYnV0ZXNcbiAgYXR0cl9yZWFkZXIgOm5hbWVzcGFjZVxuXG4gIGRlZiBpbml0aWFsaXplKGVsZW1lbnQsIG9wdGlvbnMpXG4gICAgQGVsZW1lbnQgICA9IGVsZW1lbnRcbiAgICBAbmF0aXZlICAgID0gZWxlbWVudC50b19uXG4gICAgQG5hbWVzcGFjZSA9IG9wdGlvbnNbOm5hbWVzcGFjZV1cbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8oJ0VsZW1lbnQuY2xhc3NOYW1lJykgfHwgQnJvd3Nlci5zdXBwb3J0cz8oJ0VsZW1lbnQuaHRtbEZvcicpXG4gICAgZGVmIFtdKG5hbWUsIG9wdGlvbnMgPSB7fSlcbiAgICAgIGlmIG5hbWUgPT0gOmNsYXNzICYmIEJyb3dzZXIuc3VwcG9ydHM/KCdFbGVtZW50LmNsYXNzTmFtZScpXG4gICAgICAgIG5hbWUgPSA6Y2xhc3NOYW1lXG4gICAgICBlbHNpZiBuYW1lID09IDpmb3IgJiYgQnJvd3Nlci5zdXBwb3J0cz8oJ0VsZW1lbnQuaHRtbEZvcicpXG4gICAgICAgIG5hbWUgPSA6aHRtbEZvclxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5hbWVzcGFjZSA9IG9wdGlvbnNbOm5hbWVzcGFjZV0gfHwgQG5hbWVzcGFjZVxuICAgICAgICBgI0BuYXRpdmUuZ2V0QXR0cmlidXRlTlMoI3tuYW1lc3BhY2UudG9fc30sICN7bmFtZS50b19zfSkgfHwgbmlsYFxuICAgICAgZWxzZVxuICAgICAgICBgI0BuYXRpdmUuZ2V0QXR0cmlidXRlKCN7bmFtZS50b19zfSkgfHwgbmlsYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgW109KG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pXG4gICAgICBpZiBuYW1lID09IDpjbGFzcyAmJiBCcm93c2VyLnN1cHBvcnRzPygnRWxlbWVudC5jbGFzc05hbWUnKVxuICAgICAgICBuYW1lID0gOmNsYXNzTmFtZVxuICAgICAgZWxzaWYgbmFtZSA9PSA6Zm9yICYmIEJyb3dzZXIuc3VwcG9ydHM/KCdFbGVtZW50Lmh0bWxGb3InKVxuICAgICAgICBuYW1lID0gOmh0bWxGb3JcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYW1lc3BhY2UgPSBvcHRpb25zWzpuYW1lc3BhY2VdIHx8IEBuYW1lc3BhY2VcbiAgICAgICAgaWYgdmFsdWVcbiAgICAgICAgICBgI0BuYXRpdmUuc2V0QXR0cmlidXRlTlMoI3tuYW1lc3BhY2UudG9fc30sICN7bmFtZS50b19zfSwgI3t2YWx1ZX0pYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYCNAbmF0aXZlLnJlbW92ZUF0dHJpYnV0ZU5TKCN7bmFtZXNwYWNlLnRvX3N9LCAje25hbWUudG9fc30pYFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgaWYgdmFsdWVcbiAgICAgICAgICBgI0BuYXRpdmUuc2V0QXR0cmlidXRlKCN7bmFtZS50b19zfSwgI3t2YWx1ZS50b19zfSlgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgI0BuYXRpdmUucmVtb3ZlQXR0cmlidXRlKCN7bmFtZS50b19zfSlgXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgW10obmFtZSwgb3B0aW9ucyA9IHt9KVxuICAgICAgaWYgbmFtZXNwYWNlID0gb3B0aW9uc1s6bmFtZXNwYWNlXSB8fCBAbmFtZXNwYWNlXG4gICAgICAgIGAjQG5hdGl2ZS5nZXRBdHRyaWJ1dGVOUygje25hbWVzcGFjZS50b19zfSwgI3tuYW1lLnRvX3N9KSB8fCBuaWxgXG4gICAgICBlbHNlXG4gICAgICAgIGAjQG5hdGl2ZS5nZXRBdHRyaWJ1dGUoI3tuYW1lLnRvX3N9KSB8fCBuaWxgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBbXT0obmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSlcbiAgICAgIGlmIG5hbWVzcGFjZSA9IG9wdGlvbnNbOm5hbWVzcGFjZV0gfHwgQG5hbWVzcGFjZVxuICAgICAgICBpZiB2YWx1ZVxuICAgICAgICAgIGAjQG5hdGl2ZS5zZXRBdHRyaWJ1dGVOUygje25hbWVzcGFjZS50b19zfSwgI3tuYW1lLnRvX3N9LCAje3ZhbHVlfSlgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgI0BuYXRpdmUucmVtb3ZlQXR0cmlidXRlTlMoI3tuYW1lc3BhY2UudG9fc30sICN7bmFtZS50b19zfSlgXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBpZiB2YWx1ZVxuICAgICAgICAgIGAjQG5hdGl2ZS5zZXRBdHRyaWJ1dGUoI3tuYW1lLnRvX3N9LCAje3ZhbHVlLnRvX3N9KWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGAjQG5hdGl2ZS5yZW1vdmVBdHRyaWJ1dGUoI3tuYW1lLnRvX3N9KWBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBEZWxldGVzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4gbmFtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gYW4gYXR0cmlidXRlIHZhbHVlIGJlZm9yZSBkZWxldGlvblxuICBkZWYgZGVsZXRlKG5hbWUpXG4gICAgYXR0ciA9IHNlbGZbbmFtZV1cbiAgICBzZWxmW25hbWVdID0gbmlsXG4gICAgYXR0clxuICBlbmRcblxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIEBlbGVtZW50LmF0dHJpYnV0ZV9ub2Rlcy5lYWNoIHt8YXR0cnxcbiAgICAgIHlpZWxkIGF0dHIubmFtZSwgYXR0ci52YWx1ZVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgZ2V0IFtdXG5cbiAgZGVmIGhhc19rZXk/KG5hbWUpXG4gICAgISFzZWxmW25hbWVdXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSEoaGFzaClcbiAgICBoYXNoLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgIHNlbGZbbmFtZV0gPSB2YWx1ZVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgc2V0IFtdPVxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpBdHRyaWJ1dGVzPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJlbGVtZW50Iiwib3B0aW9ucyIsIkBlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJAbmFtZXNwYWNlIiwiW10iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwibmFtZSIsIm5hbWVzcGFjZSIsIiRyZXRfb3JfMSIsInRvX3MiLCJbXT0iLCJ2YWx1ZSIsImRlbGV0ZSIsImF0dHIiLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImF0dHJpYnV0ZV9ub2RlcyIsImJsb2NrIGluIGVhY2giLCJoYXNfa2V5PyIsIiEiLCJtZXJnZSEiLCJoYXNoIiwiYmxvY2sgaW4gbWVyZ2UhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtZXJnZSEiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsaURBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxhQUFBQSxDQUFZLFdBQVpBOztBQUVBQyxVQUFBQSwwQkFBQUEsc0JBQWVDLE9BQUQsRUFBVUMsT0FBeEJGO0FBQUFBLFlBQUFBOzs7WUFDRUcsZUFBYUY7WUFDYkcsaUJBQWFILE9BQU9JLE1BQUFBLENBQUFB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Z0IsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRE5lLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFJVDtZQUlKTyxPQUFBN0I7VUFMRjZCLENBQUFBLEdBQUFBO1VBUUE5QixPQUFBLGFBQU0sS0FBTixFQUFVLEtBQVY7UUF6R0ZBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO01BRjRCRCxHQUFBQSxXQUFBQSxFQUFnQm1DLFVBQWhCbkM7SUFBWkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozOTkwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvc2Nyb2xsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG4jIEB0b2RvIENvbnNpZGVyIHVzaW5nIHRoZSBuZXcgaW50ZXJmYWNlcyB3aGljaCBhbGxvdyBmb3Igb3B0aW9uYWxcbiMgICAgICAgc21vb3RoIHRyYW5zaXRpb25zLlxuY2xhc3MgU2Nyb2xsXG4gIGF0dHJfcmVhZGVyIDplbGVtZW50XG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZShlbGVtZW50KVxuICAgIEBlbGVtZW50ID0gZWxlbWVudFxuICAgIEBuYXRpdmUgID0gZWxlbWVudC50b19uXG5cbiAgICAjIFBvcnRhYmxlIHN1cHBvcnQgZm9yIFdpbmRvdyNzY3JvbGwgYW5kIERvY3VtZW50I3Njcm9sbFxuICAgIEBzY3JvbGxpbmdfbmF0aXZlID0gQG5hdGl2ZVxuICAgIGlmIFtEb2N1bWVudCwgV2luZG93XS5pbmNsdWRlPyhAZWxlbWVudC5jbGFzcylcbiAgICAgICMgSWYgd2UgYXJlIGEgd2luZG93LCBsZXQncyBiZWNvbWUgYSBkb2N1bWVudCBmaXJzdC5cbiAgICAgIGlmIGRlZmluZWQ/IGAjQHNjcm9sbGluZ19uYXRpdmUuZG9jdW1lbnRgXG4gICAgICAgIEBzY3JvbGxpbmdfbmF0aXZlID0gYCNAc2Nyb2xsaW5nX25hdGl2ZS5kb2N1bWVudGBcbiAgICAgIGVuZFxuICAgICAgIyBUaGVyZSB3ZXJlIHNsaWdodCBkaXNhZ3JlZW1lbnRzIGluIHRoZSBwYXN0IHdoaWNoIGVsZW1lbnRcbiAgICAgICMgc2hvdWxkIHdlIGhhbmRsZS5cbiAgICAgIGlmIGRlZmluZWQ/IGAjQHNjcm9sbGluZ19uYXRpdmUuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcGBcbiAgICAgICAgQHNjcm9sbGluZ19uYXRpdmUgPSBgI0BzY3JvbGxpbmdfbmF0aXZlLmRvY3VtZW50RWxlbWVudGBcbiAgICAgIGVsc2lmIGRlZmluZWQ/IGAjQHNjcm9sbGluZ19uYXRpdmUuYm9keS5zY3JvbGxUb3BgXG4gICAgICAgIEBzY3JvbGxpbmdfbmF0aXZlID0gYCNAc2Nyb2xsaW5nX25hdGl2ZS5ib2R5YFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQG92ZXJsb2FkIHRvKHgsIHkpXG4gICNcbiAgIyAgIFNjcm9sbCB0byB0aGUgZ2l2ZW4geCBhbmQgeS5cbiAgI1xuICAjICAgQHBhcmFtIHggW0ludGVnZXJdIHNjcm9sbCB0byB4IG9uIHRoZSB4IGF4aXNcbiAgIyAgIEBwYXJhbSB5IFtJbnRlZ2VyXSBzY3JvbGwgdG8geSBvbiB0aGUgeSBheGlzXG4gICNcbiAgIyBAb3ZlcmxvYWQgdG8oaGFzaClcbiAgI1xuICAjICAgU2Nyb2xsIHRvIHRoZSBnaXZlbiB4IGFuZCB5LlxuICAjXG4gICMgICBAcGFyYW0gaGFzaCBbSGFzaF0gdGhlIGRlc2NyaXB0b3JcbiAgI1xuICAjICAgQG9wdGlvbiBoYXNoIFtJbnRlZ2VyXSA6eCBzY3JvbGwgdG8geCBvbiB0aGUgeCBheGlzXG4gICMgICBAb3B0aW9uIGhhc2ggW0ludGVnZXJdIDp5IHNjcm9sbCB0byB5IG9uIHRoZSB5IGF4aXNcbiAgI1xuICAjIEBvdmVybG9hZCB0byhzeW1ib2wpXG4gICNcbiAgIyAgIFNjcm9sbCB0byA6dG9wIG9yIHRvIDpib3R0b21cbiAgI1xuICAjICAgQHBhcmFtIHN5bWJvbCBbU3ltYm9sXSBlaXRoZXIgOnRvcCBvciA6Ym90dG9tXG4gIGRlZiB0bygqYXJncylcbiAgICB4LCB5ID0gbmlsLCBuaWxcbiAgICBjYXNlIGFyZ3MuZmlyc3RcbiAgICB3aGVuIEhhc2hcbiAgICAgIHggPSBhcmdzLmZpcnN0Wzp4XVxuICAgICAgeSA9IGFyZ3MuZmlyc3RbOnldXG4gICAgd2hlbiA6dG9wXG4gICAgICB5ID0gMFxuICAgIHdoZW4gOmJvdHRvbVxuICAgICAgeSA9IDk5OTk5OTk5XG4gICAgZWxzZVxuICAgICAgeCwgeSA9IGFyZ3NcbiAgICBlbmRcblxuICAgIHNldCh4LCB5KSBpZiB4IHx8IHlcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAb3ZlcmxvYWQgYnkoeCwgeSlcbiAgI1xuICAjICAgU2Nyb2xsIGJ5IHRoZSBnaXZlbiB4IGFuZCB5LlxuICAjXG4gICMgICBAcGFyYW0geCBbSW50ZWdlcl0gc2Nyb2xsIGJ5IHggb24gdGhlIHggYXhpc1xuICAjICAgQHBhcmFtIHkgW0ludGVnZXJdIHNjcm9sbCBieSB5IG9uIHRoZSB5IGF4aXNcbiAgI1xuICAjIEBvdmVybG9hZCBieShoYXNoKVxuICAjXG4gICMgICBTY3JvbGwgYnkgdGhlIGdpdmVuIHggYW5kIHkuXG4gICNcbiAgIyAgIEBwYXJhbSBoYXNoIFtIYXNoXSB0aGUgZGVzY3JpcHRvclxuICAjXG4gICMgICBAb3B0aW9uIGhhc2ggW0ludGVnZXJdIDp4IHNjcm9sbCBieSB4IG9uIHRoZSB4IGF4aXNcbiAgIyAgIEBvcHRpb24gaGFzaCBbSW50ZWdlcl0gOnkgc2Nyb2xsIGJ5IHkgb24gdGhlIHkgYXhpc1xuICBkZWYgYnkoKmFyZ3MpXG4gICAgY2FzZSBhcmdzLmZpcnN0XG4gICAgd2hlbiBIYXNoXG4gICAgICB4ID0gYXJncy5maXJzdFs6eF0gfHwgMFxuICAgICAgeSA9IGFyZ3MuZmlyc3RbOnldIHx8IDBcbiAgICBlbHNlXG4gICAgICB4LCB5ID0gYXJnc1xuICAgIGVuZFxuXG4gICAgc2V0X2J5KHgsIHkpXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LnNjcm9sbEJ5J1xuICAgIHByaXZhdGUgZGVmIHNldF9ieSh4LCB5KVxuICAgICAgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxCeSgje3h9LCAje3l9KWBcbiAgICBlbmRcbiAgZWxzZVxuICAgIHByaXZhdGUgZGVmIHNldF9ieSh4LCB5KVxuICAgICAgc2V0KHNlbGYueCArIHgsIHNlbGYueSArIHkpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LnNjcm9sbCdcbiAgICBwcml2YXRlIGRlZiBzZXQoeD1uaWwsIHk9bmlsKVxuICAgICAgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxUb3AgID0gI3t5fWAgaWYgeVxuICAgICAgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxMZWZ0ID0gI3t4fWAgaWYgeFxuICAgIGVuZFxuXG4gICAgZGVmIHBvc2l0aW9uXG4gICAgICBCcm93c2VyOjpQb3NpdGlvbi5uZXcoYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxMZWZ0YCwgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxUb3BgKVxuICAgIGVuZFxuICBlbHNlXG4gICAgcHJpdmF0ZSBkZWYgc2V0KHg9bmlsLCB5PW5pbClcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdzY3JvbGwgb24gZWxlbWVudCB1bnN1cHBvcnRlZCdcbiAgICBlbmRcblxuICAgIGRlZiBwb3NpdGlvblxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3Njcm9sbCBvbiBlbGVtZW50IHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB4XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHNjcm9sbCBwb3NpdGlvbiBvbiB0aGUgeCBheGlzXG4gIGRlZiB4XG4gICAgcG9zaXRpb24ueFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB5XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHNjcm9sbCBwb3NpdGlvbiBvbiB0aGUgeSBheGlzXG4gIGRlZiB5XG4gICAgcG9zaXRpb24ueVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBoZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxcbiAgZGVmIGhlaWdodFxuICAgIGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsSGVpZ2h0YFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB3aWR0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsXG4gIGRlZiB3aWR0aFxuICAgIGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsV2lkdGhgXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LnNjcm9sbEludG9WaWV3SWZOZWVkZWQnXG4gICAgZGVmIGludG9fdmlldyhhbGlnbiA9IHRydWUpXG4gICAgICBgI0BzY3JvbGxpbmdfbmF0aXZlLnNjcm9sbEludG9WaWV3SWZOZWVkZWQoYWxpZ24pYFxuICAgIGVuZFxuICBlbHNlXG4gICAgIyBOb24tc3RhbmRhcmQuIE5vdCBzdXBwb3J0ZWQgYnkgbW9kZXJuIEZpcmVmb3guIFVzZSB7I2ludG9fdmlldyF9XG4gICAgZGVmIGludG9fdmlldyhhbGlnbiA9IHRydWUpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbnRvX3ZpZXchKGFsaWduID0gdHJ1ZSlcbiAgICBgI0BzY3JvbGxpbmdfbmF0aXZlLnNjcm9sbEludG9WaWV3KGFsaWduKWBcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOlNjcm9sbD4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiZWxlbWVudCIsIkBlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJAc2Nyb2xsaW5nX25hdGl2ZSIsIkRvY3VtZW50IiwiV2luZG93IiwiaW5jbHVkZT8iLCJjbGFzcyIsInRvIiwieCIsInkiLCJIYXNoIiwiJHJldF9vcl8xIiwiYXJncyIsImZpcnN0IiwiW10iLCIwIiwiOTk5OTk5OTkiLCJzZXQiLCJieSIsIiRyZXRfb3JfMiIsInNldF9ieSIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJwcml2YXRlIiwiKyIsInBvc2l0aW9uIiwiQnJvd3Nlcjo6UG9zaXRpb24iLCJuZXciLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJoZWlnaHQiLCJ3aWR0aCIsImludG9fdmlldyIsImFsaWduIiwiaW50b192aWV3ISIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFJNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGFBQUFBLENBQVksU0FBWkE7O0FBR0FDLFVBQUFBLDBCQUFBQSxzQkFBZUMsT0FBZkQ7QUFBQUEsWUFBQUE7OztZQUNFRSxlQUFXRDtZQUNYRSxpQkFBV0YsT0FBT0csTUFBQUEsQ0FBQUE7WUFHbEJDLHdCQUFvQkY7WUFDcEIsSUFBQSxRQUFHLENBQUNHLGNBQUQsRUFBV0MsWUFBWCxDQUFrQkMsYUFBQUEsQ0FBVU4sWUFBUU8sT0FBQUEsQ0FBQUEsQ0FBbEJELENBQXJCLENBQUE7O2NBRUUsSUFBQSxRQUFHLFFBQVdILHFCQUFpQkwsU0FBNUIsa0JBQUgsQ0FBQTtnQkFDRUssd0JB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IjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3RcblxuY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG4gIGRlZiBzZWxmLmRlZmhlbHBlcihuYW1lLCAmYmxvY2spXG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvIHwqYXJncywgJmJvZHl8XG4gICAgICBpbnN0YW5jZV9leGVjKCphcmdzLCAmYmxvY2spXG5cbiAgICAgIHNlbGYuZG8oJmJvZHkpIGlmIGJvZHlcbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVmaGVscGVyIShuYW1lLCBhdHRyaWJ1dGUgPSBuYW1lKVxuICAgIGRlZmhlbHBlciBcIiN7bmFtZX0hXCIgZG9cbiAgICAgIEBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB0cnVlXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiZGVmaGVscGVyIiwic2VsZiIsIm5hbWUiLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgaW4gZGVmaGVscGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWZoZWxwZXIiLCJpbnN0YW5jZV9leGVjIiwiYXJncyIsImJsb2NrIiwidG9fcHJvYyIsImJvZHkiLCJkbyIsImRlZmhlbHBlciEiLCJhdHRyaWJ1dGUiLCJibG9jayBpbiBkZWZoZWxwZXIhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWZoZWxwZXIhIiwiW109IiwiQGF0dHJpYnV0ZXMiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVkQSxPQUFBQztNQUFBQTs7OztRQUNFQyxNQUFJQyxJQUFKRCxnQkFBQUEscUJBQW1CRSxJQUFuQkY7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFDRUEsT0FBQUcsTUFBQUYsSUFBQUUsaUJBQUFBLEVBQUFBLENBQWNELElBQWRDLENBQUFBLEVBQUFDLGFBZEosRUFjSUEsRUFBQUM7O1lBQUFBOzs7WUFkSjtZQWMyQjtZQUNyQkMsTUFBQUwsSUFBQUssaUJBQUFBLEVBQWMsTUFBQ0MsSUFBRCxDQUFkRCxFQUFzQkUsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBckJIO1lBRUEsSUFBQSxRQUFrQkksSUFBbEIsQ0FBQTtjQUFJQyxNQUFKVixJQUFJVSxNQUFBQSxFQUFBQSxFQUFBQSxFQUFLRCxJQUFERCxTQUFBQSxDQUFBQSxDQUFKRTtZQUFKO1lBQ0FOLE9BQUFKLEtBSkZHLENBQUFBLEdBQUFBLHNCQUFBQSxDQUFBRDtRQURGSCxDQUFBQSxHQUFBQTtRQVNBRCxPQUFBYSxNQUFJWCxJQUFKVyxpQkFBQUEsbUNBQW9CVixJQUFELEVBQU9XLFNBQTFCRDtBQUFBQSxVQUFBQTs7O1VBQTBCLG1DQUFZVjtVQUNwQ1UsT0FBQVosTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVSxFQUFBLEdBQUEsQ0FBR0UsSUFBSCxDQUFBLEdBQVFVLEdBQWxCWixDQUFBQSxFQUFBYyxhQUFBQSxFQUFBQztBQUFBQTs7WUFDRUEsT0FBV0MsTUFBQUEsQ0FBQ0gsU0FBWixFQUF5QixJQUFkRyxDQUFBQSxFQUFBQSxNQUFYQyxlQUFXRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxrQkFEYkYsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFkO1FBREZZLENBQUFBLElBQUFBO01BVkZiLEdBQUFBLFdBQUFBLEVBQWdCbUIsaUJBQWhCbkI7SUFGY0QsR0FBQUEsV0FBQUEsRUFBYW9CLGlCQUFicEI7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwMTU3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9zaXplLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBTaXplXG4gIGF0dHJfcmVhZGVyIDplbGVtZW50XG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZShlbGVtZW50LCAqaW5jKVxuICAgIEBlbGVtZW50ID0gZWxlbWVudFxuICAgIEBuYXRpdmUgID0gZWxlbWVudC50b19uXG4gICAgQGluY2x1ZGUgPSBpbmNcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSB3aWR0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBlbGVtZW50IHdpZHRoXG4gIGRlZiB3aWR0aFxuICAgIGAjQG5hdGl2ZS5vZmZzZXRXaWR0aGBcbiAgZW5kXG5cbiAgZGVmIHdpZHRoPSh2YWx1ZSlcbiAgICBAZWxlbWVudC5zdHlsZVs6d2lkdGhdID0gdmFsdWVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBoZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgZWxlbWVudCBoZWlnaHRcbiAgZGVmIGhlaWdodFxuICAgIGAjQG5hdGl2ZS5vZmZzZXRIZWlnaHRgXG4gIGVuZFxuXG4gIGRlZiBoZWlnaHQ9KHZhbHVlKVxuICAgIEBlbGVtZW50LnN0eWxlWzpoZWlnaHRdID0gdmFsdWVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBjbGllbnRfd2lkdGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgY29udGVudC1ib3ggd2lkdGggb2YgYW4gZWxlbWVudFxuICBkZWYgY2xpZW50X3dpZHRoXG4gICAgYCNAbmF0aXZlLmNsaWVudFdpZHRoYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIGNsaWVudF9oZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgY29udGVudC1ib3ggaGVpZ2h0IG9mIGFuIGVsZW1lbnRcbiAgZGVmIGNsaWVudF9oZWlnaHRcbiAgICBgI0BuYXRpdmUuY2xpZW50SGVpZ2h0YFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6U2l6ZT4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiZWxlbWVudCIsIkBlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJAaW5jbHVkZSIsImluYyIsIndpZHRoIiwid2lkdGg9IiwidmFsdWUiLCJbXT0iLCJzdHlsZSIsImhlaWdodCIsImhlaWdodD0iLCJjbGllbnRfd2lkdGgiLCJjbGllbnRfaGVpZ2h0IiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUU1QkEsT0FBQUM7UUFBQUE7O1VBQUFBOztBQUFBQTs7VUFDRUMsSUFBQUMsYUFBQUEsQ0FBWSxTQUFaQTs7QUFHQUMsVUFBQUEsMEJBQUFBLHNCQUFlQyxPQUFELEVBTmhCLEVBTUVEO0FBQUFBLFlBQUFBOzs7WUFORjtZQU0wQjtZQUN0QkUsZUFBV0Q7WUFDWEUsaUJBQVdGLE9BQU9HLE1BQUFBLENBQUFBO1lBQ2xCSixPQUFBSyxDQUFBQSxlQUFXQyxHQUFYRDtVQUhGTCxDQUFBQSxJQUFBQTs7QUFRQU8sVUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUosY0FBT0k7VUFEWEEsQ0FBQUEsR0FBQUE7O0FBSUFDLFVBQUFBLHNCQUFBQSwwQkFBV0MsS0FBWEQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQWNFLE1BQUFBLENBQUMsT0FBZixFQUF5QkQsS0FBWEMsQ0FBQUEsRUFBQUEsTUFBZFIsWUFBUVMsT0FBQUEsQ0FBQUEsQ0FBTUQsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7VUFEaEJGLENBQUFBLEdBQUFBOztBQU1BSSxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFVCxjQUFPUztVQURYQSxDQUFBQSxHQUFBQTs7QUFJQUMsVUFBQUEsdUJBQUFBLDJCQUFZSixLQUFaSTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBY0gsTUFBQUEsQ0FBQyxRQUFmLEVBQTBCRCxLQUFaQyxDQUFBQSxFQUFBQSxNQUFkUixZQUFRUyxPQUFBQSxDQUFBQSxDQUFNRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtVQURoQkcsQ0FBQUEsR0FBQUE7O0FBTUFDLFVBQUFBLDRCQUFBQSx3QkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVYLGNBQU9XO1VBRFhBLENBQUFBLEdBQUFBO1VBTUFqQixPQUFBa0IsNkJBQUFBLHlCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRVosY0FBT1k7VUFEWEEsQ0FBQUEsR0FBQUE7UUF0Q0ZsQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0JvQixVQUFoQnBCO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDAyMzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L29mZnNldC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgT2Zmc2V0XG4gIGF0dHJfcmVhZGVyIDplbGVtZW50XG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZShlbGVtZW50KVxuICAgIEBlbGVtZW50ID0gZWxlbWVudFxuICAgIEBuYXRpdmUgID0gZWxlbWVudC50b19uXG4gIGVuZFxuXG4gIGRlZiBwYXJlbnRcbiAgICBET00oYCNAbmF0aXZlLm9mZnNldFBhcmVudCB8fCAje0BlbGVtZW50LmRvY3VtZW50LnJvb3QudG9fbn1gKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIHhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXVxuICBkZWYgeFxuICAgIGdldC54XG4gIGVuZFxuXG4gIGRlZiB4PSh2YWx1ZSlcbiAgICBzZXQgdmFsdWUsIG5pbFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIHlcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXVxuICBkZWYgeVxuICAgIGdldC55XG4gIGVuZFxuXG4gIGRlZiB5PSh2YWx1ZSlcbiAgICBzZXQgbmlsLCB2YWx1ZVxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QnXG4gICAgZGVmIGdldFxuICAgICAgZG9jICA9IEBlbGVtZW50LmRvY3VtZW50XG4gICAgICByb290ID0gZG9jLnJvb3QudG9fblxuICAgICAgd2luICA9IGRvYy53aW5kb3cudG9fblxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIGJveCA9ICNAbmF0aXZlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgeSAgID0gYm94LnRvcCArICgje3dpbn0ucGFnZVlPZmZzZXQgfHwgI3tyb290fS5zY3JvbGxUb3ApIC0gKCN7cm9vdH0uY2xpZW50VG9wIHx8IDApLFxuICAgICAgICAgICAgeCAgID0gYm94LmxlZnQgKyAoI3t3aW59LnBhZ2VYT2Zmc2V0IHx8ICN7cm9vdH0uc2Nyb2xsTGVmdCkgLSAoI3tyb290fS5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgfVxuXG4gICAgICBCcm93c2VyOjpQb3NpdGlvbi5uZXcoYHhgLCBgeWApXG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgZ2V0XG4gICAgICBkb2MgID0gZG9jdW1lbnRcbiAgICAgIHJvb3QgPSBkb2Mucm9vdC50b19uXG4gICAgICB3aW4gID0gZG9jLndpbmRvdy50b19uXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgeSA9ICgje3dpbn0ucGFnZVlPZmZzZXQgfHwgI3tyb290fS5zY3JvbGxUb3ApIC0gKCN7cm9vdH0uY2xpZW50VG9wIHx8IDApLFxuICAgICAgICAgICAgeCA9ICgje3dpbn0ucGFnZVhPZmZzZXQgfHwgI3tyb290fS5zY3JvbGxMZWZ0KSAtICgje3Jvb3R9LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICB9XG5cbiAgICAgIEJyb3dzZXI6OlBvc2l0aW9uLm5ldyhgeGAsIGB5YClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNldCgqdmFsdWUpXG4gICAgcG9zaXRpb24gPSBAZWxlbWVudC5zdHlsZSFbOnBvc2l0aW9uXVxuXG4gICAgaWYgcG9zaXRpb24gPT0gOnN0YXRpY1xuICAgICAgQGVsZW1lbnQuc3R5bGVbOnBvc2l0aW9uXSA9IDpyZWxhdGl2ZVxuICAgIGVuZFxuXG4gICAgb2Zmc2V0ID0gZ2V0XG4gICAgdG9wICAgID0gQGVsZW1lbnQuc3R5bGUhWzp0b3BdLnRvX3VcbiAgICBsZWZ0ICAgPSBAZWxlbWVudC5zdHlsZSFbOmxlZnRdLnRvX3VcblxuICAgIGlmIEJyb3dzZXI6OlBvc2l0aW9uID09PSB2YWx1ZS5maXJzdFxuICAgICAgeCwgeSA9IHZhbHVlLmZpcnN0LngsIHZhbHVlLmZpcnN0LnlcbiAgICBlbHNpZiBIYXNoID09PSB2YWx1ZS5maXJzdFxuICAgICAgeCwgeSA9IHZhbHVlLmZpcnN0Wzp4XSwgdmFsdWUuZmlyc3RbOnldXG4gICAgZWxzZVxuICAgICAgeCwgeSA9IHZhbHVlXG4gICAgZW5kXG5cbiAgICBAZWxlbWVudC5zdHlsZVs6bGVmdF0gPSAoeC5weCAtIG9mZnNldC54KSArIGxlZnQgaWYgeFxuICAgIEBlbGVtZW50LnN0eWxlWzp0b3BdICA9ICh5LnB4IC0gb2Zmc2V0LnkpICsgdG9wICBpZiB5XG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpPZmZzZXQ+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImVsZW1lbnQiLCJAZWxlbWVudCIsIkBuYXRpdmUiLCJ0b19uIiwicGFyZW50IiwiRE9NIiwiZG9jdW1lbnQiLCJyb290IiwieCIsImdldCIsIng9IiwidmFsdWUiLCJzZXQiLCJ5IiwieT0iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiZG9jIiwid2luIiwid2luZG93IiwiQnJvd3Nlcjo6UG9zaXRpb24iLCJuZXciLCJwb3NpdGlvbiIsInN0eWxlISIsIltdIiwic3R5bGUiLCJbXT0iLCJvZmZzZXQiLCJ0b3AiLCJ0b191IiwibGVmdCIsImZpcnN0IiwiSGFzaCIsIisiLCItIiwicHgiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJ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QSxRQUFvRGIsQ0FBcEQsQ0FBQTtjQUFBRCxPQUFjYyxNQUFBQSxDQUFDLEtBQWYsRUFBMENPLFNBQVpDLFVBQUxyQixDQUFDc0IsSUFBQUEsQ0FBQUEsQ0FBSUQsRUFBRVAsTUFBTWQsR0FBQUEsQ0FBQUEsQ0FBUnFCLENBQVlELEVBQUVMLEdBQUZLLENBQTVCUCxDQUFBQSxFQUFBQSxNQUFkekIsWUFBUXdCLE9BQUFBLENBQUFBLENBQU1DLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO1lBQWQ7Y0FwRkpkLE9BQUE7WUFvRkk7VUFwQkZBLENBQUFBLElBQUFBO1FBOURGaEIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7TUFGNEJELEdBQUFBLFdBQUFBLEVBQWdCeUMsVUFBaEJ6QztJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwMzY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnVmZmVyL2FycmF5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJ1ZmZlclxuICBjbGFzcyBBcnJheVxuICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICBkZWYgc2VsZi5mb3IoYml0cywgdHlwZSlcbiAgICAgICQkW1wiI3tCdWZmZXIubmFtZV9mb3IgYml0cywgdHlwZX1BcnJheVwiXVxuICAgIGVuZFxuXG4gICAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgICBhdHRyX3JlYWRlciA6YnVmZmVyLCA6dHlwZVxuXG4gICAgZGVmIGluaXRpYWxpemUoYnVmZmVyLCBiaXRzID0gbmlsLCB0eXBlID0gbmlsKVxuICAgICAgaWYgTmF0aXZlID09IGJ1ZmZlclxuICAgICAgICBzdXBlcihidWZmZXIpXG4gICAgICBlbHNlXG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciBrbGFzcyA9ICN7QXJyYXkuZm9yKGJpdHMsIHR5cGUpfTtcblxuICAgICAgICAgICN7c3VwZXIoYG5ldyBrbGFzcygje2J1ZmZlci50b19ufSlgKX1cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIEBidWZmZXIgPSBidWZmZXJcbiAgICAgIEB0eXBlICAgPSB0eXBlXG4gICAgZW5kXG5cbiAgICBkZWYgYml0c1xuICAgICAgYCN7QG5hdGl2ZX0uQllURVNfUEVSX0VMRU1FTlQgKiA4YFxuICAgIGVuZFxuXG4gICAgZGVmIFtdKGluZGV4LCBvZmZzZXQgPSBuaWwpXG4gICAgICBvZmZzZXQgPyBgI3tAbmF0aXZlfS5zdWJhcnJheShpbmRleCwgb2Zmc2V0KWAgOiBgI3tAbmF0aXZlfVtpbmRleF1gXG4gICAgZW5kXG5cbiAgICBkZWYgW109KGluZGV4LCB2YWx1ZSlcbiAgICAgIGAje0BuYXRpdmV9W2luZGV4XSA9IHZhbHVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGJ5dGVzaXplXG4gICAgICBgI3tAbmF0aXZlfS5ieXRlTGVuZ3RoYFxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2hcbiAgICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gI3tAbmF0aXZlfS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYCN7QG5hdGl2ZX1baV1gfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBsZW5ndGhcbiAgICAgIGAje0BuYXRpdmV9Lmxlbmd0aGBcbiAgICBlbmRcblxuICAgIGRlZiBtZXJnZSEob3RoZXIsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAgIGAje0BuYXRpdmV9LnNldCgje290aGVyLnRvX259LCBvZmZzZXQpYFxuICAgIGVuZFxuXG4gICAgYWxpYXMgc2l6ZSBsZW5ndGhcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJ1ZmZlcj4iLCI8Y2xhc3M6QXJyYXk+Iiwic2VsZiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJmb3IiLCJiaXRzIiwidHlwZSIsIiQkIiwiW10iLCJCdWZmZXIiLCJuYW1lX2ZvciIsIkVudW1lcmFibGUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJidWZmZXIiLCJBcnJheSIsInRvX24iLCJAYnVmZmVyIiwiQHR5cGUiLCJAbmF0aXZlIiwiaW5kZXgiLCJvZmZzZXQiLCJbXT0iLCJ2YWx1ZSIsImJ5dGVzaXplIiwiZWFjaCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwibGVuZ3RoIiwibWVyZ2UhIiwib3RoZXIiXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEO01BRUFHLE1BQUlKLElBQUpJLFVBQUFBLHNCQUFhQyxJQUFELEVBQU9DLElBQW5CRjtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUcsUUFBRUMsT0FBQUEsQ0FBQyxFQUFBLEdBQUEsQ0FBR0MsWUFBTUMsVUFBQUEsQ0FBVUwsSUFBaEIsRUFBc0JDLElBQWhCSSxDQUFULENBQUEsR0FBOEJOLE9BQS9CSTtNQURKSixDQUFBQSxHQUFBQTtNQUlBSixJQUFBQyxTQUFBQSxDQUFRVSxnQkFBUlY7TUFFQUQsSUFBQVksYUFBQUEsQ0FBWSxRQUFaLEVBQXFCLE1BQXJCQTs7QUFFQUMsTUFBQUEsMEJBQUFBLHNCQUFlQyxNQUFELEVBQVNULElBQVQsRUFBcUJDLElBQW5DTztBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQXVCLHlCQUFPO1FBQUsseUJBQU87UUFDeEMsSUFBQSxNQUFHVixZQUFILEVBQWFXLE1BQWIsQ0FBQTtVQUNFLE9BQUFkLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTWMsTUFBTixDQUFBLEVBQUEsSUFBQTtRQURGOztBQUlORCxzQkFBd0JFLFdBQUtYLEtBQUFBLENBQUtDLElBQVYsRUFBZ0JDLElBQVhGLENBQWlCUzs7QUFFOUNBLFVBQVksT0FBQWIsSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFPYSxVQUFZQyxNQUFNRSxNQUFBQSxDQUFBQSxDQUFNSCxDQUEvQixDQUFBLEVBQUEsSUFBQTtBQUNaQTtRQVBNO1FBVUFJLGNBQVVIO1FBQ1ZELE9BQUFLLENBQUFBLFlBQVVaLElBQVZZO01BWkZMLENBQUFBLElBQUFBOztBQWVBUixNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFHYyxjQUFRZDtNQURiQSxDQUFBQSxHQUFBQTs7QUFJQUcsTUFBQUEsa0JBQUFBLHFCQUFPWSxLQUFELEVBQVFDLE1BQWRiO0FBQUFBLFFBQUFBOzs7UUFBYyw2QkFBUztRQUNyQixJQUFBLFFBQUFhLE1BQUEsQ0FBQTtVQUFTYixPQUFHVyxjQUFRWDtRQUFwQjtVQUFnREEsT0FBR1csY0FBUVg7UUFBM0Q7TUFERkEsQ0FBQUEsSUFBQUE7O0FBSUFjLE1BQUFBLG1CQUFBQSx3QkFBUUYsS0FBRCxFQUFRRyxLQUFmRDtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBR0gsY0FBUUc7TUFEYkEsQ0FBQUEsR0FBQUE7O0FBSUFFLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUdMLGNBQVFLO01BRGJBLENBQUFBLEdBQUFBOztBQUlBQyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7UUFDRSxLQUE2QkMsZ0JBQTdCO1VBQUEsT0FBTzFCLElBQUEyQixVQUFBQSxDQUFTLE1BQVRBO1FBQVA7O0FBR05GLGlDQUFtQ04sY0FBUU07QUFDM0NBLFVBQVksb0JBQVNOLGNBQVFNLEdBQWpCO0FBQ1pBO0FBQ0FBO1FBRU1BLE9BQUF6QjtNQVRGeUIsQ0FBQUEsR0FBQUE7O0FBWUFHLE1BQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUdULGNBQVFTO01BRGJBLENBQUFBLEdBQUFBOztBQUlBQyxNQUFBQSxzQkFBQUEsNkJBQVdDLEtBQUQsRUFBUVQsTUFBbEJRO0FBQUFBLFFBQUFBOzs7O1FBQ0VBLE9BQUdWLGNBQVFVLEtBQU9DLEtBQUtkLE1BQUFBLENBQUFBLENBQU1hO01BRC9CQSxDQUFBQSxJQUFBQTtNQUlBOUIsT0FBQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0lBOURGQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQURGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDA0NzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vY3NzL3VuaXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIENTUyA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIFVuaXRcbiAgVFlQRVMgICAgICA9ICV3W2VtIGV4IGNoIHJlbSB2aCB2dyB2bWluIHZtYXggcHggbW0gY20gaW4gcHQgcGMgcyBkZWddLm1hcCgmOnRvX3N5bSlcbiAgQ09NUEFUSUJMRSA9ICV3W2luIHB0IG1tIGNtIHB4IHBjXS5tYXAoJjp0b19zeW0pXG5cbiAgYXR0cl9yZWFkZXIgOnR5cGUsIDpudW1iZXJcblxuICBkZWYgaW5pdGlhbGl6ZShudW1iZXIsIHR5cGUpXG4gICAgQG51bWJlciA9IG51bWJlclxuICAgIEB0eXBlICAgPSB0eXBlXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgcmV0dXJuIHNlbGYsIG90aGVyXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICB1bmxlc3MgVW5pdCA9PT0gb3RoZXJcbiAgICAgIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyA6dG9fdVxuICAgICAgICByYWlzZSBUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje290aGVyLmNsYXNzfSBpbnRvIFVuaXRcIlxuICAgICAgZW5kXG5cbiAgICAgIG90aGVyID0gb3RoZXIudG9fdVxuICAgIGVuZFxuXG4gICAgdW5sZXNzIFVuaXQgPT09IG90aGVyXG4gICAgICBvdGhlciA9IFVuaXQubmV3KG90aGVyLCBAdHlwZSlcbiAgICBlbmRcblxuICAgIEBudW1iZXIgPT0gY29udmVydChvdGhlciwgQHR5cGUpXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgQHR5cGUgPT0gb3RoZXIudHlwZSAmJiBAbnVtYmVyID09IG90aGVyLm51bWJlclxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGhhc2hcbiAgICBbQG51bWJlciwgQHR5cGVdLmhhc2hcbiAgZW5kXG5cbiAgVFlQRVMuZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBVbml0Lm5ldyhjb252ZXJ0KHNlbGYsIG5hbWUpLCBuYW1lKVxuICAgIGVuZFxuICB9XG5cbiAgZGVmICsob3RoZXIpXG4gICAgcmV0dXJuIFVuaXQubmV3KEBudW1iZXIgKyBvdGhlciwgQHR5cGUpIHVubGVzcyBVbml0ID09PSBvdGhlclxuXG4gICAgaWYgQHR5cGUgPT0gb3RoZXIudHlwZVxuICAgICAgVW5pdC5uZXcoQG51bWJlciArIG90aGVyLm51bWJlciwgQHR5cGUpXG4gICAgZWxzaWYgY29tcGF0aWJsZT8oc2VsZikgYW5kIGNvbXBhdGlibGU/KG90aGVyKVxuICAgICAgVW5pdC5uZXcoQG51bWJlciArIGNvbnZlcnQob3RoZXIsIEB0eXBlKSwgQHR5cGUpXG4gICAgZWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCIje290aGVyLnR5cGV9IGlzbid0IGNvbXBhdGlibGUgd2l0aCAje0B0eXBlfVwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIHJldHVybiBVbml0Lm5ldyhAbnVtYmVyIC0gb3RoZXIsIEB0eXBlKSB1bmxlc3MgVW5pdCA9PT0gb3RoZXJcblxuICAgIGlmIEB0eXBlID09IG90aGVyLnR5cGVcbiAgICAgIFVuaXQubmV3KEBudW1iZXIgLSBvdGhlci5udW1iZXIsIEB0eXBlKVxuICAgIGVsc2lmIGNvbXBhdGlibGU/KHNlbGYpIGFuZCBjb21wYXRpYmxlPyhvdGhlcilcbiAgICAgIFVuaXQubmV3KEBudW1iZXIgLSBjb252ZXJ0KG90aGVyLCBAdHlwZSksIEB0eXBlKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tvdGhlci50eXBlfSBpc24ndCBjb21wYXRpYmxlIHdpdGggI3tAdHlwZX1cIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICByZXR1cm4gVW5pdC5uZXcoQG51bWJlciAqIG90aGVyLCBAdHlwZSkgdW5sZXNzIFVuaXQgPT09IG90aGVyXG5cbiAgICBpZiBAdHlwZSA9PSBvdGhlci50eXBlXG4gICAgICBVbml0Lm5ldyhAbnVtYmVyICogb3RoZXIubnVtYmVyLCBAdHlwZSlcbiAgICBlbHNpZiBjb21wYXRpYmxlPyhzZWxmKSBhbmQgY29tcGF0aWJsZT8ob3RoZXIpXG4gICAgICBVbml0Lm5ldyhAbnVtYmVyICogY29udmVydChvdGhlciwgQHR5cGUpLCBAdHlwZSlcbiAgICBlbHNlXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7b3RoZXIudHlwZX0gaXNuJ3QgY29tcGF0aWJsZSB3aXRoICN7QHR5cGV9XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgcmV0dXJuIFVuaXQubmV3KEBudW1iZXIgLyBvdGhlciwgQHR5cGUpIHVubGVzcyBVbml0ID09PSBvdGhlclxuXG4gICAgaWYgQHR5cGUgPT0gb3RoZXIudHlwZVxuICAgICAgVW5pdC5uZXcoQG51bWJlciAvIG90aGVyLm51bWJlciwgQHR5cGUpXG4gICAgZWxzaWYgY29tcGF0aWJsZT8oc2VsZikgYW5kIGNvbXBhdGlibGU/KG90aGVyKVxuICAgICAgVW5pdC5uZXcoQG51bWJlciAvIGNvbnZlcnQob3RoZXIsIEB0eXBlKSwgQHR5cGUpXG4gICAgZWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCIje290aGVyLnR5cGV9IGlzbid0IGNvbXBhdGlibGUgd2l0aCAje0B0eXBlfVwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIFVuaXQubmV3KEBudW1iZXIgKiAtMSwgQHR5cGUpXG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIFVuaXQubmV3KEBudW1iZXIsIEB0eXBlKVxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIEBudW1iZXIudG9faVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIEBudW1iZXIudG9fZlxuICBlbmRcblxuICBkZWYgdG9fdVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiNAbnVtYmVyI0B0eXBlXCJcbiAgZW5kXG5cbiAgYWxpYXMgdG9fc3RyIHRvX3NcbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5cbnByaXZhdGVcbiAgZGVmIGNvbXBhdGlibGU/KHVuaXQpXG4gICAgQ09NUEFUSUJMRS5pbmNsdWRlPyh1bml0LnR5cGUpXG4gIGVuZFxuXG4gIGRlZiBjb252ZXJ0KHVuaXQsIHR5cGUpXG4gICAgdmFsdWUgPSB1bml0Lm51bWJlclxuXG4gICAgcmV0dXJuIHZhbHVlIGlmIHVuaXQudHlwZSA9PSB0eXBlXG5cbiAgICBweCA9IGNhc2UgdW5pdC50eXBlXG4gICAgd2hlbiA6aW4gdGhlbiB2YWx1ZSAqIDk2XG4gICAgd2hlbiA6cHQgdGhlbiB2YWx1ZSAqIDQuMCAvIDMuMFxuICAgIHdoZW4gOnBjIHRoZW4gdmFsdWUgLyAxMiAqIDQuMCAvIDMuMFxuICAgIHdoZW4gOm1tIHRoZW4gdmFsdWUgKiAzLjc3OTUzXG4gICAgd2hlbiA6Y20gdGhlbiB2YWx1ZSAqIDEwICogMy43Nzk1M1xuICAgIHdoZW4gOnB4IHRoZW4gdmFsdWVcbiAgICBlbmRcblxuICAgIGNhc2UgdHlwZVxuICAgIHdoZW4gOmluIHRoZW4gcHggLyA5Ni4wXG4gICAgd2hlbiA6cHQgdGhlbiBweCAvIDQuMCAvIDMuMFxuICAgIHdoZW4gOnBjIHRoZW4gcHggKiAxMiAvIDQuMCAvIDMuMFxuICAgIHdoZW4gOm1tIHRoZW4gcHggLyAzLjc3OTUzXG4gICAgd2hlbiA6Y20gdGhlbiBweCAvIDEwIC8gMy43Nzk1M1xuICAgIHdoZW4gOnB4IHRoZW4gcHhcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcblxuY2xhc3MgTnVtZXJpY1xuICBQYWdnaW86OkNTUzo6VW5pdDo6VFlQRVMuZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBQYWdnaW86OkNTUzo6VW5pdC5uZXcoc2VsZiwgbmFtZSlcbiAgICBlbmRcbiAgfVxuXG4gIGRlZiB0b191XG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5bRml4bnVtLCBGbG9hdF0uZWFjaCB7fGtsYXNzfFxuICBrbGFzcy5jbGFzc19ldmFsIHtcbiAgICBhbGlhcyBvbGRfcGVyY2VudCAlXG5cbiAgICBkZWYgJShvdGhlciA9IG5pbClcbiAgICAgIGlmIG90aGVyXG4gICAgICAgIG9sZF9wZXJjZW50KG90aGVyKVxuICAgICAgZWxzZVxuICAgICAgICBQYWdnaW86OkNTUzo6VW5pdC5uZXcoc2VsZiwgOiUpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgfVxufVxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX3VcbiAgICBpZiBtYXRjaGVzID0gbWF0Y2goL14oW1xcZCsuXSspKC4rKT8kLylcbiAgICAgIHZhbHVlID0gbWF0Y2hlc1sxXS50b19mXG5cbiAgICAgIGlmIHVuaXQgPSBtYXRjaGVzWzJdXG4gICAgICAgIHZhbHVlLl9fc2VuZF9fKHVuaXQuZG93bmNhc2UpXG4gICAgICBlbHNlXG4gICAgICAgIHZhbHVlXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAwXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gIGRlZiB0b191XG4gICAgMFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpDU1M+IiwiPGNsYXNzOlVuaXQ+IiwibWFwIiwidG9fcHJvYyIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJudW1iZXIiLCJ0eXBlIiwiQG51bWJlciIsIkB0eXBlIiwiY29lcmNlIiwib3RoZXIiLCI9PSIsIlVuaXQiLCJyZXNwb25kX3RvPyIsInJhaXNlIiwiVHlwZUVycm9yIiwiY2xhc3MiLCJ0b191IiwibmV3IiwiY29udmVydCIsIj09PSIsIiRyZXRfb3JfMSIsImhhc2giLCJlYWNoIiwiVFlQRVMiLCJibG9jayBpbiA8Y2xhc3M6VW5pdD4iLCJuYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6VW5pdD4iLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6VW5pdD4iLCIrIiwiY29tcGF0aWJsZT8iLCJBcmd1bWVudEVycm9yIiwiLSIsIioiLCIvIiwiLUAiLCItMSIsIitAIiwidG9faSIsInRvX2YiLCJ0b19zIiwicHJpdmF0ZSIsInVuaXQiLCJDT01QQVRJQkxFIiwiaW5jbHVkZT8iLCJ2YWx1ZSIsInB4IiwiOTYiLCIxMiIsIjEwIiwiQmFzaWNPYmplY3QiLCI8Y2xhc3M6TnVtZXJpYz4iLCJQYWdnaW86OkNTUzo6VW5pdDo6VFlQRVMiLCJQYWdnaW86OkNTUzo6VW5pdCIsIlBhZ2dpbzo6Q1NTIiwiUGFnZ2lvIiwiYmxvY2sgaW4gPGNsYXNzOk51bWVyaWM+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6TnVtZXJpYz4iLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpOdW1lcmljPiIsIkZpeG51bSIsIkZsb2F0IiwiYmxvY2sgaW4gPHRvcCAocmVxdWlyZWQpPiIsImtsYXNzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8dG9wIChyZXF1aXJlZCk+IiwiY2xhc3NfZXZhbCIsImJsb2NrICgzIGxldmVscykgaW4gPHRvcCAocmVxdWlyZWQpPiIsIiUiLCJvbGRfcGVyY2VudCIsIjxjbGFzczpTdHJpbmc+IiwibWF0Y2hlcyIsIm1hdGNoIiwiW10iLCIxIiwiMiIsIl9fc2VuZF9fIiwiZG93bmNhc2UiLCIwIiwiPGNsYXNzOk5pbENsYXNzPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQVVBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFZEEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRSxpQ0FBcUVDLE1BQXhELENBQUdELElBQUgsRUFBTUEsSUFBTixFQUFTQSxJQUFULEVBQVlBLEtBQVosRUFBZ0JBLElBQWhCLEVBQW1CQSxJQUFuQixFQUFzQkEsTUFBdEIsRUFBMkJBLE1BQTNCLEVBQWdDQSxJQUFoQyxFQUFtQ0EsSUFBbkMsRUFBc0NBLElBQXRDLEVBQXlDQSxJQUF6QyxFQUE0Q0EsSUFBNUMsRUFBK0NBLElBQS9DLEVBQWtEQSxHQUFsRCxFQUFvREEsS0FBcEQsQ0FBd0RDLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sUUFBREMsU0FBQUEsQ0FBQUEsQ0FBTEQsQ0FBckU7UUFDQSxzQ0FBa0NBLE1BQXJCLENBQUdELElBQUgsRUFBTUEsSUFBTixFQUFTQSxJQUFULEVBQVlBLElBQVosRUFBZUEsSUFB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T0FBQWpFLElBQUFrRSxhQUFBQSxDQUFZMUQsS0FBWjBEO1FBREY7VUFHRUQsT0FBQWIsSUFBQUMsSUFBQUMsWUFBQUQsUUFBQUQsU0FBaUJwQyxLQUFBQSxDQUFLaEIsSUFBdEIsRUFBNEIsR0FBWGdCO1FBSG5CO01BREZpRCxDQUFBQSxJQUFBQSxFQUhGSCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBS0MsRUFEUEgsQ0FBQUEsR0FBQUEscUJBQUFBLENBQWV2QztFQWNmOEM7RUFBQUE7OztJQUNFQSxPQUFBcEQsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdxRCxDQUFBQSxVQUFVcEUsSUFBQXFFLE9BQUFBLENBQU0sa0JBQU5BLENBQVZELENBQUgsQ0FBQTs7UUFDRXhCLFFBQVF3QixPQUFPRSxPQUFBQSxDQUFDQyxDQUFERCxDQUFHaEMsTUFBQUEsQ0FBQUE7UUFFbEIsSUFBQSxRQUFHRyxDQUFBQSxPQUFPMkIsT0FBT0UsT0FBQUEsQ0FBQ0UsQ0FBREYsQ0FBZDdCLENBQUgsQ0FBQTtVQUNFMUIsT0FBQTZCLEtBQUs2QixVQUFBQSxDQUFVaEMsSUFBSWlDLFVBQUFBLENBQUFBLENBQWREO1FBRFA7VUFHRTFELE9BQUE2QjtRQUhGO01BSEY7UUFTRTdCLE9BQUE0RDtNQVRGO0lBREY1RCxDQUFBQSxHQUFBQTtFQURGb0QsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFnQkF6RSxPQUFBa0Y7RUFBQUE7OztJQUNFQSxPQUFBN0Qsb0JBQUFBLFlBQ0U0RCxDQURGNUQsQ0FBQUEsR0FBQUE7RUFERjZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBaE5BbEY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwNzUzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9mb3JtLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBGb3JtIDwgRWxlbWVudFxuICBkZWZfc2VsZWN0b3IgXCJmb3JtXCJcblxuICAjIENhcHR1cmUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmb3JtIHRvIGEgbmV3IHtGb3JtRGF0YX0gb2JqZWN0LFxuICAjXG4gICMgQHJldHVybiBbRm9ybURhdGFdXG4gIGRlZiBmb3JtX2RhdGFcbiAgICBGb3JtRGF0YS5jcmVhdGUoc2VsZilcbiAgZW5kXG5cbiAgIyBTdWJtaXQgYSBmb3JtLiBUaGlzIHdpbGwgZmlyZSBhIHN1Ym1pdCBldmVudC5cbiAgZGVmIHN1Ym1pdFxuICAgIGAjQG5hdGl2ZS5zdWJtaXQoKWBcbiAgZW5kXG5cbiAgIyBSZXNldCBhIGZvcm0uIFRoaXMgd2lsbCBmaXJlIGEgcmVzZXQgZXZlbnQuXG4gIGRlZiByZXNldFxuICAgIGAjQG5hdGl2ZS5yZXNldCgpYFxuICBlbmRcblxuICBhbGlhc19uYXRpdmUgOmFjdGlvblxuICBhbGlhc19uYXRpdmUgOmFjdGlvbj1cbiAgYWxpYXNfbmF0aXZlIDptZXRob2RcbiAgYWxpYXNfbmF0aXZlIDptZXRob2Q9XG4gIGFsaWFzX25hdGl2ZSA6dGFyZ2V0XG4gIGFsaWFzX25hdGl2ZSA6dGFyZ2V0PVxuICBhbGlhc19uYXRpdmUgOmVuY29kaW5nXG4gIGFsaWFzX25hdGl2ZSA6ZW5jb2Rpbmc9XG5cbiAgIyBSZXR1cm4gYSBOb2RlU2V0IGNvbnRhaW5pbmcgYWxsIGZvcm0gY29udHJvbHMgYmVsb25naW5nIHRvIHRoaXMgZm9ybSBlbGVtZW50LlxuICBkZWYgY29udHJvbHNcbiAgICBOb2RlU2V0W05hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5lbGVtZW50c2ApXVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6Rm9ybT4iLCJzZWxmIiwiZGVmX3NlbGVjdG9yIiwiZm9ybV9kYXRhIiwiRm9ybURhdGEiLCJjcmVhdGUiLCJzdWJtaXQiLCJAbmF0aXZlIiwicmVzZXQiLCJhbGlhc19uYXRpdmUiLCJjb250cm9scyIsIk5vZGVTZXQiLCJbXSIsIk5hdGl2ZTo6QXJyYXkiLCJOYXRpdmUiLCJuZXciLCJFbGVtZW50IiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUU1QkEsT0FBQUM7UUFBQUE7O1VBQUFBOztBQUFBQTs7VUFDRUMsSUFBQUMsY0FBQUEsQ0FBYUYsTUFBYkU7O0FBS0FDLFVBQUFBLHlCQUFBQSxxQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFDLGNBQVFDLFFBQUFBLENBQVFKLElBQVJJO1VBRFZGLENBQUFBLEdBQUFBOztBQUtBRyxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFQyxjQUFPRDtVQURYQSxDQUFBQSxHQUFBQTs7QUFLQUUsVUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0M7VUFEWEEsQ0FBQUEsR0FBQUE7VUFJQVAsSUFBQVEsY0FBQUEsQ0FBYSxRQUFiQTtVQUNBUixJQUFBUSxjQUFBQSxDQUFhLFNBQWJBO1VBQ0FSLElBQUFRLGNBQUFBLENBQWEsUUFBYkE7VUFDQVIsSUFBQVEsY0FBQUEsQ0FBYSxTQUFiQTtVQUNBUixJQUFBUSxjQUFBQSxDQUFhLFFBQWJBO1VBQ0FSLElBQUFRLGNBQUFBLENBQWEsU0FBYkE7VUFDQVIsSUFBQVEsY0FBQUEsQ0FBYSxVQUFiQTtVQUNBUixJQUFBUSxjQUFBQSxDQUFhLFdBQWJBO1VBR0FULE9BQUFVLHdCQUFBQSxvQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFDLGFBQU9DLE9BQUFBLENBQUNDLElBQUFDLFlBQUFELFVBQWFFLEtBQUFBLENBQU9SLGNBQU9HLFNBQWRLLENBQWRIO1VBRFRGLENBQUFBLEdBQUFBO1FBOUJGVixHQUFBQSxXQUFBQSxFQUFhZ0IsYUFBYmhCO01BRjRCRCxHQUFBQSxXQUFBQSxFQUFnQmtCLFVBQWhCbEI7SUFBWkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MDgxNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9jc3MvZm9udC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgQ1NTIDwgQmFzaWNPYmplY3RcblxuY2xhc3MgRm9udCA8IEJhc2ljT2JqZWN0XG4gIGF0dHJfcmVhZGVyIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUobmFtZSlcbiAgICBAbmFtZSAgICAgICA9IG5hbWVcbiAgICBAZGVmaW5pdGlvbiA9IERlZmluaXRpb24ubmV3XG5cbiAgICBmb250IGZhbWlseTogbmFtZVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcoKmFyZ3MsICZibG9jaylcbiAgICBAZGVmaW5pdGlvbi5fX3NlbmRfXygqYXJncywgJmJsb2NrKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpDU1M+IiwiPGNsYXNzOkZvbnQ+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIm5hbWUiLCJAbmFtZSIsIkBkZWZpbml0aW9uIiwiRGVmaW5pdGlvbiIsIm5ldyIsImZvbnQiLCJtZXRob2RfbWlzc2luZyIsIl9fc2VuZF9fIiwiYXJncyIsImJsb2NrIiwidG9fcHJvYyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWRBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLGFBQUFBLENBQVksTUFBWkE7O0FBRUFDLFFBQUFBLDBCQUFBQSxzQkFBZUMsSUFBZkQ7QUFBQUEsVUFBQUE7OztVQUNFRSxZQUFjRDtVQUNkRSxrQkFBY0MsZ0JBQVVDLEtBQUFBLENBQUFBO1VBRXhCTCxPQUFBRixJQUFBUSxNQUFBQSxDQUFLLG9CQUFBLFVBQVFMLElBQVIsRUFBTEs7UUFKRk4sQ0FBQUEsR0FBQUE7UUFPQUgsT0FBQVUsOEJBQUFBLDBCQXRCRixFQXNCRUE7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUF0QkY7VUFzQnFCO1VBQ2pCQSxPQUFXQyxNQUFYTCxlQUFXSyxZQUFBQSxFQUFVLE1BQUNDLElBQUQsQ0FBVkQsRUFBa0JFLEtBQURDLFNBQUFBLENBQUFBLENBQWpCSDtRQURiRCxDQUFBQSxJQUFBQTtNQVZGVixHQUFBQSxXQUFBQSxFQUFhZSxpQkFBYmY7SUFGY0QsR0FBQUEsV0FBQUEsRUFBWWdCLGlCQUFaaEI7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwODYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9pbWcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEltZyA8IHNlbGZcbiAgeyBzcmM6IDpzcmMsXG4gICAgdXJsOiA6c3JjLFxuXG4gICAgYWx0OiAgICAgICAgIDphbHQsXG4gICAgZGVzY3JpcHRpb246IDphbHQsXG5cbiAgICBoZWlnaHQ6IDpoZWlnaHQsXG4gICAgd2lkdGg6ICA6d2lkdGgsXG5cbiAgICBtYXA6IDp1c2VtYXAsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlLnRvX3NcbiAgICBlbmRcbiAgfVxuXG4gIGRlZmhlbHBlciA6bWFwISBkb1xuICAgIEBhdHRyaWJ1dGVzWzppc21hcF0gPSB0cnVlXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6SW1nPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6SW1nPiIsIm5hbWUiLCJhdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpJbWc+IiwiZGVmaGVscGVyIiwic2VsZiIsInZhbHVlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6SW1nPiIsIltdPSIsInRvX3MiLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQVdHQyxNQVZELHdFQUFBLE9BQU8sS0FBUCxFQUFBLE9BQ08sS0FEUCxFQUFBLE9BR2UsS0FIZixFQUFBLGVBSWUsS0FKZixFQUFBLFVBTVUsUUFOVixFQUFBLFNBT1UsT0FQVixFQUFBLE9BU08sUUFUUCxFQVVDQSxRQUFBQSxFQUFBQSxFQUFBQSxFQVZEQyxnQkFVU0MsSUFBRCxFQUFPQyxTQVZmRixFQUFBRzs7O1lBVVM7WUFBTTtZQUNiQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVSCxJQUFWRyxDQUFBQSxFQUFBRCxhQUFtQkcsS0FBbkJILEVBQUFJO0FBQUFBOzs7Y0FBbUI7Y0FDakJBLE9BQVdDLE1BQUFBLENBQUNQLElBQVosRUFBb0JLLEtBQUtHLE1BQUFBLENBQUFBLENBQWRELENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiTCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUMsRUFYRkosQ0FBQUEsR0FBQUEscUJBQUFBLENBVUNEO1VBTURELE9BQUFNLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVUsTUFBVkEsQ0FBQUEsRUFBQUosZ0JBQUFBLEVBQUFHO0FBQUFBOztZQUNFQSxPQUFXSyxNQUFBQSxDQUFDLE9BQVosRUFBc0IsSUFBWEEsQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsa0JBRGJSLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBSTtRQWpCRk4sR0FBQUEsV0FBQUEsRUFBWU8sSUFBWlA7TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCYyxpQkFBaEJkO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhZSxpQkFBYmY7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwOTA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2Nzcy9hbmltYXRpb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIENTUyA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEFuaW1hdGlvbiA8IEJhc2ljT2JqZWN0XG4gIGNsYXNzIFN0ZXAgPCBCYXNpY09iamVjdFxuICAgIGF0dHJfcmVhZGVyIDp2YWx1ZVxuXG4gICAgZGVmIGluaXRpYWxpemUodmFsdWUpXG4gICAgICBAdmFsdWUgICAgICA9IHZhbHVlXG4gICAgICBAZGVmaW5pdGlvbiA9IERlZmluaXRpb24ubmV3XG4gICAgZW5kXG5cbiAgICBkZWYgbWV0aG9kX21pc3NpbmcoKmFyZ3MsICZibG9jaylcbiAgICAgIEBkZWZpbml0aW9uLl9fc2VuZF9fKCphcmdzLCAmYmxvY2spXG4gICAgZW5kXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpuYW1lLCA6c3RlcHNcblxuICBkZWYgaW5pdGlhbGl6ZShuYW1lKVxuICAgIEBuYW1lICA9IG5hbWVcbiAgICBAc3RlcHMgPSBbXVxuICBlbmRcblxuICBkZWYgc3RlcCh2YWx1ZSwgJmJsb2NrKVxuICAgIEBzdGVwcyA8PCBTdGVwLm5ldyh2YWx1ZSlcbiAgICBibG9jay5jYWxsXG4gIGVuZFxuXG4gIGRlZiBmcm9tKHZhbHVlLCAmYmxvY2spXG4gICAgQHN0ZXBzIDw8IFN0ZXAubmV3KDAuJSlcbiAgICBibG9jay5jYWxsXG4gIGVuZFxuXG4gIGRlZiB0byh2YWx1ZSwgJmJsb2NrKVxuICAgIEBzdGVwcyA8PCBTdGVwLm5ldygxMDAuJSlcbiAgICBibG9jay5jYWxsXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZygqYXJncywgJmJsb2NrKVxuICAgIEBzdGVwcy5sYXN0Ll9fc2VuZF9fKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkNTUz4iLCI8Y2xhc3M6QW5pbWF0aW9uPiIsIjxjbGFzczpTdGVwPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJ2YWx1ZSIsIkB2YWx1ZSIsIkBkZWZpbml0aW9uIiwiRGVmaW5pdGlvbiIsIm5ldyIsIm1ldGhvZF9taXNzaW5nIiwiX19zZW5kX18iLCJhcmdzIiwiYmxvY2siLCJ0b19wcm9jIiwiQmFzaWNPYmplY3QiLCJuYW1lIiwiQG5hbWUiLCJAc3RlcHMiLCJzdGVwIiwiPDwiLCJTdGVwIiwiY2FsbCIsImZyb20iLCIwIiwiJSIsInRvIiwiMTAwIiwibGFzdCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVkQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxhQUFBQSxDQUFZLE9BQVpBOztBQUVBQyxVQUFBQSwwQkFBQUEsc0JBQWVDLEtBQWZEO0FBQUFBLFlBQUFBOzs7WUFDRUUsYUFBY0Q7WUFDZEQsT0FBQUcsQ0FBQUEsa0JBQWNDLGdCQUFVQyxLQUFBQSxDQUFBQSxDQUF4QkY7VUFGRkgsQ0FBQUEsR0FBQUE7VUFLQUgsT0FBQVMsOEJBQUFBLDBCQXJCSixFQXFCSUE7QUFBQUEsWUFBQUE7O1lBQUFBOzs7WUFyQko7WUFxQnVCO1lBQ2pCQSxPQUFXQyxNQUFYSixlQUFXSSxZQUFBQSxFQUFVLE1BQUNDLElBQUQsQ0FBVkQsRUFBa0JFLEtBQURDLFNBQUFBLENBQUFBLENBQWpCSDtVQURiRCxDQUFBQSxJQUFBQTtRQVJGVCxHQUFBQSxXQUFBQSxFQUFhYyxpQkFBYmQ7UUFhQUMsSUFBQUMsYUFBQUEsQ0FBWSxNQUFaLEVBQW1CLE9BQW5CQTs7QUFFQUMsUUFBQUEsMEJBQUFBLHNCQUFlWSxJQUFmWjtBQUFBQSxVQUFBQTs7O1VBQ0VhLFlBQVNEO1VBQ1RaLE9BQUFjLENBQUFBLGFBQVMsRUFBVEE7UUFGRmQsQ0FBQUEsR0FBQUE7O0FBS0FlLFFBQUFBLG9CQUFBQSxnQkFBU2QsS0FBVGM7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFDRUQsVUFBT0UsT0FBQUEsQ0FBR0MsVUFBSVosS0FBQUEsQ0FBS0osS0FBTEksQ0FBUFc7VUFDUEQsT0FBQU4sS0FBS1MsTUFBQUEsQ0FBQUE7UUFGUEgsQ0FBQUEsR0FBQUE7O0FBS0FJLFFBQUFBLG9CQUFBQSxnQkFBU2xCLEtBQVRrQjtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQUNFTCxVQUFPRSxPQUFBQSxDQUFHQyxVQUFJWixLQUFBQSxDQUFLZSxDQUFBQSxDQUFBQSxDQUFDQyxNQUFBQSxDQUFBQSxDQUFOaEIsQ0FBUFc7VUFDUEcsT0FBQVYsS0FBS1MsTUFBQUEsQ0FBQUE7UUFGUEMsQ0FBQUEsR0FBQUE7O0FBS0FHLFFBQUFBLGtCQUFBQSxjQUFPckIsS0FBUHFCO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBQ0VSLFVBQU9FLE9BQUFBLENBQUdDLFVBQUlaLEtBQUFBLENBQUtrQixDQUFBQSxHQUFBQSxDQUFHRixNQUFBQSxDQUFBQSxDQUFSaEIsQ0FBUFc7VUFDUE0sT0FBQWIsS0FBS1MsTUFBQUEsQ0FBQUE7UUFGUEksQ0FBQUEsR0FBQUE7UUFLQTFCLE9BQUFVLDhCQUFBQSwwQkFoREYsRUFnREVBO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBaERGO1VBZ0RxQjtVQUNqQkEsT0FBV0MsTUFBWE8sVUFBTVUsTUFBQUEsQ0FBQUEsQ0FBS2pCLFlBQUFBLEVBQVUsTUFBQ0MsSUFBRCxDQUFWRCxFQUFrQkUsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBakJIO1FBRGJELENBQUFBLElBQUFBO01BcENGVixHQUFBQSxXQUFBQSxFQUFrQmUsaUJBQWxCZjtJQUZjRCxHQUFBQSxXQUFBQSxFQUFZZ0IsaUJBQVpoQjtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDEwMTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2lmcmFtZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgSWZyYW1lIDwgRWxlbWVudFxuICBkZWZfc2VsZWN0b3IgXCJpZnJhbWVcIlxuXG4gICMgQCFhdHRyaWJ1dGUgc3JjXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgVVJMIG9mIHRoZSBwYWdlIHRvIGVtYmVkXG4gIGFsaWFzX25hdGl2ZSA6c3JjXG4gIGFsaWFzX25hdGl2ZSA6c3JjPVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGNvbnRlbnRfd2luZG93XG4gICMgQHJldHVybiBbV2luZG93XSB3aW5kb3cgb2YgY29udGVudCBvZiB0aGlzIGlmcmFtZVxuICBkZWYgY29udGVudF93aW5kb3dcbiAgICBCcm93c2VyOjpXaW5kb3cubmV3KGAjQG5hdGl2ZS5jb250ZW50V2luZG93YClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gY29udGVudF9kb2N1bWVudFxuICAjIEByZXR1cm4gW0RvY3VtZW50XSBkb2N1bWVudCBvZiBjb250ZW50IG9mIHRoaXMgaWZyYW1lIFxuICBkZWYgY29udGVudF9kb2N1bWVudFxuICAgIERPTShgI0BuYXRpdmUuY29udGVudERvY3VtZW50IHx8ICNAbmF0aXZlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnRgKVxuICBlbmRcblxuICAjIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBpZnJhbWUgY29udGVudCdzIHdpbmRvdy5cbiAgI1xuICAjIEBwYXJhbSBtZXNzYWdlIFtTdHJpbmddIHRoZSBtZXNzYWdlXG4gICMgQHBhcmFtIG9wdGlvbnMgW0hhc2hdIG9wdGlvbmFsIGB0bzogdGFyZ2V0YFxuICBkZWYgc2VuZChtZXNzYWdlLCBvcHRpb25zPXt9KVxuICAgIGNvbnRlbnRfd2luZG93LnNlbmQobWVzc2FnZSwgb3B0aW9ucylcbiAgZW5kXG5lbmRcblxuIyBPYmplY3QgaXMgbm90IGFuIGlmcmFtZSwgYnV0IGFjdHMgdGhlIHNhbWUuXG5jbGFzcyBPYmplY3QgPCBJZnJhbWVcbiAgZGVmX3NlbGVjdG9yIFwib2JqZWN0XCJcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6SWZyYW1lPiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJhbGlhc19uYXRpdmUiLCJjb250ZW50X3dpbmRvdyIsIkJyb3dzZXI6OldpbmRvdyIsIkJyb3dzZXIiLCJuZXciLCJAbmF0aXZlIiwiY29udGVudF9kb2N1bWVudCIsIkRPTSIsInNlbmQiLCJtZXNzYWdlIiwib3B0aW9ucyIsIkVsZW1lbnQiLCI8Y2xhc3M6T2JqZWN0PiIsIklmcmFtZSIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBRTVCQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxjQUFBQSxDQUFhRixRQUFiRTtVQUlBRCxJQUFBRSxjQUFBQSxDQUFhLEtBQWJBO1VBQ0FGLElBQUFFLGNBQUFBLENBQWEsTUFBYkE7O0FBSUFDLFVBQUFBLDhCQUFBQSwwQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFDLElBQUFDLGFBQUFELFdBQWVFLEtBQUFBLENBQU9DLGNBQU9KLGNBQWRHO1VBRGpCSCxDQUFBQSxHQUFBQTs7QUFNQUssVUFBQUEsZ0NBQUFBLDRCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQVIsSUFBQVMsS0FBQUEsQ0FBTUYsY0FBT0Msb0JBQXFCRCxjQUFPQyx1QkFBekNDO1VBREZELENBQUFBLEdBQUFBO1VBUUFULE9BQUFXLG9CQUFBQSxnQkFBU0MsT0FBRCxFQUFVQyxPQUFsQkY7QUFBQUEsWUFBQUE7OztZQUFrQiwrQkFBUSxZQUFBO1lBQ3hCQSxPQUFBVixJQUFBRyxnQkFBQUEsQ0FBQUEsQ0FBY08sTUFBQUEsQ0FBTUMsT0FBcEIsRUFBNkJDLE9BQWZGO1VBRGhCQSxDQUFBQSxJQUFBQTtRQXhCRlgsR0FBQUEsV0FBQUEsRUFBZWMsYUFBZmQ7UUE4QkFELE9BQUFnQjtRQUFBQTs7O1VBQ0VBLE9BQUFkLElBQUFDLGNBQUFBLENBQWFhLFFBQWJiO1FBREZhLEdBQUFBLFdBQUFBLEVBQWVDLFlBQWZEO01BaEM0QmhCLEdBQUFBLFdBQUFBLEVBQWdCa0IsVUFBaEJsQjtJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxMDcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC90ZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgVGQgPCBzZWxmXG4gIGRlZmhlbHBlciA6Y29sdW1ucyBkbyB8dmFsdWV8XG4gICAgQGF0dHJpYnV0ZXNbOmNvbHNwYW5dID0gdmFsdWUudG9fc1xuICBlbmRcblxuICBkZWZoZWxwZXIgOnJvd3MgZG8gfHZhbHVlfFxuICAgIEBhdHRyaWJ1dGVzWzpyb3dzcGFuXSA9IHZhbHVlLnRvX3NcbiAgZW5kXG5cbiAgZGVmaGVscGVyIDpoZWFkZXJzIGRvIHwqYXJnc3xcbiAgICBAYXR0cmlidXRlc1s6aGVhZGVyc10gPSBhcmdzLmpvaW4oJyAnKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOlRkPiIsImRlZmhlbHBlciIsInNlbGYiLCJibG9jayBpbiA8Y2xhc3M6VGQ+IiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpUZD4iLCJbXT0iLCJ0b19zIiwiQGF0dHJpYnV0ZXMiLCJhcmdzIiwiam9pbiIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEseUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQUNFQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVLFNBQVZBLENBQUFBLEVBQUFFLGVBQXVCQyxLQUF2QkQsRUFBQUU7QUFBQUE7OztZQUF1QjtZQUNyQkEsT0FBV0MsTUFBQUEsQ0FBQyxTQUFaLEVBQXdCRixLQUFLRyxNQUFBQSxDQUFBQSxDQUFsQkQsQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJILENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRjtVQUlBQSxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVLE1BQVZBLENBQUFBLEVBQUFFLGVBQW9CQyxLQUFwQkQsRUFBQUU7QUFBQUE7OztZQUFvQjtZQUNsQkEsT0FBV0MsTUFBQUEsQ0FBQyxTQUFaLEVBQXdCRixLQUFLRyxNQUFBQSxDQUFBQSxDQUFsQkQsQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJILENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRjtVQUlBRCxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVLFNBQVZBLENBQUFBLEVBQUFFLGVBckJGLEVBcUJFQSxFQUFBRTtBQUFBQTs7O1lBckJGO1lBcUJ5QjtZQUNyQkEsT0FBV0MsTUFBQUEsQ0FBQyxTQUFaLEVBQXdCRyxJQUFJQyxNQUFBQSxDQUFNTCxHQUFOSyxDQUFqQkosQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJILENBQUFBLEdBQUFBLHNCQUFBQSxDQUFBRjtRQVRGRCxHQUFBQSxXQUFBQSxFQUFXRSxJQUFYRjtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JZLGlCQUFoQlo7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFhLGlCQUFiYjtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDExMjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L29iamVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgT2JqZWN0IDwgc2VsZlxuICB7IHR5cGU6IDp0eXBlLFxuICAgIGRhdGE6IDpkYXRhLFxuICAgIG5hbWU6IDpuYW1lLFxuXG4gICAgaGVpZ2h0OiA6aGVpZ2h0LFxuICAgIHdpZHRoOiAgOndpZHRoXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlXG4gICAgZW5kXG4gIH1cbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOk9iamVjdD4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOk9iamVjdD4iLCJuYW1lIiwiYXR0cmlidXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6T2JqZWN0PiIsImRlZmhlbHBlciIsInNlbGYiLCJ2YWx1ZSIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOk9iamVjdD4iLCJbXT0iLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7O1VBQ0VBLE9BTUNDLE1BTkQscURBQUEsUUFBUSxNQUFSLEVBQUEsUUFDUSxNQURSLEVBQUEsUUFFUSxNQUZSLEVBQUEsVUFJVSxRQUpWLEVBQUEsU0FLVSxPQUxWLEVBTUNBLFFBQUFBLEVBQUFBLEVBQUFBLEVBTkRDLG1CQU1TQyxJQUFELEVBQU9DLFNBTmZGLEVBQUFHOzs7WUFNUztZQUFNO1lBQ2JBLE9BQUFDLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVVILElBQVZHLENBQUFBLEVBQUFELGFBQW1CRyxLQUFuQkgsRUFBQUk7QUFBQUE7OztjQUFtQjtjQUNqQkEsT0FBV0MsTUFBQUEsQ0FBQ1AsSUFBWixFQUFvQkssS0FBVEUsQ0FBQUEsRUFBQUEsTUFBWEMsZUFBV0QsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJMLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBQyxFQVBGSixDQUFBQSxHQUFBQSxxQkFBQUEsQ0FNQ0Q7UUFQSEQsR0FBQUEsV0FBQUEsRUFBZU8sSUFBZlA7TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCYSxpQkFBaEJiO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhYyxpQkFBYmQ7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxMTYwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2Nzcy9kZWZpbml0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBDU1MgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBEZWZpbml0aW9uIDwgQmFzaWNPYmplY3RcbiAgU3R5bGUgPSA6OlN0cnVjdC5uZXcoOm5hbWUsIDp2YWx1ZSwgOmltcG9ydGFudClcblxuICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgQHN0eWxlID0gW11cblxuICAgIGlmIGJsb2NrLmFyaXR5ID09IDBcbiAgICAgIGluc3RhbmNlX2V4ZWMoJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIGJsb2NrLmNhbGwoc2VsZilcbiAgICBlbmQgaWYgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIEBzdHlsZS5lbXB0eT9cbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIEBzdHlsZS5lYWNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGdyYWRpZW50KCphcmdzKVxuICAgIEdyYWRpZW50Lm5ldygqYXJncylcbiAgZW5kXG5cbiAgZGVmIHVybCh2YWx1ZSlcbiAgICBcInVybCgje3ZhbHVlLnRvX3MuaW5zcGVjdH0pXCJcbiAgZW5kXG5cbiAgJXdbYmx1ciBicmlnaHRuZXNzIHJvdGF0ZSBjb250cmFzdCBncmF5c2NhbGUgaW52ZXJ0IG9wYWNpdHkgc2F0dXJhdGUgc2VwaWFdLmVhY2gge3xuYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBcIiN7bmFtZX0oI3t2YWx1ZX0pXCJcbiAgICBlbmRcbiAgfVxuXG4gIGRlZiByZ2IociwgZywgYilcbiAgICBcInJnYigje3J9LCAje2d9LCAje2J9LCAje2F9KVwiXG4gIGVuZFxuXG4gIGRlZiByZ2JhKHIsIGcsIGIsIGEpXG4gICAgXCJyZ2JhKCN7cn0sICN7Z30sICN7Yn0sICN7YX0pXCJcbiAgZW5kXG5cbiAgJXdbc2NhbGUgc2tldyB0cmFuc2xhdGVdLmVhY2gge3xuYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkbyB8YSwgYiA9IG5pbHxcbiAgICAgIGlmIGJcbiAgICAgICAgXCIje25hbWV9KCN7YX0sICN7Yn0pXCJcbiAgICAgIGVsc2VcbiAgICAgICAgXCIje25hbWV9KCN7YX0pXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuICB9XG5cbiAgJXdbdHJhbnNsYXRlWCB0cmFuc2xhdGVZIHRyYW5zbGF0ZVogcm90YXRlWCByb3RhdGVZIHJvdGF0ZVogc2tld1ggc2tld1kgc2NhbGVYIHNjYWxlWV0uZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIFwiI3tuYW1lfSgje3ZhbHVlfSlcIlxuICAgIGVuZFxuICB9XG5cbiAgZGVmIGJhY2tncm91bmQoKmFyZ3MpXG4gICAgaWYgR3JhZGllbnQgPT09IGFyZ3MuZmlyc3RcbiAgICAgIGlmIGFyZ3MubGVuZ3RoID4gMVxuICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIm11bHRpcGxlIGdyYWRpZW50cyBub3QgaW1wbGVtZW50ZWQgeWV0XCJcbiAgICAgIGVuZFxuXG4gICAgICBhcmdzLmZpcnN0LmVhY2gge3xzfFxuICAgICAgICBzdHlsZSBzLm5hbWUgfHwgJ2JhY2tncm91bmQtaW1hZ2UnLCBzLnZhbHVlXG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaWYgOjpIYXNoID09PSBhcmdzLmZpcnN0XG4gICAgICAgIGFyZ3MuZmlyc3QuZWFjaCB7fHN1YiwgdmFsdWV8XG4gICAgICAgICAgc3R5bGUgXCJiYWNrZ3JvdW5kLSN7c3VifVwiLCB2YWx1ZVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0eWxlIDpiYWNrZ3JvdW5kLCBhcmdzXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGJvcmRlcigqYXJncylcbiAgICBpZiA6Okhhc2ggPT09IGFyZ3MuZmlyc3RcbiAgICAgIGlmIGFyZ3MubGVuZ3RoID09IDFcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3MuZmlyc3RcbiAgICAgIGVuZFxuXG4gICAgICBvcHRpb25zLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgICAgY2FzZSBuYW1lXG4gICAgICAgIHdoZW4gOnRvcCwgOmJvdHRvbSwgOmxlZnQsIDpyaWdodFxuICAgICAgICAgIGlmIDo6SGFzaCA9PT0gdmFsdWVcbiAgICAgICAgICAgIHZhbHVlLmVhY2gge3xuLCB2fFxuICAgICAgICAgICAgICBzdHlsZSBcImJvcmRlci0je25hbWV9LSN7bn1cIiwgdlxuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0eWxlIFwiYm9yZGVyLSN7bmFtZX1cIiwgdmFsdWVcbiAgICAgICAgICBlbmRcblxuICAgICAgICB3aGVuIDpyYWRpdXNcbiAgICAgICAgICBpZiA6Okhhc2ggPT09IHZhbHVlXG4gICAgICAgICAgICB2YWx1ZS5lYWNoIHt8aG9yaXpvbnRhbCwgdmFsdWV8XG4gICAgICAgICAgICAgIHZhbHVlLmVhY2gge3x2ZXJ0aWNhbCwgdmFsdWV8XG4gICAgICAgICAgICAgICAgc3R5bGUgXCItbW96LWJvcmRlci1yYWRpdXMtI3tob3Jpem9udGFsfSN7dmVydGljYWx9XCIsIHZhbHVlXG4gICAgICAgICAgICAgICAgc3R5bGUgXCItd2Via2l0LWJvcmRlci0je2hvcml6b250YWx9LSN7dmVydGljYWx9LXJhZGl1c1wiLCB2YWx1ZVxuICAgICAgICAgICAgICAgIHN0eWxlIFwiYm9yZGVyLSN7aG9yaXpvbnRhbH0tI3t2ZXJ0aWNhbH0tcmFkaXVzXCIsIHZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdHlsZSAnLW1vei1ib3JkZXItcmFkaXVzJywgdmFsdWVcbiAgICAgICAgICAgIHN0eWxlICctd2Via2l0LWJvcmRlci1yYWRpdXMnLCB2YWx1ZVxuICAgICAgICAgICAgc3R5bGUgJ2JvcmRlci1yYWRpdXMnLCB2YWx1ZVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgIHdoZW4gOmNvbG9yXG4gICAgICAgICAgaWYgOjpIYXNoID09PSB2YWx1ZVxuICAgICAgICAgICAgdmFsdWUuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgICAgICAgICBzdHlsZSBcImJvcmRlci0je25hbWV9LWNvbG9yXCIsIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3R5bGUgJ2JvcmRlci1jb2xvcicsIHZhbHVlXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0eWxlIFwiYm9yZGVyLSN7bmFtZX1cIiwgdmFsdWVcbiAgICAgICAgZW5kXG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3R5bGUgOmJvcmRlciwgYXJnc1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYm94KG9wdGlvbnMpXG4gICAgaWYgOjpIYXNoID09PSBvcHRpb25zXG4gICAgICBvcHRpb25zLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgICAgY2FzZSBuYW1lXG4gICAgICAgIHdoZW4gOnNoYWRvd1xuICAgICAgICAgIGlmIDo6QXJyYXkgPT09IHZhbHVlXG4gICAgICAgICAgICBpZiA6OkFycmF5ID09PSB2YWx1ZVswXVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCB7IHx2fCB2LmpvaW4gJyAnIH0uam9pbignLCAnKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4gJyAnXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHN0eWxlICctbW96LWJveC1zaGFkb3cnLCB2YWx1ZVxuICAgICAgICAgIHN0eWxlICctd2Via2l0LWJveC1zaGFkb3cnLCB2YWx1ZVxuICAgICAgICAgIHN0eWxlICdib3gtc2hhZG93JywgdmFsdWVcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgc3R5bGUgXCJib3gtI3tuYW1lfVwiLCB2YWx1ZVxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzdHlsZSA6Ym94LCBvcHRpb25zXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBvcGFjaXR5KHZhbHVlKVxuICAgIHN0eWxlICdvcGFjaXR5JywgdmFsdWVcbiAgICBzdHlsZSAnLW1vei1vcGFjaXR5JywgdmFsdWVcblxuICAgIHN0eWxlICctbXMtZmlsdGVyJywgJVF7XCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT0jeyh2YWx1ZSAqIDEwMCkudG9faX0pXCJ9XG4gICAgc3R5bGUgJ2ZpbHRlcicsIFwiYWxwaGEob3BhY2l0eT0jeyh2YWx1ZSAqIDEwMCkudG9faX0pXCJcbiAgZW5kXG5cbiAgZGVmIGFuaW1hdGlvbigqYXJncylcbiAgICBpZiBIYXNoID09PSBhcmdzLmZpcnN0XG4gICAgICBpZiBhcmdzLmxlbmd0aCA9PSAxXG4gICAgICAgIG9wdGlvbnMgPSBhcmdzLmZpcnN0XG4gICAgICBlbmRcblxuICAgICAgb3B0aW9ucy5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICAgIHN0eWxlIFwiLXdlYmtpdC1hbmltYXRpb24tI3tuYW1lfVwiLCB2YWx1ZVxuICAgICAgICBzdHlsZSBcImFuaW1hdGlvbi0je25hbWV9XCIsIHZhbHVlXG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3R5bGUgJ2FuaW1hdGlvbicsIGFyZ3NcbiAgICAgIHN0eWxlICctd2Via2l0LWFuaW1hdGlvbicsIGFyZ3NcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRyYW5zaXRpb24oKmFyZ3MpXG4gICAgc3R5bGUgJ3RyYW5zaXRpb24nLCBhcmdzXG4gICAgc3R5bGUgJy13ZWJraXQtdHJhbnNpdGlvbicsIGFyZ3NcbiAgICBzdHlsZSAnLW1vei10cmFuc2l0aW9uJywgYXJnc1xuICBlbmRcblxuICBkZWYgdXNlcl9zZWxlY3QoKmFyZ3MpXG4gICAgc3R5bGUgJ3VzZXItc2VsZWN0JywgYXJnc1xuICAgIHN0eWxlICctd2Via2l0LXVzZXItc2VsZWN0JywgYXJnc1xuICAgIHN0eWxlICctbW96LXVzZXItc2VsZWN0JywgYXJnc1xuICAgIHN0eWxlICctbXMtdXNlci1zZWxlY3QnLCBhcmdzXG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm0oKmFyZ3MpXG4gICAgc3R5bGUgJ3RyYW5zZm9ybScsIGFyZ3NcbiAgICBzdHlsZSAnLXdlYmtpdC10cmFuc2Zvcm0nLCBhcmdzXG4gICAgc3R5bGUgJy1tb3otdHJhbnNmb3JtJywgYXJnc1xuICAgIHN0eWxlICctbXMtdHJhbnNmb3JtJywgYXJnc1xuICAgIHN0eWxlICctby10cmFuc2Zvcm0nLCBhcmdzXG4gIGVuZFxuXG4gIGRlZiBmaWx0ZXIoKmFyZ3MpXG4gICAgc3R5bGUgJ2ZpbHRlcicsIGFyZ3NcbiAgICBzdHlsZSAnLXdlYmtpdC1maWx0ZXInLCBhcmdzXG4gICAgc3R5bGUgJy1tb3otZmlsdGVyJywgYXJnc1xuICAgIHN0eWxlICctbXMtZmlsdGVyJywgYXJnc1xuICAgIHN0eWxlICctby1maWx0ZXInLCBhcmdzXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIG5hbWUgPSBuYW1lLnRvX3NcblxuICAgIGlmIG5hbWUuZW5kX3dpdGg/ID8hXG4gICAgICBuYW1lID0gbmFtZVswIC4uIC0yXVxuXG4gICAgICBAaW1wb3J0YW50ID0gdHJ1ZVxuICAgICAgX19zZW5kX18gbmFtZSwgKmFyZ3MsICZibG9ja1xuICAgICAgQGltcG9ydGFudCA9IGZhbHNlXG5cbiAgICAgIHJldHVyblxuICAgIGVuZFxuXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMVxuICAgICAgYXJndW1lbnQgPSBhcmdzLmZpcnN0XG5cbiAgICAgIGlmIDo6SGFzaCA9PT0gYXJndW1lbnRcbiAgICAgICAgYXJndW1lbnQuZWFjaCB7fHN1YiwgdmFsdWV8XG4gICAgICAgICAgc3R5bGUgXCIje25hbWV9LSN7c3VifVwiLCB2YWx1ZVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0eWxlIG5hbWUsIGFyZ3VtZW50XG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdHlsZSBuYW1lLCBhcmdzLmpvaW4oJyAnKVxuICAgIGVuZFxuXG4gICAgQGltcG9ydGFudCA9IGZhbHNlXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzdHlsZShuYW1lLCB2YWx1ZSA9IG5pbCwgaW1wb3J0YW50ID0gQGltcG9ydGFudClcbiAgICBpZiA6OkFycmF5ID09PSB2YWx1ZVxuICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luICcgJ1xuICAgIGVuZFxuXG4gICAgaWYgU3R5bGUgPT09IG5hbWVcbiAgICAgIEBzdHlsZSA8PCBuYW1lXG4gICAgZWxzZVxuICAgICAgQHN0eWxlIDw8IFN0eWxlLm5ldyhuYW1lLCB2YWx1ZSwgaW1wb3J0YW50KVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc3R5bGUhKG5hbWUsIHZhbHVlID0gbmlsKVxuICAgIHN0eWxlKG5hbWUsIHZhbHVlLCB0cnVlKVxuICBlbmRcblxuICBjbGFzcyBHcmFkaWVudFxuICAgICMgVE9ETzogYWxsIG9mIGl0LCBzZXJpb3VzbHlcbiAgICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAgIG9wdGlvbnMgPSA6Okhhc2ggPT09IGFyZ3MubGFzdCA/IGFyZ3MucG9wIDoge31cblxuICAgICAgQHRvICAgPSBvcHRpb25zWzp0b11cbiAgICAgIEBmcm9tID0gb3B0aW9uc1s6ZnJvbV1cblxuICAgICAgaWYgQHRvICYmICFAZnJvbVxuICAgICAgICBAZnJvbSA9IG90aGVyKEB0bylcbiAgICAgIGVsc2lmIEBmcm9tICYmICFAdG9cbiAgICAgICAgQHRvID0gb3RoZXIoQGZyb20pXG4gICAgICBlbmRcblxuICAgICAgQHN0YXJ0ID0gYXJncy5zaGlmdFxuICAgICAgQGVuZCAgID0gYXJncy5zaGlmdFxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2goJmJsb2NrKVxuICAgICAgYmxvY2suY2FsbCBzdHlsZShcIi1tb3otbGluZWFyLWdyYWRpZW50KCNAdG8sICNAc3RhcnQgMCUsICNAZW5kIDEwMCUpXCIpXG5cbiAgICAgIGlmIGhvcml6b250YWw/XG4gICAgICAgIGJsb2NrLmNhbGwgc3R5bGUoXCItd2Via2l0LWdyYWRpZW50KGxpbmVhciwgI0Bmcm9tIHRvcCwgI0B0byB0b3AsIGNvbG9yLXN0b3AoMCUsICNAc3RhcnQpLCBjb2xvci1zdG9wKDEwMCUsICNAZW5kKSlcIilcbiAgICAgIGVsc2VcbiAgICAgICAgYmxvY2suY2FsbCBzdHlsZShcIi13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0ICNAZnJvbSwgbGVmdCAjQHRvLCBjb2xvci1zdG9wKDAlLCAjQHN0YXJ0KSwgY29sb3Itc3RvcCgxMDAlLCAjQGVuZCkpXCIpXG4gICAgICBlbmRcblxuICAgICAgYmxvY2suY2FsbCBzdHlsZShcIi13ZWJraXQtbGluZWFyLWdyYWRpZW50KCNAdG8sICNAc3RhcnQgMCUsICNAZW5kIDEwMCUpXCIpXG4gICAgICBibG9jay5jYWxsIHN0eWxlKFwiLW8tbGluZWFyLWdyYWRpZW50KCNAdG8sICNAc3RhcnQgMCUsICNAZW5kIDEwMCUpXCIpXG4gICAgICBibG9jay5jYWxsIHN0eWxlKFwiLW1zLWxpbmVhci1ncmFkaWVudCgjQHRvLCAjQHN0YXJ0IDAlLCAjQGVuZCAxMDAlKVwiKVxuICAgICAgYmxvY2suY2FsbCBzdHlsZShcImxpbmVhci1ncmFkaWVudCh0byAjQHRvLCAjQHN0YXJ0IDAlLCAjQGVuZCAxMDAlKVwiKVxuICAgIGVuZFxuXG4gICAgZGVmIGhvcml6b250YWw/XG4gICAgICBAdG8gPT0gOmxlZnQgfHwgQHRvID09IDpyaWdodFxuICAgIGVuZFxuXG4gICAgZGVmIHZlcnRpY2FsP1xuICAgICAgQHRvID09IDp0b3AgfHwgQHRvID09IDpib3R0b21cbiAgICBlbmRcblxuICBwcml2YXRlXG4gICAgZGVmIG90aGVyKHNpZGUpXG4gICAgICBjYXNlIHNpZGVcbiAgICAgIHdoZW4gOmxlZnQgICB0aGVuIDpyaWdodFxuICAgICAgd2hlbiA6cmlnaHQgIHRoZW4gOmxlZnRcbiAgICAgIHdoZW4gOnRvcCAgICB0aGVuIDpib3R0b21cbiAgICAgIHdoZW4gOmJvdHRvbSB0aGVuIDp0b3BcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBGSVhNRTogdXNlIGRlZmF1bHQgYXJnc1xuICAgIGRlZiBzdHlsZSgqYXJncylcbiAgICAgIGlmIGFyZ3MubGVuZ3RoID09IDFcbiAgICAgICAgU3R5bGUubmV3KG5pbCwgYXJncy5maXJzdClcbiAgICAgIGVsc2VcbiAgICAgICAgU3R5bGUubmV3KCphcmdzKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkNTUz4iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJTdHJ1Y3QiLCJuZXciLCJpbml0aWFsaXplIiwiQHN0eWxlIiwiYmxvY2siLCJhcml0eSIsIjAiLCJpbnN0YW5jZV9leGVjIiwic2VsZiIsInRvX3Byb2MiLCJjYWxsIiwiZW1wdHk/IiwiZWFjaCIsImdyYWRpZW50IiwiR3JhZGllbnQiLCJhcmdzIiwidXJsIiwidmFsdWUiLCJ0b19zIiwiaW5zcGVjdCIsImJsb2NrIGluIDxjbGFzczpEZWZpbml0aW9uPiIsIm5hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpEZWZpbml0aW9uPiIsImRlZmluZV9tZXRob2QiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpEZWZpbml0aW9uPiIsInJnYiIsInIiLCJnIiwiYiIsImEiLCJyZ2JhIiwiYmFja2dyb3VuZCIsImZpcnN0IiwiPiIsImxlbmd0aCIsIjEiLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJibG9jayBpbiBiYWNrZ3JvdW5kIiwicyIsImJsb2NrICgyIGxldmVscykgaW4gYmFja2dyb3VuZCIsInN0eWxlIiwiJHJldF9vcl8xIiwiSGFzaCIsInN1YiIsImJvcmRlciIsIm9wdGlvbnMiLCJibG9jayBpbiBib3JkZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGJvcmRlciIsIm4iLCJ2IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBib3JkZXIiLCJob3Jpem9udGFsIiwidmVydGljYWwiLCJibG9jayAoNCBsZXZlbHMpIGluIGJvcmRlciIsImJveCIsImJsb2NrIGluIGJveCIsImJsb2NrICgyIGxldmVscykgaW4gYm94IiwiQXJyYXkiLCJbXSIsIm1hcCIsImJsb2NrICgzIGxldmVscykgaW4gYm94Iiwiam9pbiIsIm9wYWNpdHkiLCIqIiwiMTAwIiwidG9faSIsImFuaW1hdGlvbiIsImJsb2NrIGluIGFuaW1hdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gYW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsInVzZXJfc2VsZWN0IiwidHJhbnNmb3JtIiwiZmlsdGVyIiwibWV0aG9kX21pc3NpbmciLCJlbmRfd2l0aD8iLCItMiIsIkBpbXBvcnRhbnQiLCJfX3NlbmRfXyIsImFyZ3VtZW50IiwiYmxvY2sgaW4gbWV0aG9kX21pc3NpbmciLCJibG9jayAoMiBsZXZlbHMpIGluIG1ldGhvZF9taXNzaW5nIiwiaW1wb3J0YW50IiwiU3R5bGUiLCI8PCIsInN0eWxlISIsIjxjbGFzczpHcmFkaWVudD4iLCJsYXN0IiwicG9wIiwiQHRvIiwiQGZyb20iLCJvdGhlciIsIkBzdGFydCIsInNoaWZ0IiwiQGVuZCIsImhvcml6b250YWw/IiwiPT0iLCJ2ZXJ0aWNhbD8iLCJwcml2YXRlIiwic2lkZSIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWRBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0UsaUNBQVFDLGFBQVFDLEtBQUFBLENBQUssTUFBYixFQUFvQixPQUFwQixFQUE0QixXQUFwQkEsQ0FBaEI7O0FBRUFDLFFBQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFDRUMsYUFBUztVQUVULElBQUEsUUFJT0MsS0FKUCxDQUFBO1lBQUEsSUFBQSxNQUFHQSxLQUFLQyxPQUFBQSxDQUFBQSxDQUFSLEVBQWtCQyxDQUFsQixDQUFBO2NBQ0VKLE9BQUFLLE1BQUFDLElBQUFELGlCQUFBQSxFQUFBQSxFQUFBQSxFQUFlSCxLQUFESyxTQUFBQSxDQUFBQSxDQUFkRjtZQURGO2NBR0VMLE9BQUFFLEtBQUtNLE1BQUFBLENBQU1GLElBQU5FO1lBSFA7VUFBQTtZQWxCSlIsT0FBQTtVQWtCSTtRQUhGQSxDQUFBQSxHQUFBQTs7QUFVQVMs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QSxpQkFoVUosRUFnVUlBO0FBQUFBLFlBQUFBOzs7WUFoVUo7WUFnVWM7WUFDUixJQUFBLE1BQUcxQixJQUFJbUIsUUFBQUEsQ0FBQUEsQ0FBUCxFQUFrQkMsQ0FBbEIsQ0FBQTtjQUNFTSxPQUFBMEMsV0FBS2xGLEtBQUFBLENBQUssR0FBVixFQUFlYyxJQUFJaUIsT0FBQUEsQ0FBQUEsQ0FBZC9CO1lBRFA7Y0FHRXdDLE9BQUt4QyxNQUFMa0YsV0FBS2xGLE9BQUFBLEVBQUssTUFBQ2MsSUFBRCxDQUFMZDtZQUhQO1VBREZ3QyxDQUFBQSxJQUFBQTtRQXBERjZDLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO01BaFFGdkYsR0FBQUEsV0FBQUEsRUFBbUJxRyxpQkFBbkJyRztJQUZjRCxHQUFBQSxXQUFBQSxFQUFZc0csaUJBQVp0RztFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDE2NTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L3Bvc2l0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBQb3NpdGlvblxuICBhdHRyX3JlYWRlciA6ZWxlbWVudFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIGluaXRpYWxpemUoZWxlbWVudClcbiAgICBAZWxlbWVudCA9IGVsZW1lbnRcbiAgICBAbmF0aXZlICA9IGVsZW1lbnQudG9fblxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBnZXRcbiAgICBvZmZzZXQgICAgICAgID0gQGVsZW1lbnQub2Zmc2V0XG4gICAgcG9zaXRpb24gICAgICA9IG9mZnNldC5nZXRcbiAgICBwYXJlbnQgICAgICAgID0gb2Zmc2V0LnBhcmVudFxuICAgIHBhcmVudF9vZmZzZXQgPSBCcm93c2VyOjpQb3NpdGlvbi5uZXcoMCwgMClcblxuICAgIGlmIEBlbGVtZW50LnN0eWxlWzpwb3NpdGlvbl0gPT0gOmZpeGVkXG4gICAgICB1bmxlc3MgcGFyZW50ID1+IDpodG1sXG4gICAgICAgIHBhcmVudF9vZmZzZXQgPSBwYXJlbnQub2Zmc2V0XG4gICAgICBlbmRcblxuICAgICAgcGFyZW50X29mZnNldC54ICs9IHBhcmVudC5zdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddLnRvX2lcbiAgICAgIHBhcmVudF9vZmZzZXQueSArPSBwYXJlbnQuc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10udG9faVxuICAgIGVuZFxuXG4gICAgQnJvd3Nlcjo6UG9zaXRpb24ubmV3KFxuICAgICAgcG9zaXRpb24ueCAtIHBhcmVudF9vZmZzZXQueCAtIEBlbGVtZW50LnN0eWxlWydtYXJnaW4tbGVmdCddLnRvX2ksXG4gICAgICBwb3NpdGlvbi55IC0gcGFyZW50X29mZnNldC55IC0gQGVsZW1lbnQuc3R5bGVbJ21hcmdpbi10b3AnXS50b19pKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB4XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IG9uIHRoZSB4IGF4aXNcbiAgZGVmIHhcbiAgICBnZXQueFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB5XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IG9uIHRoZSB5IGF4aXNcbiAgZGVmIHlcbiAgICBnZXQueVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6UG9zaXRpb24+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImVsZW1lbnQiLCJAZWxlbWVudCIsIkBuYXRpdmUiLCJ0b19uIiwiZ2V0Iiwib2Zmc2V0IiwicG9zaXRpb24iLCJwYXJlbnQiLCJwYXJlbnRfb2Zmc2V0IiwiQnJvd3Nlcjo6UG9zaXRpb24iLCJCcm93c2VyIiwibmV3IiwiMCIsInN0eWxlIiwiW10iLCI9fiIsIng9IiwiKyIsIngiLCJ0b19pIiwieT0iLCJ5IiwiLSIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGFBQUFBLENBQVksU0FBWkE7O0FBR0FDLFVBQUFBLDBCQUFBQSxzQkFBZUMsT0FBZkQ7QUFBQUEsWUFBQUE7OztZQUNFRSxlQUFXRDtZQUNYRCxPQUFBRyxDQUFBQSxpQkFBV0YsT0FBT0csTUFBQUEsQ0FBQUEsQ0FBbEJEO1VBRkZILENBQUFBLEdBQUFBOztBQU1BSyxVQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsWUFBQUE7OztZQUNFQyxTQUFnQkosWUFBUUksUUFBQUEsQ0FBQUE7WUFDeEJDLFdBQWdCRCxNQUFNRCxLQUFBQSxDQUFBQTtZQUN0QkcsU0FBZ0JGLE1BQU1FLFFBQUFBLENBQUFBO1lBQ3RCQyxnQkFBZ0JDLElBQUFDLGFBQUFELGFBQWlCRSxLQUFBQSxDQUFLQyxDQUF0QixFQUF5QkEsQ0FBUkQ7WUFFakMsSUFBQSxNQUFHVixZQUFRWSxPQUFBQSxDQUFBQSxDQUFNQyxPQUFBQSxDQUFDLFVBQURBLENBQWpCLEVBQWdDLE9BQWhDLENBQUE7O2NBQ0UsS0FBQSxRQUFPUCxNQUFPUSxPQUFBQSxDQUFHLE1BQUhBLENBQWQsQ0FBQTtnQkFDRVAsZ0JBQWdCRCxNQUFNRixRQUFBQSxDQUFBQTtjQUR4QjtjQUlBRyxhQUFhUSxPQUFBQSxDQUFBQyxTQUFiVCxhQUFhVSxHQUFBQSxDQUFBQSxDQUFBRCxFQUFNVixNQUFNTSxPQUFBQSxDQUFBQSxDQUFNQyxPQUFBQSxDQUFDVixrQkFBRFUsQ0FBb0JLLE1BQUFBLENBQUFBLENBQXRDRixDQUFBRDtjQUNiUixhQUFhWSxPQUFBQSxDQUFBSCxTQUFiVCxhQUFhYSxHQUFBQSxDQUFBQSxDQUFBSixFQUFNVixNQUFNTSxPQUFBQSxDQUFBQSxDQUFNQyxPQUFBQSxDQUFDVixtQkFBRFUsQ0FBcUJLLE1BQUFBLENBQUFBLENBQXZDRixDQUFBRztZQU5mO1lBU0FoQixPQUFBSyxJQUFBQyxhQUFBRCxhQUFpQkUsS0FBQUEsQ0FDY1csVUFBbEJBLFVBQVhoQixRQUFRWSxHQUFBQSxDQUFBQSxDQUFHSSxFQUFFZCxhQUFhVSxHQUFBQSxDQUFBQSxDQUFmSSxDQUFrQkEsRUFBRXJCLFlBQVFZLE9BQUFBLENBQUFBLENBQU1DLE9BQUFBLENBQUNWLGFBQURVLENBQWVLLE1BQUFBLENBQUFBLENBQS9CRyxDQUQvQixFQUUrQkEsVUFBbEJBLFVBQVhoQixRQUFRZSxHQUFBQSxDQUFBQSxDQUFHQyxFQUFFZCxhQUFhYSxHQUFBQSxDQUFBQSxDQUFmQyxDQUFrQkEsRUFBRXJCLFlBQVFZLE9BQUFBLENBQUFBLENBQU1DLE9BQUFBLENBQUNWLFlBQURVLENBQWNLLE1BQUFBLENBQUFBLENBQTlCRyxDQUZkWDtVQWZuQlAsQ0FBQUEsR0FBQUE7O0FBc0JBYyxVQUFBQSxpQkFBQUEsYUFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFyQixJQUFBTyxLQUFBQSxDQUFBQSxDQUFHYyxHQUFBQSxDQUFBQTtVQURMQSxDQUFBQSxHQUFBQTtVQU1BdEIsT0FBQXlCLGlCQUFBQSxhQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQXhCLElBQUFPLEtBQUFBLENBQUFBLENBQUdpQixHQUFBQSxDQUFBQTtVQURMQSxDQUFBQSxHQUFBQTtRQXRDRnpCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO01BRjRCRCxHQUFBQSxXQUFBQSxFQUFnQjRCLFVBQWhCNUI7SUFBWkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MTcyMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvaW5wdXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIElucHV0IDwgc2VsZlxuICB7IHR5cGU6ICAgICAgICAgOnR5cGUsXG4gICAgbmFtZTogICAgICAgICA6bmFtZSxcbiAgICB2YWx1ZTogICAgICAgIDp2YWx1ZSxcbiAgICBzaXplOiAgICAgICAgIDpzaXplLFxuICAgIHBsYWNlX2hvbGRlcjogOnBsYWNlaG9sZGVyLFxuICAgIHJlYWRfb25seTogICAgOnJlYWRvbmx5LFxuICAgIHJlcXVpcmVkOiAgICAgOnJlcXVpcmVkLFxuICAgIGxpbWl0OiAgICAgICAgOm1heGxlbmd0aFxuICB9LmVhY2gge3xuYW1lLCBhdHRyaWJ1dGV8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZVxuICAgIGVuZFxuICB9XG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpJbnB1dD4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOklucHV0PiIsIm5hbWUiLCJhdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpJbnB1dD4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpJbnB1dD4iLCJbXT0iLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsNENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7O1VBQ0VBLE9BUUNDLE1BUkQsNkZBQUEsUUFBZ0IsTUFBaEIsRUFBQSxRQUNnQixNQURoQixFQUFBLFNBRWdCLE9BRmhCLEVBQUEsUUFHZ0IsTUFIaEIsRUFBQSxnQkFJZ0IsYUFKaEIsRUFBQSxhQUtnQixVQUxoQixFQUFBLFlBTWdCLFVBTmhCLEVBQUEsU0FPZ0IsV0FQaEIsRUFRQ0EsUUFBQUEsRUFBQUEsRUFBQUEsRUFSREMsa0JBUVNDLElBQUQsRUFBT0MsU0FSZkYsRUFBQUc7OztZQVFTO1lBQU07WUFDYkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUgsSUFBVkcsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDUCxJQUFaLEVBQW9CSyxLQUFURSxDQUFBQSxFQUFBQSxNQUFYQyxlQUFXRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFDLEVBVEZKLENBQUFBLEdBQUFBLHFCQUFBQSxDQVFDRDtRQVRIRCxHQUFBQSxXQUFBQSxFQUFjTyxJQUFkUDtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JhLGlCQUFoQmI7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFjLGlCQUFiZDtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDE3NjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L2xpbmsucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBMaW5rIDwgc2VsZlxuICB7IGNyb3NzX29yaWdpbjogOmNyb3Nzb3JpZ2luLFxuXG4gICAgaHJlZjogICAgICA6aHJlZixcbiAgICBocmVmX2xhbmc6IDpocmVmbGFuZyxcblxuICAgIG1lZGlhOiA6bWVkaWEsXG4gICAgcmVsOiAgIDpyZWwsXG4gICAgc2l6ZXM6IDpzaXplcyxcbiAgICB0eXBlOiAgOnR5cGUsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlLnRvX3NcbiAgICBlbmRcbiAgfVxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6TGluaz4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOkxpbms+IiwibmFtZSIsImF0dHJpYnV0ZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkxpbms+IiwiZGVmaGVscGVyIiwic2VsZiIsInZhbHVlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6TGluaz4iLCJbXT0iLCJ0b19zIiwiQGF0dHJpYnV0ZXMiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUEwQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUV4Q0EsT0FBQUM7UUFBQUE7OztVQUNFQSxPQVNDQyxNQVRELGdGQUFBLGdCQUFnQixhQUFoQixFQUFBLFFBRWEsTUFGYixFQUFBLGFBR2EsVUFIYixFQUFBLFNBS1MsT0FMVCxFQUFBLE9BTVMsS0FOVCxFQUFBLFNBT1MsT0FQVCxFQUFBLFFBUVMsTUFSVCxFQVNDQSxRQUFBQSxFQUFBQSxFQUFBQSxFQVREQyxpQkFTU0MsSUFBRCxFQUFPQyxTQVRmRixFQUFBRzs7O1lBU1M7WUFBTTtZQUNiQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVSCxJQUFWRyxDQUFBQSxFQUFBRCxhQUFtQkcsS0FBbkJILEVBQUFJO0FBQUFBOzs7Y0FBbUI7Y0FDakJBLE9BQVdDLE1BQUFBLENBQUNQLElBQVosRUFBb0JLLEtBQUtHLE1BQUFBLENBQUFBLENBQWRELENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiTCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUMsRUFWRkosQ0FBQUEsR0FBQUEscUJBQUFBLENBU0NEO1FBVkhELEdBQUFBLFdBQUFBLEVBQWFPLElBQWJQO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQmMsaUJBQWhCZDtJQUExQkQsR0FBQUEsV0FBQUEsRUFBYWUsaUJBQWJmO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MTgwMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvYS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgQSA8IHNlbGZcbiAgeyBocmVmOiA6aHJlZixcbiAgICB1cmw6ICA6aHJlZixcblxuICAgIHJlbDogICAgICA6cmVsLFxuICAgIHJlbGF0aXZlOiA6cmVsLFxuXG4gICAgdGFyZ2V0OiA6dGFyZ2V0LFxuXG4gICAgdHlwZTogOnR5cGUsXG5cbiAgICBsYW5nOiAgICAgOmhyZWZsYW5nLFxuICAgIGxhbmd1YWdlOiA6aHJlZmxhbmcsXG5cbiAgICBtZWRpYTogOm1lZGlhLFxuICB9LmVhY2gge3xuYW1lLCBhdHRyaWJ1dGV8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZS50b19zXG4gICAgZW5kXG4gIH1cblxuICBkZWZoZWxwZXIhIDpkb3dubG9hZFxuICBkZWZoZWxwZXIhIDpwaW5nXG5cbiAgZGVmaGVscGVyIDp0ZXh0IGRvIHxzdHJpbmd8XG4gICAgc2VsZiA8PCBzdHJpbmdcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpBPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6QT4iLCJuYW1lIiwiYXR0cmlidXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6QT4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpBPiIsIltdPSIsInRvX3MiLCJAYXR0cmlidXRlcyIsImRlZmhlbHBlciEiLCJzdHJpbmciLCI8PCIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQWVHQyxNQWRELDJGQUFBLFFBQVEsTUFBUixFQUFBLE9BQ1EsTUFEUixFQUFBLE9BR1ksS0FIWixFQUFBLFlBSVksS0FKWixFQUFBLFVBTVUsUUFOVixFQUFBLFFBUVEsTUFSUixFQUFBLFFBVVksVUFWWixFQUFBLFlBV1ksVUFYWixFQUFBLFNBYVMsT0FiVCxFQWNDQSxRQUFBQSxFQUFBQSxFQUFBQSxFQWREQyxjQWNTQyxJQUFELEVBQU9DLFNBZGZGLEVBQUFHOzs7WUFjUztZQUFNO1lBQ2JBLE9BQUFDLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVVILElBQVZHLENBQUFBLEVBQUFELGFBQW1CRyxLQUFuQkgsRUFBQUk7QUFBQUE7OztjQUFtQjtjQUNqQkEsT0FBV0MsTUFBQUEsQ0FBQ1AsSUFBWixFQUFvQkssS0FBS0csTUFBQUEsQ0FBQUEsQ0FBZEQsQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJMLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBQyxFQWZGSixDQUFBQSxHQUFBQSxxQkFBQUEsQ0FjQ0Q7VUFNRE0sSUFBQU0sZUFBQUEsQ0FBVyxVQUFYQTtVQUNBTixJQUFBTSxlQUFBQSxDQUFXLE1BQVhBO1VBRUFiLE9BQUFNLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVUsTUFBVkEsQ0FBQUEsRUFBQUosY0FBb0JZLE1BQXBCWixFQUFBRzs7O1lBQW9CO1lBQ2xCQSxPQUFBRSxJQUFLUSxPQUFBQSxDQUFHRCxNQUFIQyxFQURQYixDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUk7UUF4QkZOLEdBQUFBLFdBQUFBLEVBQVVPLElBQVZQO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQmlCLGlCQUFoQmpCO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFha0IsaUJBQWJsQjtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDE4NDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2RhdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbmNsYXNzIERhdGFcbiAgYXR0cl9yZWFkZXIgOmVsZW1lbnRcblxuICBkZWYgaW5pdGlhbGl6ZShlbGVtZW50KVxuICAgIEBlbGVtZW50ID0gZWxlbWVudFxuICAgIEBuYXRpdmUgID0gZWxlbWVudC50b19uXG5cbiAgICB1bmxlc3MgZGVmaW5lZD8oYCNAbmF0aXZlLiRkYXRhYClcbiAgICAgIGAjQG5hdGl2ZS4kZGF0YSA9IHt9YFxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoIHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgZGF0YSA9ICNAbmF0aXZlLiRkYXRhO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAje2Jsb2NrLmNhbGwgYGtleWAsIGBkYXRhW2tleV1gfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBAZWxlbWVudC5hdHRyaWJ1dGVzLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgIGlmIG5hbWUgPX4gL15kYXRhLSguKikkL1xuICAgICAgICBibG9jay5jYWxsICQxLCB2YWx1ZVxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYXNzaWduKGRhdGEpXG4gICAgZGF0YS5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICBzZWxmW25hbWVdID0gdmFsdWVcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShuYW1lKVxuICAgIGlmIGRhdGEgPSBAZWxlbWVudFtcImRhdGEtI3tuYW1lfVwiXVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gI0BuYXRpdmUuJGRhdGFbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBgZGVsZXRlICNAbmF0aXZlLiRkYXRhW25hbWVdYFxuICAgIGlmIFt0cnVlLCBmYWxzZSwgbmlsXS5pbmNsdWRlPyh2YWx1ZSlcbiAgICAgIEBlbGVtZW50W1wiZGF0YS0je25hbWV9XCJdID0gdmFsdWVcbiAgICBlbHNpZiB2YWx1ZS5yZXNwb25kX3RvPyA6dG9fc3RyXG4gICAgICBAZWxlbWVudFtcImRhdGEtI3tuYW1lfVwiXSA9IHZhbHVlLnRvX3N0clxuICAgIGVsc2lmIHZhbHVlLnJlc3BvbmRfdG8/IDp0b19pbnRcbiAgICAgIEBlbGVtZW50W1wiZGF0YS0je25hbWV9XCJdID0gdmFsdWUudG9faW50LnRvX3NcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUuJGRhdGFbbmFtZV0gPSB2YWx1ZWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShuYW1lKVxuICAgIGRhdGEgPSBzZWxmW25hbWVdXG4gICAgc2VsZltuYW1lXSA9IG5pbFxuICAgIGRhdGFcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkRhdGE+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImVsZW1lbnQiLCJAZWxlbWVudCIsIkBuYXRpdmUiLCJ0b19uIiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJlYWNoIiwiYmxvY2siLCJlbnVtX2ZvciIsImNhbGwiLCJhdHRyaWJ1dGVzIiwiYmxvY2sgaW4gZWFjaCIsIm5hbWUiLCJ2YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsIj1+IiwiYXNzaWduIiwiZGF0YSIsImJsb2NrIGluIGFzc2lnbiIsImJsb2NrICgyIGxldmVscykgaW4gYXNzaWduIiwiW109IiwiW10iLCJpbmNsdWRlPyIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwidG9faW50IiwidG9fcyIsImRlbGV0ZSIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSwyQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGFBQUFBLENBQVksU0FBWkE7O0FBRUFDLFVBQUFBLDBCQUFBQSxzQkFBZUMsT0FBZkQ7QUFBQUEsWUFBQUE7OztZQUNFRSxlQUFXRDtZQUNYRSxpQkFBV0YsT0FBT0csTUFBQUEsQ0FBQUE7WUFFbEIsSUFBQSxRQUFPLFFBQVdELGNBQU9ILE1BQWxCLGtC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LEVBQUFBO1lBRFY7Y0FHRUEsT0FBRWxCLGNBQU9rQjtZQUhYO1VBTkZBLENBQUFBLEdBQUFBO1VBYUF4QixPQUFBK0Isc0JBQUFBLHdCQUFXZixJQUFYZTtBQUFBQSxZQUFBQTs7O1lBQ0VWLE9BQU9wQixJQUFJd0IsT0FBQUEsQ0FBQ1QsSUFBRFM7WUFDWHhCLElBQUl1QixRQUFBQSxDQUFDUixJQUFMLEVBQWEsR0FBVFE7WUFDSk8sT0FBQVY7VUFIRlUsQ0FBQUEsR0FBQUE7UUF4RUYvQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0JpQyxVQUFoQmpDO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDE5ODEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vY3NzL3J1bGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIENTUyA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIFJ1bGUgPCBCYXNpY09iamVjdFxuICBhdHRyX3JlYWRlciA6c2VsZWN0b3IsIDptZWRpYVxuXG4gIGRlZiBpbml0aWFsaXplKHNlbGVjdG9yLCBtZWRpYSlcbiAgICBAc2VsZWN0b3IgICA9IHNlbGVjdG9yXG4gICAgQG1lZGlhICAgICAgPSBtZWRpYVxuICAgIEBkZWZpbml0aW9uID0gRGVmaW5pdGlvbi5uZXdcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKCphcmdzLCAmYmxvY2spXG4gICAgQGRlZmluaXRpb24uX19zZW5kX18oKmFyZ3MsICZibG9jaylcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6Q1NTPiIsIjxjbGFzczpSdWxlPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJzZWxlY3RvciIsIm1lZGlhIiwiQHNlbGVjdG9yIiwiQG1lZGlhIiwiQGRlZmluaXRpb24iLCJEZWZpbml0aW9uIiwibmV3IiwibWV0aG9kX21pc3NpbmciLCJfX3NlbmRfXyIsImFyZ3MiLCJibG9jayIsInRvX3Byb2MiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVkQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxhQUFBQSxDQUFZLFVBQVosRUFBdUIsT0FBdkJBOztBQUVBQyxRQUFBQSwwQkFBQUEsc0JBQWVDLFFBQUQsRUFBV0MsS0FBekJGO0FBQUFBLFVBQUFBOzs7VUFDRUcsZ0JBQWNGO1VBQ2RHLGFBQWNGO1VBQ2RGLE9BQUFLLENBQUFBLGtCQUFjQyxnQkFBVUMsS0FBQUEsQ0FBQUEsQ0FBeEJGO1FBSEZMLENBQUFBLEdBQUFBO1FBTUFILE9BQUFXLDhCQUFBQSwwQkFyQkYsRUFxQkVBO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBckJGO1VBcUJxQjtVQUNqQkEsT0FBV0MsTUFBWEosZUFBV0ksWUFBQUEsRUFBVSxNQUFDQyxJQUFELENBQVZELEVBQWtCRSxLQUFEQyxTQUFBQSxDQUFBQSxDQUFqQkg7UUFEYkQsQ0FBQUEsSUFBQUE7TUFURlgsR0FBQUEsV0FBQUEsRUFBYWdCLGlCQUFiaEI7SUFGY0QsR0FBQUEsV0FBQUEsRUFBWWlCLGlCQUFaakI7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQyMDI3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9vcHRpb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIE9wdGlvbiA8IHNlbGZcbiAgJXdbbGFiZWwgdmFsdWVdLmVhY2gge3xuYW1lfFxuICAgIGRlZmhlbHBlciBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWVcbiAgICBlbmRcbiAgfVxuXG4gIGRlZmhlbHBlciEgOmRpc2FibGVkXG4gIGRlZmhlbHBlciEgOnNlbGVjdGVkXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpPcHRpb24+IiwiZWFjaCIsImJsb2NrIGluIDxjbGFzczpPcHRpb24+IiwibmFtZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOk9wdGlvbj4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpPcHRpb24+IiwiW109IiwiQGF0dHJpYnV0ZXMiLCJkZWZoZWxwZXIhIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQVVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBMEJBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFeENBLE9BQUFDO1FBQUFBOzs7O1VBQ2lCQyxNQUFmLENBQUdELE9BQUgsRUFBU0EsT0FBVCxDQUFlQyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFmQyxtQkFBdUJDLElBQXZCRCxFQUFBRTs7O1lBQXVCO1lBQ3JCQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVRixJQUFWRSxDQUFBQSxFQUFBRCxhQUFtQkcsS0FBbkJILEVBQUFJO0FBQUFBOzs7Y0FBbUI7Y0FDakJBLE9BQVdDLE1BQUFBLENBQUNOLElBQVosRUFBb0JJLEtBQVRFLENBQUFBLEVBQUFBLE1BQVhDLGVBQVdELE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiTCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUMsRUFERkgsQ0FBQUEsR0FBQUEscUJBQUFBLENBQWVEO1VBTWZLLElBQUFLLGVBQUFBLENBQVcsVUFBWEE7VUFDQVgsT0FBQU0sSUFBQUssZUFBQUEsQ0FBVyxVQUFYQTtRQVJGWCxHQUFBQSxXQUFBQSxFQUFlTSxJQUFmTjtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JhLGlCQUFoQmI7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFjLGlCQUFiZDtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDIwNjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L2Jsb2NrcXVvdGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEJsb2NrcXVvdGUgPCBzZWxmXG4gIGRlZmhlbHBlciA6Y2l0ZSBkbyB8dmFsdWV8XG4gICAgQGF0dHJpYnV0ZXNbOmNpdGVdID0gdmFsdWUudG9fc1xuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkJsb2NrcXVvdGU+IiwiZGVmaGVscGVyIiwic2VsZiIsImJsb2NrIGluIDxjbGFzczpCbG9ja3F1b3RlPiIsInZhbHVlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6QmxvY2txdW90ZT4iLCJbXT0iLCJ0b19zIiwiQGF0dHJpYnV0ZXMiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLGlEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUEwQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUV4Q0EsT0FBQUM7UUFBQUE7OztVQUNFQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVLE1BQVZBLENBQUFBLEVBQUFFLHVCQUFvQkMsS0FBcEJELEVBQUFFO0FBQUFBOzs7WUFBb0I7WUFDbEJBLE9BQVdDLE1BQUFBLENBQUMsTUFBWixFQUFxQkYsS0FBS0csTUFBQUEsQ0FBQUEsQ0FBZkQsQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJILENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBRjtRQURGRCxHQUFBQSxXQUFBQSxFQUFtQkUsSUFBbkJGO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQlUsaUJBQWhCVjtJQUExQkQsR0FBQUEsV0FBQUEsRUFBYVcsaUJBQWJYO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjEwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvYnV0dG9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBCdXR0b24gPCBzZWxmXG4gIHsgZm9ybTogIDpmb3JtLFxuICAgIG5hbWU6ICA6bmFtZSxcbiAgICB0eXBlOiAgOnR5cGUsXG4gICAgdmFsdWU6IDp2YWx1ZSxcblxuICAgIGFjdGlvbjogICA6Zm9ybWFjdGlvbixcbiAgICBlbmNvZGluZzogOmZvcm1lbmN0eXBlLFxuICAgIG1ldGhvZDogICA6Zm9ybW1ldGhvZCxcbiAgICB0YXJnZXQ6ICAgOmZvcm10YXJnZXQsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXN8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZS50b19zXG4gICAgZW5kXG4gIH1cblxuICBkZWZoZWxwZXIhIDphdXRvZm9jdXNcbiAgZGVmaGVscGVyISA6ZGlzYWJsZWRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkJ1dHRvbj4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOkJ1dHRvbj4iLCJuYW1lIiwiYXR0cmlidXRlcyIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkJ1dHRvbj4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpCdXR0b24+IiwiW109IiwidG9fcyIsIkBhdHRyaWJ1dGVzIiwiZGVmaGVscGVyISIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQVVHQyxNQVRELHFGQUFBLFFBQVMsTUFBVCxFQUFBLFFBQ1MsTUFEVCxFQUFBLFFBRVMsTUFGVCxFQUFBLFNBR1MsT0FIVCxFQUFBLFVBS1ksWUFMWixFQUFBLFlBTVksYUFOWixFQUFBLFVBT1ksWUFQWixFQUFBLFVBUVksWUFSWixFQVNDQSxRQUFBQSxFQUFBQSxFQUFBQSxFQVREQyxtQkFTU0MsSUFBRCxFQUFPQyxVQVRmRixFQUFBRzs7O1lBU1M7WUFBTTtZQUNiQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVSCxJQUFWRyxDQUFBQSxFQUFBRCxhQUFtQkcsS0FBbkJILEVBQUFJO0FBQUFBOzs7Y0FBbUI7Y0FDakJBLE9BQVdDLE1BQUFBLENBQUNQLElBQVosRUFBb0JLLEtBQUtHLE1BQUFBLENBQUFBLENBQWRELENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiTCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUMsRUFWRkosQ0FBQUEsR0FBQUEscUJBQUFBLENBU0NEO1VBTURNLElBQUFNLGVBQUFBLENBQVcsV0FBWEE7VUFDQWIsT0FBQU8sSUFBQU0sZUFBQUEsQ0FBVyxVQUFYQTtRQWpCRmIsR0FBQUEsV0FBQUEsRUFBZU8sSUFBZlA7TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCZSxpQkFBaEJmO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhZ0IsaUJBQWJoQjtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDIxNDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L2NhbnZhcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgQ2FudmFzIDwgc2VsZlxuICB7IHdpZHRoOiAgOndpZHRoLFxuICAgIGhlaWdodDogOmhlaWdodFxuICB9LmVhY2gge3xuYW1lLCBhdHRyaWJ1dGV8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZS50b19zXG4gICAgZW5kXG4gIH1cbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkNhbnZhcz4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOkNhbnZhcz4iLCJuYW1lIiwiYXR0cmlidXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6Q2FudmFzPiIsImRlZmhlbHBlciIsInNlbGYiLCJ2YWx1ZSIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOkNhbnZhcz4iLCJbXT0iLCJ0b19zIiwiQGF0dHJpYnV0ZXMiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUEwQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUV4Q0EsT0FBQUM7UUFBQUE7OztVQUNFQSxPQUVDQyxNQUZELDZCQUFBLFNBQVUsT0FBVixFQUFBLFVBQ1UsUUFEVixFQUVDQSxRQUFBQSxFQUFBQSxFQUFBQSxFQUZEQyxtQkFFU0MsSUFBRCxFQUFPQyxTQUZmRixFQUFBRzs7O1lBRVM7WUFBTTtZQUNiQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVSCxJQUFWRyxDQUFBQSxFQUFBRCxhQUFtQkcsS0FBbkJILEVBQUFJO0FBQUFBOzs7Y0FBbUI7Y0FDakJBLE9BQVdDLE1BQUFBLENBQUNQLElBQVosRUFBb0JLLEtBQUtHLE1BQUFBLENBQUFBLENBQWRELENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiTCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBQUMsRUFIRkosQ0FBQUEsR0FBQUEscUJBQUFBLENBRUNEO1FBSEhELEdBQUFBLFdBQUFBLEVBQWVPLElBQWZQO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQmMsaUJBQWhCZDtJQUExQkQsR0FBQUEsV0FBQUEsRUFBYWUsaUJBQWJmO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjE4NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJ1ZmZlci92aWV3LnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJ1ZmZlclxuICBjbGFzcyBWaWV3XG4gICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICAgICEkJFs6RGF0YVZpZXddLm5pbD9cbiAgICBlbmRcblxuICAgIGF0dHJfcmVhZGVyIDpidWZmZXIsIDpvZmZzZXRcblxuICAgIGRlZiBpbml0aWFsaXplKGJ1ZmZlciwgb2Zmc2V0ID0gbmlsLCBsZW5ndGggPSBuaWwpXG4gICAgICBpZiBuYXRpdmU/KGJ1ZmZlcilcbiAgICAgICAgc3VwZXIoYnVmZmVyKVxuICAgICAgZWxzaWYgb2Zmc2V0ICYmIGxlbmd0aFxuICAgICAgICBzdXBlcihgbmV3IERhdGFWaWV3KCN7YnVmZmVyLnRvX259LCAje29mZnNldC50b19ufSwgI3tsZW5ndGgudG9fbn0pYClcbiAgICAgIGVsc2lmIG9mZnNldFxuICAgICAgICBzdXBlcihgbmV3IERhdGFWaWV3KCN7YnVmZmVyLnRvX259LCAje29mZnNldC50b19ufSlgKVxuICAgICAgZWxzZVxuICAgICAgICBzdXBlcihgbmV3IERhdGFWaWV3KCN7YnVmZmVyLnRvX259KWApXG4gICAgICBlbmRcblxuICAgICAgQGJ1ZmZlciA9IGJ1ZmZlclxuICAgICAgQG9mZnNldCA9IG9mZnNldFxuICAgIGVuZFxuXG4gICAgZGVmIGxlbmd0aFxuICAgICAgYCN7QG5hdGl2ZX0uYnl0ZUxlbmd0aGBcbiAgICBlbmRcblxuICAgIGRlZiBnZXQob2Zmc2V0LCBiaXRzID0gOCwgdHlwZSA9IDp1bnNpZ25lZCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfVtcImdldFwiICsgI3tCdWZmZXIubmFtZV9mb3IgYml0cywgdHlwZX1dKG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGFsaWFzIFtdIGdldFxuXG4gICAgZGVmIHNldChvZmZzZXQsIHZhbHVlLCBiaXRzID0gOCwgdHlwZSA9IDp1bnNpZ25lZCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfVtcInNldFwiICsgI3tCdWZmZXIubmFtZV9mb3IgYml0cywgdHlwZX1dKG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBhbGlhcyBbXT0gc2V0XG5cbiAgICBkZWYgZ2V0X2ludDgob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldEludDgob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIHNldF9pbnQ4KG9mZnNldCwgdmFsdWUsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uc2V0SW50OChvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF91aW50OChvZmZzZXQsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uZ2V0VWludDgob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIHNldF91aW50OChvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgZ2V0X2ludDE2KG9mZnNldCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5nZXRJbnQxNihvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X2ludDE2KG9mZnNldCwgdmFsdWUsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uc2V0SW50MTYob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBnZXRfdWludDE2KG9mZnNldCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5nZXRVaW50MTYob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIHNldF91aW50MTYob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5zZXRVaW50MTYob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBnZXRfaW50MzIob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldEludDMyKG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBzZXRfaW50MzIob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5zZXRJbnQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF91aW50MzIob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X3VpbnQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldFVpbnQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF9mbG9hdDMyKG9mZnNldCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5nZXRGbG9hdDMyKG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBzZXRfZmxvYXQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldEZsb2F0MzIob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBnZXRfZmxvYXQ2NChvZmZzZXQsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uZ2V0RmxvYXQ2NChvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X2Zsb2F0NjQob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5zZXRGbG9hdDY0KG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBhbGlhcyBzaXplIGxlbmd0aFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6QnVmZmVyPiIsIjxjbGFzczpWaWV3PiIsInNlbGYiLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwic3VwcG9ydGVkPyIsIiQkIiwiW10iLCJuaWw/IiwiISIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImJ1ZmZlciIsIm9mZnNldCIsImxlbmd0aCIsIm5hdGl2ZT8iLCJ0b19uIiwiQGJ1ZmZlciIsIkBvZmZzZXQiLCJAbmF0aXZlIiwiZ2V0IiwiYml0cyIsInR5cGUiLCJsaXR0bGUiLCI4IiwiQnVmZmVyIiwibmFtZV9mb3IiLCJzZXQiLCJ2YWx1ZSIsImdldF9pbnQ4Iiwic2V0X2ludDgiLCJnZXRfdWludDgiLCJzZXRfdWludDgiLCJnZXRfaW50MTYiLCJzZXRfaW50MTYiLCJnZXRfdWludDE2Iiwic2V0X3VpbnQxNiIsImdldF9pbnQzMiIsInNldF9pbnQzMiIsImdldF91aW50MzIiLCJzZXRfdWludDMyIiwiZ2V0X2Zsb2F0MzIiLCJzZXRfZmxvYXQzMiIsImdldF9mbG9hdDY0Iiwic2V0X2Zsb2F0NjQiXSwibWFwcGluZ3MiOiJBQUFBQSw4QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEO01BRUFHLE1BQUlKLElBQUpJLGlCQUFBQSxnQ0FBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNDLFFBQUVDLE9BQUFBLENBQUMsVUFBREEsQ0FBV0MsU0FBQUEsQ0FBQUEsQ0FBZEMsTUFBQUEsQ0FBQUE7TUFERkosQ0FBQUEsR0FBQUE7TUFJQUosSUFBQVMsYUFBQUEsQ0FBWSxRQUFaLEVBQXFCLFFBQXJCQTs7QUFFQUMsTUFBQUEsMEJBQUFBLHNCQUFlQyxNQUFELEVBQVNDLE1BQVQsRUFBdUJDLE1BQXJDSDtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQXVCLDZCQUFTO1FBQUssNkJBQVM7UUFDNUMsSUFBQSxRQUFHVixJQUFBYyxZQUFBQSxDQUFRSCxNQUFSRyxDQUFILENBQUE7VUFDRSxPQUFBZCxJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFB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QUFBOzs7UUFBK0IsNkJBQVM7UUFDdENBLE9BQUd2QixjQUFRdUI7TUFEYkEsQ0FBQUEsSUFBQUE7O0FBSUFDLE1BQUFBLDJCQUFBQSx1QkFBZ0I5QixNQUFELEVBQVNVLE1BQXhCb0I7QUFBQUEsUUFBQUE7OztRQUF3Qiw2QkFBUztRQUMvQkEsT0FBR3hCLGNBQVF3QjtNQURiQSxDQUFBQSxJQUFBQTs7QUFJQUMsTUFBQUEsMkJBQUFBLHVCQUFnQi9CLE1BQUQsRUFBU2UsS0FBVCxFQUFnQkwsTUFBL0JxQjtBQUFBQSxRQUFBQTs7O1FBQStCLDZCQUFTO1FBQ3RDQSxPQUFHekIsY0FBUXlCO01BRGJBLENBQUFBLElBQUFBO01BSUE1QyxPQUFBLGFBQU0sTUFBTixFQUFXLFFBQVg7SUF4R0ZBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjM5MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvZW1iZWQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEVtYmVkIDwgc2VsZlxuICB7IHR5cGU6ICAgOnR5cGUsXG4gICAgaGVpZ2h0OiA6aGVpZ2h0LFxuICAgIHdpZHRoOiAgOndpZHRoXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlXG4gICAgZW5kXG4gIH1cbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkVtYmVkPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6RW1iZWQ+IiwibmFtZSIsImF0dHJpYnV0ZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkVtYmVkPiIsImRlZmhlbHBlciIsInNlbGYiLCJ2YWx1ZSIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOkVtYmVkPiIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSw0Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQVVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBMEJBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFeENBLE9BQUFDO1FBQUFBOzs7VUFDRUEsT0FHQ0MsTUFIRCxxQ0FBQSxRQUFVLE1BQVYsRUFBQSxVQUNVLFFBRFYsRUFBQSxTQUVVLE9BRlYsRUFHQ0EsUUFBQUEsRUFBQUEsRUFBQUEsRUFIREMsa0JBR1NDLElBQUQsRUFBT0MsU0FIZkYsRUFBQUc7OztZQUdTO1lBQU07WUFDYkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUgsSUFBVkcsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDUCxJQUFaLEVBQW9CSyxLQUFURSxDQUFBQSxFQUFBQSxNQUFYQyxlQUFXRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFDLEVBSkZKLENBQUFBLEdBQUFBLHFCQUFBQSxDQUdDRDtRQUpIRCxHQUFBQSxXQUFBQSxFQUFjTyxJQUFkUDtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JhLGlCQUFoQmI7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFjLGlCQUFiZDtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDI0MzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L29wdGdyb3VwLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBPcHRncm91cCA8IHNlbGZcbiAgJXdbbGFiZWwgdmFsdWVdLmVhY2gge3xuYW1lfFxuICAgIGRlZmhlbHBlciBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWVcbiAgICBlbmRcbiAgfVxuXG4gIGRlZmhlbHBlciEgOmRpc2FibGVkXG4gIGRlZmhlbHBlciEgOnNlbGVjdGVkXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpPcHRncm91cD4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOk9wdGdyb3VwPiIsIm5hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpPcHRncm91cD4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpPcHRncm91cD4iLCJbXT0iLCJAYXR0cmlidXRlcyIsImRlZmhlbHBlciEiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLCtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUEwQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUV4Q0EsT0FBQUM7UUFBQUE7Ozs7VUFDaUJDLE1BQWYsQ0FBR0QsT0FBSCxFQUFTQSxPQUFULENBQWVDLFFBQUFBLEVBQUFBLEVBQUFBLEVBQWZDLHFCQUF1QkMsSUFBdkJELEVBQUFFOzs7WUFBdUI7WUFDckJBLE9BQUFDLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVVGLElBQVZFLENBQUFBLEVBQUFELGFBQW1CRyxLQUFuQkgsRUFBQUk7QUFBQUE7OztjQUFtQjtjQUNqQkEsT0FBV0MsTUFBQUEsQ0FBQ04sSUFBWixFQUFvQkksS0FBVEUsQ0FBQUEsRUFBQUEsTUFBWEMsZUFBV0QsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJMLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBQyxFQURGSCxDQUFBQSxHQUFBQSxxQkFBQUEsQ0FBZUQ7VUFNZkssSUFBQUssZUFBQUEsQ0FBVyxVQUFYQTtVQUNBWCxPQUFBTSxJQUFBSyxlQUFBQSxDQUFXLFVBQVhBO1FBUkZYLEdBQUFBLFdBQUFBLEVBQWlCTSxJQUFqQk47TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCYSxpQkFBaEJiO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhYyxpQkFBYmQ7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQyNDczLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9zZWxlY3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIFNlbGVjdCA8IHNlbGZcbiAgJXdbZm9ybSBuYW1lIHNpemVdLmVhY2gge3xuYW1lfFxuICAgIGRlZmhlbHBlciBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWVcbiAgICBlbmRcbiAgfVxuXG4gIGRlZmhlbHBlciEgOmF1dG9fZm9jdXMsIDphdXRvZm9jdXNcbiAgZGVmaGVscGVyISA6ZGlzYWJsZWRcbiAgZGVmaGVscGVyISA6cmVxdWlyZWRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOlNlbGVjdD4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOlNlbGVjdD4iLCJuYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6U2VsZWN0PiIsImRlZmhlbHBlciIsInNlbGYiLCJ2YWx1ZSIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOlNlbGVjdD4iLCJbXT0iLCJAYXR0cmlidXRlcyIsImRlZmhlbHBlciEiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUEwQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUV4Q0EsT0FBQUM7UUFBQUE7Ozs7VUFDb0JDLE1BQWxCLENBQUdELE1BQUgsRUFBUUEsTUFBUixFQUFhQSxNQUFiLENBQWtCQyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFsQkMsbUJBQTBCQyxJQUExQkQsRUFBQUU7OztZQUEwQjtZQUN4QkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUYsSUFBVkUsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDTixJQUFaLEVBQW9CSSxLQUFURSxDQUFBQSxFQUFBQSxNQUFYQyxlQUFXRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEscUJBQUFBLENBQUFDLEVBREZILENBQUFBLEdBQUFBLHFCQUFBQSxDQUFrQkQ7VUFNbEJLLElBQUFLLGVBQUFBLENBQVcsWUFBWCxFQUF3QixXQUF4QkE7VUFDQUwsSUFBQUssZUFBQUEsQ0FBVyxVQUFYQTtVQUNBWCxPQUFBTSxJQUFBSyxlQUFBQSxDQUFXLFVBQVhBO1FBVEZYLEdBQUFBLFdBQUFBLEVBQWVNLElBQWZOO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQmEsaUJBQWhCYjtJQUExQkQsR0FBQUEsV0FBQUEsRUFBYWMsaUJBQWJkO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjUxNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgQmFzZSA8IHNlbGZcbiAgeyBocmVmOiA6aHJlZixcbiAgICB1cmw6ICA6aHJlZixcblxuICAgIHRhcmdldDogOnRhcmdldCxcbiAgfS5lYWNoIHt8bmFtZSwgYXR0cmlidXRlfFxuICAgIGRlZmhlbHBlciBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWUudG9fc1xuICAgIGVuZFxuICB9XG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpCYXNlPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6QmFzZT4iLCJuYW1lIiwiYXR0cmlidXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6QmFzZT4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpCYXNlPiIsIltdPSIsInRvX3MiLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7O1VBQ0VBLE9BSUNDLE1BSkQsbUNBQUEsUUFBUSxNQUFSLEVBQUEsT0FDUSxNQURSLEVBQUEsVUFHVSxRQUhWLEVBSUNBLFFBQUFBLEVBQUFBLEVBQUFBLEVBSkRDLGlCQUlTQyxJQUFELEVBQU9DLFNBSmZGLEVBQUFHOzs7WUFJUztZQUFNO1lBQ2JBLE9BQUFDLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVVILElBQVZHLENBQUFBLEVBQUFELGFBQW1CRyxLQUFuQkgsRUFBQUk7QUFBQUE7OztjQUFtQjtjQUNqQkEsT0FBV0MsTUFBQUEsQ0FBQ1AsSUFBWixFQUFvQkssS0FBS0csTUFBQUEsQ0FBQUEsQ0FBZEQsQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJMLENBQUFBLEdBQUFBLHFCQUFBQSxDQUFBQyxFQUxGSixDQUFBQSxHQUFBQSxxQkFBQUEsQ0FJQ0Q7UUFMSEQsR0FBQUEsV0FBQUEsRUFBYU8sSUFBYlA7TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCYyxpQkFBaEJkO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhZSxpQkFBYmY7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQyNTU2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9hcHBsaWNhdGlvbi5qcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdvcGFsJ1xucmVxdWlyZSAnbmF0aXZlJ1xucmVxdWlyZSAncHJvbWlzZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvc2V0dXAvZnVsbCdcblxuJHdpbmRvdy5hbGVydCBcImhlbGxvIHdvcmxkXCJcbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCJzZWxmIiwicmVxdWlyZSIsIiR3aW5kb3ciLCJhbGVydCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJCQUFBQTtFQUFBQTtBQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLE1BQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLFFBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLFNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRyxhQUFPQyxPQUFBQSxDQUFPSixhQUFQSTtBQUxQSjsifX0seyJvZmZzZXQiOnsibGluZSI6NDI1NjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIoZXhpdCkiXSwic291cmNlc0NvbnRlbnQiOlsiOjpLZXJuZWwuZXhpdFxuIl0sIm5hbWVzIjpbIjxtYWluPiIsIktlcm5lbCIsImV4aXQiXSwibWFwcGluZ3MiOiJBQUFBQSwyQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDLE9BQVFDLE1BQUFBLENBQUFBO0FBQVJGOyJ9fV19
